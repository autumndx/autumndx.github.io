{"title":"串、数组和广义表","date":"2020-10-24T15:38:06.000Z","date_formatted":{"ll":"2020年10月24日","L":"2020/10/24","MM-DD":"10-24"},"link":"posts/32c38e43","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2020-11-03T12:31:34.593Z","content":"<h1 id=\"常用的串运算\">常用的串运算<a href=\"#常用的串运算\" title=\"常用的串运算\"></a></h1><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;string.h&gt;</span></span></span><br><span class=\"line\">串比较，<span class=\"built_in\">strcmp</span>(<span class=\"keyword\">char</span> s1,<span class=\"keyword\">char</span> s2) </span><br><span class=\"line\">串复制，<span class=\"built_in\">strcpy</span>(<span class=\"keyword\">char</span> to,<span class=\"keyword\">char</span> from)</span><br><span class=\"line\">串连接，<span class=\"built_in\">strcat</span>(<span class=\"keyword\">char</span> to,<span class=\"keyword\">char</span> from) </span><br><span class=\"line\">求串长，<span class=\"built_in\">strlen</span>(<span class=\"keyword\">char</span> s)</span><br></pre></td></tr></table></figure><h1 id=\"串string\">串(String)<a href=\"#串string\" title=\"串(String)\"></a></h1><ul><li>零个或多个字符组成的有限序列</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101124645.png\" style=\"zoom: 33%;\" /><h2 id=\"顺序存储\">顺序存储<a href=\"#顺序存储\" title=\"顺序存储\"></a></h2><p>后面算法描述当中所用到的顺序存储的字符串都是从下标1的数组分量开始存储的，下标为0的分量闲置不用</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//--------串的定长顺序存储结构------</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXLEN 255\t\t<span class=\"comment\">//串的最大长度</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch[MAXLEN+<span class=\"number\">1</span>];\t<span class=\"comment\">//存储串的一维数组</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length;\t\t<span class=\"comment\">//串当前的长度</span></span><br><span class=\"line\">&#125;SString;</span><br></pre></td></tr></table></figure><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//--------串的堆式顺序存储结构------</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> *ch;\t\t<span class=\"comment\">//若是非空串，则按串长分配存储空间，否则ch为Null</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> length;\t\t<span class=\"comment\">//串的当前长度</span></span><br><span class=\"line\">&#125;HString;</span><br></pre></td></tr></table></figure><h2 id=\"链式存储\">链式存储<a href=\"#链式存储\" title=\"链式存储\"></a></h2><p><strong>优点</strong>：操作方便<br><strong>缺点</strong>：存储密度较低</p>\n<p><strong>存储密度=串值所占的存储位/实际分配的存储位</strong></p>\n<blockquote>\n<p><mark><strong>可将多个字符存放在一个结点中，以克服其缺点</strong></mark></p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101134935.png\" style=\"zoom: 33%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> CHUNKSIZE 80       <span class=\"comment\">//可由用户定义的块大小</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chunk</span>&#123;</span></span><br><span class=\"line\">   <span class=\"keyword\">char</span>  ch[CHUNKSIZE];</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">Chunk</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125;Chunk;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span></span><br><span class=\"line\">   Chunk *head,*tail;      <span class=\"comment\">//串的头指针和尾指针</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> curlen;                    <span class=\"comment\">//串的当前长度</span></span><br><span class=\"line\">&#125;LString;</span><br></pre></td></tr></table></figure><h2 id=\"串的模式匹配算法\">串的模式匹配算法<a href=\"#串的模式匹配算法\" title=\"串的模式匹配算法\"></a></h2><ul><li><strong>算法目的</strong> : 确定主串中所含子串第一次出现的位置（定位）</li>\n<li><strong>算法种类</strong> : <ul><li><strong>BF算法</strong>（又称古典的、经典的、朴素的、穷举的）</li>\n<li><strong>KMP算法</strong>（特点：速度快）</li>\n</ul></li>\n</ul><h3 id=\"bf算法\"><strong>BF算法</strong><a href=\"#bf算法\" title=\"BF算法\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101135724.png\" style=\"zoom:44%;\" /><blockquote>\n<p>eg</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101140002.png\" style=\"zoom:50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Index</span><span class=\"params\">(SString S, SString T, <span class=\"keyword\">int</span> pos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0</span></span><br><span class=\"line\">\t<span class=\"comment\">//其中，T非空，1≤pos≤StrLength(S)</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = pos;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> j = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(i &lt;= S[<span class=\"number\">0</span>]&amp;&amp;j &lt;= T[<span class=\"number\">0</span>])</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(S[i]==T[j])</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t++i;</span><br><span class=\"line\">\t\t\t++j;</span><br><span class=\"line\">\t\t&#125; <span class=\"comment\">//继续比较后继字符</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\ti=i-j+<span class=\"number\">2</span>;</span><br><span class=\"line\">\t\t\tj=<span class=\"number\">1</span>;</span><br><span class=\"line\">\t\t&#125; <span class=\"comment\">//指针后退重新开始匹配</span></span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j &gt; T.length)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i - T.length;\t<span class=\"comment\">//匹配成功</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;\t<span class=\"comment\">//匹配失败</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101140203.png\" style=\"zoom: 33%;\" /><blockquote>\n<p><strong><font color=\"red\">若n为主串长度，m为子串长度，最坏情况是</font></strong></p>\n</blockquote>\n<p>主串前面<code>n-m</code>个位置都部分匹配到子串的最后一位，即这<code>n-m</code>位各比较了<code>m</code>次,最后<code>m</code>位也各比较了1次</p>\n<p><strong>总次数为</strong>：<code>(n-m)*m+m＝(n-m+1)*m</code><br>若<code>m&lt;&lt;n</code>，则算法复杂度<code>O(n*m)</code></p>\n<h3 id=\"kmp（knuth-morris-pratt）算法\">KMP（Knuth Morris Pratt）算法<a href=\"#kmp（knuth-morris-pratt）算法\" title=\"KMP（Knuth Morris Pratt）算法\"></a></h3><ul><li>利用已经<strong>部分匹配</strong>的结果而加快模式串的滑动速度？    且主串<code>S</code>的指针<strong><code>i</code>不必回溯</strong>！可提速到<code>O(n+m)</code>！</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101143817.png\" style=\"zoom: 67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">Index_KMP</span><span class=\"params\">(SString S, SString T, <span class=\"keyword\">int</span> pos)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123; \t<span class=\"comment\">// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法</span></span><br><span class=\"line\">\t<span class=\"comment\">//其中，T非空，1≤pos≤S.Length</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i = pos, j = <span class=\"number\">1</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">while</span> (i &lt;= S.length &amp;&amp; j &lt;= T.length)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> (j == <span class=\"number\">0</span> || S.ch[i] == T.ch[j]) <span class=\"comment\">// 继续比较后继字</span></span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\t++i;</span><br><span class=\"line\">\t\t\t++j;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t\tj = next[j]; <span class=\"comment\">// 模式串向右移动</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (j &gt; T[<span class=\"number\">0</span>]) <span class=\"comment\">// 匹配成功</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> i - T[<span class=\"number\">0</span>];</span><br><span class=\"line\">\t<span class=\"keyword\">else</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"计算next函数值\">计算next函数值<a href=\"#计算next函数值\" title=\"计算next函数值\"></a></h4><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101145202.png\" style=\"zoom: 67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">get_next</span><span class=\"params\">(SString T, <span class=\"keyword\">int</span> next[])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;<span class=\"comment\">//求模式串T的next函数值并存入数组next</span></span><br><span class=\"line\">     i= <span class=\"number\">1</span>; next[<span class=\"number\">1</span>] = <span class=\"number\">0</span>; j = <span class=\"number\">0</span>;   </span><br><span class=\"line\">     <span class=\"keyword\">while</span>( i&lt;T.length)</span><br><span class=\"line\">     &#123;</span><br><span class=\"line\">          <span class=\"keyword\">if</span>(j==<span class=\"number\">0</span> || T.ch[i] == T.ch[j])</span><br><span class=\"line\">          &#123;</span><br><span class=\"line\">                ++i; ++j; </span><br><span class=\"line\">                next[i] = j;</span><br><span class=\"line\">          &#125;</span><br><span class=\"line\">          <span class=\"keyword\">else</span></span><br><span class=\"line\">                j = next[j];</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"数组\">数组<a href=\"#数组\" title=\"数组\"></a></h1><ul><li>数组一旦被定义，他的维数和维界就不再改变</li>\n</ul><h2 id=\"一维数组\">一维数组<a href=\"#一维数组\" title=\"一维数组\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101150853.png\" style=\"zoom: 80%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101150647.png\" style=\"zoom: 67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101150658.png\" style=\"zoom:67%;\" /><h2 id=\"二维数组\">二维数组<a href=\"#二维数组\" title=\"二维数组\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101151722.png\" style=\"zoom: 67%;\" /><p>​              </p>\n<h2 id=\"三维数组\">三维数组<a href=\"#三维数组\" title=\"三维数组\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101151749.png\" style=\"zoom: 67%;\" /><p><code>a[m1][m2] [m3]</code> 各维元素个数为  <code>m1</code>, <code>m2</code>, <code>m3</code></p>\n<p> 下标为 <code>i1, i2, i3</code>的数组元素的存储位置：    </p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101151952.png\" style=\"zoom:80%;\" /><h1 id=\"特殊矩阵的压缩存储\">特殊矩阵的压缩存储<a href=\"#特殊矩阵的压缩存储\" title=\"特殊矩阵的压缩存储\"></a></h1><p><strong>什么是压缩存储？</strong></p>\n<p>​    若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。</p>\n<p><strong>什么样的矩阵能够压缩？</strong> </p>\n<p>​    一些特殊矩阵，如：<strong>对称矩阵，对角矩阵，三角矩阵，稀疏矩阵</strong>等。</p>\n<p> <strong>什么叫稀疏矩阵？</strong></p>\n<p>​    矩阵中非零元素的个数较少（一般小于5%）</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101152444.png\" style=\"zoom: 67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101152457.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101152516.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201101152547.png\" style=\"zoom:67%;\" />","prev":{"title":"列表和超链接","link":"posts/9a7f11f9"},"next":{"title":"ACM数据结构","link":"posts/5d201f0e"},"plink":"https://dxsummer.gitee.io/posts/32c38e43/","toc":[{"id":"常用的串运算","title":"常用的串运算","index":"1"},{"id":"串string","title":"串(String)","index":"2","children":[{"id":"顺序存储","title":"顺序存储","index":"2.1"},{"id":"链式存储","title":"链式存储","index":"2.2"},{"id":"串的模式匹配算法","title":"串的模式匹配算法","index":"2.3","children":[{"id":"bf算法","title":"BF算法","index":"2.3.1"},{"id":"kmp（knuth-morris-pratt）算法","title":"KMP（Knuth Morris Pratt）算法","index":"2.3.2","children":[{"id":"计算next函数值","title":"计算next函数值","index":"2.3.2.1"}]}]}]},{"id":"数组","title":"数组","index":"3","children":[{"id":"一维数组","title":"一维数组","index":"3.1"},{"id":"二维数组","title":"二维数组","index":"3.2"},{"id":"三维数组","title":"三维数组","index":"3.3"}]},{"id":"特殊矩阵的压缩存储","title":"特殊矩阵的压缩存储","index":"4"}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/32c38e43/\" title=\"串、数组和广义表\">https://dxsummer.gitee.io/posts/32c38e43/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年10月24日","updated":"2020年11月3日"}}