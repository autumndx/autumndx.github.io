[{"title":"列表和超链接","date":"2020-10-25T09:33:17.000Z","date_formatted":{"ll":"2020年10月25日","L":"2020/10/25","MM-DD":"10-25"},"updated":"2020-10-25T14:31:52.427Z","content":"列表标签123&lt;ul&gt;&lt;/ul&gt;\t标签用于定义无序列表&lt;li&gt;&lt;/li&gt;\t标签用于描述具体的列表项每对&lt;ul&gt;&lt;/ul&gt;中至少应包含一对&lt;li&gt;&lt;/li&gt;。无序列表 ul&lt;ul&gt;和&lt;li&gt;都拥有type属性，用于指定列表项目符号。\n\n不赞成使用无序列表的type属性，一般通过CSS样式属性替代。\n\n&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有的元素。但是&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入文字的做法是不被允许的。\n\n\ntype属性值显示效果\n\ndisc（默认值）●\n\ncircle○\n\nsquare■\n\n例\n\n\n    春\n    夏\n    秋\n    冬\n12345678&lt;body&gt;\t&lt;ul&gt;\t\t&lt;li  type=\"square\" &gt;春&lt;/li&gt;\t\t&lt;li&gt;夏&lt;/li&gt;\t\t&lt;li&gt;秋&lt;/li&gt;\t\t&lt;li&gt;冬&lt;/li&gt;\t&lt;/ul&gt;&lt;/body&gt;有序列表 ol每对&lt;ol&gt;&lt;/ol&gt;中至少应包含一对&lt;li&gt;&lt;/li&gt;。\n有序列表中，除了type属性之外，还可以为&lt;ol&gt;定义start属性、为&lt;li&gt;定义value属性。\n定义列表定义列表常用于图文混排，其中&lt;dt&gt;&lt;/dt&gt;标签中插入图片，&lt;dd&gt;&lt;/dd&gt;标签中放入对图片解释说明的文字。\n&lt;dl&gt; &lt;dt&gt; &lt;dd&gt; 3个标签之间不允许出现其他标签\n&lt;dl&gt; 必须与&lt;dt&gt;相邻\n\n列表的嵌套123456789101112131415&lt;h2&gt;饮品&lt;/h2&gt;&lt;ul&gt;\t&lt;li&gt;咖啡    \t\t&lt;ol&gt;                    &lt;!--有序列表的嵌套--&gt;        \t\t&lt;li&gt;拿铁&lt;/li&gt;            \t&lt;li&gt;摩卡&lt;/li&gt;        \t&lt;/ol&gt;     &lt;/li&gt;    &lt;li&gt;茶        &lt;ul&gt;                     &lt;!--无序列表的嵌套--&gt;         \t\t&lt;li&gt;碧螺春&lt;/li&gt;            \t&lt;li&gt;龙井&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;&lt;/ul&gt;CSS控制列表样式定义无序或有序列表时，可以通过标签的属性控制列表的项目符号，但是这种方式实现的效果并不理想，因此需要使用CSS中的列表样式属性。\nlist-style-type因为各个浏览器对list-style-type属性的解析不同。因此，在实际网页制作过程中不推荐使用   list-style-type属性。\nlist-style-image1ul&#123;list-style-image:url(图片路径);&#125;123&lt;style type=\"text/css\"&gt;ul&#123;list-style-image:url(images/book.png);&#125;  &lt;/style&gt;list-style-positioninside：列表项目符号位于列表文本以内。\noutside：列表项目符号位于列表文本以外。\n12345&lt;style type=\"text/css\"&gt;.in&#123;list-style-position:inside;&#125;   .out&#123;list-style-psition:outside;&#125; li&#123; border:1px solid #CCC;&#125;&lt;/style&gt;list-style 复合属性在实际网页制作过程中，为了更高效地控制列表项目符号，通常将list-style的属性值定义为none，然后通过为&lt;li&gt;设置背景图像的方式实现不同的列表项目符号。\n1list-style:列表项目符号 列表项目符号的位置 列表项目图像;链接超链接通过超链接，实现页面之间的跳转\nhref用于指定链接目标的url地址，当为&lt;a&gt;标签应用href属性时，它就具有了超链接的功能。\ntarget：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，意为在原窗口中打开，_blank为在新窗口中打开。\n1&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt;1、暂时没有确定链接目标时，通常将&lt;a&gt;标签的href属性值定义为“#” (即href=&quot;#&quot;)，表示该链接暂时为一个空链接。2、不仅可以创建文本超链接，在网页中各种网页元素，如图像、 表格、音频、视频等都可以添加超链接。3、当给图像添加超链接时，图像会自动加上边框，通常需要清除超链接图像的边框。\n锚点链接通过创建锚点链接，用户能够快速定位到目标内容。\n创建锚点步骤\n使用“&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;”创建链接文本\n使用相应的id名标注跳转目标的位置\n12345&lt;a href=\"#one\"&gt;平面广告设计&lt;/a&gt;...&lt;h3 id=\"one\"&gt;平面广告设计&lt;/h3&gt;链接伪类定义超链接时，为了提高用户体验，经常需要为超链接指定不同的状态，使得超链接在点击前、点击后和鼠标悬停时的样式不同。\n在CSS中通过链接伪类可以实现不同的链接状态\n伪类并不是真正意义上的类，它的名称是由系统定义的，通常由标签名、类名或id名加“：”构成。\n\n超链接标签&lt;a&gt;的伪类含义\n\na:link{ CSS样式规则; }未访问时超链接的状态\n\na:visited{ CSS样式规则; }访问后超链接的状态\n\na:hover{ CSS样式规则; }鼠标经过、悬停时超链接的状态\n\na:active{ CSS样式规则; }鼠标点击不动时超链接的状态\n同时使用链接的4种伪类时，通常按照a:link、a:visited、a:hover和a:active的顺序书写，否则定义的样式可能不起作用。\n\n除了文本样式之外，链接伪类还常常用于控制超链接的背景、边框等样式。\n\n123456789101112&lt;style type=\"text/css\"&gt;a:link,a:visited&#123;\t/*未访问和访问后*/\tcolor:#FC0;\ttext-decoration:none;         /*清除超链接默认的下划线*/\tmargin-right:20px;&#125;a:hover&#123;                             \tcolor:#0F0;\ttext-decoration:underline;  /*鼠标悬停时出现下划线*/&#125;a:active&#123; color:#F00;&#125;            &lt;/style&gt;","plink":"https://dxsummer.gitee.io/posts/9a7f11f9/"},{"title":"串、数组和广义表","date":"2020-10-24T15:38:06.000Z","date_formatted":{"ll":"2020年10月24日","L":"2020/10/24","MM-DD":"10-24"},"updated":"2020-10-24T15:38:39.605Z","content":"","plink":"https://dxsummer.gitee.io/posts/32c38e43/"},{"title":"ACM数据结构","date":"2020-10-24T07:13:14.000Z","date_formatted":{"ll":"2020年10月24日","L":"2020/10/24","MM-DD":"10-24"},"updated":"2020-10-25T08:54:11.156Z","content":"顺序表应用1：多余元素删除之移位算法Description一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。\n要求：\n1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能；\n2、本题的目标是熟悉顺序表的移位算法，因此题目必须要用元素的移位实现删除；\nInput第一行输入整数n，代表下面有n行输入；\n之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。\nOutput输出有n行，为每个顺序表删除多余元素后的结果\nSampleInput1234545 6 9 6 8 93 5 5 55 9 8 7 6 510 1 2 3 4 5 5 4 2 1 3Output12346 9 859 8 7 6 51 2 3 4 5Answer12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;typedef struct&#123;    int data[10010];&#125;SL;            //定义顺序表void creatlist(SL *l,int n)&#123;\tint i;\t    for(i=0;i&lt;n;i++)\t    &#123;\t        scanf(\"%d\",&amp;l-&gt;data[i]);\t    &#125;&#125;               //创建顺序表int deletelist(SL *l,int n)&#123;\tint i,j,k;\t    for(i=0;i&lt;n-1;i++)\t        for( j=i+1;j&lt;n;j++)  //循环遍历\t        &#123;\t          if(l-&gt;data[i]==l-&gt;data[j])\t            &#123;\t                n--;\t                for( k=j;k&lt;n;k++)  //将后面的移到前面\t                    l-&gt;data[k]=l-&gt;data[k+1];\t                j--;\t            &#125;\t        &#125;\t        return n;&#125;               //删除重复元素void printlist(SL *l,int n)&#123;\tint i;\t    for(i=0;i&lt;n;i++)\t        if(i==n-1)\t            printf(\"%d\\n\",l-&gt;data[i]);\t        else printf(\"%d \",l-&gt;data[i]);&#125;               //输出顺序表int main()&#123;    int n;    scanf(\"%d\",&amp;n);    while(n--)    &#123;        int m;        scanf(\"%d\",&amp;m);        SL l;        creatlist(&amp;l,m);        m=deletelist(&amp;l,m);        printlist(&amp;l,m);    &#125;    return 0;&#125;顺序表应用5：有序顺序表归并Description已知顺序表A与B是两个有序的顺序表，其中存放的数据元素皆为普通整型，将A与B表归并为C表，要求C表包含了A、B表里所有元素，并且C表仍然保持有序。\nInput输入分为三行：第一行输入m、n（1&lt;=m,n&lt;=10000）的值，即为表A、B的元素个数；第二行输入m个有序的整数，即为表A的每一个元素；第三行输入n个有序的整数，即为表B的每一个元素；\nOutput输出为一行，即将表A、B合并为表C后，依次输出表C所存放的元素。\nSampleInput1235 31 3 5 6 92 4 10Output11 2 3 4 5 6 9 10Answer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define MaxSize 100001using namespace std;typedef int element;typedef struct List&#123;    element data[MaxSize];    int size;&#125;list,list1,list2,list3;void init(list1 &amp;l1,list2 &amp;l2,int a,int b,list3 &amp;l3)&#123;    for(int i = 0 ; i &lt; a;i++)&#123;        l1.data[i] = 0;    &#125;    l1.size = a;     for(int i = 0 ; i &lt; b;i++)&#123;        l2.data[i] = 0;    &#125;    l2.size = b;     for(int i = 0 ; i &lt; a + b;i++)&#123;        l3.data[i] = 0;    &#125;    l3.size = a + b;&#125; void input(list1 &amp;l1,list2 &amp;l2,int a,int b)&#123;    int j;    for(int i = 0 ; i &lt; a;i++)&#123;\t\t//对顺序表A赋值         cin &gt;&gt; j;        l1.data[i] = j;    &#125;     for(int i = 0 ; i &lt; b;i++)&#123;\t//对顺序表B赋值         cin &gt;&gt; j;        l2.data[i] = j;    &#125;&#125; void merge(list1 &amp;l1,list2 &amp;l2,list3 &amp;l3)&#123;    int aa = 0,bb = 0,index=0;    int c = l1.size + l2.size;    while(c--)&#123; \t//a b对比 将较小值放到前面         int a = (aa &gt;= l1.size ? 65535 : l1.data[aa]);        int b = (bb &gt;= l2.size ? 65535 : l2.data[bb]);        if(a &gt; b)&#123;            l3.data[index++] = b;            bb++;        &#125;\t\telse&#123;            l3.data[index++] = a;            aa++;        &#125;    &#125;&#125; void output(list3 &amp;l3)&#123;    int i;    for(i = 0 ; i &lt; l3.size;i++)&#123;        printf(\"%d \",l3.data[i]);    &#125;&#125; int main()&#123;    int a,b;    list1 l1;    list2 l2;    list3 l3;    cin &gt;&gt; a &gt;&gt; b;    init(l1,l2,a,b,l3);\t//初始化     input(l1,l2,a,b);\t//负值     merge(l1,l2,l3);\t    output(l3);&#125;顺序表应用6：有序顺序表查询Description顺序表内按照由小到大的次序存放着n个互不相同的整数，任意输入一个整数，判断该整数在顺序表中是否存在。如果在顺序表中存在该整数，输出其在表中的序号；否则输出“No Found!”。\nInput第一行输入整数n (1 &lt;= n &lt;= 100000)，表示顺序表的元素个数；第二行依次输入n个各不相同的有序非负整数，代表表里的元素；第三行输入整数t (1 &lt;= t &lt;= 100000)，代表要查询的次数；第四行依次输入t个非负整数，代表每次要查询的数值。\n保证所有输入的数都在 int 范围内。\nOutput输出t行，代表t次查询的结果，如果找到在本行输出该元素在表中的位置，否则本行输出No Found!\nSampleInput1234101 22 33 55 63 70 74 79 80 87455 10 2 87Output12344No Found!No Found!10Answer123456789101112131415161718192021222324252627282930313233343536/*此题有疑问  需要请教老师*/#include &lt;stdio.h&gt;typedef struct&#123;\tint data[100001];&#125;sl;void putin(int n,sl *l)&#123;\t//问题 int putin(int n,sl &amp;l)----------1 \tfor(int a=0;a&lt;n;a++)\t\tscanf(\"%d\",&amp;l-&gt;data[a]);&#125;//\tfor(int a=0;a&lt;n;a++)&#123;\t//测试是否赋值成功 //\t\tprintf(\"%d\",l-&gt;data[a]);//\t&#125;void cmp(int t,sl *list1,sl *list2,int n)&#123;\tfor(int a=0;a&lt;t;a++)&#123;\t\tint c=0;\t\tfor(int b=0;b&lt;n;b++)&#123;\t\t\tif(list2-&gt;data[a]==list1-&gt;data[b])&#123;\t\t\t\tprintf(\"%d\\n\",++b);\t\t\t\tc=1;\t\t\t\tbreak;\t\t\t&#125;\t\t&#125;\t\tif(c!=1)\t\t\t\tprintf(\"No Found!\\n\"); \t&#125;&#125;int main()&#123;\tint n,t;\tscanf(\"%d\",&amp;n);\tsl list1,list2;\tputin(n,&amp;list1);\t//对结构体赋值\t问题  putin(n,list1)----1 \tscanf(\"%d\",&amp;t);\tputin(t,&amp;list2);\t//输入对比数 \tcmp(t,&amp;list1,&amp;list2,n);\t//duibi &#125;","plink":"https://dxsummer.gitee.io/posts/5d201f0e/"},{"title":"栈和队列","date":"2020-10-19T13:37:29.000Z","date_formatted":{"ll":"2020年10月19日","L":"2020/10/19","MM-DD":"10-19"},"updated":"2020-10-24T15:35:09.632Z","content":"栈顺序栈\n“进” ＝压入=PUSH（)“出” ＝弹出=POP( )\n\n定义：只能在表的一端（栈顶）进行插入和删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序栈或链栈存储均可，但以顺序栈更常见\n运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）或先进后出（FILO）的原则\n实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同，基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等\n表示123456#define MAXSIZE  100//顺序栈存储空间的初始分配量typedef struct &#123;\tSElemType *base;//栈底指针\tSElemType *top;//栈顶指针\tint stacksize;//栈可用的最大容量&#125; SqStack;初始化构造一个空栈步骤：\n分配空间并检查空间是否分配失败，若失败则返回错误\n\n设置栈底和栈顶指针 S.top = S.base;\n\n设置栈大小\n\n123456789Status InitStack(SqStack &amp;S) &#123;\t//构造一个空栈S\tS.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间\tif (!S.base)\t\texit(OVERFLOW); //存储分配失败\tS.top = S.base; //top初始为base，空栈\tS.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE\treturn OK;&#125;判断顺序栈是否为空\n12345bool StackEmpty( SqStack S )&#123;\tif(S.top == S.base) return true;   else return false;&#125;求顺序栈的长度\n1234int StackLength( SqStack S )&#123;\treturn S.top – S.base;&#125;清空顺序栈\n12345Status ClearStack( SqStack S )&#123;\tif( S.base ) S.top = S.base;\treturn OK;&#125;销毁顺序栈\n12345678910Status DestroyStack( SqStack &amp;S )&#123;\tif( S.base )\t&#123;\t\tdelete S.base ;\t\tS.stacksize = 0;\t\tS.base = S.top = NULL;\t&#125;  return OK;&#125;进栈判断是否栈满，若满则出错\n元素e压入栈顶\n栈顶指针加1\n1234567Status Push(SqStack &amp;S, SElemType e) &#123;\t// 插入元素e为新的栈顶元素\tif (S.top - S.base == S.stacksize)\t\treturn ERROR; //栈满\t*(S.top++) = e; //元素e压入栈顶，栈顶指针加1 *S.top=e;S.top++;\treturn OK;&#125;出栈判断是否栈空，若空则出错\n获取栈顶元素e\n栈顶指针减1\n1234567Status Pop(SqStack &amp;S, SElemType &amp;e) &#123;\t//删除S的栈顶元素，用e返回其值\t\tif (S.base == S.top)\t\treturn ERROR;//栈空\te = *(--S.top); //栈顶指针减1，将栈顶元素赋给e --S.top;e=*S.top;\treturn OK;&#125;取栈顶元素判断是否空栈，若空则返回错误\n否则通过栈顶指针获取栈顶元素\n1234Status GetTop( SqStack S)  &#123;\tif (S.top != S.base) //栈非空\t\treturn *(S.top - 1); //返回栈顶元素的值，栈顶指针不变&#125;链栈运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针\n1234typedef struct StackNode &#123;\tSElemType data;\tstruct StackNode *next;&#125; StackNode, *LinkStack;初始化1234Status InitStack(LinkStack &amp;S) &#123; // 构造一个空栈 S，栈顶指针置空\tS = NULL;\treturn OK;&#125;判断链栈是否为空\n12345Status StackEmpty(LinkStack S)&#123;\t    if (S==NULL) return TRUE; \telse return FALSE;&#125;进栈12345678Status Push(LinkStack &amp;S, SElemType e) &#123;//在栈顶插入元素e\tLinkStack p;\tp = new StackNode; //生成新结点\tp-&gt;data = e; //将新结点数据域置为e\tp-&gt;next = S; //将新结点插入栈顶\tS = p; //修改栈顶指针为p\treturn OK;&#125;出栈12345678910Status Pop(LinkStack &amp;S, SElemType &amp;e) &#123;//删除S的栈顶元素，用e返回其值\tLinkStack p;\tif (S == NULL)\t\treturn ERROR; //栈空\te = S-&gt;data; //将栈顶元素赋给e\tp = S; //用p临时保存栈顶元素空间，以备释放\tS = S-&gt;next; //修改栈顶指针\tdelete p; //释放原栈顶元素的空间\treturn OK;&#125;取栈顶元素1234SElemType GetTop(LinkStack S) &#123;//返回S的栈顶元素，不修改栈顶指针\tif (S != NULL) //栈非空\t\treturn S-&gt;data; //返回栈顶元素的值，栈顶指针不变&#125;栈与递归递归的定义：若一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称他们是递归的。若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。\n12345long Fact ( long n ) &#123;    if ( n == 0) return 1;    else return n * Fact (n-1); &#125;\n以下三种情况常常用到递归方法\n递归定义的数学函数\n具有递归特性的数据结构\n可递归求解的问题\n优点：结构清晰，程序易读\n缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。\n队列队列是一种先进先出(FIFO) 的线性表. 在表一端插入,在另一端删除\n定义：只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序队列或链队存储均可\n运算规则：先进先出（FIFO）\n实现方式：关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同\n队列的顺序表示 一维数组base[M]123456#define M  100   //最大队列长度Typedef struct &#123;   QElemType *base;  //初始化的动态分配存储空间   int  front;            //头指针      int  rear;             //尾指针&#125;SqQueue;存在问题循环队列\n问题：队空：front==rear    队满：front==rear\n\n解决方案：\n另外设一个标志以区别队空、队满\n少用一个元素空间：队空：front==rear\n队满：(rear+1)%M==front\n初始化1234567Status InitQueue(SqQueue &amp;Q) &#123;//构造一个空队列Q\tQ.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间\tif (!Q.base)\t\texit(OVERFLOW); //存储分配失败\tQ.front = Q.rear = 0; //头指针和尾指针置为零，队列为空\treturn OK;&#125;求循环队列的长度123int QueueLength(SqQueue Q) &#123;//返回Q的元素个数，即队列的长度\treturn (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;&#125;入队1234567Status EnQueue(SqQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\tif ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满\t\treturn ERROR;\tQ.base[Q.rear] = e; //新元素插入队尾\tQ.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1\treturn OK;&#125;出队1234567Status DeQueue(SqQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值\tif (Q.front == Q.rear)\t\treturn ERROR; //队空\te = Q.base[Q.front]; //保存队头元素\tQ.front = (Q.front + 1) % MAXQSIZE; //队头指针加1\treturn OK;&#125;取循环队列的队头元素1234SElemType GetHead(SqQueue Q) &#123;//返回Q的队头元素，不修改队头指针\tif (Q.front != Q.rear) //队列非空\t\treturn Q.base[Q.front]; //返回队头元素的值，队头指针不变&#125;链队12345678typedef struct QNode &#123;\tQElemType data;\tstruct QNode *next;&#125; QNode, *QueuePtr;typedef struct &#123;\tQueuePtr front; //队头指针c\tQueuePtr rear; //队尾指针&#125; LinkQueue;初始化12345Status InitQueue(LinkQueue &amp;Q) &#123;//构造一个空队列Q\tQ.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点\tQ.front-&gt;next = NULL; //头结点的指针域置空\treturn OK;&#125;入队123456789Status EnQueue(LinkQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\tQueuePtr p;\tp = new QNode; //为入队元素分配结点空间，用指针p指向\tp-&gt;data = e; //将新结点数据域置为e\tp-&gt;next = NULL;\tQ.rear-&gt;next = p; //将新结点插入到队尾\tQ.rear = p; //修改队尾指针\treturn OK;&#125;出队123456789101112Status DeQueue(LinkQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值 \tQueuePtr p;\tif (Q.front == Q.rear)\t\treturn ERROR; //若队列空，则返回ERROR\tp = Q.front-&gt;next; //p指向队头元素\te = p-&gt;data; //e保存队头元素的值\tQ.front-&gt;next = p-&gt;next; //修改头指针\tif (Q.rear == p)\t\tQ.rear = Q.front; //最后一个元素被删，队尾指针指向头结点\tdelete p; //释放原队头元素的空间\treturn OK;&#125;取链队的队头元素1234SElemType GetHead(LinkQueue Q) &#123;//返回Q的队头元素，不修改队头指针\tif (Q.front != Q.rear) //队列非空\t\treturn Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变&#125;","plink":"https://dxsummer.gitee.io/posts/8d66b5f2/"},{"title":"盒子模型","date":"2020-10-18T04:17:26.000Z","date_formatted":{"ll":"2020年10月18日","L":"2020/10/18","MM-DD":"10-18"},"updated":"2020-10-18T07:53:15.523Z","content":"边框属性\n在设置边框宽度时，必须同时设置边框样式，如果未设置样式或设置为none，则不论宽度设置为多少都无效。注意：常用取值单位为像素。\n\n颜色border-color:transparent 透明色\nCSS3在原边框颜色属性（border-color）的基础上派生了4个边框颜色属性。border-top/right/bottom/left-colors \n例如对段落文本&lt;p&gt;添加渐变边框效果，示例代码如下：\n12345678p&#123;\tborder-style:solid;\tborder-width:10px;\t-moz-border-top-colors:#a0a #909 #808 #707 #606 #505 #404 #303;\t-moz-border-right-colors:#a0a #909 #808 #707 #606 #505 #404 #303;\t-moz-border-bottom-colors:#a0a #909 #808 #707 #606 #505 #404 #303;\t-moz-border-left-colors:#a0a #909 #808 #707 #606 #505 #404 #303;&#125;内边距属性内外边距清除\n1234*&#123;\tpadding:0;         /*清除内边距*/\tmargin:0;          /*清除外边距*/&#125;\n外边距属性块级元素水平居中\n1.num&#123;margin:0 auto;&#125;\n背景属性颜色图像12345body&#123;background-color:#CCC; background-image:url(images/jianbian.jpg);&#125;图像平铺1background-repeat:图像平铺属性背景图像的位置1background-position:图像位置属性背景图像固定1background-attachment:图像固定属性综合设置元素的背景12background:背景色 url(\"图像\") 平铺 定位 固定;background: url(img/wdjl.jpg) no-repeat 50px 80px fixed;盒子的宽与高盒子模型新增属性颜色透明度通过引入RGBA模式和opacity属性，对背景与图片设置不透明度\n12rgba(r,g,b,alpha);p&#123;background-color:rgba(255,0,0,0.5);&#125;\nopacity属性用于定义标签的不透明度，参数opacityValue表示不透明度的值，它是一个介于0~1之间的浮点数值。其中，0表示完全透明，1表示完全不透明，而0.5则表示半透明。\n1opacity：opacityValue;\n圆角1border-radius:水平半径参数1 水平半径参数2 水平半径参数3 水平半径参数4/垂直半径参数1 垂直半径参数2 垂直半径参数3 垂直半径参数4;水平半径参数和垂直半径参数设置2两个参数值时,第一个参数值代表左上和右下圆角半径 , 第二个表示右上左下\n\n三个参数值,第一个参数值左上 第二个参数值右上左下 第三个参数值 右下\n\n需要注意的是，当应用值复制原则设置圆角边框时，如果“垂直半径参数”省略，则会默认等于“水平半径参数”的参数值。此时圆角的水平半径和垂直半径相等。\n\n图片边框1border-image: border-image-source/ border-image-slice/ border-image-width/ border-image-outset/ border-image-repeat;12345678910111213141516&lt;style type=\"text/css\"&gt;p&#123;\twidth:362px; \theight:362px;\tborder-style:solid; \tborder-image-source:url(3.png); /*设置边框图片路径*/\tborder-image-slice:33%;           /*边框图像顶部、右侧、底部、左侧向内偏移量*/\tborder-image-width:40px;          /*设置边框宽度*/\tborder-image-outset:0;\t\t  /*设置边框图像区域超出边框量*/\tborder-image-repeat:repeat;\t      /*设置图片平铺方式*/\t&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;&lt;/body&gt;阴影box-shadow属性也可以改变阴影的投射方向以及添加多重阴影效果。\n1box-shadow: h-shadow v-shadow blur spread color outset;\n参数值描述\n\nh-shadow水平阴影位置(必选)\n\nv-shadow垂直阴影的位置(必选)\n\nblur阴影模糊半径\n\nspread阴影扩展半径 不能为负\n\ncolor阴影颜色\n\noutset/inset外阴影/内阴影\n1box-shadow:5px 5px 10px 2px #999 inset,-5px -5px 10px 2px #333 inset;渐变线性渐变1background-image:linear-gradient(渐变角度,颜色值1,颜色值2...,颜色值n);linear-gradient用于定义渐变方式为线性渐变，括号内用于设定渐变角度和颜色值。\n径向渐变1background-image:radial-gradient(渐变形状 圆心位置,颜色值1,颜色值2...,颜色值n);重复渐变重复线性渐变\n1background-image:repeating-linear-gradient(渐变角度,颜色值1,颜色值2...,颜色值n);重复径向渐变\n1background-image:repeating-radial-gradient(渐变形状 圆心位置,颜色值1,颜色值2...,颜色值n);多背景图像1234background-image:url(images/caodi.png),url(images/taiyang.png),url(images/tiankong.png);修剪背景图像设置背景图像的大小1background-size:属性值1 属性值2;设置背景图像的显示区域1background-origin:属性值;在上面的语法格式中，background-origin属性有三种取值，分别表示不同的含义，具体解释如下。\npadding-box：背景图像相对于内边距区域来定位。\nborder-box：背景图像相对于边框来定位。\ncontent-box：背景图像相对于内容框来定位。\n设置背景图像的裁剪区域1background-clip:属性值;在语法格式上，background-clip属性和background-origin 属性的取值相似，但含义不同，具体解释如下。\nborder-box：默认值，从边框区域向外裁剪背景。\npadding-box：从内边距区域向外裁剪背景。\ncontent-box：从内容区域向外裁剪背景。\n元素的类型和转换&lt;div&gt;和&lt;span&gt;标签块元素: &lt;h1&gt;—&lt;h6&gt; &lt;div&gt; &lt;ul&gt; &lt;p&gt; &lt;ol&gt; &lt;li&gt; 其中&lt;div&gt;标签是最典型的块元素。\n行内元素: &lt;strong&gt; &lt;b&gt; &lt;a&gt; &lt;em&gt; &lt;span&gt; &lt;u&gt; 其中&lt;span&gt;标签最典型的行内元素。\n元素类型的转换块元素垂直外边距的合并嵌套块元素垂直外边距的合并如果父标签没有上内边距及边框,则父标签的上边距会与子标签的上边距发生重合,取最大者\neg:\n12345678910111213141516171819202122&lt;style type=\"text/css\"&gt;*&#123;margin:0; padding:0;&#125;   /*使用通配符清除所有HTML标记的默认边距*/div.father&#123;\twidth:400px;\theight:400px;\tbackground:#FC0;\t\tmargin-top:20px;      /*定义第一个div的上外边距为20px*/\tborder-top:1px solid #FCC;       /*定义父div的上边框*/ \t&#125;div.son&#123;\twidth:200px;\theight:200px;\tbackground:#63F;\t\tmargin-top:40px;      /*定义第二个div的上外边距为40px*/\t&#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"father\"&gt;     &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;","plink":"https://dxsummer.gitee.io/posts/998dffd6/"},{"title":"css选择器","date":"2020-10-09T06:32:51.000Z","date_formatted":{"ll":"2020年10月9日","L":"2020/10/09","MM-DD":"10-09"},"updated":"2020-10-17T15:37:09.980Z","content":"CSS基础选择器标签选择器用HTML标签名称作为选择器，按标签名称分类，为页面某一类标签指定统一的css样式\n1标签名&#123;属性1:属性值1;属性2:属性值2;属性3:属性值3；&#125;12345p&#123;    font-size:12px;     color:#666;     font-family:\"微软雅黑\"；&#125;类选择器使用.进行标识\n类名的第一个字符不能使用数字\n严格区分大小写，一般采用小写英文\n1.类名&#123;属性1:属性值1;属性2:属性值2;属性3:属性值3；&#125;\n1234567891011121314&lt;style type=\"text/css\"&gt;.red&#123;color:red;&#125;\t\t//类选择器.green&#123;color:green;&#125;.font22&#123;font-size:22px;&#125;p&#123;\t\t\t//标签选择器   text-decoration:underline;    font-family:\"微软雅黑\";&#125;&lt;/style&gt;&lt;h2 class=\"red\"&gt;二级标题文本&lt;/h2&gt;&lt;p class=\"green font22\"&gt;段落一文本内容&lt;/p&gt;\t\t//类支持定义多个值&lt;p class=\"red font22\"&gt;段落二文本内容&lt;/p&gt;&lt;p&gt;段落三文本内容&lt;/p&gt;id选择器使用#进行标识，后面紧跟id名\n绝大多数HTML元素都可以定义id属性，元素id名是唯一的，只能对应于文档中某一个具体的元素\n同一个id也可以应用于多个标签，浏览器不会报错，但不允许\nid选择器不支持像类选择器那样定义多个值 id=&quot;bold font24&quot;错误\n1#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;\n123456789&lt;style type=\"text/css\"&gt;#bold &#123;font-weight:bold;&#125;#font24 &#123;font-size:24px;&#125;&lt;/style&gt;&lt;p id=\"bold\"&gt;段落1：id=\"bold\"，设置粗体文字。&lt;/p&gt;&lt;p id=\"font24\"&gt;段落2：id=\"font24\"，设置字号为24px。&lt;/p&gt;&lt;p id=\"font24\"&gt;段落3：id=\"font24\"，设置字号为24px。&lt;/p&gt;\t\t//不允许 行6已经用过font24&lt;p id=\"bold font24\"&gt;段落4：id=\"bold font24\"，同时设置粗体和字号24px。&lt;/p&gt;\t\t//错误通配符选择器用*号表示，它是所有选择器中作用范围最广的，能匹配页面中所有的元素\n通配符选择器设置的样式对所有的HTML标签都生效，不管标签是否需要该样式\n1*&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;1234*&#123;\tmargin: 0;\t/*定义外边距*/    padding: 0;\t/*定义内边距*/&#125;CSS复合选择器标签指定式选择器（交集选择器）由两个选择器构成，其中第一个为标签选择器，第二个为class选择器或id选择器，两个选择器之间不能有空格，如h3.special或p#one\n\n123456789&lt;style type=\"text/css\"&gt;p&#123; color:blue;&#125;.special&#123; color:green;&#125;p.special&#123; color:red;&#125;    /*标签指定式选择器*/   &lt;/style&gt;&lt;p&gt;普通段落文本（蓝色）&lt;/p&gt;&lt;p class=\"special\"&gt;指定了.special类的段落文本（红色）&lt;/p&gt;&lt;h3 class=\"special\"&gt;指定了.special类的标题文本（绿色）&lt;/h3&gt;后代选择器把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n1234567&lt;style type=\"text/css\"&gt;p strong&#123;color:red;&#125;     /*后代选择器*/strong&#123;color:blue;&#125;\t\t//标签选择器&lt;/style&gt;&lt;p&gt;段落文本&lt;strong&gt;嵌套在段落中，使用strong标记定义的文本（红色）。&lt;/strong&gt;&lt;/p&gt;&lt;strong&gt;嵌套之外由strong标记定义的文本（蓝色）。&lt;/strong&gt;并集选择器各个选择器通过逗号连接而成的，任何形式的选择器都可以作为并集选择器的一部分。若某些选择器定义的样式完全或部分相同，可利用并集选择器为它们定义相同的样式。\n\n12345678910&lt;style type=\"text/css\"&gt;h2,h3,p&#123;color:red; font-size:14px;&#125;              /*不同标签组成的并集选择器*/h3,.special,#one&#123;text-decoration:underline;&#125;   /*标签、类、id组成的的并集选择器*/&lt;/style&gt;&lt;h2&gt;二级标题文本。&lt;/h2&gt;&lt;h3&gt;三级标题文本,加下画线。&lt;/h3&gt;&lt;p class=\"special\"&gt;段落文本1，加下画线。&lt;/p&gt;&lt;p&gt;段落文本2，普通文本。&lt;/p&gt;&lt;p id=\"one\"&gt;段落文本3，加下画线。&lt;/p&gt;CSS的层叠性和继承性层叠性多种CSS样式的叠加\n\n123456789101112&lt;style type=\"text/css\"&gt;p&#123;    font-size:12px;    font-family:\"楷体\";&#125;.special&#123; font-size:16px;&#125;#one&#123; color:red;&#125;&lt;/style&gt;&lt;p class=\"special\" id=\"one\"&gt;段落文本1&lt;/p&gt;&lt;p&gt;段落文本2&lt;/p&gt;&lt;p&gt;段落文本3&lt;/p&gt;继承性书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。\n不必在元素的每个后代上添加相同的样式\n\n12p,div,h1,h2,h3,h4,ul,ol&#123;color:black;&#125;body&#123;color:black;&#125;\t//与行1相同CSS的优先级标签选择器权重1、类选择器权重10、id选择器权重100\n\n继承样式的权重为0。不管父元素样式的权重多大，被子元素继承时，它的权重都为0，子元素定义的样式会覆盖继承来的样式\n\n行内样式优先。应用style属性的元素，其行内式的权重很高，远大于100。\n\n权重相同时，CSS遵循就近原则。 内嵌式比外链式更靠近HTML元素，行内式&gt;内嵌式&gt;外链式\n\nCSS定义了一个！important（位于属性值和分号之间），该命令被赋予最大的优先级\n1#header&#123;color:red!important;&#125;\n属性选择器E[att^=value] 前缀选择名称为E的标记，且该标记定义了att属性，att属性值包含前缀为value的子字符串。\n1div[id^=section]​    表示匹配包含id属性，且id属性值是以“section”字符串开头的div元素。\n12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;E[att^=value] 属性选择器的应用&lt;/title&gt;&lt;style type=\"text/css\"&gt;p[id^=\"one\"]&#123;\tcolor:pink;\tfont-family:\"微软雅黑\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=\"one\"&gt;\t为了看日出，我常常早起。那时天还没有大亮，周围非常清静，船上只有机器的响声。&lt;/p&gt;&lt;p id=\"two\"&gt;\t天空还是一片浅蓝，颜色很浅。转眼间天边出现了一道红霞，慢慢地在扩大它的范围，加强它的亮光。我知道太阳要从天边升起来了，便不转眼地望着那里。&lt;/p&gt;&lt;p id=\"one1\"&gt;\t果然过了一会儿，在那个地方出现了太阳的小半边脸，红是真红，却没有亮光。这个太阳好象负着重荷似地一步一步、慢慢地努力上升，到了最后，终于冲破了云霞，完全跳出了海面，颜色红得非常可爱。一刹那间，这个深红的圆东西，忽然发出了夺目的亮光，射得人眼睛发痛，它旁边的云片也突然有了光彩。&lt;/p&gt;&lt;p id=\"two1\"&gt;\t有时太阳走进了云堆中，它的光线却从云里射下来，直射到水面上。这时候要分辨出哪里是水，哪里是天，倒也不容易，因为我就只看见一片灿烂的亮光。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;E[att$=value] 后缀选择名称为E的标记，且该标记定义了att属性，att属性值包含后缀为value的子字符串。与E[att^=value]选择器一样，E元素可以省略，如果省略则表示可以匹配满足条件的任意元素。\n1div[id$=section]表示匹配包含id属性，且id属性值是以“section”字符串结尾的div元素。\n12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;E[att$=value] 属性选择器的应用&lt;/title&gt;&lt;style type=\"text/css\"&gt;p[id$=\"main\"]&#123;\tcolor:#0cf;\tfont-family: \"宋体\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=\"old1\"&gt;\t盼望着，盼望着，东风来了，春天的脚步近了。&lt;/p&gt;&lt;p id=\"old2\"&gt;\t小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏。风轻悄悄的，草绵软软的。&lt;/p&gt;&lt;p id=\"oldmain\"&gt;\t桃树、杏树、梨树，你不让我，我不让你，都开满了花赶趟儿。红的像火，粉的像霞，白的像雪。花里带着甜味，闭了眼，树上仿佛已经满是桃儿、杏儿、梨儿！花下成千成百的蜜蜂嗡嗡地闹着……&lt;/p&gt;&lt;p id=\"newmain\"&gt;\t“吹面不寒杨柳风”，不错的，像母亲的手抚摸着你。风里带来些新翻的泥土的气息，混着青草味，还有各种花的香，都在微微润湿的空气里酝酿。鸟儿将窠巢安在繁花嫩叶当中，高兴起来了……&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;E[att*=value] 包含E[att*=value]选择器用于选择名称为E的标记，且该标记定义了att属性，att属性值包含value子字符串。该选择器与前两个选择器一样，E元素也可以省略，如果省略则表示可以匹配满足条件的任意元素。\n1div[id*=section]表示匹配包含id属性，且id属性值包含“section”字符串的div元素。\n12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;E[att*=value]属性选择器的使用&lt;/title&gt;&lt;style type=\"text/css\"&gt;p[id*=\"demo\"]&#123;\tcolor:#0ca; \tfont-family: \"宋体\"; \tfont-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=\"demo1\"&gt;\t 我们消受得秦淮河上的灯影，当四月犹皎的仲夏之夜。&lt;/p&gt;&lt;p id=\"main1\"&gt;\t 在茶店里吃了一盘豆腐干丝，两个烧饼之后，以至歪的脚步踅上夫子庙前停泊着的画访，就懒洋洋到躺到藤椅上去了。好郁蒸的江南，傍也还是热的。\"快开船罢！\"桨声响了。&lt;/p&gt;&lt;p id=\"newdemo\"&gt;\t 小的灯舫初次在河中荡漾；于我，情景是颇朦胧，滋味是怪羞涩的。我要错认它作七里的山塘；可是，河房里明窗洞启，映着玲珑入画的栏干，顿然省得身在何处了……&lt;/p&gt;&lt;p id=\"olddemo\"&gt;\t 又早是夕阳西下，河上妆成一抹胭脂的薄媚。是被青溪的姊妹们所薰染的吗？还是匀得她们脸上的残脂呢？寂寂的河水，随双桨打它，终没言语。密匝匝的绣恨逐老去的年华，已都如蜜饧似的融在流波的心窝里、连呜咽也将嫌它多事，更哪里论到哀嘶……&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;关系选择器子元素选择器 &gt;选择某个元素的第一级子元素\n希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：h1 &gt; strong\n123456789101112131415161718&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;子元素择器的应用&lt;/title&gt;&lt;style type=\"text/css\"&gt;h1&gt;strong&#123;\tcolor:red;\tfont-size:20px;\tfont-family:\"微软雅黑\";&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这个&lt;strong&gt;知识点&lt;/strong&gt;很&lt;strong&gt;重要&lt;/strong&gt;&lt;/h1&gt;&lt;h1&gt;首都&lt;em&gt;&lt;strong&gt;人民&lt;/strong&gt;&lt;/em&gt;欢迎你！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;相邻兄弟选择器（+、~）临近兄弟选择器该选择器使用加号“+”来链接前后两个选择器。选择器中的两个元素有同一个父亲，而且第二个元素必须紧跟第一个元素。\n123456789101112131415&lt;style type=\"text/css\"&gt;p+h2&#123;\tcolor:green;\tfont-family:\"宋体\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;《赠汪伦》&lt;/h2&gt;&lt;p&gt;李白乘舟将欲行，&lt;/p&gt;&lt;h2&gt;忽闻岸上踏歌声。&lt;/h2&gt;\t//作用者&lt;h2&gt;桃花潭水深千尺，&lt;/h2&gt;&lt;h2&gt;不及汪伦送我情。&lt;/h2&gt;&lt;/body&gt;普通兄弟选择器普通兄弟选择器使用 “~”来链接前后两个选择器。选择器中的两个元素有同一个父亲，但第二个元素不必紧跟第一个元素。\n1234567891011121314&lt;style type=\"text/css\"&gt;p~h2&#123;\tcolor:pink;\tfont-family:\"微软雅黑\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;你站在桥上看风景&lt;/p&gt;&lt;h2&gt;看风景的人在楼上看你&lt;/h2&gt;&lt;h2&gt;明月装饰了你的窗子&lt;/h2&gt;&lt;h2&gt;你装饰了别人的梦&lt;/h2&gt;&lt;/body&gt;结构化伪类选择器:root选择器:root选择器用于匹配文档根元素，在HTML中，根元素始终是html元素。也就是说使用“:root选择器”定义的样式，对所有页面元素都生效。对于不需要该样式的元素，可以单独设置样式进行覆盖。\n123456789101112&lt;style type=\"text/css\"&gt;:root&#123;color:red;&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;《面朝大海春暖花开》&lt;/h2&gt;&lt;p&gt;从明天起做个幸福的人喂马劈柴周游世界 从明天起关心粮食和蔬菜我有一所房子 面朝大海春暖花开&lt;/p&gt;&lt;/body&gt;:not选择器如果对某个结构元素使用样式，但是想排除这个结构元素下面的子结构元素，让它不使用这个样式，可以使用:not选择器。\n123456789101112131415&lt;style type=\"text/css\"&gt;body *:not(h3)&#123;\tcolor: orange;\tfont-size: 20px;\tfont-family: \"宋体\";&#125;&lt;/style&gt;&lt;body&gt;&lt;h3&gt;《世界上最远的距离》&lt;/h3&gt;\t&lt;p&gt;世界上最远的距离&lt;/p&gt; &lt;p&gt;不是生与死的距离&lt;/p&gt; &lt;p&gt;而是我站在你面前&lt;/p&gt; &lt;p&gt;你却不知道我爱你...&lt;/p&gt;&lt;/body&gt;:only-child选择器匹配属于某父元素的唯一子元素的元素，也就是说，如果某个父元素仅有一个子元素，则使用“:only-child 选择器”可以选择这个子元素。\n\n123456789101112131415161718&lt;style type=\"text/css\"&gt;strong:only-child&#123;color:red;&#125;&lt;/style&gt;&lt;body&gt;\t&lt;p&gt;    \t&lt;strong&gt;一代宗师&lt;/strong&gt;    \t&lt;strong&gt;英雄&lt;/strong&gt;    &lt;/p&gt;\t&lt;p&gt;    \t&lt;strong&gt;复仇者联盟4&lt;/strong&gt;    &lt;/p&gt;\t&lt;p&gt;    \t&lt;strong&gt;非诚勿扰&lt;/strong&gt;    \t&lt;strong&gt;火影忍者&lt;/strong&gt;        &lt;strong&gt;进击的巨人&lt;/strong&gt;    &lt;/p&gt;&lt;/body&gt;:first-child和:last-child选择器:first-child选择器和:last-child选择器分别用于为父元素中的第一个或者最后一个子元素设置样式。\n1234567891011121314151617181920&lt;style type=\"text/css\"&gt;p:first-child&#123;   color:pink;   font-size:16px;   font-family:\"宋体\";\t&#125;p:last-child&#123;   color:blue;   font-size: 16px;   font-family: \"微软雅黑\";&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;第一篇 毕业了&lt;/p&gt;&lt;p&gt;第二篇 关于考试&lt;/p&gt;&lt;p&gt;第三篇 夏日飞舞&lt;/p&gt;&lt;p&gt;第四篇 惆怅的心&lt;/p&gt;&lt;p&gt;第五篇 畅谈美丽&lt;/p&gt;&lt;/body&gt;:nth-child(n)和:nth-last-child(n)选择器如果用户想要选择第2个或倒数第2个子元素，这两个选择器就不起作用了。为此，CSS3引入了:nth-child(n)和:nth-last-child(n)选择器，它们是:first-child选择器和:last-child选择器的扩展。\n1234567891011121314151617181920&lt;style type=\"text/css\"&gt;p:nth-child(2)&#123;   color:pink;   font-size:16px;   font-family:\"宋体\";&#125;p:nth-last-child(2)&#123;  color:blue;  font-size: 16px;  font-family: \"微软雅黑\";&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;第一篇 毕业了&lt;/p&gt;&lt;p&gt;第二篇 关于考试&lt;/p&gt;&lt;p&gt;第三篇 夏日飞舞&lt;/p&gt;&lt;p&gt;第四篇 惆怅的心&lt;/p&gt;&lt;p&gt;第五篇 畅谈美丽&lt;/p&gt;&lt;/body&gt;:nth-of-type(n)和:nth-last-of-type(n)选择器:nth-of-type(n)和:nth-last-of-type(n)选择器用于匹配属于父元素的特定类型的第 n 个子元素和倒数第n个子元素。\n12345678910111213141516&lt;style type=\"text/css\"&gt;h2:nth-of-type(odd)&#123;color:#f09;&#125;\t//奇数h2:nth-of-type(even)&#123;color:#12ff65;&#125;\t//偶数p:nth-last-of-type(2)&#123;font-weight:bold;&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;网页设计&lt;/h2&gt;&lt;p&gt;网页设计是根据企业希望向浏览者传递的信息（包括产品、服务、理念、文化），进行网站功能策划，然后进行的页面设计美化工作。&lt;/p&gt;&lt;h2&gt;Java&lt;/h2&gt;&lt;p&gt;Java是一种可以撰写跨平台应用程序的面向对象的程序设计语言。&lt;/p&gt;&lt;h2&gt;iOS&lt;/h2&gt;&lt;p&gt;iOS是由苹果公司开发的移动操作系统。&lt;/p&gt;&lt;h2&gt;PHP&lt;/h2&gt;&lt;p&gt;PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。&lt;/p&gt;&lt;/body&gt;:empty选择器:empty选择器用来选择没有子元素或文本内容为空的所有元素。\n123456789101112131415&lt;style type=\"text/css\"&gt;p&#123;\twidth:150px;\theight:30px;&#125;:empty&#123;background-color: #999;&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;北京校区&lt;/p&gt;&lt;p&gt;上海校区&lt;/p&gt;&lt;p&gt;广州校区&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;武汉校区&lt;/p&gt;\t&lt;/body&gt;伪元素选择器:before选择器:before伪元素选择器用于在被选元素的内容前面插入内容，必须配合content属性来指定要插入的具体内容。\n1234&lt;元素&gt;:before&#123;\tcontent:文字/url();&#125;1234567891011121314&lt;style type=\"text/css\"&gt;p:before&#123;\t content:\"学习IT视频教程\";\t color:#c06;\t font-size: 20px;\t font-family: \"微软雅黑\";\t font-weight: bold;&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;专注于Java、.Net、PHP、网页设计和平面设计、IOS、C++工程师的培养，提供的免费视频教程是目前覆盖面最广，项目最真实的视频教程之一。&lt;/p&gt;&lt;/body&gt;:after选择器:after伪元素选择器用于在某个元素之后插入一些内容，使用方法与:before选择器相同。\n1234567&lt;style type=\"text/css\"&gt;p:after&#123;content:url(zhongqiu.png);&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;十五的月亮&lt;br&gt;&lt;/p&gt;&lt;/body&gt;","plink":"https://dxsummer.gitee.io/posts/676848e4/"},{"title":"css基础","date":"2020-10-02T07:15:23.000Z","date_formatted":{"ll":"2020年10月2日","L":"2020/10/02","MM-DD":"10-02"},"updated":"2020-10-10T15:06:33.192Z","content":"css样式规则1选择器&#123;属性1：属性值1；属性2：属性值2；属性3：属性值3；····&#125;每条声明由一个属性和属性值组成，以“键值对”的形式出现\nCSS样式中的选择器严格区分大小写\n\n多个属性之间必须用英文状态下的;隔开\n\n若属性的属性值由多个单词组成且中间包含空格，则必须加&quot;&quot;\n1p &#123;font-family:\"Times New Roman\"&#125;\n在CSS代码中空格是不被解析的，{}``;前后的空格可有可无\n1h1&#123; color:green; font-size:14px; &#125;1234h1&#123;   \tcolor:green;\t/* 定义颜色的属性*/  \tfont-size:14px;\t/*定义字体大小属性*/  &#125;代码2可读性更高\n\n属性值和单位之间不能出现空格\n1h1&#123;font-size:14 px; &#125;\t/* 14和单位px之间有空格，浏览器解析时会出现错误*/\n引入CSS样式表行内式（内联式）通过标签的style属性来设置标签样式，没有做到结构与样式分离\n1&lt;标签名 style=\"属性1：属性值1；属性2：属性值2；属性3：属性值3；\"&gt;内容&lt;/标签名&gt;style：标签的属性\n1&lt;h1 style=\"font-size：20px；color：blue；\"&gt;使用CSS行内式修饰一级标签的字体大小和颜色&lt;/h1&gt;内嵌式只对其所在的HTML页面有效\n网站不建议使用这种方法，不能充分发挥CSS代码重用的优势\n写在HTML文档的&lt;head&gt;标签之中\n12345&lt;head&gt;&lt;style type=\"text/css\"&gt;\t选择器&#123;属性1：属性值1；属性2：属性值2；属性3：属性值3；&#125;&lt;/style&gt;&lt;/head&gt;123456789&lt;style type=\"text/css\"&gt;.red&#123;color:red;&#125;.green&#123;color:green;&#125;.font22&#123;font-size:22px;&#125;p&#123;   text-decoration:underline;    font-family:\"微软雅黑\";&#125;&lt;/style&gt;&lt;style&gt;标签一般位于&lt;title&gt;标签之后，也可以放到HTML文档的任何地方\n外链式(链入式)同CSS可以被不同的HTML页面链接使用\n外链式是使用频率最高，最实用的CSS样式表\n123&lt;head&gt;&lt;link href=\"css文件的路径\" type=\"text/css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;1&lt;link href=\"style.css\" type=\"text/css\" rel=\"stylesheet\" /&gt;必须指定&lt;link /&gt;标签的3个属性\nhref：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径\ntype：定义所链接文档的类型，&quot;text/css&quot;表示链接的外部文件为CSS样式表\nrel：定义当前文档与被链接文档之间的关系，&quot;stylesheet&quot;表示被链接的文档是一个样式表文件\n导入式与外链式相同，针对外部样式表文件\n两者加载时间和顺序不同\n当一个页面被加载时&lt;link /&gt;引用的CSS样式表同时被加载\n@import会等到页面全部下载完成后再被加载，当网速慢时，会造成不好的用户体验\n\n1234&lt;style type=\"text/css\" &gt;\t@import url(css文件路径); 或 @import \"css文件路径\"；    /*在此还可以存放其他css样式*/&lt;/style&gt;123&lt;style type=\"text/css\" &gt;\t@import \"style.css\";&lt;/style&gt;123&lt;style type=\"text/css\" &gt;\t@import url(style.css);&lt;/style&gt;设置文本样式字体样式font-size用于设置字号\n\n相对长度单位说明\n\nem相对于当前对象内文本的字体尺寸\n\npx像素，最常用，推荐使用\n\n绝对长度单位说明\n\nin英寸\n\ncm厘米\n\nmm毫米\n\npt点\nfont-family用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等。\n中文字体需要加&quot;&quot;，英文一般不需要，英文字体名称必须位于中文字体名称之前\n如果字体名中包含、#、$等符号，字体必须加英文状态下的单引号或双引号\n1p&#123; font-family:\"微软雅黑\";&#125;12body&#123;font-family: Arial,\"华文云彩\",\"宋体\",\"黑体\"；&#125;\t//正确body&#123;font-family: \"华文云彩\",\"宋体\",\"黑体\",Arial；&#125;\t//错误font-weight用于定义字体的粗细\n\n值描述\n\nnormal默认值。定义标准的字符。\n\nbold定义粗体字符。\n\nbolder定义更粗的字符。\n\nlighter定义更细的字符。\n\n100~900（100的整数倍）定义由细到粗的字符。其中400等同于normal，700等同于bold，值越大字体越粗。\nfont-style定义字体风格，如设置斜体、倾斜或正常字体\n\n值描述\n\nnormal默认值，浏览器会显示标准的字体样式\n\nitalic浏览器会显示斜体的字体样式（文字本身的斜体）\n\noblique浏览器会显示倾斜的字体样式（强制斜体）\nfont综合属性1选择器&#123;font: font-style font-weight font-size/line-height font-family;&#125;123456p&#123;\tfont-style:Arial,\"宋体\";    font-size:30px;    font-weight:bold;    line-height:40px;&#125;等价于：\n1p&#123;font:italic bold 30px/40px Arial,\"宋体\";&#125;必须保留font-size、font-family，否则font属性不起作用\n@font-faceCSS3的新增属性，用于定义服务器字体。通过@font-face属性，开发者可以在用户计算机未安装字体时，使用任何喜欢的字体\n1234@font-face&#123;\t\tfont-family:jianzhi;\t//字体名称\t\tsrc:url(FZJZJW.TTF);\t//字体路径&#125;文本外观属性color：文本颜色red、green、blue\n十六进制 #FF0000 最常用\nRGB rgb(255,0,0) rgb(100%,0%,0%) 0不能省略\n\n十六进制颜色值 每两位一个颜色分量 分别表示颜色红、绿、蓝，#FF6600可缩写为#F60\n\nletter-spacing: 字间距定义字间距，所谓字间距就是字符与字符之间的空白。\nletter-spacing属性，其属性值可为不同单位的数值，允许使用负值，默认为normal。\n1h2&#123;letter-spacing:20px;&#125;word-spacing：单词间距定义英文单词之间的间距，对中文字符无效。\n属性值可为不同单位的数值，允许使用负值，默认为normal\nline-height：行间距设置行间距，所谓行间距就是行与行之间的距离，即字符的垂直间距，一般称为行高。\n像素px、相对值em、百分比%\ntext-transform：文本转换控制英文字符的大小写。\n\n值描述\n\nnone不转换（默认值）\n\ncapitalize首字母大写\n\nuppercase全部字符转换为大写\n\nlowercase全部字符转换为小写\ntext-decoration：文本装饰设置文本的下划线，上划线，删除线等装饰效果\n\n值描述\n\nnone没有装饰（正常文本默认值）\n\nunderline下划线\n\noverline上划线\n\nline-through删除线\ntext-align：水平对齐方式设置文本内容水平对齐，相当于html中的align对齐属性\n仅适用于块级元素，对行内元素无效\n\n如果需要对图像设置水平对齐，可以为图像添加一个父标签&lt;p&gt;,然后对父标签应用text-align,可实现图像水平对齐\n\n\n值描述\n\nleft左对齐（默认值）\n\nright右对齐\n\ncenter居中对齐\ntext-indent：首行缩进设置首行文本的缩进。\nem字符宽度倍数（建议）、%、数值\n适用于块级元素，对行内元素无效\nwhite-space: 空白符处理设置空白符的处理方式\n\n值描述\n\nnormal常规（默认值），文本中的空格、空行无效，满行（到达区域边界）后自动换行\n\npre预格式化，按文档的书写格式保留空格、空行原样显示\n\nnowrap空格空行无效，强制文本不能换行，除非遇到换行标签&lt;br /&gt;。内容超出元素的边界也不换行，若超出浏览器页面则会自动增加滚动条。\ntext-shadow：阴影效果为页面中的文本添加阴影效果。\nh-shadow用于设置水平阴影的距离，v-shadow用于设置垂直阴影的距离，blur用于设置模糊半径，color用于设置阴影颜色。\n1选择器&#123;text-shadow:h-shadow v-shadow blur color&#125;1p&#123;text-shadow:10px 10px 10px red&#125;\n阴影的水平或垂直距离参数可以负值，但阴影的模糊半径只能为正值\n可以给文字添加多个阴影，产生阴影叠加效果\n\n1p&#123;text-shadow:10px 10px 10px red,20px 20px 20px green;&#125;text-overflow：标示对象内溢出文本用于处理溢出的文本\n1选择器&#123;text-overflow:属性值；&#125;clip：修剪溢出文本，不显示省略标签“…”。ellipsis：用省略标签“…”替代被修剪文本，省略标签插入的位置是最后一个字符。\n\n123456789101112&lt;style type=\"text/css\"&gt;P&#123;\twidth:200px; \theight:100px; \tborder:1px solid #000;\twhite-space:nowrap;        /*强制文本不能换行*/\toverflow:hidden;           /*修剪溢出文本*/\ttext-overflow:ellipsis;    /*用省略标签标示被修剪的文本*/&#125;&lt;/style&gt;&lt;p&gt;把很长的一段文本中溢出的内容隐藏，出现省略号&lt;/p&gt;word-wrap实现长单词和URL地址的自动换行。\nnormal：只在允许的断字点换行（浏览器保持默认处理）。break-word：在长单词或 URL 地址内部进行换。\n12345678910111213&lt;style type=\"text/css\"&gt;\tp&#123;       width:100px;        height:100px;       border:1px solid #000;    &#125;\t.break_word&#123;word-wrap:break-word;&#125;   /*网址在段落内部换行*/&lt;/style&gt;&lt;span&gt;word-wrap:normal;&lt;/span&gt;&lt;p&gt;网页平面ui设计学院http://icd.XXXXXXX.cn/&lt;/p&gt;&lt;span&gt;word-wrap:break-word;&lt;/span&gt;&lt;p class=\"break_word\"&gt;网页平面ui设计学院http://icd.XXXXXXXXX.cn/&lt;/p&gt;","plink":"https://dxsummer.gitee.io/posts/dfb45e1c/"},{"title":"结构体变量和结构体类型的定义","date":"2020-10-01T15:17:20.000Z","date_formatted":{"ll":"2020年10月1日","L":"2020/10/01","MM-DD":"10-01"},"updated":"2020-10-11T14:25:57.382Z","content":"结构体类型定义定义方式1：\n1234Typedef struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125; *LinkList;定义方式2：\n123456struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125;;Typedef struct  LNode  *LinkList;以上两个定义方式是等价的，是将 *LinkList 定 义为 struct LNode 类型，即 LinkList 被定义为一个类型名。这样就可以用 LinkList 来定义说明新的变量了，如：\n1LinkList  L;即将 L 定义为 struct LNode 类型的指针变量。\n结构体类型变量定义定义方式1：\n12345struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125;LnodeA;定义方式2：\n123456struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125;;struct  LNode LnodeA;以上两个定义方式也是等价的，这样就将 LnodeA 定义为一个 struct LNode 类型的变量，即 LnodeA 为一个 struct LNode 类型的变量名。\n","plink":"https://dxsummer.gitee.io/posts/4d0d4efc/"},{"title":"线性表","date":"2020-10-01T15:17:20.000Z","date_formatted":{"ll":"2020年10月1日","L":"2020/10/01","MM-DD":"10-01"},"updated":"2020-10-11T14:03:07.347Z","content":"线性表的定义和特点同一线性表的元素必定具有相同的特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系\n由n（n&gt;=0）个数据特性相同的元素构成的有限序列称为线性表\n线性表中元素的个数n（n&gt;=0）定义为线性表的长度，n=0时称为空表\n非空线性表或线性结构的特点\n存在唯一的一个被称作“第一个”的数据元素\n存在唯一的一个被称作“最后一个”的数据元素\n除第一个之外，结构中的每个数据元素均只有一个前驱\n除最后一个之外，结构中的每个数据元素均只有一个后继\n什么是线性表线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。\n首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：\n图 2 数据的”线性”结构\n图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。\n图 3 两种线性存储结构\n图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样）。因此可以认定，这两种存储方式都是正确的。\n将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。\n使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。\n顺序存储结构和链式存储结构图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：\n如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；\n\n如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；\n\n也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。\n线性表常用术语数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。\n另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：\n某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；\n某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；\n以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：\n图 4 前驱和后继\n顺序表示和实现顺序存储表示用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称线性表的顺序存储结构或顺序映像，这种存储结构的线性表为顺序表\n逻辑上相邻的数据元素，物理次序也相邻\n顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙\n\n线性表的顺序存储结构是一种随机存取\n\n\n\nLOC(ai+1) = LOC(ai) + l\nLOC(ai) = LOC(a1) + (i-1) x l\n\ni：第i个数据元素    \n\nLOC(ai)：第i个数据元素的存储地址    \n\nL：每个元素占用L个存储单位\n\n基本操作的实现类型定义123456#define  MAXSIZE 100     //最大长度typedef struct &#123; \t ElemType  *elem;      //指向数据元素的基地址  \tint  length;                 //线性表的当前长度                         &#125;SqList；ElemType可以是int、float、char，也可以是结构体类型struct\nlength当前数据元素的个数，C语言数组的下标是从0开始的，而位置序号从1开始\n\n图书表的顺序存储结构类型定义\n\n12345678910111213#define MAXSIZE 10000\t//图书表可能达到的最大长度 typedef struct\t\t\t//图书信息定义&#123;    char no[20];\t\t\t//图书ISBN   char name[50];\t\t//图书名字   float price; \t\t\t//图书价格&#125;Book;typedef struct&#123;    Book *elem;\t             //存储空间的基地址    int length;\t\t//图书表中当前图书个数 c&#125;SqList;\t\t//图书表的顺序存储结构类型为SqListSqList L;将L定义为Sqlist类型的变量，利用L.elem[i-1]访问表中位置序号为i的图书记录\n初始化使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：\n顺序表申请的存储容量；\n顺序表的长度，也就是表中存储数据元素的个数；\n提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。\n初始化线性表L （参数用引用）\n1234567Status InitList_Sq(SqList &amp;L)                   //构造一 个空的顺序表L&#123;    L.elem=new ElemType[MAXSIZE];   //为顺序表分配空间    if(!L.elem) exit(OVERFLOW);           //存储分配失败    L.length=0;\t\t\t\t     //空表长度为0    return OK;&#125;取值(随机存取) O(1)根据位置i获取相应位置数据元素的内容\n1234567int GetElem(SqList L,int i,ElemType &amp;e)&#123;  if (i&lt;1||i&gt;L.length) return ERROR;      //判断i值是否合理，若不合理，返回ERROR  e=L.elem[i-1];   //第i-1的单元存储着第i个数据  return OK;&#125;查找 O(n)顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、插值查找算法等。这里，我们选择顺序查找算法，具体实现代码为：\n1234567在线性表L中查找值为e的数据元素int LocateELem(SqList L,ElemType e)&#123;  \tfor (i=0;i&lt; L.length;i++)      \tif (L.elem[i]==e) return i+1;                 \t return 0;&#125;插入 O(n)向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：\n插入到顺序表的表头；\n在表的中间位置插入元素；\n尾随顺序表中已有元素，作为顺序表中的最后一个元素；\n虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：\n将要插入位置元素以及后续的元素整体向后移动一个位置；\n将元素放到腾出来的位置上；\n例如，在 {1,2,3,4,5} 的第 3 个位置上插入元素 6，实现过程如下：\n遍历至顺序表存储第 3 个数据元素的位置，如图 1 所示：\n图 1 找到目标元素位置\n将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：\n图 2 将插入位置腾出\n将新元素 6 放入腾出的位置，如图 3 所示：\n图 3 插入目标元素\n\n在线性表L中第i个数据元素之前插入数据元素e \n\n12345678910Status ListInsert_Sq(SqList &amp;L,int i ,ElemType e)&#123;   if(i&lt;1 || i&gt;L.length+1) return ERROR;\t         //i值不合法   if(L.length==MAXSIZE) return ERROR;    //当前存储空间已满        for(j=L.length-1;j&gt;=i-1;j--)        L.elem[j+1]=L.elem[j];    //插入位置及之后的元素后移    L.elem[i-1]=e;                     //将新元素e放入第i个位置    ++L.length;\t\t     \t//表长增1    return OK;&#125;删除从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。\n后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。\n例如，从 {1,2,3,4,5} 中删除元素 3 的过程如图 4 所示：\n图 4 顺序表删除元素的过程示意图\n\n将线性表L中第i个数据元素删除\n\n12345678Status ListDelete_Sq(SqList &amp;L,int i)&#123;   if((i&lt;1)||(i&gt;L.length)) return ERROR;\t //i值不合法   for (j=i;j&lt;=L.length-1;j++)                   　  　L.elem[j-1]=L.elem[j];       //被删除元素之后的元素前移     --L.length;               \t                 //表长减1  return OK;&#125;链式表示和实现结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n线性表的链式表示又称为非顺序映像或链式映像。\n数据元素本身，其所在的区域称为数据域；\n\n指向直接后继元素的指针，所在的区域称为指针域；即链表中存储各数据元素的结构如图 3 所示：\n\n   图 3 节点结构\n图 3 所示的结构在链表中称为结点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：\n图 4 链表中的节点\n\n单链表、双链表、循环链表： \n\n结点只有一个指针域的链表，称为单链表或线性链表\n有两个指针域的链表，称为双链表\n首尾相接的链表称为循环链表\n头指针是指向链表中第一个结点的指针\n首元结点是指链表中存储第一个数据元素a1的结点\n头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息\n如何表示空表？\n有头结点时，当头结点的指针域为空时表示空表\n在链表中设置头结点有什么好处？\n便于首元结点的处理首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理\n便于空表和非空表的统一处理无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\n头结点的数据域内装的是什么？\n 头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。\n单链表的定义和实现12345678typedef struct Lnode&#123;     ElemType   data;       //数据域     struct LNode  *next;   //指针域&#125;LNode,*LinkList;   // *LinkList为Lnode类型的指针LNode *p\t//p为指向单链表中某个节点的指针 *p表示该结点LinkList L\t//L为单链表的头指针指针变量p：表示结点地址结点变量*p：表示一个结点\n基本操作初始化(构造一个空表 )12345Status InitList_L(LinkList &amp;L)&#123;    L=new LNode;                    \t   L-&gt;next=NULL;　　　　　   return OK; &#125;销毁\n1234567891011Status DestroyList_L(LinkList &amp;L)&#123;    LinkList p;       while(L)        &#123;            p=L;              L=L-&gt;next;            delete p;          &#125;     return OK; &#125;清空\n123456789Status ClearList(LinkList &amp; L)&#123;  // 将L重置为空表    LinkList p,q;   p=L-&gt;next;   //p指向第一个结点   while(p)       //没到表尾       &#123;  q=p-&gt;next; delete p;     p=q;   &#125;   L-&gt;next=NULL;   //头结点指针域为空    return OK; &#125;求表长\n12345678910int  ListLength_L(LinkList L)&#123;//返回L中数据元素个数    LinkList p;    p=L-&gt;next;  //p指向第一个结点     i=0;                  while(p)&#123;//遍历单链表,统计结点数           i++;           p=p-&gt;next;    &#125;     return i;                              &#125;判断表是否为空\n12345678int ListEmpty(LinkList L)&#123; \t//若L为空表，则返回1，否则返回0    if(L-&gt;next)   //非空      return 0;   else     return 1; &#125;取值（根据位置i获取相应位置数据元素的内容）12345678910//获取线性表L中的某个数据元素的内容Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123;     p=L-&gt;next;j=1; //初始化     while(p&amp;&amp;j&lt;i)&#123;\t//向后扫描，直到p指向第i个元素或p为空        p=p-&gt;next; ++j;      &#125;      if(!p || j&gt;i)return ERROR; //第i个元素不存在      e=p-&gt;data; //取第i个元素      return OK; &#125;//GetElem_L查找（根据指定数据获取数据所在的位置）12345678//在线性表L中查找值为e的数据元素LNode *LocateELem_L (LinkList L，Elemtype e) &#123; //返回L中值为e的数据元素的地址，查找失败返回NULL  p=L-&gt;next;  while(p &amp;&amp;p-&gt;data!=e)          p=p-&gt;next;                \t\t  return p; \t&#125;插入（插在第 i 个结点之前）1234567891011//在L中第i个元素之前插入数据元素e Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123;      p=L;j=0;       while(p&amp;&amp;j&lt;i−1)&#123;p=p-&gt;next;++j;&#125;\t//寻找第i−1个结点       if(!p||j&gt;i−1)return ERROR;\t//i大于表长 + 1或者小于1        s=new LNode;\t\t\t//生成新结点s       s-&gt;data=e;      \t\t           //将结点s的数据域置为e       s-&gt;next=p-&gt;next;\t   \t          //将结点s插入L中       p-&gt;next=s;       return OK; &#125;//ListInsert_L删除（删除第 i 个结点）12345678910111213//将线性表L中第i个数据元素删除 Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123;    p=L;j=0;     while(p-&gt;next &amp;&amp;j&lt;i-1)&#123;                  //寻找第i个结点，并令p指向其前驱         p=p-&gt;next; ++j;     &#125;     if(!(p-&gt;next)||j&gt;i-1) return ERROR; //删除位置不合理     q=p-&gt;next;                                        //临时保存被删结点的地址以备释放     p-&gt;next=q-&gt;next; \t                  //改变删除结点前驱结点的指针域     e=q-&gt;data; \t                                //保存删除结点的数据域     delete q; \t                                //释放删除结点的空间  return OK; &#125;//ListDelete_L单链表的建立（前插法）123456789void CreateList_F(LinkList &amp;L,int n)&#123;      L=new LNode;       L-&gt;next=NULL; //先建立一个带头结点的单链表       for(i=n;i&gt;0;--i)&#123;         p=new LNode; //生成新结点         cin&gt;&gt;p-&gt;data; //输入元素值         p-&gt;next=L-&gt;next;L-&gt;next=p; \t//插入到表头      &#125; &#125;//CreateList_F单链表的建立（尾插法）123456789101112void CreateList_L(LinkList &amp;L,int n)&#123;       //正位序输入n个元素的值，建立带表头结点的单链表L       L=new LNode;       L-&gt;next=NULL; \t      r=L; \t                                //尾指针r指向头结点       for(i=0;i&lt;n;++i)&#123;         p=new LNode;\t　\t       //生成新结点         cin&gt;&gt;p-&gt;data;   \t\t       //输入元素值         p-&gt;next=NULL; r-&gt;next=p;       //插入到表尾         r=p; \t                                  //r指向新的尾结点       &#125; &#125;//CreateList_L顺序表和链表的比较","plink":"https://dxsummer.gitee.io/posts/40f24371/"},{"title":"HTML5","date":"2020-09-19T08:04:16.000Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-10-10T02:35:43.638Z","content":"\n为什么有单表签\n\n单表签本身就可以描述一个功能，不需要选择 例如 水平线标签&lt;hr/&gt;\n标签嵌套关系123456&lt;html&gt;\t&lt;head&gt;\t&lt;/head&gt;\t&lt;body&gt;\t&lt;/body&gt;&lt;/html&gt;标签属性1&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" ...&gt; 内容 &lt;/标签名&gt;我是剧中文本1&lt;p align=\"center\"&gt;我是剧中文本&lt;/p&gt;\n键值对：对“属性”设置“属性值”\n例如 color=&quot;red&quot;、width=200px\n\n定义页面元信息标签&lt;meta/&gt;设置网页关键字\n1&lt;meta name=\"keywords\" content=\"千图网,免费素材下载,千图网免费素材图库,矢量图,矢量图库,图片素材,网页素材,免费素材,PS素材,网站素材,设计模板,设计素材,www.58pic.com,网页模板免费下载,千图,素材,素材,免费设计,图片\"/&gt;\n设置网站描述（不超200字）\n1&lt;meta name=\"description\" content=\"千图网(www.58pic.com) 是专注正版图片设计素材下载的网站！提供矢量图素材、背景图片素材、矢量图库、psd素材、字体模板、设计素材、PPT模板、视频素材、插画绘画、平面设计模板、Excel模板素材以及网页模板、网站设计素材、网页图标的下载服务。\"/&gt;\n这是网页作者\n1&lt;meta name=\"author\" content=\"网络部\"\n设置字符集\n1&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gbk\" /&gt;\n设置页面自动刷新与跳转\n1&lt;meta http-equiv=\"refresh\" content=\"10; url= https://www.baidu.com/\" /&gt;\n页面格式化标签标题标签\n一个页面只能用一个&lt;h1&gt;标签 常用于网站logo部分\n不建议使用h标签的align对齐属性，可使用CSS样式设置\n\n标题文本1&lt;h5 align=\"center/left/right\"&gt;标题文本&lt;/h5&gt;段落标签标题文本1&lt;p align=\"center/left/right\"&gt;标题文本&lt;/p&gt;水平线1&lt;hr 属性=\"属性值\" /&gt;\n属性名含义属性值\n\nalign对齐方式可选left，right，center 3种值，默认 center， 居中对齐显示\n\nsize粗细以像素为单位，默认2像素\n\ncolor颜色可用颜色名称、十六进制#RGB、rgb(r，g，b)表示\n\nwidth宽度可以是确定的像素值，也可以是浏览器窗口的百分比，默认100%\n换行标签1&lt;br /&gt;文本样式标签 文本内容\n1&lt;font size=\"6\" color=\"red\" face=\"宋体\"&gt; 文本内容&lt;/font&gt;1&lt;font 属性=\"属性值\"&gt; 文本内容&lt;/font&gt;\n属性名含义\n\nface字体\n\nsize文字大小 1~7整数\n\ncolor颜色\n文本格式化标签\n标签效果\n\n&lt;b&gt;&lt;/b&gt;和&lt;strong&gt;&lt;/strong&gt;粗体显示\n\n&lt;u&gt;&lt;/u&gt;和&lt;ins&gt;&lt;/ins&gt;下划线\n\n&lt;i&gt;&lt;/i&gt;和&lt;em&gt;&lt;/em&gt;斜体\n\n&lt;s&gt;&lt;/s&gt;和&lt;del&gt;&lt;/del&gt;删除\n\n&lt;sub&gt;&lt;/sub&gt;下标\n\n&lt;sup&gt;&lt;/sup&gt;上标\ntime标签本消息发布于2020年9月19日\n1&lt;time datetime=\"2015-08-15\" pubdate= \"pubdate\"&gt;本消息发布于2020年9月19日&lt;/time&gt;mark标签wikew\n1&lt;mark&gt;wikew&lt;/mark&gt;cite标签(参考文献说明)—————我\n1&lt;cite&gt;—————我&lt;/cite&gt;图像标签图像格式GIF\n支持动画，无损，支持透明，256种颜色\n\nPNG\n体积小，支持Alpha透明（全透明、半透明、不透明），256种颜色\n\nJPG\n有损压缩，超过256种颜色\n\n图像标签&lt;img/&gt;1&lt;img src=\"图像URL\" /&gt;\n属性属性值描述\n\nsrcURL图片路径\n\nalt文本图像不能显示的交替文本\n\ntitle文本鼠标悬停显示内容\n\nwidth像素宽度\n\nheight像素高度\n\nborder数字边框的宽度\n\nvspace像素垂直边距\n\nhspace像素水平边距\n\nalignlefttopmiddlebottomrighttop：图像顶端和文本的第一行文字对齐，其他文字居图像下方middle：图像水平中线和文本的第一行文字对齐，其他文字居图像下方bottom：图像底部和文本的第一行文字对齐，其他文字居图像下方\n","plink":"https://dxsummer.gitee.io/posts/98f3a6d9/"},{"title":"绪论","date":"2020-09-19T06:29:02.000Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-09-19T08:00:49.846Z","content":"基本概念和术语1.1 数据、数据元素、数据项、数据对象关系\n数据（data)：所有能输入到计算机中去的描述客观事物的符号\n数据对象(Data Object)：相同特性数据元素的集合，是数据的一个子集\n数据元素（data element）：数据的基本单位，也称结点（node）或记录（record）\n数据项（data item）：有独立含义的数据最小单位，也称域(field)\n1.2 数据结构\n逻辑结构集合结构：数据元素同属一个集合，单个数据元素之间没有任何关系。\n\n线性结构：类似于线性关系，也就是说，线性结构中的数据元素之间是一对一的关系。注意：重点在一对一。\n\n树形结构：树形结构中的数据元素之间存在一对多的关系。（各元素及元素关系所组成图形类似于树状图）。注意：关系为一对多。如下图所示。\n\n图形结构：数据元素之间是多对多的关系。\n\n存储结构(物理结构)物理结构又叫存储结构，分为四种种，顺序存储结构、链式存储结构、索引结构、散列结构。\n顺序存储结构：一段连续的内存空间。\n优点：随机访问\n缺点：插入删除效率低，大小固定\n\n链式存储结构：不连续的内存空间，借助指针\n优点：大小动态扩展，插入删除效率高\n缺点：不能随机访问。\n\n索引存储结构：为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。\n优点：对顺序查找的一种改进，查找效率高\n缺点：需额外空间存储索引\n散列存储结构：选取某个函数，数据元素根据函数计算存储位置\n可能存在多个数据元素存储在同一位置，引起地址冲\n优点：查找基于数据本身即可找到，查找效率高，存取效率高。\n缺点：存取随机，不便于顺序查找。\n1.3 数据类型和抽象数据类型数据类型数据类型是一个值的集合和定义在此集合上的一组操作的总称。例如 c语言中的整型，浮点型，他们的取值范围不同，进行运算时所遵循的规范也不同\n抽象数据类型抽象数据类型=逻辑结构＋抽象运算抽象数据类型暂不考虑计算机的具体存储结构和运算的具体实现。抽象数据类型实质上，就是在描述问题本身（与计算机无关）。目标：在不涉及具体的，和计算机系统相关的细节情况下，优先理解问题本身，在此基础上，实现用计算机求解问题的过程。\n我们可以认为抽象数据类型是包含着数据类型的，也就是说，抽象数据类型是一个更大的概念\n例如：在定义一个学生类型的抽象数据类型时，学生对象既包含整型的年龄，身高，又包含char类型的姓名，这时，我们就可以用一个结构体定义这个学生类型\n12345ADT &lt;抽象数据类型名&gt;&#123;数据对象：&lt;数据对象的定义&gt;数据关系：&lt;数据关系的定义&gt;基本操作：&lt;基本操作的定义&gt;&#125;这里，Student是一个抽象数据类型，而里面的int,char类型又是不同的数据类型\n12345struct Student &#123;char sno; //学号int age; //年龄… …&#125;这里，Student是一个抽象数据类型，而里面的int,char类型又是不同的数据类型\n1.4 算法和算法分析算法：解决某类问题而规定的一个有限长的操作序列\n算法的五个重要特征：有穷性\n确定性\n可行性\n有输入\n有输出\n算法优劣基本标准正确性\n可读性\n健壮性\n高效性：包括时间和空间（占用存储合理），\n算法效率的度量一条语句的重复执行次数称作语句频度\n1234567for(i=1;i&lt;=n;i++)\t\t\t\t\t\t//n+1\tfor(j=1;j&lt;=n;j++)\t\t\t\t\t//n*(n+1)    &#123;        C[i][j]=0;\t\t\t\t\t\t//n²        for(k=1;k&lt;=n;k++)\t\t\t\t//n²*（n+1）            c[i][j]=c[i][j]+a[i][k]*b[k][j];\t//n³    &#125;所有语句频度之和f(n)\n1f(n)&#x3D;2n³+3n²+2n+1算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度\n  它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度简称时间复杂度  语句的频度指的是该语句重复执行的次数\n算法的存储空间需求  如果所占空间量依赖于特定的输入，除特别指明外，均按最坏情况来分析\n1T（n）&#x3D;O(f(n))  它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度 简称时间复杂度\n语句的频度指的是该语句重复执行的次数\n空间复杂度1S（n)&#x3D;O(f(n))\n数组逆序，将一维数组a中的n个数逆序存放到原数组中\n\n1234567算法1for(i&#x3D;0;i&lt;n&#x2F;2;i++)&#123;\tt&#x3D;a[i];\ta[i]&#x3D;a[n-i-1];\ta[n-i-1]&#x3D;t;&#125;算法1 需要借助t，与问题规模n大小无关，所以空间复杂度为O（1）\n12345算法2for(i&#x3D;0;i&lt;n;i++)\tb[i]&#x3D;a[n-i-1];for(i&#x3D;0;i&lt;n;i++)\ta[i]&#x3D;b[i];算法2 借助大小为n的辅助数组b，空间复杂度为O(n)\n","plink":"https://dxsummer.gitee.io/posts/43830010/"},{"title":"Eclipse使用手册","date":"2020-09-10T12:04:31.000Z","date_formatted":{"ll":"2020年9月10日","L":"2020/09/10","MM-DD":"09-10"},"updated":"2020-09-10T14:12:31.360Z","content":"Java Eclipse下载与安装安装(1) Eclipse 是一个开放源代码的项目，其官方网站是 www.eclipse.org。图 1 所示为 Eclipse 官方网站的首页。\n\nEclipse IDE for Java EE Developers下载地址\n\n\n(2) 从首页中单击 DOWNLOAD 按钮，进入图 2 所示的页面。\n\n(3) 点击 Download Packages，进入 Eclipse 下载页面。从 Eclipse IDE for Java EE Developers 后面选择适合当前系统的版本，这里单击 64 bit 按钮，下载 64 位的安装包，如图 3 所示。\n\n(4) 点击“64-bit”后跳转到“Choose a mirror close to you”界面。点击“Sellect Another Mioor”，选择“大连东软信息学院”，如图 4 所示。\n\n(5) 下载完成后或者下载没有开始，进入如下所示的页面。如果下载没有开始，点击“click here”重新开始下载。\n\n下载完成后会得到一个名为 eclipse_java_mars_2_win32_x86_64.zip 的压缩文件。虽然 Eclipse 本身是用 Java 语言编写，但下载的压缩包中并不包含 Java 运行环境（即安装 Eclipse，应首先安装 JDK），需要用户自己另行安装 JRE，并且要在操作系统的环境变量中指明 JRE 中 bin 的路径。\n(6) Eclipse 的安装非常简单，只需将下载的压缩包进行解压，然后双击 eclipse.exe 文件即可。Eclipse 第一次启动时会要求用户选择一个工作空间（Workspace），如图 6 所示。\n\n配置汉化由于 Eclipse 是一个开源项目，因此所有社区和开发者都可以为 Eclipse 开发扩展功能。下面介绍为 Eclipse 安装汉化包的方法。\n(7) Eclipse 有一个子项目 Babel，专门负责 Eclipse 程序的多国语言包，其官方网站是 www.eclipse.org/babel，进入后的Babel 项目首页如图 7 所示。\n\n(8) 从页面导航中单击 Downloads 链接进入下载页面。在下载页面的 Babel Language Pack Zips 标题下选择对应 Eclipse 版本的超链接下载语言包。前面下载 Eclipse 的安装文件是 eclipse_java_mars_2_win32_x86_64.zip，因此这里单击 Mars 链接，如图 8 所示。\n\n(9) 在进入的语言选择页面中列出了当前支持的所有语言列表，从中单击 Chinese(Simplified) 链接进入简体中文的下载列表，在这里又针对不同插件和功能分为多个 ZIP 压缩包。从列表中单击 BabelLanguagePack_birt_zh_4.5.0.v20151128060001.zip 链接，下载完整版语言包，如图 9 所示。\n\n(10) 下载后会得到 BabelLanguagePack_birt_zh_4.5.0.v20151128060001.zip 文件，将其解压并覆盖 Eclipse\\drogins文件夹中同名的 features 目录和 plugins 目录，这样下次启动 Eclipse 时便会自动加载语言包。\n(11) 在工作空间选择页面中，单击“浏览”按钮，将工作空间放到 E:\\java_workspace，然后选中“将此值用作缺省值并且不再询问”复选框，再单击“确定”按钮。\n(12) 启动 Eclipse，进入 Eclipse 的欢迎界面。选择“帮助”|“关于 Eclipse”命令，可以在弹出的对话框中查看当前 Eclipse 的详细信息。\n开始配置在 Eclipse 中编写程序，必须先创建项目。Eclipse 中有很多项目，其中 Java 项目用于管理和编写 Java 程序，具体步骤如下。\n(1) 在图 1 所示的界面中选择“file（文件）”|“new（新建）”|“Java Project（Java项目）”命令，打开“New Java Project（新建Java项目）”对话框。\n(2) 设置“Project name（项目名）”为 HelloJava，选中“Use default location（使用缺省位置）”复选框，将项目保存到工作空间中，其他暂时不用设置，如图 1 所示。\n图 1 New Java Project（新建Java项目）对话框\n(3) 单击“Next（下一步）”按钮，在进入的对话框中更改项目的 Sourse（源码）选项，如图 2 所示。同时还可以设置 Project（项目）、Libraries（库）、Order and Export（排序和导出）方面的选项，分别如图 3、图 4 和图 5 所示。\n图 2 设置Sourse（源码）选项\n图 3 设置Project（项目）选项\n图 4 设置Libraries（库）选项\n图 5 设置Order and Export（排序和导出）选项\n(3) 单击“Finish（完成）”按钮，创建名为 HelloJava 的项目，Eclipse 会自动生成相关代码和布局结构。在 Eclipse 左侧“Package Explorer（包资源管理器）”窗格中会显示整个 Java 项目的目录结构，默认为空项目。\n(4) 右击 src 目录，选择“new（新建）”|“Class（类）” 命令，打开“New Java Class（新建 Java 类）”对话框。设置类的名称为 HelloJava，并选中 public static void main(String[] args) 复选框为新类生成 main() 方法，如图 6 所示。\n图 6 New Java Class（新建Java类）对话框\n(7) 最后单击“Finish（完成）”按钮，会看到生成的 HelloJava.java 文件的内容，并处于编辑状态，如图 7 所示。\n图 7 HelloJava.java 文件\n\n例一\n\n1) 对生成的源代码进行修改，最终文件代码如下。\n12345678910public class HelloJava &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; TODO自动生成的方法存根        System.out.println(&quot;    *&quot;);        System.out.println(&quot;   ***&quot;);        System.out.println(&quot;  *****&quot;);        System.out.println(&quot; *******&quot;);        System.out.println(&quot;*********&quot;);    &#125;&#125;读者输入上面代码的时候，会充分体会到 Eclipse 强大的代码辅助功能。图 8 所示为代码的自动提示补全功能。\n图 8 自动补全代码\n2) 编写完成之后按 Ctrl+S 快捷键保存修改。在工具栏中单击“运行”按钮后，如果程序没有编译错误，在底部的“Console（控制台）”窗格中会看到输出的等腰三角形，这就是程序的运行效果，如图 9 所示。\n图 9 查看输出结果\n字体配置在第一次使用 Eclipse 编写程序时，由于 Eclipse 默认使用的是 Cosnolas 字体，字号为 10，所以编辑器中的字体非常小，不方便查看。\n我们可以通过下面所示的方法来修改编辑器的字体大小。如图 1 所示，具体修改方法为：\n选择“窗口”|“首选项”命令，打开“首选项”对话框，从左侧窗格依次展开“General（常规）”|“Appearance（外观）”|“Colors and Fonts（颜色和字体）”选项。\n从右侧选择 Java 下的“Java Editor Text Font（Java编辑器文本字体）”选项。\n单击“Edit（编辑）”按钮，在弹出的“字体”对话框中设置字体的样式和大小。\n图 1 设置编辑器字体大小\n设置完成后，依次单击“Apply and Close（确定）”按钮返回 Eclipse，此时即可看到修改效果。图 2 所示为 14 号字体的效果。\n图 2 14号字体的效果\n快捷键大全编辑类快捷键\n编辑类快捷键\n\nCtrl+1快速修复（最经典的快捷键，可以解决很多问题，比如 import 类、try catch 包围等）\n\nCtrl+Shift+F格式化当前代码\n\nCtrl+Shift+M添加类的 import 导入\n\nCtrl+Shift+O组织类的 import 导入（既有 Ctrl+Shift+M 的作用，又可以去除没用的导入，一般用这个导入包）\n\nCtrl+Y重做（与撤销 Ctrl+Z 相反）\n\nAlt+/内容辅助（用户编辑的好帮手，省了很多次键盘敲打，太常用了）\n\nCtrl+D删除当前行或者多行（不用为删除一行而按那么多次的删除键）\n\nAlt+↓当前行和下面一行交互位置（特别实用，可以省去先剪切，再粘贴了）\n\nAlt+↑当前行和上面一行交互位置（同上）\n\nCtrl+Alt+↓复制当前行到下一行\n\nCtrl+Alt+↑复制当前行到上一行\n\nShift+Enter在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置，不一定是最后）\n\nCtrl+/注释当前行，再按则取消注释\n选择类快捷键\n选择类快捷键\n\nAlt+Shift+↑选择封装元素\n\nAlt+Shift+←选择上一个元素\n\nAlt+Shift+→选择下一个元素\n\nShift+←从光标处开始往左选择字符\n\nShift+→从光标处开始往右选择字符\n\nCtrl+Shift+←选中光标左边的单词\n\nCtrl+Shift+→选中光标右边的单词\n移动类快捷键\n移动类快捷键\n\nCtrl+←光标移到左边单词的开头，相当于 vim 的 b\n\nCtrl+→光标移到右边单词的末尾，相当于 vim 的 e\n搜索类快捷键\n搜索类快捷键\n\nCtrl+K参照选中的 Word 快速定位到下一个（如果没有选中 word，则搜索上一次使用搜索的 word）\n\nCtrl+Shift+K参照选中的 Word 快速定位到上一个\n\nCtrl+J正向增量查找（按下 Ctrl+J 后，你所输入的每个字母编辑器都提供快速匹配定位到某个单词，如果没有，则在状态栏中显示没有找到了，查一个单词时，特别实用，要退出这个模式，按 escape 键）\n\nCtrl+Shift+J反向增量查找（和上条相同，只不过是从后往前查）\n\nCtrl+Shift+U列出所有包含字符串的行\n\nCtrl+H打开搜索对话框\n\nCtrl+G工作区中的声明\n\nCtrl+Shift+G工作区中的引用\n导航类快捷键\n导航类快捷键\n\nCtrl+Shift+T搜索类（包括工程和关联的第三 jar 包）\n\nCtrl+Shift+R搜索工程中的文件\n\nCtrl+E快速显示当前 Editer 的下拉列表（如果当前页面没有显示的用黑体表示）\n\nF4打开类型层次结构\n\nF3跳转到声明处\n\nAlt+←前一个编辑的页面\n\nAlt+→下一个编辑的页面（当然是针对上面那条来说了）\n\nCtrl+PageUp/PageDown在编辑器中，切换已经打开的文件\n调试类快捷键\n调试类快捷键\n\nF5单步跳入\n\nF6单步跳过\n\nF7单步返回\n\nF8继续\n\nCtrl+Shift+D显示变量的值\n\nCtrl+Shift+B在当前行设置或者去掉断点\n\nCtrl+R运行至行（超好用，可以节省好多的断点）\n重构\n重构（一般重构的快捷键都是 Alt+Shift 开头的）类快捷键\n\nAlt+Shift+R重命名方法名、属性或者变量名 （尤其是变量和类的 Rename，比手工方法能节省很多劳动力）\n\nAlt+Shift+M把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了，尤其是对一大堆泥团代码有用）\n\nAlt+Shift+C修改函数结构（比较实用，有 N 个函数调用了这个方法，修改一次搞定）\n\nAlt+Shift+L抽取本地变量（可以直接把一些魔法数字和字符串抽取成一个变量，尤其是多处调用的时候）\n\nAlt+Shift+F把 Class 中的 local 变量变为 field 变量 （比较实用的功能）\n\nAlt+Shift+I合并变量\n\nAlt+Shift+V移动函数和变量（不常用）\n\nAlt+Shift+Z撤销（重构的后悔药）\n其他快捷键\n其他快捷键\n\nAlt+Enter显示当前选择资源的属性，windows 下的查看文件的属性就是这个快捷键，通常用来查看文件在 windows 中的实际路径\n\nCtrl+↑文本编辑器 上滚行\n\nCtrl+↓文本编辑器 下滚行\n\nCtrl+M最大化当前的 Edit 或 View （再按则反之）\n\nCtrl+O显示类中方法和属性的大纲，能快速定位类的方法和属性（在查找 Bug 时非常有用）\n\nCtrl+T快速显示当前类的继承结构\n\nCtrl+W关闭当前 Editer（windows 下关闭打开的对话框也是这个，还有 qq、旺旺、浏览器等都是）\n\nCtrl+L文本编辑器 转至行\n\nF2显示工具提示描述\n","plink":"https://dxsummer.gitee.io/posts/4865d579/"},{"title":"Java编程基础","date":"2020-09-10T11:24:37.000Z","date_formatted":{"ll":"2020年9月10日","L":"2020/09/10","MM-DD":"09-10"},"updated":"2020-09-29T03:38:02.766Z","content":"\nJava 程序运行流程\n\n\n\nJVM 是 Java 平台架构的基础，Java 的跨平台特性正是通过在 JVM 中运行 Java 程序实现的。\n\n\nJava的基本语法Java的基本语法格式123[修饰符] class 类名 &#123;\t程序代码&#125;12345public class HelloWord &#123;\tpublic static void main(String[] args) &#123;\t\tSystem.out.println(\"只是第一个Java程序！\");\t&#125;&#125;Java严格区分大小写\n\n一个连续的字符串不能分开在两行中书写\n12System.out.println(\"只是第一个\t\t\tJava程序！\");\n为方便阅读可用‘+’连接两个字符串\n\n12System.out.println(\"只是第一个\"+\t\t\t\"Java程序！\");\n注释多行注释/*...*/可以嵌套//\n12/*int=10;\t//定义一个整型cint x=5;*/\n多行注释/*...*/不能嵌套/*...*/\n\n关键字数据类型：boolean、int、long、short、byte、float、double、char、class、interface。\n流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。\n修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。\n动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。\n保留字：true、false、null、goto、const。\n\n由于 Java 区分大小写，因此 public 是关键字，而 Public 则不是关键字。但是为了程序的清晰及可读性，要尽量避免使用关键字的其他形式来命名。\n\npackage：包的声明\nimport：用于引用包\nclass：类的声明\n标识符标识符由数字和字母、$、_构成\n标识符的第一个符号不能是数字，也不能是关键字\n\n定义标识符规范\n\n包名所有字母一律小写，com.itheima.example01\n\n类名和接口名每个单词的首字母都要大写 ArrayList\n\n常量名所有字母都大写，单词之间下划线 DAY_OF_MONTH\n\n变量名和方法名的第一个单词首字母小写，第二个单词开始首字母大写lineNumber\n\n变量\n整型类型变量\n类型名占用空间\n\nbyte8位（1字节）\n\nshort16位（2字节）\n\nint32位（4字节）\n\nlong64位（8字节）【 c语言32位 4字节 与int相同】\nlong 赋值的后面要加 L（l），说明赋值位 long 类型123long num=2200000000L;\t//所赋值超过int型的取值范围，后面必须加 Llong num=198L;\t\t\t//所赋值未超过int型的取值范围，后面可以加 Llong num=198;\t\t\t//所赋值未超过int型的取值范围，后面可省略 L浮点类型变量\n类型名占用空间\n\nfloat32位（4字节）\n\ndouble64位（8字节）\n一个小数会被默认为double类型的值，为一个 float 类型变量赋值时，要在后面加 F （f）12float f = 123.4f;\t//为float类型的变量赋值时，后面必须加f或Fdouble d1=199.3d;\t//为double类型的变量赋值时，后面可以加d或D（也可省略）字符类型变量char 占2字节 C语言中是1字节12char c='a';\tchar c=97;布尔类型变量12boolean flag=false;flag=true;变量的类型转化自动类型转换\n123byte b=3;int x=b;\t\t//程序把byte类型的变量b转换成int类型，无须特殊声明double y=x;\t\t//将int类型的变量x转换成double类型，无须特殊声明强制类型转换（显示类型转换）12int num=4;byte b=(byte)num;int    298    00000000 00000000 00000001 00101010\nbyte  42                                                               00101010\n表达式类型自动提升1234byte b=3;short s=4;char c=5;byte b2=（byte）（b+s+c）;\t//將byte、short、char类型数值相加，再赋值给byte类型byte、short、char在运算期间类型会自动提升为int，然后再进行运算1byte b2=b+s+c;\t//报错 因为(b+s+c)为int常量整型常量二进制：0b 0B 开头 \n八进制：0 开头\n十六进制：0x 0X 开头\n浮点型单精度浮点型： F f 结尾\n双精度浮点型：D d  结尾    \n结尾不加后缀，默认为double双精度浮点型\n12e3f\t3.6d\t5.022e+23f","plink":"https://dxsummer.gitee.io/posts/95a56e9d/"},{"title":"java环境搭建","date":"2020-09-08T13:13:33.000Z","date_formatted":{"ll":"2020年9月8日","L":"2020/09/08","MM-DD":"09-08"},"updated":"2020-09-10T13:40:00.339Z","content":"JDK安装JDK\nOracle官方下载 Java se\n\nJava SE Development Kit 8 Downloads\n开发工具：JDK核心功能模块，包含一系列Java程序必需的可执行文件，包含 专用JRE环境\n源代码：Java程序的运行环境，所有核心类库的源代码\n公共JRE：Java运行环境\n\nJVM是运行Java程序的核心虚拟机\nJDK目录介绍bin：可执行程序  javac.exe (Java编译器)\njava.exe（Java运行工具）\njar.exe (打包工具)\njavadoc.exe (文档生成工具)\n\ndb: 小型数据库\ninclude：JDK通过C、C++实现，存放头文件\nlib ( library ) :  Java类库或库文件，开发工具使用的归档包文件\njavafx-src.zip: Java FX ( java图形用户界面工具 ) 所有核心类库的源代码\nsrc.zip: src文件夹的压缩文件，JDK核心类的源代码\nREADNE： 说明文档\n\n\nJava源文件扩展名: “HelloWord.java”\n编译后执行文件 java字码文件：”HelloWord.class“\n\n系统环境变量PATH环境变量JAVA_HOME\nPATH - %JAVA_HOME%\\bin（加到path最上面）\n常用开发工具1）Notepad++Notepad++ 是 Windows 操作系统下的一套文本编辑器，有完整的中文化接口及支持多国语言编写的功能（UTF8 技术）。\nNotepad++ 优点：\n功能比 Windows 中的 Notepad（记事本）强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。\n不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。\n是免费软件，可以免费使用，自带中文，支持所有主流的计算机程序语言。\nNotepad++ 缺点：\n比起专用的 IDE 缺少语法检查，颜色选取，代码的 outline，注释的解析，TODO，调试工具集成，部署工具集成等等好多功能。\n打开大文件比较慢\n\n2）EditPlusEditPlus 是一款由韩国 Sangil Kim （ES-Computing）出品的小巧但是功能强大的可处理文本、HTML 和程序语言的 Windows 编辑器，甚至可以通过设置用户工具将其作为 C，Java，Php 等等语言的一个简单的 IDE。\nEditPlus 优点：\nEditPlus 界面简洁美观，且启动速度快。\n对中文支持比较好。\n支持多种日期、时间输入；支持语法高亮；支持代码折叠；支持代码自动完成。\n配置功能强大，且比较容易，扩展也比较强。\n适合编辑网页。\nEditPlus 缺点：\n不支持代码提示功能。\n不免费，收费单位美元，注册费用高\n功能较简单。\n版本更新比较慢。\n\n3）UltraEditUltraEdit 是一套功能强大的文本编辑器，可以编辑文本、十六进制、ASCII 码，完全可以取代记事本，它是一款需要花费 49.95 美元的共享软件。\nUltraEdit 优点：\n提供了友好界面的编程编辑器，支持语法高亮，代码折叠和宏。\n内置了对于 HTML、PHP 和 JavaScript 等语法的支持，可同时编辑多个文件，而且即使开启很大的文件速度也不会慢。\nUltraEdit 缺点：\n启动速度较慢。\n默认的设置中不支持 Pascal 语言。\n对中文支持不是很好。\n\n4）Sublime TextSublime Text 是由程序员 Jon Skinner 于 2008 年 1 月份所开发出来，它最初被设计为一个具有丰富扩展功能的 Vim。\n它是一款收费软件，但是可以无限期试用，它是一个跨平台的编辑器，同时支持 Windows、Linux、Mac OS X 等操作系统。\nSublime Text 优点：\n主流前端开发编辑器\n体积较小，运行速度快\n文本功能强大\n支持编译功能且可在控制台看到输出\n\n5）VimVim 是从 Vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。是 Unix 系统用户最喜欢的文本编辑器。\nVim 优点：\n支持多种操作系统\n打开大文件速度较快，在大文件中查找的速度也非常快。\n免费，开源\n有搜索高亮功能\n支持多中编辑语言\n功能强大\nVim 缺点：\n比较难学\n虽然有菜单，但 Windows 用户第一次上手会很难\n界面不太好看\n键盘命令多，必须长期使用才能熟练。\n\n","plink":"https://dxsummer.gitee.io/posts/560c49b8/"},{"title":"中专教师资格证考试","date":"2020-08-17T12:54:39.000Z","date_formatted":{"ll":"2020年8月17日","L":"2020/08/17","MM-DD":"08-17"},"updated":"2020-08-17T13:08:58.603Z","content":"中职专业课教师资格证考试经历转自知乎：蕴锦流觞\n先上图吧，拿到了教师证偷偷激动了好久（表面很淡定）。\n\n其实在考教资之前犹豫了很久，一是因为自己非师范出身，二是觉得自己怎么也达不到做一个光荣的人民教师标准，三是受高中时某位老师影响，觉得老师真的很辛苦。所以，一直很排斥去考教师证。然后去年突然不知道怎么想通了，教师证只是一个证件，当老师还是要经过很多磨炼的，就开始投入到了教资考试中。\n一、教资笔试\n关于笔试，知乎上已经有很多大神级别的分享帖了，我也是浏览了许多，集各家所长以后开始备考，详细的过程就不细说了，大家可以去搜索其他高分回答，就我自己备考经验进行简单总结如下：\n1、教材及真题：中公教师资格证教材真题套装。\n2、笔记：买了知乎上一位叫大七的妹子的笔记，不过貌似她现在专注学业，不再整理了。\n3、关注的公众号：一起考教师、教师资格证作文。\n4、刷题的APP：一起考教师（里面的模考大赛强烈推荐参加）。\n5、网课：看了有道精品课里面一些免费的公开课。\n6、心得：a、一定要做真题，一定要做真题，一定要做真题。重要的事情放前面说，真题可以发现一些出题套路，简答啊，材料分析啊，考的知识点比较固定。不刷题真的不容易过。\nb、该背的东西一定要背，千万别心存侥幸。是有很多人欧气，但是未必是你。随着近几年考教资的人越来越多，裸考能过的几率已经逐渐消失。\nc、多总结，虽然上面推荐的公众号会经常发一些总结好的资料。但是自己一定也要学会总结，这就是学而不思则罔吧。\n二、教资面试\n这可能是我写这篇文章的初衷吧，我为小众学科叫屈。当我决定要报考中职的面试，我发现一件很尴尬的事：市面上几乎没有中职的面试课程。也就是完全要靠自己准备和摸索了。所以，我很积极地去做各种准备，我是江苏的，以我们省为例子，大致经历如下：\n1、找到考试形式：\n很多人都知道中职类的面试是只要通过中学两门公共科目笔试，对于面试到底考什么却不清楚。最好在省教育考试网上找找有没有公告。通过公告可以了解面试评分标准，面试内容和形式。江苏的中职专业课教资面试大致是三部分：专业概述、讲课、答辩。\n\n2、面试准备：\nA、选定自己要报考的科目\n中职专业课的科目是相当多，根据公告最下面附件里的目录进行选择。\n\n目录里面也有指定教材，当然如果买不到指定教材，也可以买其他版本的。但是必须买一本，因为面试时，要自己带教材去考试，不带教材是不让考试的。\nB、专业概述\n三部分中讲课和答辩其实和其他科目差不多，那么这个专业概述到底是什么呢？我们到底该怎么准备呢？我其实很焦虑，在网上搜索了许久也没搜到，幸好碰到一位已经通过前辈的帮助，感动非常，这年头还是好人多呀。我就自己准备专业概述来说几点：\n(1)、一定要像演讲一样准备稿子，专业概述在代替其他科目的结构化问答占分还是很大，可以提前准备抓住这部分的分值。\n(2)、稿子演讲的时间准备差不多为4分钟，太长了容易超时，太短了考官会问很多问题。一定要自己反复练习，尽量不要卡壳，最好脱稿。\n(3)、专业概述怎么写？可以从你选的专业几个方面来写：1、专业的发展现状2、专业的培养目标3、专业的主要课程4、专业的就业前景。字数大概普通笔记本两页就可以了。这些内容完全可以从招生简介和一些文章上提取加上自己润色。例如：加入一些真实数据，以我为例，网民人数上升百分比；加入一些案例，电子商务发展迅速，亚马逊、天猫等。\n(4)、考官提问：一般来说当你说完专业概述，考官也就最多问一个或两个问题，通常十分简单，所以不要紧张，从容应对，不要胡编，真诚回答就行。\nC、课程试讲\n(1)、要熟悉自己的教材，可以在书里画出重难点。因为自带教材，其实有效缩小了范围，只在一本书上，而且可以带进考场，那么在书上写写画画做小抄是允许的，但是不能夹带纸质材料进去。\n(2)、有可能的话，买一本对应教案。有的书本后面，会有增值服务，赠送电子版教案，对于一些没有经验的考生来说就是捷径。参考上面的教师提问和重难点划分。\n(3)、多练习试讲。这点我自己没做好，导致上场以后这部分发挥不好。这部分好心妹纸推荐我看了老师们微课，大家也可以多观摩学习。\n\n(4)、答辩\n江苏中职专业课答辩一般带有一定运气成分，什么意思呢？我的那组考官问了我跟专业相关的问题：网购和传统商务的优缺点？网购存在各种问题，为什么大家依旧选择网购？如果碰到这种问题，一定要冷静下来理清思路，然后分层次回答，切忌慌乱囫囵吞枣。思路可以是分别简述他们的优缺点，可以加上自己的观点，如我回答的完第一个问题后说我认为这两种形式是不会被互相替代掉的，阐述一下自己想法。中职专业课面试的老师是大学的老师，对于专业是精通的能看出来你认真准备与否。如果抽到常规题，那么就按照一般答辩思路去回答就好。\n3、面试流程\nA、报名\n和笔试一样的过程，看清楚该选择的考点和是否需要现场审核。目前江苏所有报考中职专业课及中职实习指导教师的考生（含师范生）选择江苏理工学院考区。是网上审核。一定要看清公告上要求！\nB、流程\n（1）按准考证规定的时间，提前30分钟到达考点。一天貌似只有两个时间段，上午和下午。我是下午场的，要求12：15到达，提醒下午场的考生一定要吃午饭。\n（2）到点后，考场外会贴出分配的表格。上面找到你的姓名、准考证、科目、候考室和考场号。然后排队进入候考室。\n\n\n（3）进入候考室会进行面试顺序抽签。一个考场是9个人，如果不小心抽到9，那么要等到最后，所以大家一定要吃午饭，会饿死。候考室会有人发装手机的信封、试讲章节抽签单、领取物品单，按要求填写然后将手机装入上交。\n（4）候考。手机关机上交后就是漫长的候考，你可以翻书复习，看教案，喝水，但是尽量不要大声说话，过程挺难熬。时间差不多会有人让你带上教材、笔、证件、准考证、两张单子排队。出了候考室在备考室外面进行试讲章节抽签，如果课本上没有章节就重新抽。（这里有个技巧，抽到很难讲的操作课可以跟抽签人主动要求重新抽取，一般不会拒绝）\n（5）备课。抽签完，进入备课室，有20分钟备课。其中写教案要尽量压缩在十分钟，还有十分钟进行梳理和简单串联。写教案这个就不细说了，要写简案就行。最好提前把板书设计好。\n\n（6）面试。进入考场后，记得要先将准考证和那个写着抽题的单子交给学生助理，然后上台后要对考官进行问好。考官会按流程引导你，尽量让自己不要紧张，放轻松。试讲的时候要写板书，字丑的同学有机会要练练黑板字。等整个面试结束后，要把教案交给学生助理，拿回自己的准考证。\n（7）离场。回到候考室，将物品领取单交给工作人员，自己不可以再进候考室。所以在前面离开候考室之前，把自己物品整理好，尽量放进一个包里。\n三、教资认定\n1、网上申请\n当成绩合格后，就要关注当地教师证认定时间了。一般在教育局的网站上会有相关通知，在规定的时间内进行认定申请。申请认定时如果没有符合的普通话证成绩也无法认定。所以没有的同学要考一个普通话证。\n2、现场审核\n网上申请之后，会要求带相关材料进行现场审核，具体时间、地点和材料清单关注当地教育局网站。\n3、体检\n同样，在审核成功后，教育局会通知你去指定医院参加体检。一般要求带身份证和照片，自己缴纳体检费用，医保卡有的时候可刷。（具体流程根据各地教育局要求）\n4、领证\n在体检无误后，就是等待领证了，这个时间有长有短，江苏一般是体检后一个月多一点。时刻关注教育局网站上通知。一般是去现场审核地方凭身份证领取，应届生同时需要带毕业证书。领取时还会发一张认定申请表，记得交到档案存放的地方，放进档案里。\n最后，一些重要网站给大家列举下来：\n1、教师资格证考试报名网站：NTCE - 中国教育考试网\n2、教师资格证认定网站：中国教师资格网\n3、中国语言文字网（普通话考试信息）：中国语言文字网\n4、当地的教育局网站（自行查找，不列举）\n祝大家都能早日通过考试！\n","plink":"https://dxsummer.gitee.io/posts/81a6fc20/"},{"title":"程序员注释","date":"2020-07-30T09:14:41.000Z","date_formatted":{"ll":"2020年7月30日","L":"2020/07/30","MM-DD":"07-30"},"updated":"2020-09-08T09:00:54.626Z","content":"1234567891011121314151617181920*                   ___&#x3D;&#x3D;&#x3D;&#x3D;-_  _-&#x3D;&#x3D;&#x3D;&#x3D;___*             _--^^^#####&#x2F;&#x2F;      \\\\#####^^^--_*          _-^##########&#x2F;&#x2F; (    ) \\\\##########^-_*         -############&#x2F;&#x2F;  |\\^^&#x2F;|  \\\\############-*       _&#x2F;############&#x2F;&#x2F;   (@::@)   \\############\\_*      &#x2F;#############((     \\\\&#x2F;&#x2F;     ))#############\\*     -###############\\\\    (oo)    &#x2F;&#x2F;###############-*    -#################\\\\  &#x2F; VV \\  &#x2F;&#x2F;#################-*   -###################\\\\&#x2F;      \\&#x2F;&#x2F;###################-*  _#&#x2F;|##########&#x2F;\\######(   &#x2F;\\   )######&#x2F;\\##########|\\#_*  |&#x2F; |#&#x2F;\\#&#x2F;\\#&#x2F;\\&#x2F;  \\#&#x2F;\\##\\  |  |  &#x2F;##&#x2F;\\#&#x2F;  \\&#x2F;\\#&#x2F;\\#&#x2F;\\#| \\|*  &#96;  |&#x2F;  V  V  &#96;   V  \\#\\| |  | |&#x2F;#&#x2F;  V   &#39;  V  V  \\|  &#39;*     &#96;   &#96;  &#96;      &#96;   &#x2F; | |  | | \\   &#39;      &#39;  &#39;   &#39;*                      (  | |  | |  )*                     __\\ | |  | | &#x2F;__*                    (vvv(VVV)(VVV)vvv)* *      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~* *                神兽保佑            永无BUG123456789101112131415161718192021*                                                     __----~~~~~~~~~~~------___*                                    .  .   ~~&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;......          __--~ ~~*                    -.            \\_|&#x2F;&#x2F;     |||\\\\  ~~~~~~::::... &#x2F;~*                 ___-&#x3D;&#x3D;_       _-~o~  \\&#x2F;    |||  \\\\            _&#x2F;~~-*         __---~~~.&#x3D;&#x3D;~||\\&#x3D;_    -_--~&#x2F;_-~|-   |\\\\   \\\\        _&#x2F;~*     _-~~     .&#x3D;~    |  \\\\-_    &#39;-~7  &#x2F;-   &#x2F;  ||    \\      &#x2F;*   .~       .~       |   \\\\ -_    &#x2F;  &#x2F;-   &#x2F;   ||      \\   &#x2F;*  &#x2F;  ____  &#x2F;         |     \\\\ ~-_&#x2F;  &#x2F;|- _&#x2F;   .||       \\ &#x2F;*  |~~    ~~|--~~~~--_ \\     ~&#x3D;&#x3D;-&#x2F;   | \\~--&#x3D;&#x3D;&#x3D;~~        .\\*           &#39;         ~-|      &#x2F;|    |-~\\~~       __--~~*                       |-~~-_&#x2F; |    |   ~\\_   _-~            &#x2F;\\*                            &#x2F;  \\     \\__   \\&#x2F;~                \\__*                        _--~ _&#x2F; | .-~~____--~-&#x2F;                  ~~&#x3D;&#x3D;.*                       ((-&gt;&#x2F;~   &#39;.|||&#39; -_|    ~~-&#x2F; ,              . _||*                                  -_     ~\\      ~~---l__i__i__i--~~_&#x2F;*                                  _-~-__   ~)  \\--______________--~~*                                &#x2F;&#x2F;.-~~~-~_--~- |-------~~~~~~~~*                                       &#x2F;&#x2F;.-~~~--\\*                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~* *                               神兽保佑            永无BUG123456789*                   江城子 . 程序员之歌* *               十年生死两茫茫，写程序，到天亮。*                   千行代码，Bug何处藏。*               纵使上线又怎样，朝令改，夕断肠。* *               领导每天新想法，天天改，日日忙。*                   相顾无言，惟有泪千行。*               每晚灯火阑珊处，夜难寐，加班狂。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647* ......................................&amp;&amp;.........................* ....................................&amp;&amp;&amp;..........................* .................................&amp;&amp;&amp;&amp;............................* ...............................&amp;&amp;&amp;&amp;..............................* .............................&amp;&amp;&amp;&amp;&amp;&amp;..............................* ...........................&amp;&amp;&amp;&amp;&amp;&amp;....&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;........* ..................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..............* ................&amp;...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.................* .......................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........* ...................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...............* ..................&amp;&amp;&amp;   &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............* ...............&amp;&amp;&amp;&amp;&amp;@  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........* ..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;&amp;....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;.........* ..........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;........* ........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;....&amp;&amp;&amp;.......* .......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....&amp;&amp;......* ........&amp;&amp;&amp;&amp;&amp;.....................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.............* ..........&amp;...................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............* ................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............* ..................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;............* ..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;....&amp;&amp;&amp;&amp;&amp;............* ...........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;......&amp;&amp;&amp;&amp;............* .........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;............* .......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........&amp;&amp;&amp;&amp;............* ......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;&amp;&amp;...............&amp;&amp;&amp;.............* .....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............................&amp;&amp;..............* ....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.................&amp;&amp;...........................* ...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....................&amp;&amp;&amp;&amp;......................* ...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;&amp;&amp;........................&amp;&amp;&amp;&amp;&amp;...................* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;..........................&amp;&amp;&amp;&amp;&amp;&amp;&amp;...............* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;............&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;&amp;&amp;&amp;.............* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.................&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........* ..&amp;&amp;.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.......* ...&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;......* ....&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....* .......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;....* .......&amp;&amp;&amp;&amp;&amp;.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;..........&amp;&amp;&amp;&amp;&amp;&amp;....* ........&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........&amp;..&amp;&amp;&amp;&amp;...* .......&amp;&amp;&amp;........&amp;&amp;&amp;.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;.................&amp;&amp;&amp;&amp;...* .......&amp;&amp;&amp;...............&amp;&amp;&amp;&amp;&amp;&amp;&amp;.......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............&amp;&amp;&amp;...* ........&amp;&amp;...................&amp;&amp;&amp;&amp;&amp;&amp;.........................&amp;&amp;&amp;..* .........&amp;.....................&amp;&amp;&amp;&amp;........................&amp;&amp;....* ...............................&amp;&amp;&amp;.......................&amp;&amp;......* ................................&amp;&amp;......................&amp;&amp;.......* .................................&amp;&amp;..............................* ..................................&amp;..............................1212345678910111213141516171819202122232425262728293031&#x2F;&#x2F;                            _ooOoo_&#x2F;&#x2F;                           o8888888o&#x2F;&#x2F;                           88&quot; . &quot;88&#x2F;&#x2F;                           (| -_- |)&#x2F;&#x2F;                            O\\ &#x3D; &#x2F;O&#x2F;&#x2F;                        ____&#x2F;&#96;---&#39;\\____&#x2F;&#x2F;                      .   &#39; \\\\| |&#x2F;&#x2F; &#96;.&#x2F;&#x2F;                       &#x2F; \\\\||| : |||&#x2F;&#x2F; \\&#x2F;&#x2F;                     &#x2F; _||||| -:- |||||- \\&#x2F;&#x2F;                       | | \\\\\\ - &#x2F;&#x2F;&#x2F; | |&#x2F;&#x2F;                     | \\_| &#39;&#39;\\---&#x2F;&#39;&#39; | |&#x2F;&#x2F;                      \\ .-\\__ &#96;-&#96; ___&#x2F;-. &#x2F;&#x2F;&#x2F;                   ___&#96;. .&#39; &#x2F;--.--\\ &#96;. . __&#x2F;&#x2F;                .&quot;&quot; &#39;&lt; &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;.&#x2F;&#x2F;               | | : &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | |&#x2F;&#x2F;                 \\ \\ &#96;-. \\_ __\\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F;&#x2F;&#x2F;         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F;                            &#96;&#x3D;---&#x3D;&#39;&#x2F;&#x2F;&#x2F;&#x2F;         .............................................&#x2F;&#x2F;            佛祖镇楼        永不宕机          BUG辟易&#x2F;&#x2F;          佛曰:&#x2F;&#x2F;                  写字楼里写字间，写字间里程序员；&#x2F;&#x2F;                  程序人员写程序，又拿程序换酒钱。&#x2F;&#x2F;                  酒醒只在网上坐，酒醉还来网下眠；&#x2F;&#x2F;                  酒醉酒醒日复日，网上网下年复年。&#x2F;&#x2F;                  但愿老死电脑间，不愿鞠躬老板前；&#x2F;&#x2F;                  奔驰宝马贵者趣，公交自行程序员。&#x2F;&#x2F;                  别人笑我忒疯癫，我笑自己命太贱；&#x2F;&#x2F;                  不见满街漂亮妹，哪个归得程序员？---------------------123456789101112131415161718192021*　　　　　　　　┏┓　　　┏┓+ +*　　　　　　　┏┛┻━━━┛┻┓ + +*　　　　　　　┃　　　　　　　┃ 　*　　　　　　　┃　　　━　　　┃ ++ + + +*　　　　         ██ ━██  ┃+*　　　　　　　┃　　　　　　　┃ +*　　　　　　　┃　　　┻　　　┃*　　　　　　　┃　　　　　　　┃ + +*　　　　　　　┗━┓　　　┏━┛*　　　　　　　　　┃　　　┃　　　　　　　　　　　*　　　　　　　　　┃　　　┃ + + + +*　　　　　　　　　┃　　　┃　　　　Code is far away from bug with the animal protecting　　　　　　　*　　　　　　　　　┃　　　┃ + 　　　　神兽保佑,代码无bug　　*　　　　　　　　　┃　　　┃*　　　　　　　　　┃　　　┃　　+　　　　　　　　　*　　　　　　　　　┃　 　　┗━━━┓ + +*　　　　　　　　　┃ 　　　　　　　┣┓*　　　　　　　　　┃ 　　　　　　　┏┛*　　　　　　　　　┗┓┓┏━┳┓┏┛ + + + +*　　　　　　　　　　┃┫┫　┃┫┫*　　　　　　　　　　┗┻┛　┗┻┛+ + + +1234567891011121314151617181920212223242526272829303132333435363738394041424344 * ━━━━━━神兽出没━━━━━━ * 　　　┏┓　　　┏┓ * 　　┏┛┻━━━┛┻┓ * 　　┃　　　　　　　┃ * 　　┃　　　━　　　┃ * 　　┃　┳┛　┗┳　┃ * 　　┃　　　　　　　┃ * 　　┃　　　┻　　　┃ * 　　┃　　　　　　　┃ * 　　┗━┓　　　┏━┛Code is far away from bug with the animal protecting * 　　　　┃　　　┃    神兽保佑,代码无bug * 　　　　┃　　　┃ * 　　　　┃　　　┗━━━┓ * 　　　　┃　　　　　　　┣┓ * 　　　　┃　　　　　　　┏┛ * 　　　　┗┓┓┏━┳┓┏┛ * 　　　　　┃┫┫　┃┫┫ * 　　　　　┗┻┛　┗┻┛ * * ━━━━━━感觉萌萌哒━━━━━━ *&#x2F;&#x2F;** * 　　　　　　　　┏┓　　　┏┓ * 　　　　　　　┏┛┻━━━┛┻┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　...　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛","plink":"https://dxsummer.gitee.io/posts/8f0fd6d2/"},{"title":"三级网络技术考过指南","date":"2020-07-30T02:31:31.000Z","date_formatted":{"ll":"2020年7月30日","L":"2020/07/30","MM-DD":"07-30"},"updated":"2020-07-30T02:38:42.192Z","content":"前言（必读）\n文章转载\n\n本文档总大小 5MB 左右，请注意流量若手机端浏览不便，请尝试使用电脑浏览器\n这份指南写于我备考三级一周后，因为做了几套题之后感觉这个考试的知识点和题型很固定，而将这些知识点和做法概括总结出来可以帮助以后考试的同学。\n对于没有相应基础的绝大多数同学，如果想考过三级网络技术，首先要克服见到陌生复杂题目的恐惧感。话说回来，其实这些题没有哪一道是真正需要动脑进行复杂思考的，只是知识点没见过，做题的方法不清楚，一旦知道了就能写对。这个考试没有什么含金量，一周的练习基本上足够了。\n我们专业去年上了计算机网络这门课，但跟这个考试的关系不大，只有少量的考点学过。所以我对题目的解析是很业余的，但这也是个好处，正是因为不专业写的就比较直白，适合没有基础的同学参考。\n后增：为什么考三级？既然二级都过了，再考个三级呗，有的学校可能还有实践学分。别人二级office的很多，你三级看上去就显得厉害一点。\n【重要更新】自2018年3月份全国计算机等级考试（第51次）起，取消了三级获证的前置条件。直接报名考三级就可以了，不再需要对应的二级科目通过。\n为什么三级选网络技术这科？\n因为我考的时候，查了查发现考这个的最多，考的人越多的科目考试题就可能越标准规范，我对其他的科目也没有特别有兴趣的，所以就考这个了。所以我也只能写网络技术，所以你们选网络技术备考也就最方便。\n要不要考四级？从用我的角度来讲，这个考试本来就没什么含金量，我没有考。还想考计算机方面的证，可以去考软考 [ 计算机技术与软件专业技术资格（水平）考试 ] 。如果考研想考计算机，可以去了解CCF CSP考试，对一些学校复试上机可能有用。听说计算机等级考试四级比三级还简单，也是买题做题就行了。\n\n1.基础准备1.1 题库买一本三级网络技术题库或者是题库软件（20 元左右），不需要买更多，总之有成套的题可以做就行。真题目前大概有二十套左右。\n1.2 二进制转换应该学过\n网络技术用到的一般是八位二进制数。也就是 0 ~ 255，即 0000 0000 ~ 1111 1111（每四位空一格便于观察）\n我做题前在草稿纸上先这样画\n这样，比如说我看见 1001 1000 这个数，就知道这是 128+16+8 对应的数。\n反过来，十进制转换二进制也可以利用这个简图。还有一些规律，自己做题中摸索吧，你可能会找到更好的方法。\n下面几组记忆一下，做题时会比较方便（不要畏难，做题见多了就记住了）\n\n二进制十进制\n\n1000 0000128\n\n1100 0000192\n\n1110 0000224\n\n1111 0000240\n\n1111 1111255\n1.3 基础概念如果是学过计算机网络相关知识的同学可以不看，下面是非专业的不标准的可能还有错的描述，仅仅是为了完全没有基础的同学有个粗略了解。\n计算机网络是一些电脑相互链接组成的，这些电脑叫做主机，可能相距很远，也可能是一间屋子里的。\n就像正常情况下两个人要用同一种语言交流一样。主机之间的联系也要按照相同的标准才行，这些标准叫做协议。因为主机之间的联系是一件复杂的事。所以有多种协议解决不同方面的问题，比如 TCP、BGP、DHCP 等等。\n相距太远的主机之间不能直接联系，就需要一些设备，比如路由器、交换机等等，你只知道他们都是为了主机联系的中间转发设备就行。\n还需要地址，因为没有地址就不知道主机在哪，这个标识主机的就是 IP 地址。IP 地址是类似这样的：10000000.1110000.01000000.10110001，一共 32 位，为了人看起来方便就写成 128.224.64.177 这种点分十进制的形式。\n还有一种叫做 MAC 地址，是标识硬件设备的地址。\n主机还可以广播给整个网络，广播地址是 IP地址 32 位全置 1 的地址，即 255.255.255.255。\n当你访问一个网站，你的电脑先将网址发送给 DNS 服务器（域名解析服务器），这个服务器能将你写的网址域名变成 IP 地址，这样你的电脑就知道想要访问的网页放在哪了。\n上面这些并不能让你真正理解计算机网络（其实我也不是很清楚），主要是让你在见到陌生名词的时候别害怕，有些名词不理解也不会影响做题。\n1.4 备考建议这就是个人的方法了，也不一定适合你。\n【1】首先对着一套三级题和答案看一遍，每道题都看答案解析是怎么说的。看答案不必弄懂（当然你要真的全弄懂也很厉害），知道怎么选出来就行，不明白跳过也行。同时也找找看看我笔记里写没写这道题的知识点。\n这一遍是比较简略的，对题目有个简单的印象就够了。但这遍也是比较困难的，因为几乎都是陌生的东西。\n【2】接下来，同时做两三套试题甚至更多套。按着笔记里的知识点做，看到哪个知识点就到这些套题里找，对照着做题来掌握这个知识点。如果笔记里没有提到或者没写详细的就看答案怎么说，实在不明白的还可以跳过。\n这个阶段是需要比较认真的看了，我这个阶段是在写笔记中度过的。经过这个阶段你就能明白哪些知识点考察比较固定，一些题的固定做法是什么，对考试有比较完全的认识了。\n【3】接下来，就把剩下的套题都做了，反正一共就二十套左右。怎么做都行，按套或者按题型什么的自己安排，反正做一遍。如果没时间了，至少把选择题做一遍。\n这一遍就是完善熟练的阶段，还可能有一些我笔记里没写的知识点你也会了。\n【补充】有的同学还是感觉难，那就先把第一道大题和最后一道大题的两个填表都仔细弄会了。这两个表就 20 分到手了。接下来学习可能会感觉踏实一点。\n\n2.选择题（40 道 40 分）根据做题方法不同划为三类\n第一类：几乎每套题都考，掌握简单做法即可选出正确答案\n第二类：每套题里有 5 道左右，看上去非常复杂的大段配置代码\n第三类：从四个选项里选出一项正确或错误的，其中部分知识点是常考的，比较零散\n2.1 第一类选择题2.1.1 问传输速度OC-3 对应 155.52 MbpsOC-12 对应 622.08 Mbps\n（显然，这是一道送分题）\n2.1.2 求交换机带宽通常是求总带宽例：某交换机有 12 个 10/100 Mbps 电端口和 2 个 1000 Mbps 光端口，所有端口都在全双工状态下，那么总带宽为（ ）解：忽略 10/100 中的 10，当成 100 Mbps 就好。12 * 100 + 2 * 1000 = 3200，又因为全双工所以乘以 2 得 6400 Mbps ,即 6.4 Gbps\n有时候求上联端口带宽例：某交换机有 16个100/1000 Mbps 全双工下联端口，那么上联端口带宽至少为（ ）解：16 * 1000 * 2 = 32000 Mbps = 32 Gbps，上联一般是下联的 1/20 ，所以至少为 32 除以 20 得 1.6 Gbps\n2.1.3 系统可用性与停机时间\n可用性停机时间\n\n99.9%≤8.8小时\n\n99.99%≤53分钟\n\n99.999%≤5分钟\n也是送分题，但要记准确。比如 53 分钟，有时候会问 55 分钟的情况，要是记成 50 或者大约 1 小时就没法做了。\n2.1.4 写地址块的子网掩码例：IP 地址块 59.67.159.125/11 的子网掩码可写为（ ）解：不用看 IP 地址，只看 /11 就够了。11 代表子网掩码的前 11 位都是 1 ，所以可以写出子网掩码 11111111.11100000.00000000.00000000 转换为十进制即是 255.224.0.0做题熟练后其实不用写上面那堆 1 和 0 就能选出正确答案。\n2.1.5 网络地址转换 NAT会给你一个这样的图，问你 ① ② 是什么只需要知道②和紧挨着它的 S 数字相同，所以②应该是 202.0.1.1,5001 ;同理，①是 10.0.0.1,3342。还有时候会问某个小方框里的 S,D 分别是什么，看上面的图你会发现，上面两个方框和下面两个方框里的数字是对称的，做题时对称一下就写出答案了。\n2.1.6 IP 地址块聚合第一种：问聚合后的地址块\n下面演示三个地址的聚合步骤为：转成二进制；对齐找前多少位是相同的；转回十进制写答案。这样就得出聚合后的地址为：192.67.159.192/26Tips：转换二进制时，因为前三段十进制本来就一样，所以可以只转换最后一段；不要一个一个数有多少位相同的，因为前三段相同就知道有 3 * 8 = 24 位，再加上 2 就是 26。\n第二种：问聚合后可用 IP 数\n下面两种情况的做法由网友 Yes 补充，十分感谢，之前我写的不当方法已删除。\n【第一种情况】如未来教育上机考试第一套试题第10题：\n“ IP 地址块 202.113.79.128/27、202.113.79.160/27 和 202.113.79.192/27 经过聚合后可用的地址数为___”\n因为格式都是 xxx.xxx.xxx.xxx/27，本题中“/”后边的数字都是相同的。\n所以遇到这种题，先把前两个 IP 聚合求出可用地址数，然后单独算出第三个 IP 地址可用地址数，两个地址数相加即正确答案。\n【第二种情况】如未来教育上机考试第三套试题第10题：\n“ IP 地址块 202.113.79.0/27、202.113.79.32/27、202.113.79.64/26 经过聚合后可用的地址数为___”\n本题中“/”后边的数字前两个是相同的，第三个与前两个不同。\n所以遇到这种题，直接将三个 IP 聚合得到地址块，然后求出三个 IP 的可用地址数。\n2.1.7 路由表距离更新例：R1,R2 是一个系统中采用RIP路由协议的两个相邻路由器，R1 的路由表如（a）所示，R1 收到 R2 发送的报文（b）后，R1 更新后的距离值从上到下依次是（ ）解：做法如下步骤为：b距离+1；与a距离比较；更新为距离最小的。则更新后的距离值从上到下依次是 0、4、4、3、2\n还经常这样考——给出更新后距离值和（a）中的距离，求（b）报文距离的可能值。规则不变，上面的做法反过去求就行。\n2.1.8 IPv6 地址简化表示例：某地址 FF23:0:0:0:0510:0:0:9C5B，可以简化为 FF23::0510:0:0:9C5B，双冒号替代连续出现的 0 位段，不能简化为 FF23::0510::9C5B，因为双冒号只能使用一次，可以简化为 FF23::510:0:0:9C5B，因为 0510 就是 510 ，不能简化为 FF23::051:0:0:9C5B，因为 0510 不是 51。\n例：下列 IPv6 地址表示中错误的是（ ）A) ::10F:BC:0:0:03DAB) FE::0:45:03/48C) FE31:0:BC:3E:0:050D:BC::03DAD) FF34:42:BC::3E:50F:21:03D解：IPv6 地址是 128 位划分为 8 段的地址，而 C 项不算双冒号那段已经有了 8 段，双冒号又至少压缩一个 0 位段，所以超了 8 段，是错误的。B 中的 /48 做题时可以忽略，写不写没关系。做这种题先看有没有包含两个** :: **的选项，再看最长的那项有没有超过 8 段。\n2.1.9 数据包例：下图是 A 发送的数据包通过路由器转发到 B 的过程示意图，求数据包 3 中的目的IP地址和目的MAC地址解：无论哪个数据包，目的 IP 地址就是 B 的 IP 地址，所以数据包 3 的目的 IP 为 129.42.56.216；而目的 MAC 地址就是下一个路由器的 MAC 地址，数据包 3 的下一个路由器是 R3，所以数据包 3 的目的 MAC 地址是 00d0.63c3.3c41。\n2.1.10 三种备份备份速度从快到慢：增量备份、差异备份、完全备份（备份越详细越慢）恢复速度从快到慢：完全备份、差异备份、增量备份（和上面顺序相反，也好理解，备份时详细的恢复快）空间占用从多到少：完全备份、差异备份、增量备份（备份越详细占用空间越多）题目通常问你其中某一种的顺序。\n【补充】恢复备份时使用的备份数的顺序，使用备份数最多的是增量备份，最少的是完全备份。\n2.2 第二类选择题这部分将进一步体现本指南的优越性\n我们先来看一道“第二类选择题”的四个选项，不需要看题。\n-从这开始-到这结束看起来异常复杂，但这是在我完全不懂知识点的情况下就能选对的题。下面要讲的是技巧方法，不是知识点，适用于这类题首先，你需要来回观察这四个选项，找出他们的不同点。可能是两句颠倒的代码，可能是一个单词一个数，也可能是其他的。这是我把他们不同的地方做了荧光标记首先一眼看上去，C 项的大段数字位置和其他三项不一样，所以排除 C；然后，看蓝色的数字，只有 A 项和其他三项不一样，所以排除 A；最后，看绿色的地方，只有 B 项少了一句，所以排除 B；选 D。\n悟性比较高的同学肯定已经明白了，为了大家更好的体会，再换一道题演示：不先写选项了，直接展示标记后的方法一样，找出不同点，然后“少数服从多数”，最后选 C。\n下面一道题自己练习一下答案是C。\n说出来你可能不信，这种方法可以解决80%以上的“第二类选择题”，有的题可能没办法排除掉三个选项，这时候就要结合一下题目内容推断来做或者蒙。\n2.3 第三类选择题下面列举的是高频考点，需要记忆，但不要死记。一开始可能感觉很陌生很难，做题碰见得多了就熟悉了能迅速选出答案。\n2.3.1 弹性分组环 RPR每一个节点都执行SRP公平算法\n与 FDDI 一样使用双环结构\n传统的 FDDI 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由源结点从环中回收\n而 RPR 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由目的结点从环中回收\nRPR 采用自愈环设计思路，能在 50ms 时间内隔离故障结点和光纤段\n两个 RPR 结点间的裸光纤最大长度可达 100公里\nRPR 的外环（顺时针）和内环（逆时针）都可以用于传输分组和控制分组\n2.3.2 无线接入技术主要有 WLAN、WiMAX、WiFi、WMAN 和 Ad hoc ( WiFi 肯定知道，记住无线技术一般是W开头的，但有个特殊的A开头)\nAPON 不是无线传输技术，这个经常是迷惑项\n2.3.3 城域网 QoS题库有一道题中说 QoS是广域网的缩写 可能是写错了考的时候通常只写英文缩写，下面写上中文名是为了方便你记忆（其他的地方也应该养成粗略推测英文缩写的习惯）\n主要的技术有 资源预留（RSVP）、区分服务（DiffServ）、多协议标记交换（MPLS）\n2.3.4 接入技术特征ADSL 使用一对铜双绞线，具有非对称技术特性，上行速率 64 kbps640 kbps，下行速率 500 kbps7 Mbps\n采用 ADSL 技术可以通过 PSTN 接入 Internet\nCable Modom（电缆调制解调器）利用频分复用的方法将信道分为上行信道和下行信道，把用户计算机与有线电视同轴电缆连接起来\n光纤传输距离可达 100km 以上（这个知道光纤很远就行了）\n2.3.5 服务器技术热插拔功能允许用户在不切断电源的情况下更换硬盘、板卡等（不能更换主板卡）\n集群技术中，如果一台主机出现故障，不会影响正常服务，但会影响系统性能\n磁盘性能表现在储存容量和 I/O 速度（I/O=input/output 即输入/输出，学过计算机应该知道）\n服务器总体性能取决于 CPU 数量、CPU 主频、系统内存、网络速度\n2.3.6 综合布线双绞线可以避免电磁干扰\n嵌入式插座用来连接双绞线\n多介质插座用来连接铜缆和光纤，满足用户“光纤到桌面”的需求\n建筑群子系统可以是多种布线方式的任意组合，地下管道布线是最理想的方式\nSTP 比 UTP 贵、复杂、抗干扰能力强、辐射小\n水平布线子系统电缆长度在 90 m 以内\n干线线缆铺设经常采用点对点结合和分支结合两种方式\n2.3.7 BGP 协议BGP 是边界网关协议，而不是内部网关协议（所以遇到问某两个自治系统之间使用什么协议，就选 BGP）\nBGP 交换路由信息的节点数不小于自治系统数\n一个 BGP 发言人使用 TCP（不是UDP）与其他自治系统的 BGP 发言人交换信息\nBGP 采用路由向量协议，而 RIP 采用距离向量协议\nBGP 发言人通过 update 而不是 noticfication 分组通知相邻系统\nopen 分组用来与相邻的另一个 BGP 发言人建立关系，两个 BGP 发言人需要周期性地交换 keepalive 分组来确认双方的相邻关系\n2.3.8 RIP 协议RIP 是内部网关协议中使用最广泛的一种协议，它是一种分布式、基于距离向量的路由选择协议，要求路由器周期性地向外发送路由刷新报文\n路由刷新报文主要内容是由若干个（V，D）组成的表。V 标识该路由器可以到达的目标网络（或目的主机）；D 指出该路由器到达目标网络（或目标主机）的距离。距离D对应该路由器上的跳数。其他路由器在接收到某个路由器的（V，D）报文后，按照最短路径原则\\对各自的路由表进行刷新\n使用 RIP v1 路由协议在配置网络地址时无须给定子网掩码\\\n2.3.9 OSPF 协议OSPF 是内部网关协议的一种，每个区域有一个 32 位的标识符，区域内路由器不超过 200 个\n区域内每个路由器包含本区域的完整网络拓扑，而不是全网的情况（拓扑的意思是链接形式和位置关系之类的）\n链路状态“度量”主要指费用、距离、延时、带宽等\nOSPF 采用洪泛法交换链路状态信息\n2.3.10 集线器工作在物理层，连接到一个集线器的所有结点共享一个冲突域\n集线器不是基于 MAC 地址完成数据转发，而是用广播的方法\n在链路中串接一个集线器可以监听数据包\n每次只有一个结点能够发送数据，而其他的结点都处于接收数据的状态。这些结点执行CSMA/CD介质访问控制方法\n2.3.11 交换机是一种工作在数据链路层的网络设备，基本功能是维护一个表示 MAC 地址和交换机端口对应关系的交换表\n在源端口与目的端口间建立虚链接\n具有三种交换模式：1.快速转发直通式，接收到前 14 个字节就转发数据；2.碎片丢弃式，缓存前 64 个字节；3.储存转发式，转发之前读取整个帧\n三层交换机是具有部分路由器功能的交换机，用于加快大型局域网内部的数据交换\n2.3.12 路由器丢包率是衡量路由器超负荷工作时的性能指标之一\n背板能力决定路由器吞吐量\n传统路由器一般采用共享背板的结构，高性能路由器一般采用交换式的结构\n突发处理能力不是以最小帧间隔值来衡量的\n语音视频业务对延时抖动要求较高\n高端路由器应达到：无故障连续工作时间大于 10 万小时；故障恢复时间小于 30 分钟；切换时间小于 50 毫秒\n2.3.13 IEEE 802.11IEEE 802.11 最初定义的三个物理层包括了两个扩频技术和一个红外传播规范，无线频道定义在 2.4GHz ISM频段，传输速度 1~2 Mbps\n802.11b 最大容量 33 Mbps，将传输速率提高到 11 Mbps，802.11a和802.11g 将传输速率提高到 54 Mbps\nIEEE 802.11b 标准使用的是开放的 2.4GHZ 频段，无须申请就可以直接使用\nIEEE 802.1d 是当前最流行的 STP（生成树协议）标准\n2.3.14 蓝牙同步信道速率 64 kbps，跳频速率为 1600 次/s\n工作在 2.402 ~ 2.480 GHz 的 ISM 频段\n非对称的异步信道速率为 723.2 kbps / 57.6 kbps\n对称的异步信道速率为 433.9 kbps\n发射功率为100mw时，最大传输距离为100米\n2.3.15 Serv-U FTP 服务器使用动态 IP 地址时，服务器 IP 地址应配置为空，而不是 0.0.0.0。（为空代表全部 IP 地址）\n每个 Serv-U FTP 服务器中的虚拟服务器由 IP 地址和端口号唯一识别，而不是依靠 IP 地址\n向服务器中添加“anonymous”，系统自动判定为匿名。而不是创建新域时自动添加一个“anonymous”匿名\n服务器最大用户数是指服务器允许同时在线的最大用户数量\n用户上传下载选项要求 FTP 客户端在下载信息的同时也要上传文件\n2.3.16 DNS 服务器允许客户机在发生更改时动态更新其资源记录\nDNS 服务器中的根服务器被自动加入到系统中，不需管理员手工配置\n转发器是网络上的 DNS 服务器（不是路由器），用于外域名的 DNS 查询\n使用 nslookup 命令可以测试正向和反向查找区域\n主机记录的生存时间指该记录被客户端查询到，放在缓存中的持续时间\n2.3.17 DHCP 服务器负责多个网段 IP 地址分配时需配置多个作用域\n添加保留时需在 DHCP 客户机上获得其 MAC 地址信息（添加排除时不需从客户端获得 MAC 地址）\n不添加排除和保留时，服务器可将地址池内的 IP 地址动态指派给 DHCP 客户机\n地址池是作用域应用排除范围之后剩余的 IP 地址\n保留是指确保 DHCP 客户端永远可以得到同一 IP 地址，客户端可以释放该租约\n收到非中继转发的“DHCP发现”消息时,选择收到该消息的子网所处的网段分配 IP 地址\n2.3.18 WWW 服务器Web 站点可以配置静态和动态 IP 地址\n访问 Web 站点时可以使用站点的域名或站点的 IP 地址\n建立 Web 站点时必须为该站点指定一个主目录，也可以是虚拟的子目录\nWeb 站点的性能选项包括影响带宽使用的属性和客户端 Web 连接的数量\n在 Web 站点的主目录选项卡中，可配置主目录的读取和写入等权限\n2.3.19 Wmail 邮件服务器Winmail 用户不可以使用 Outlook 自行注册新邮箱\nWinmail 快速设置向导中创建新用户时，输入新建用户的信息，包括用户名、域名及用户密码（不是系统邮箱的密码）\n建立路由时，需在 DNS 服务器中建立该邮件服务器主机记录和邮件交换器记录\n邮件系统工作过程：1.用户在客户端创建新邮件；2.客户端软件使用 SMTP 协议将邮件发到发件方的邮件服务器；3.发件方邮件服务器使用 SMTP 协议将邮件发到收件方的邮件服务器；4.接收方邮件服务器将收到邮件储存待处理；5.接收方客户端软件使用 POP3 或 IMAP4 协议从邮件服务器读取邮件\n邮件交换器记录的配置只能在服务器上，不能通过浏览器配置\nWinmail 支持基于 Web 方式的访问和管理，管理工具包括系统设置、域名设置等\n发送邮件时通常采用 SMTP 协议，接收邮件时通常采用 POP3 或者 IMAP 协议。Winmail 用户使用浏览器查看邮件会使用到 HTTP 协议\n2.3.20 PIX 防火墙监视模式中，可以更新操作系统映像和口令恢复\n防火墙开机自检后处于非特权模式，输入“enable”进入特权模式\n2.3.21 可信计算机评估准则没有保护就是 D类，不能用于多用户环境下重要信息处理\n提到用户自主保护就是 C类\n2.3.22 入侵防护系统HIPS 基于主机的入侵防护系统，安装在受保护的主机系统中\nNIPS 基于网络的入侵防护系统，布置在网络出口\nAIPS 基于应用的入侵防护系统，部署于应用服务器前端\n（他们的首字母 H、N、A 即 Host、Net、Application）\n2.3.23 网络攻击DDos 攻击：利用已经攻占的多个系统向目标攻击，被害设备面对大量请求无法正常处理而拒绝服务\nSYN Flooding 攻击：利用 TCP 三次握手过程，使受害主机处于会话请求之中，直至连接超时停止响应\nSQL 注入攻击：属于利用系统漏洞，防火墙（基于网络的防护系统）无法阻断\nLand攻击：向某个设备发送数据包，并将数据包的源 IP 地址和目的地址都设置成攻击目标的地址\n基于网络的防护系统也无法阻断 Cookie篡改 和 DNS欺骗\nTear doop 、Smurf 攻击可以被路由器阻止\n2.3.24 无线局域网设备无线接入点（AP）：集合无线或者有线终端（类似于集线器和交换机），负责频段管理和漫游工作（SSID 是客户端设备用来访问接入点的唯一标识）\n无线路由器：具有无线路由功能和 NAT 功能的 AP ，可用来建立小的无线局域网。\n无线网桥：用于连接几个不同的网段，实现较远距离的无线通信（网桥最重要的维护工作是构建和维护 MAC 地址表）\n无线网卡：实现点对点通信，安装于各终端节点\n2.3.25 VLANVLAN name 用 1~32 个字符表示，它可以是字母和数字。不给定名字的 VLAN 系统自动按缺省的 VLAN 名（VLAN00xxx）\nVLAN ID的取值范围是 1~4094。其中无法执行“no vlan 1”命令\n2.3.26 Cisco 路由器上的存储器Flash 主要用于存储当前使用的操作系统映像文件和微代码\nNVRAM 主要存储启动配置文件或备份配置文件\nRAM 主要存储路由表、快速交换缓存、ARP 缓存、数据分组缓冲区和缓冲队列、运行配置文件等\nROM 主要用来永久保存路由器的开机诊断程序、引导程序和操作系统软件\n2.3.27 防火墙对应端口的连接方案pix525 在缺省情况下\nethernet0 被命名为外部接口 outside，安全级别是 0\nethernet1 被命名为内部接口 inside，安全级别是 100\nethernet2 被命名为中间接口 dmz，安装级别是 50\n2.3.28 STP 生成树结构无论是根的确定，还是树状结构的生成，主要依靠 BPDU 提供的信息\nBridge ID 由两个字节的优先级值和 6 个字节的交换机 MAC 地址组成，优先级取值范围是0~61440，增值量是4096，优先值越小，优先级越高\nMAC 地址最小的为根网桥\nBPDU 数据包有两种类型，配置 BPDU 不超过 35 个字节，拓扑变化通知 BPDU 不超过 4 个字节\n2.3.29 Catelyst 配置命令Catelyst3548 设置时间的格式是：clock set 小时:分钟:秒 日 月 年\nCatelyst6500 设置时间的格式是：set time 星期 月/日/年 小时 分钟 秒\n2.3.30 其他有一些知识点因为考频不是很高或者比较复杂，就不写了，自己做题时积累或者放弃。\n在遇到陌生题目时，试着结合常识思考推断。比如说，某网络计划有三台计算机，但只有一个 VLAN 端口，需要的设备是（）这里需要的其实就是路由器，联想宿舍上网的情况\n3.大题（前四道每道10分，最后一道20分）3.1 第一道 填地址表例：\n\nIP 地址115.151.29.58\n\n子网掩码255.240.0.0\n\n地址类别【1】\n|网络地址|【2】|\n|直接广播地址|【3】|\n|主机号|【4】||子网内第一个可用 IP 地址|【5】|\n解：\n\nIP 地址类别IP 首段范围\n\nA类1~127\n\nB类128~191\n|C类|192~223|\n则【1】填：A类对 IP地址和子网掩码做如下处理：熟练以后其实没有看起来这么麻烦，做两道就会了。少数情况会给出表格的后两项，让你补充前五项，原理其实是一样的，倒推一下。这道题是大题里面考点最稳定的一道，必须掌握。\n3.2 第二道 配置路由器例：一般就考这些空，做几道之后就能填上大部分，小部分可以放弃。\n【来自张斌的修改建议，由于不方便改图就直接贴在这里了】network __ area 0和#area 0 range ___，这两个空的讲解可以修改为“R3所在的子网号+子网掩码的反码/子网掩码，如果有两个子网号则先对两个子网进行聚合，然后填写聚合后的子网号+子网掩码的反码/子网掩码”，因为就题库中的题目而言，有两个子网号的情况还是挺多的。除此之外，还可以增加当配置R4时的#ip route _____，空里应该是目的网络子网号（与上题同）+子网掩码（与上题同）+下一跳路由器地址（R3的地址），阴影中有两个子网号时同样先进行聚合。R3由于本身就是阴影区域的一部分，故目的网络和目的子网掩码都是0.0.0.0。同理，如果配置R1或R2，他们都是阴影区域的一部分，目的网络与子网掩码也都是0.0.0.0。\n3.3 第三道 DHCP 报文例：\n3.4 第四道 sniffer 数据包例1：根据图中信息回答以下问题\n该主机执行的命令是（ ），该主机配置的 DNS 服务器的 IP 地址是（ ）解：看图中有 ICMP 几个字母，还有个邮箱地址，所以命令是 tracert mail.tj.edu.cn，DNS服务器的 IP 地址是第一行第二个地址 202.113.64.3（只要这么问，就基本是第一行第二个）\n图中 ② ③ ④ 处分别是（ ）解：② 处前面 Protocol 意思是协议，协议就是 ICMP；③ 写源地址，就是第一行第一个地址 202.113.64.137；④ Destination address 意思是目的地址，这个位置应该写题中有的网址 mail.tj.edu.cn。\n例2：根据图中信息回答以下问题\n该主机配置的域名服务器的 IP 地址是（ ）解：和上题一样，还是第一行第二个 202.113.64.3\n① 处的信息应该是（ ）解：填 ACK。一般都是有一个 SEQ，后再有一个 ACK，接着再有 SEQ，再有 ACK。他们的数值每次 +1，有时候会根据上下行填数字。\n主机 202.38.97.197 是（ ）服务器，其提供服务的端口是（ ）解：因为图中有 FTP 几个字母，所以这是 ftp服务器；提供服务的端口是 21（DNS服务器的端口是 53，邮件服务器的端口是 6）\n该主机执行的命令是（ ）解：填 ftp ftp.pku.edu.cn（网站在图中，前面加 ftp）\n这道题通常就考上面这两种模式，一种有 ICMP 对应 tracert mail.tj.edu.cn 的，一种有 FTP 对应 ftp ftp.pku.edu.cn 的。如果让写 URL 就是 https :// mail.tj.edu.cn 或者 ftp :// ftp.pku.edu.cn（中间都没有空格，我为了格式不自动转换成链接才加的）\n第四道大题也是考点很不稳定的一道。\n3.5 最后一道\n3.5.1 填表部分（12分）\n目的网络/掩码长度输出端口\n\n【1】S0（直接连接）\n\n【2】S1（直接连接）\n|【3】|S0|\n|【4】|S1|\n|【5】|S0|\n|【6】|S1|\n解：图中最上方的 RG 有两个分支，左侧分支是 S0 ，有末段为 129 和 130 的两个地址，进行聚合：所以【1】处填 192.168.6.128/30 ；同理【2】处是 192.168.6.133 和 192.168.6.134 聚合，结果为 192.168.6.132/30。做题实际上只要写出最后那段就行，前面选择题时已经说过了。\n【3】是 RE 下方 192.168.6.65、192.168.6.66、192.168.6.67 三个子网的聚合；【4】是 RF 下方 192.168.6.80、192.168.6.81、192.168.6.82 三个子网的聚合；【5】是 左下方 192.168.64.0/24、192.168.65.0/24、192.168.66.0/24、192.168.67.0/24 四个地址块的聚合；【6】是 右下方 192.168.96.0/24、192.168.97.0/24、192.168.98.0/24、192.168.99.0/24 四个地址块的聚合；\n在【3】【4】两空聚合时往往需要多注意最终答案应为【3】192.168.6.64/29【4】192.168.6.64/27\n【5】192.168.64.0/22\n【6】192.168.96.0/22\n这个填表是必拿分的题。\n3.5.2 中间部分（2~4分）这部分考点很不固定，下面是频率稍高的，考试这几分放弃也可以\n问在某路由器上，最多还可链接的路由器数量是多少。如果所在子网掩码是 /29 就填 3，是 /28 就填 11。\n问串接一种设备能监听路由器之间的流量，写 TAP\n问串接一种设备能提供安全保护，一般是 IPS\n问防火墙访问外网设置，分别填 nat 和 global\n3.5.3 计算子网掩码和 IP 段部分（4~6分）例：将 192.168.66.128/25 划分为三个子网，子网 1 能容纳 50 台主机，子网 2 和 3 能分别容纳 20 台主机……求他们的子网掩码和可用 IP 地址段\n解：题中说多少台主机的具体数字不重要，刚好大于那个数字加 2 后的 2 的 n 次方的数才重要。比如 50 台，就是 64，是 2 的 6 次方。所以子网掩码后 6 位都是 0 （前面全是 1 ），11111111.11111111.11111111.11000000 ，最后填空写 255.255.255.192同理 20 台，就是 32，是 2 的 5次方。所以子网掩码后 5位都是 0，最后填空 2 和 3 的子网掩码都是 255.255.255.224\n可用 IP 地址从题目所给的那个数 +1 开始，本题是 192.168.66.129（因为太乱，下面只写末段数字，反正前面都一样）从 129 开始，因为子网 1 的那个数字是 64 ，所以到 190 结束（129+64-3=190，不用管为什么，结束都是 -3）下一段从 193 开始（190+3=193，不用管为什么，开始都是 +3），因为子网 2 的那个数字是 32 ，所以到 222 结束（193+32-3=222）再下一段从 225 开始（222+3=225），因为子网 3 的那个数字也是 32 ，所以到 254 结束（225+32-3=254）\n写成答案分别为：子网 1 的可用 IP 地址段为 192.168.66.129~192.168.66.190\n子网 2 的可用 IP 地址段为 192.168.66.193~192.168.66.222\n子网 3 的可用 IP 地址段为 192.168.66.225~192.168.66.254\n看起来上面写了一大堆，其实明白了就很简单，这个也是必拿分的题。\n\n总结：得分策略目标是通过考试，也就是 60 分\n选择题部分：前面一共写了 10 个做法固定的“第一类选择题”，还有 19 个“第三类选择题”的高频考点，加上“第二类选择题”。选择题得分在 20 分以上是很保守的估计，没有意外的话选择题应该在 25 分以上。\n大题部分：第一道的 10 分是必得的，最后一道除了中间部分后有 16 分是必得的。从前面写的也能看出第二、三、四道大题的考点不是特别固定，所以尽量写，填对一半就很好了（其实也没有那么难），所以这三道大题 30 分目标是得 15 分。【2018/9/6补充】有时间可以去b站看看正规的大题讲解视频，也许第二、三、四道大题的做法并不难。现在看来我当时的想法还是消极了一些（不过还是一定要先学会固定的题型再说）\n来算一下 20 + 10 + 16 + 15 = 61 分。实际情况当然可能会出现意外，比如三道大题没得到 15 分，但刚才也没算你蒙对的题得分。\n多练习几套题，来回对照着知识点就熟悉了，这个考试题型固定，含金量不高，难度不大，不用害怕。题库软件有很多缺陷，比如大题评分不准、填空题缺少空格，甚至是答案错误。自己要注意核对。这份文档并未涵盖所有知识点，多做一套题就多了一分考过的把握。\n（未来教育题库的第九套题有点特殊，看起来像 13 年考试改革之前的老题，和其他套的题有很大差别，留意一下。）\n完。2017/3/19 初版2017/4/25 修改了前言与总结2017/5/12 修改内容略2017/5/16 刚查到成绩，84分，本来还以为能上90…2017/8/23 补充了备考建议2017/9/12 改正了 2.1.6 IP地址块聚合2017/9/21 增加了 2.3 中近一半的内容，感谢佚名进行的补充2017/12/18 考试获证条件改变，三级不再需要对应的二级科目通过2018/3/24 修正了若干错误，感谢何林刚、张斌、fun、sang_wang 等的帮助2018/6/6 末尾加了收款码2019/2/10 修改两处笔误等\n每次更新编辑会导致分享页面审核，影响同学复习，所以我一般不更新了\n","plink":"https://dxsummer.gitee.io/posts/445a1dcd/"},{"title":"Linux目录结构","date":"2020-07-12T10:17:24.000Z","date_formatted":{"ll":"2020年7月12日","L":"2020/07/12","MM-DD":"07-12"},"updated":"2020-07-12T11:45:14.480Z","content":"一切皆文件\n💎 /bin [重点] (/usr/bin 、 /usr/local/bin)• 是Binary的缩写, 这个目录存放着最经常使用的命令\n💎 /home [重点]• 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\n💎 /root [重点]• 该目录为系统管理员，也称作超级权限者的用户主目录。\n🌱 /sbin (/usr/sbin 、 /usr/local/sbin)• s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。  \n🌱 /lib• 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。\n🌱 /lost+found• 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n💎 /etc [重点]• 所有的系统管理所需要的配置文件和子目录 my.conf\n💎 /usr [重点]• 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。  \n💎 /boot [重点]• 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件  \n🌱 /proc• 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。  \n🌱 /srv• service缩写，该目录存放一些服务启动之后需要提取的数据。\n🌱 /sys• 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sy\n🌱 /tmp• 这个目录是用来存放一些临时文件的。  \n🌱 /dev• 类似于windows的设备管理器，把所有的硬件用文件的形式存储。\n💎 /media [重点]• linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后， linux会把识别的设备挂载到这个目录下。\n💎 /mnt [重点]• 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare  \n🌱 /opt• 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。\n💎 /usr/local [重点]• 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。  \n💎 /var [重点]• 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。  \n🌱 /selinux [security-enhanced linux] 360• SELinux是一种安全子系统,它能控制程序只能访问特定文件。  \n","plink":"https://dxsummer.gitee.io/posts/5e2eb880/"},{"title":"VMware虚拟机的CentOS无法上网的解决方法","date":"2020-07-12T09:25:30.000Z","date_formatted":{"ll":"2020年7月12日","L":"2020/07/12","MM-DD":"07-12"},"updated":"2020-07-12T10:18:42.399Z","content":"流程如下：\n1)点击 VM-&gt;Settings Hardware（虚拟机-设置）选项卡下面\n2)点击Network Adapter （网络适配器）设置如下图所示，首先我们在虚拟机中将网络配置设置成NAT，\n\n3、然后右键点击我们的电脑，进入到管理界面 计算机-&gt; 管理-&gt;服务和应用程序-&gt;服务，找到如下服务进程 VMware DHCP Service, VMware NAT Service。 分别点击右键-&gt;启动\n\n在这里，我们找到VMware NAT service和VMware DHCP service，我们启动它，然后我们进入到CentOS，输入reboot命令重启下系统，在等待了几分钟以后，怀着无比期待的心情点开了CentOS自带的火狐浏览器，输入了google的网站。。。。当看见这个界面时，我不淡定了!!!!\n4)在Centos里面打开终端，输入shutdown -r now\n重启即可上网。\n\n现在心里除了激动还是激动，终于通过一个小手段搞定了在CentOS下上网的问题了!\n","plink":"https://dxsummer.gitee.io/posts/740f0ea7/"},{"title":"英语期末考试","date":"2020-07-02T12:12:49.000Z","date_formatted":{"ll":"2020年7月2日","L":"2020/07/02","MM-DD":"07-02"},"updated":"2020-07-02T13:32:31.606Z","content":"Unit5Explore 1My Mother’s Gift　　母亲的礼物　　I grew up in a small town where the elementary school was a ten-minute walk from my house and in an age, not so long ago , when children could go home for lunch and find their mothers waiting.　　我是在一个小镇上长大的，从镇上的小学校到我家， 只需步行10分钟。离当前不算太太久远的那个时代 ， 小学生可以回家吃午饭，而他们的母亲，则会老早在家等候着。　　At the time, I did not consider this a luxury, although today it certainly would be. I took it for granted that mothers were the sandwich-makers, the finger-painting appreciators and the homework monitors. I never questioned that this ambitious, intelligent woman, who had had a career before I was born and would eventually return to a career, would spend almost every lunch hour throughout my elementary school years just with me.　　这一切对如今的孩子来说，无疑是一种奢望了，可是那时的我，却并不以为然。 我觉得做母亲的给她的孩子制作三明治，鉴赏指画，检查他们的家庭作业，都是理所当然的事。我从来没有想过：像我母亲这样一个颇有抱负又很聪明的女人，在我降生之前，她有一份工作，而且后来她又谋了份差事，可是，在我上小学那几年，她却几乎天天陪着我吃午饭，一同打发午餐时的每一分钟。　　母亲的礼物 My Mother’s Gift　　I only knew that when the noon bell rang, I would race breathlessly home. My mother would be standing1 at the top of the stairs, smiling down at me with a look that suggested I was the only important thing she had on her mind. For this, I am forever grateful.　　只记得，每当午时铃声一响，我就一口气地往家里跑。母亲总是站在门前台阶的最高层，笑盈盈地望着我–那神情分明表示：我便是母亲心目中唯一最重要的东西了。为此，我一辈子都要感谢我的母亲。　　Some sounds bring it all back: the high-pitched squeal2 of my mother’s teakettle, the rumble3 of the washing machine in the basement and the jangle of my dog’s license4 tags as she bounded down the stairs to greet me. Our time together seemed devoid5 of the gerrymandered schedules that now pervade6 my life.　　如今，每当我听到一些声音，像母亲那把茶壶水开时发出的尖叫声，地下室洗衣机的隆隆声，还有， 我那条狗蹦下台阶冲我摇头摆尾时它脖子上那牌照发出的撞击声，便会勾起我对往事的回忆。和母亲在一起的岁月，全然没有充斥于我的生活中的、事先排定的虚情假意的日程表。　　One lunchtime when I was in the third grade will stay with me always. I had been picked to be the princess in the school play, and for weeks my mother had painstakingly7 rehearsed my lines with me. But no matter how easily I delivered them at home, as soon as I stepped onstage, every word disappeared from my head.　　我永远忘不了在我上三年级时的那一顿午饭。在那天之前，我被学校选中，要在一个即将演出的小剧中扮演公主的角色。一连好几个礼拜，母亲总是不辞辛劳地陪着我，一起背诵台词。可是，不管在家里怎么背得滚瓜烂熟，只要一上舞台，我的脑子里就成了一片空白。　　Finally, my teacher took me aside. She explained that she had written a narrator’s part to the play, and asked me to switch roles. Her word, kindly8 delivered, still stung, especially when I saw my part go to another girl.　　终于，老师把我叫到了一边。她说剧中旁白这个角色的台词已写好了，想把我替换下来当旁白。尽管老师这些话说得和和气气，可还是刺痛了我的心，特别是当我发觉自己扮演的公主角色让另外一个女孩顶替时，更是如此。　　I didn’t tell my mother what had happened when I went home for lunch that day. But she sensed my unease, and instead of suggesting we practice my lines, she asked if I wanted to walk in the yard.　　那天回家吃午饭时我没有把这事告诉母亲。然而，母亲见我心神不定，因此没有再提练习背台词的事儿，而是问我愿意不愿意到院子里散散步。　　It was a lovely spring day and the rose vine on the trellis was turning green. Under the huge elm trees, we could see yellow dandelions popping through the grass in bunches, as if a painter had touched our landscape with dabs9 of gold .I watched my mother casually10 bend down by one of the clumps11. “I think I’m going to dig up all these weeds, “she said, yanking a blossom up by its roots.”From now on, we’ll have only roses in this garden.”　　那真是一个可爱的春日，棚架上蔷薇的藤蔓正在转青。在一些高大的榆树下面，我们可以看到，一丛丛黄色的蒲公英冒出草坪，仿佛是一位画家为了给眼前的美景增色而着意加上的点点金色。我看到母亲在一簇花丛旁漫不经心地弯下身来。”我看得把这些野草都拨了，”她说着，一边使劲把一丛蒲公英连根拨出。”往后咱这园子里只让长蔷薇花。”　　“But I like dandelions, “I protested. “All flowers are beautiful-even dandelions. “My mother looked at me seriously.”Yes, every flower gives pleasure in its own way, doesn’t it?” She asked thoughtfully. I nodded, pleased that I had won her over. “And that is true of people too, “she added.” Not everyone can be a princess, but there is no shame in that.”　　可是我喜欢蒲公英，”我不满地说，”凡是花都好看–蒲公英也不例外。”母亲严肃地看着我。”噢，这么说，每朵花都自有它令人赏心悦目的地方喽？”她若有所思地问道。我点了点头，总算说服了母亲，这使我很得意。”可是人也一样呀，”母亲接着又发话，”不见得人人都能当公主，但当不了公主并不丢脸。”　　Relieved that she had guessed my pain, I started to cry as I told her what had happened. She listened and smiled reassuringly12.　　母亲猜到了我的苦恼，这使我的情绪安定下来。我哭了起来，把事情的经过讲给母亲听。母亲专注地听着，脸上带着安详的微笑。　　“But you will be a beautiful narrator, “ she said , reminding me of how much I loved to read stories aloud to her . “The narrator’s part is every bit as important as the part of a princess.　　“但你会成为一名顶呱呱的解说员，”母亲又说。她说平常我是多么喜欢朗诵故事给她听，还说”从哪方面看，旁白这个角色都和公主那个角色一样重要”。　　My Mother’s Gift　　母亲的礼物　　I grew up in a small town where the elementary school was a ten-minute walk from my house and in an age, not so long ago , when children could go home for lunch and find their mothers waiting.　　我是在一个小镇上长大的，从镇上的小学校到我家， 只需步行10分钟。离当前不算太太久远的那个时代 ， 小学生可以回家吃午饭，而他们的母亲，则会老早在家等候着。　　At the time, I did not consider this a luxury, although today it certainly would be. I took it for granted that mothers were the sandwich-makers, the finger-painting appreciators and the homework monitors. I never questioned that this ambitious, intelligent woman, who had had a career before I was born and would eventually return to a career, would spend almost every lunch hour throughout my elementary school years just with me.　　这一切对如今的孩子来说，无疑是一种奢望了，可是那时的我，却并不以为然。 我觉得做母亲的给她的孩子制作三明治，鉴赏指画，检查他们的家庭作业，都是理所当然的事。我从来没有想过：像我母亲这样一个颇有抱负又很聪明的女人，在我降生之前，她有一份工作，而且后来她又谋了份差事，可是，在我上小学那几年，她却几乎天天陪着我吃午饭，一同打发午餐时的每一分钟。　　母亲的礼物 My Mother’s Gift　　I only knew that when the noon bell rang, I would race breathlessly home. My mother would be standing at the top of the stairs, smiling down at me with a look that suggested I was the only important thing she had on her mind. For this, I am forever grateful.　　只记得，每当午时铃声一响，我就一口气地往家里跑。母亲总是站在门前台阶的最高层，笑盈盈地望着我–那神情分明表示：我便是母亲心目中唯一最重要的东西了。为此，我一辈子都要感谢我的母亲。　　Some sounds bring it all back: the high-pitched squeal of my mother’s teakettle, the rumble of the washing machine in the basement and the jangle of my dog’s license tags as she bounded down the stairs to greet me. Our time together seemed devoid of the gerrymandered schedules that now pervade my life.　　如今，每当我听到一些声音，像母亲那把茶壶水开时发出的尖叫声，地下室洗衣机的隆隆声，还有， 我那条狗蹦下台阶冲我摇头摆尾时它脖子上那牌照发出的撞击声，便会勾起我对往事的回忆。和母亲在一起的岁月，全然没有充斥于我的生活中的、事先排定的虚情假意的日程表。　　One lunchtime when I was in the third grade will stay with me always. I had been picked to be the princess in the school play, and for weeks my mother had painstakingly rehearsed my lines with me. But no matter how easily I delivered them at home, as soon as I stepped onstage, every word disappeared from my head.　　我永远忘不了在我上三年级时的那一顿午饭。在那天之前，我被学校选中，要在一个即将演出的小剧中扮演公主的角色。一连好几个礼拜，母亲总是不辞辛劳地陪着我，一起背诵台词。可是，不管在家里怎么背得滚瓜烂熟，只要一上舞台，我的脑子里就成了一片空白。　　Finally, my teacher took me aside. She explained that she had written a narrator’s part to the play, and asked me to switch roles. Her word, kindly delivered, still stung, especially when I saw my part go to another girl.　　终于，老师把我叫到了一边。她说剧中旁白这个角色的台词已写好了，想把我替换下来当旁白。尽管老师这些话说得和和气气，可还是刺痛了我的心，特别是当我发觉自己扮演的公主角色让另外一个女孩顶替时，更是如此。　　I didn’t tell my mother what had happened when I went home for lunch that day. But she sensed my unease, and instead of suggesting we practice my lines, she asked if I wanted to walk in the yard.　　那天回家吃午饭时我没有把这事告诉母亲。然而，母亲见我心神不定，因此没有再提练习背台词的事儿，而是问我愿意不愿意到院子里散散步。　　It was a lovely spring day and the rose vine on the trellis was turning green. Under the huge elm trees, we could see yellow dandelions popping through the grass in bunches, as if a painter had touched our landscape with dabs of gold .I watched my mother casually bend down by one of the clumps. “I think I’m going to dig up all these weeds, “she said, yanking a blossom up by its roots.”From now on, we’ll have only roses in this garden.”　　那真是一个可爱的春日，棚架上蔷薇的藤蔓正在转青。在一些高大的榆树下面，我们可以看到，一丛丛黄色的蒲公英冒出草坪，仿佛是一位画家为了给眼前的美景增色而着意加上的点点金色。我看到母亲在一簇花丛旁漫不经心地弯下身来。”我看得把这些野草都拨了，”她说着，一边使劲把一丛蒲公英连根拨出。”往后咱这园子里只让长蔷薇花。”　　“But I like dandelions, “I protested. “All flowers are beautiful-even dandelions. “My mother looked at me seriously.”Yes, every flower gives pleasure in its own way, doesn’t it?” She asked thoughtfully. I nodded, pleased that I had won her over. “And that is true of people too, “she added.” Not everyone can be a princess, but there is no shame in that.”　　可是我喜欢蒲公英，”我不满地说，”凡是花都好看–蒲公英也不例外。”母亲严肃地看着我。”噢，这么说，每朵花都自有它令人赏心悦目的地方喽？”她若有所思地问道。我点了点头，总算说服了母亲，这使我很得意。”可是人也一样呀，”母亲接着又发话，”不见得人人都能当公主，但当不了公主并不丢脸。”　　Relieved that she had guessed my pain, I started to cry as I told her what had happened. She listened and smiled reassuringly.　　母亲猜到了我的苦恼，这使我的情绪安定下来。我哭了起来，把事情的经过讲给母亲听。母亲专注地听着，脸上带着安详的微笑。　　“But you will be a beautiful narrator, “ she said , reminding me of how much I loved to read stories aloud to her . “The narrator’s part is every bit as important as the part of a princess.　　“但你会成为一名顶呱呱的解说员，”母亲又说。她说平常我是多么喜欢朗诵故事给她听，还说”从哪方面看，旁白这个角色都和公主那个角色一样重要”。　　Over the next few weeks, with her constant encouragement, I learned to take pride in the role. Lunchtimes were spent reading over my lines and talking abut13 what I would wear.　　往后的几个星期，在母亲的一再鼓励下，我渐渐地以担任旁白的角色感到骄傲。利用午饭时间，我们又一起念台词，议论到时候我该穿什么样的演出服装。　　Backstage the night of the performance, I felt nervous. A few minutes before the play, my teacher came over to me. “Your mother asked me to give this to you, “ she said, handing me a dandelion. Its edges were already beginning to curl and it flopped14 lazily from its stem. But just looking at it, knowing my mother was out there and thinking of our lunchtime talk, made me proud.　　到了演出那个晚上，当我登上后台，心里还感到紧张。离演出还有几分钟的时候，老师朝我走了过来。”你母亲让我把这个交给你，”说着她递过来了一朵蒲公英。那花儿四周已开始打蔫，花瓣儿从梗上向下有气无力地耷拉着。可是，只要看一眼，知道母亲就在外面呆着，回想起和母亲用午饭时说的那些话，我就感到胸有成竹。　　After the play, I took home the flower I had stuffed in the apron15 of my costume. My mother pressed it between two sheets of paper toweling in a dictionary, laughing as she did it that we were perhaps the only people who would press such a sorry-looking weed.　　演出结束后，我把塞在演出服围裙里的那朵蒲公英拿回了家。母亲将花接了过去，用两张纸巾将它压平，夹在了一本字典里。她一边忙碌着，一边笑，想到也许只有我们俩会珍藏这么一朵打了蔫的野草花。　　I often look back on our lunchtimes together, bathed in the soft midday light. They were the commas in my childhood, the pauses that told me life is not savored16 in premeasured increment17, but in the sum of daily rituals and small pleasures we casually share with loved ones. Over peanut-butter sandwiches and chocolate-chip cookies, I learned that love, first and foremost, means being there for the little things.　　我常常回想起和母亲在一起度过的那些沐浴在和煦阳光之中的午餐时光。它们是我孩提时代的一个个小插曲，告诉我一个道理：人生的滋味，就在于和我们所爱的人在一起不经意地共度的日常生活、分享的点点滴滴的欢乐，而不在于某种事先测量好的”添加剂”。在享用母亲做的花生酱、三明治和巧克力碎末小甜饼的时候，我懂得了，爱就体现在这些细微这处。　　A few months ago, my mother came to visit. I took off a day from work and treated her to lunch. The restaurant bustled18 with noontime activity as businesspeople made deals and glanced at their watches. In the middle of all this sat my mother, now retired19, and I. From her face I could see that she relished20 the pace of the work world.　　几个月前，母亲又来看我。我特意请了天假，陪母亲吃午饭。中午，饭馆里熙熙壤攘，做生意的人忙不迭地从事交易活动，他们不时地看看手表。如今已经退休的母亲和我就坐在这群人中间。从母亲的表情中，我看得出，母亲打心眼里喜欢上班族这种生活的节奏。　　“Mom, you must have been terribly bored staying at home when I was a child,” I said.”Bored? Housework is boring. But you were never boring. “　　“妈，我小的时候，您老呆在家里一定觉得很烦吧？”我说。”烦？做家务是令人心烦，不过，你从来没使我感到心烦过。　　“I didn’t believe her, so I pressed.”Surely children are not as stimulating21 as a career.”　　我不相信这是实话，于是我又想法子套她的话。”看孩子哪会像工作那样富有刺激性呢？”　　“A career is stimulating,” she said.” I’m glad I had one. But a career is like an open balloon. It remains22 inflated23 only as long as you keep pumping. A child is a seed. You water it. You care for it the best you can. And then it grows all by itself into a beautiful flower.”　　“工作是富有刺激性的，”母亲答道，”很高兴我也有过工作。可是工作好比开了口的气球，你只有不停地充气，它才能鼓着劲。可是一个孩子就是一粒种子，你浇灌了它，全心全意地爱护它，然后，它就会独立自主地开出美丽的花朵来。”　　Just then, looking at her, I could picture us sitting at her kitchen table once again, and I understood why I kept that flaky brown dandelion in our old family dictionary pressed between two crumpled24 bits of paper towel.　　此时此刻，我凝望着我的母亲，脑海里又浮现出儿时的我和母亲一起坐在饭桌旁的情景，也明白了为什么我还珍藏着夹在我们家里那本旧字典中的那朵用两小块皱皱巴巴的纸巾压平的蒲公英。\nIt was 1) a lovely spring day. Under the huge elm trees, we could see 2), yellow dandelions in the grass. My mother 3)_ pulled up dandelions by their roots and said that she was going to 4) dig up all these weeds. 15)_ protested_ and said that even dandelions are beautiful. My mother looked at me 6)_ seriously confirming that every flower 7) gives pleasure in its own way, and so do people. She added that not everyone can be a princess, but there is 8). no shame in that. 9)_ Relieved that she had guessed my pain, I 10)_ started tocry as I told her what had happened. She listened and smiled 11). reassuringly She told me that the narrator’s part is as important as the part of a princess and 12). encouraged me to be a beautiful narrator. I learned to 13) take pride in the role.It was 1) a lovely spring day. Under the huge elm trees, we could see 2), yellow dandelions in the grass. My mother 3) pulled up dandelions by their roots and said that she was going to 4) dig up all these weeds. 15)_ protested_ and said that even dandelions are beautiful. My mother looked at me 6)_ seriously confirming that every flower 7) gives pleasure in its own way, and so do people. She added that not everyone can be a princess, but there is 8). no shame in that. 9)_ Relieved that she had guessed my pain, I 10)_ started tocry as I told her what had happened. She listened and smiled 11). reassuringly She told me that the narrator’s part is as important as the part of a princess and 12). encouraged me to be a beautiful narrator. I learned to 13) take pride in the role.\n1 How do we live a better life? Most people have this question on their mind . 2 My father, takes a week off every year to travel with uS. 3 For college students, the ability of solving problems is_ every bit as_ important as the knowledge they learn in class. 4 The pianist says he _ is grateful_ to his parents for . their encouragement and support. 5 It’s no secret that many children would be happier with their adoptive parents (养父母). That is especially_ true of children who are badly treated by their biological parents. 6 At first they didn’t want to join uS for dinner, but we finally_ won them over 7 The yard was bathed in bright sunshine where my mother grew various kinds of vegetables. 8 When I look back on my childhood, I can barely remember what I did or liked or watched.\n1 Most people would prefer to be cared_ for at home rather than in a hospital. 2 | can well remember how proud I was when my mother was asked to_ deliver_ . a speech at a parent-teacher conference. 3 My parents are now so accustomed to Android (安卓操作系统) that they don’t want to switch_ to iPhone. 4 Excited at his success, I told my cousin that I would treat him to dinner and he could name the restaurant. 5 My mother is quite forgetful. | have to_ remind her of her promise. 6 Parents_ protested_ against the school’s decision to cut down music lessons. 7 My parents take pride in my accomplishments, which are stepping stones to my dreams. 8 As he grew up, his parents were gradually_ relieved of the burden of planning for his future.When the author treats her mother to a lunch, she 1)， remembers again her childhood lunchtimes with her mother. After her birth, her mother 2)_ quit her job and stayed home, taking care of her. Her mother would spend almost every lunch hour with her throughout her elementary school years. She had never 3). guestioned that and took everything for granted. When she grew up, she thought she mattered less than a(n) 4), stimulating career to her mother, but she was wrong. In fact, her mother enjoyed their time together because a child is like a(n) 5) seed_ which grows all by itself into a beautiful flower as long as one cares for it. The pressed dandelion in the family dictionary 6)_ reminds her of the most unforgettable lunchtime with her mother. Being told that she had to 7)_ switch_ roles in a school play, she felt quite uneasy. During the walk in the yard, her mother made her realize everybody has their own existence value just as all flowers give 8) pleasure_ in their own ways. With her mother’s constant 9) encouragement, she learned to take pride in the role and spent the lunchtimes reading over her lines and talking about what she would wear. Her mother’s company during lunchtimes and the dandelion her mother gave her on the night of the performance 10)_ meanmuch to her.\nexplore2In the faint light of the attic, an old man, tall and stooped, bent his great frame and made his way to a stack of boxes that sat near one of the little half-windows. Brushing aside a bit of a spider ‘s web, he pointed the top box toward the light and began to carefully lift out one old photograph album after another. Eyes once bright but now dim searched longingly for the source that had drawn him here. It began with the fond memory of the love of his life, long gone, and somewhere in these albums was a photo of her he hoped to rediscover. Silent as a mouse, he patiently opened the long buried treasures and soon was lost in a sea of memories. Although his world had not stopped spinning when his wife left it, the past was more alive in his heart than his present aloneness. Setting aside one of the dusty albums, he pulled from the box what appeared to be a journal from his grown son’s childhood. He could not recall ever having seen it before, or that his son had ever kept a journal. Why did Elizabeth always save the children’s old junk? He wondered, shaking his white head.Opening the yellowed pages, he glanced over a short reading, and his lips curved in an unconscious smile. Even his eyes brightened as he read the words that spoke clear and sweet to his soul. It was the voice of the little boy who had grown up far too fast in this very house, and whose voice had grown fainter and fainter over the years. In the utter silence of the attic, the words of an innocent six-year-old worked their magic and carried the old man back to a time almost totally forgotten. Entry after entry stirred an emotional hunger in his heart like the longing a gardener feels in the winter for the fragrance of spring flowers. But it was accompanied by the fact that his son’s simple memories of those days were far different from his own. But how different? Reminded that he had kept a daily journal of his business activities over the years, he closed his son’s journal and turned to leave, having forgotten the cherished photo that originally triggered his search. Trying to avoid bumping his head, the old man stepped to the wooden stairs that led to the study. Opening a glass cabinet door, he reached in and pulled out an old business journal. Turning, he sat down at his desk and placed the two journals beside each other. His was leather-bound with his name printed neatly in gold, while his son’s had not been well kept and the name Jimmy had been nearly erased from its surface. He ran a long skinny finger over the letters, as though he could restore what had been worn away with time and use.As he opened his journal, the old man’s eyes fell upon a passage that stood out because it was so brief in comparison to other days’. In his own neat handwriting were these words: Wasted the whole day fishing with Jimmy. Didn’t catch a thing. With a deep sigh and a shaking hand, he took Jimmy’s journal and found the boy’s entry for the same day, June 4. Large letters, pressed deeply into the paper, read: Went fishing with my dad. Best day of my life.\n1 Her grandmother was always insisting that she was tooskinny and was never tiredof trying to force more food on her.2 They switched off all lights and waited for their lttle sister in thefaint___ light ofcandles, hoping to give her a birthday surprise.3 When they were talking about the education of children, his remarks on strict disciplinetriggered_ heated debate.4 Thanks to the _ emotional support from my family, I finally went through the tough timein my freshman year.5 Show your care to people youcherish__ most and let them feel they are important inyour life.6 He seemed so young and__ innocent_ that no one expected he’d have done things like that.\n1 Though upsetting events happened to the family_ one by one_, the family became closer than ever. 2 Water, if it drops continually, will make a stone disappear; this is true of our mind and efforts in front of difficulties. 3 The boy walked slowly to the door to go out, trying not to be noticed by his mother. 4 Feeling tired, he put his pen to one side and read over what he had written. 5 The children went together with their parents and teachers on their field trip on the Children’s Day. 6 She looks very short compared with other children of the same age.1 | had to bury myself in a stack of textbooks before the final exams, while my mother would always get me a glass of milk when I was tred. 2 We parked beneath a clump of trees a hundred meters away from the entrance of the museum. 3 He always brought with him a bunch of flowers for his mother when he came home. 4 In fact, without a clear searching target, you might be drown in a sea of information when surfing online. 5 The couple have an album of stamps from all over the world which make them remember their traveling in their early years. 6 Start budgeting and saving to repay student loans so you won’t face a mountain of debts for years.\n翻译家庭对中国人来说极其重要;随着时代的发展，中国人的家庭观念也在发生着变化。\nThe family is of crucial importance to Chinese people. As time goes on,Chinese people’s attachment to the family has been changing.\n在中国，一个人孝顺自己的父母长辈,不仅仅是个人的道德行为,也是对社会承担的- -份责任。(filial piety; commitment)\nIn China, practicing filial piety toward parents and elders is not only apersonal moral behavior, but also a commitment to society.\n中国人在情感表达方面比较含蓄，但这并不代表我们不真挚，不热烈。(implicit; sincere;enthusiastic)\nChinese people are relatively implicit in expressing their emotions, but thisdoesn’t mean that we are not sincere or enthusiastic.\n年夜饭是中国人重要的情感寄托，吸引着世界各地的中国人回家庆祝春节。(reunion dinner;bear; from all corners)\nThe reunion dinner, important for bearing the emotions of Chinese people,draws them from all corners of the world to return home and celebrate theSpring Festival.\nUnit 7Explore 1Chinese Technology\nWhen I moved to China in 2004,I took a short trip to Zhaoxian County in Hebei Province to see a bridge.A bridge?Yes.This was not just any bridge.It was the Zhaozhou Bridge,completed in AD 605,the earliest and best-preserved open-spandrel stone arch bridge in the world.In 1991,it was designated as the International Historic Civil Engineering Landmark,equally famous as the Eiffel Tower in Paris,the Panama Canal in Central America,and the Pyramids in Egypt.\nThis experience helped shape my view of China as innovative.It informed my work over the next dozen years as a teacher and consultant working with private companies,state-owned enterprises,universities and government agencies.\nAt college,I became familiar with China’s four great inventions:gunpowder,papermaking,printing and the compass.The inventions,in the words of the English philosopher Roger Bacon,changed the whole appearance and status of things in the world.For most Westerners,this is all we learned about China’s technological achievements.But,if we dig a little deeper,we will uncover a rich tradition of technological innovation.We learn that China’s global firsts include paper currency,oil wells,and even the explanation of the camera obscura.The list goes on and on.China was ahead of the time in some fields until the early years of the Qing Dynasty.Chinese discoveries and innovations contributed to the economic development of Asia and Europe.\nThe rise of modern China’s technological achievements should not come as a surprise to anyone.It is built on a long history of innovation.Indeed,its achievements have captured global attention.For example,China’s progress in clean technology drew praise from Steven Chu,former Secretary of the US Department of Energy.He once identified several crucial technologies,mostly in the areas of power generation and transportation,where China is leading.\nHigh voltage transmission\nChina has deployed the world’s first-class ultra-high voltage AC and DC lines—including one capable of delivering 6.4 gigawatt to Shanghai from a plant over 1,900 kilometers away in southwestern China.\nHigh-speed rail\nChina’s high-speed railways have witnessed significant development in recent years.Its highspeed railway technology has reached the world’s advanced level and has been exported to other countries.China also has the world’s greatest high-speed network—22,000 kilometers at the end of 2016,or about 60 percent of the world’s total.\nAdvanced coal technologies\nChina is rapidly deploying supercritical and ultra-supercritical coal combustion plants,which have fewer emissions and are more efficient than conventional coal plants because they burn coal at much higher temperatures and pressures.\nEnergy-saving and new-energy vehicles\nChina has invested a lot in fuel economy,hybrids,and electric and fuel cell vehicles.It’s expected that at least one in every five cars sold in China will be a new-energy model by 2025.\nSupercomputing\nChina’s Sunway TaihuLight,developed by the Chinese National Research Center of Parallel Computer Engineering&amp;Technology,is the world’s fastest supercomputer,according to the TOP500 list of supercomputers released in November 2017.The Sunway TaihuLight was built entirely using processors designed and made in China.\nLikewise,China’s ambitious space program has been progressing at a rapid pace.China has given the world a first glimpse of its design for the space probe and rover which the country plans to use in its first mission to Mars in mid-2020.On August 16,2016,China launched a potentially groundbreaking quantum-enabled satellite,testing new communications technology.In early August 2016,its Jade Rabbit lunar rover shut down after operating on the Moon for 31 months.\nWhere will China go from here?How will the rapid growth of technological innovations be developed and applied?Since 2014,China has been promoting mass entrepreneurship and innovation to cultivate grass-roots entrepreneurship throughout the country.According to the government,science and technology will contribute to 60 percent of the country’s economic growth in the near future.\nIn addition to the top-down goal to upgrade its innovation capacity in order to stay competitive,China’s innovation drive is also being led by bottom-up factors such as the rise of Chinese entrepreneurs who are disrupting traditional industries.Technological influences are helping China leapfrog its innovation process.\nIn my own work with private companies,state-owned enterprises,and government agencies,I have witnessed remarkable changes in the way technology is developed and applied to meet real world challenges.Particularly of importance has been the growing cooperation between private entrepreneurs and the government.From my experience,I am optimistic that China will achieve much in more technologies and that the development of grass-roots entrepreneurship will be successful.\nTo encourage innovation, China 1) has been developing (develop) indigenous (本土的) technicalstandards. One example is the TD-SCDMA, the 3G standard. China initially 2)launched(launch) a national TD-SCDMA network in 2005, but the network only 3) reached(reach)large-scale commercial trials with 60,000 users across eight cities in 2008. On January 7, 2009,China 4)granted (grant) a TD-SCDMA 3G license to China Mobile. China Mobile officially5) announced (announce) on September 21, 2009 that it had had 1 ,327,000 TD-SCDMAusers by the end of August 2009. Critics claim that the standard 6)_ delayed (delay) 3Gintroduction, while supporters argue that it 7)_ increased (increase) technical experience and8)_ enhanced_ (enhance) China’s competitiveness regarding 4G.\n1 A space engineer says we shouldpreserve_ the satellites after they finish their missionsin the same way we__ preserveships, aircraft and trains in museums.2 He works as a(n) _ consultant for Chinese and foreign institutions and gives advice onenvironmental protection.3 China’s space industry has witnessed rapid progress since 2011.4 Jiaozi (交子) first appeared in the Northern Song Dynasty and is the earliest papercurrency in the world.5 If the cost of developing a technology is high, a more efficient way is to buy thetechnology abroad.6As China’s transport and industrial capacities have beenupgraded , China’s directexports and imports have tended to increase more rapidly.7Our products adopt advanced security measures; . _ likewise , our services protect banks’customers from identity theft.8 To make products creative, Steve Jobs encouraged and_ cultivated creativity of his staffin the company.\n1 Future generations will probably be able to atrip around the Earth in private spacecraft. 2 China is developing an advanced new spaceship_ capable_ of both flying in low-Earth orbit and landing on the Moon. 3 Taking into account the creativity and diligence of the Chinese, China’s remarkable development does not come as a surprise. 4 For the next few years, the satellite will travel further in the space and dig_ deeper to find its beauty. 5 China, as is widely recognized, has made great progress in science and technology. 6 This new product will help those who suffer from sleeplessness and view__ sleep as a luxury. 7 People are moving into urban centers at a record pace in search of high-paying jobs.\n1 Thousands of people had gathered along the road, hoping to catch L have L get a glimpse of their heroes. 2 To protect their living environment, the local people opposed the plan to construct one more coal-fired power plant that would undoubtedly bring air pollution. No one can foretell the result of an innovation, but the successful innovation aims from the beginning to become the standard setter, and to determine the direction of a new technology or a new industry. 4 The research group put forward a plan to the board of the company, intending to improve their efficiency of production in the following five years. 5 Product innovation involves the development of new products, changes in design of established products, or use of new materials in the production of established products. 6 He talked about his ambitious goal, but failed to mention any serious steps his company would take to reach L pursue the goal .\nThe four great inventions of ancient China refer to papermaking, gunpowder, printing and the compass. The statement was first 1) put forward by British sinologist (汉学家) Dr. Joseph Edkins and was later widely accepted by Chinese historians. These inventions enormously 2)_ promoted_ the development of China’s economy, politics and culture. The four inventions were introduced to the Western countries through various channels. They changed the appearance and 3)_ status_ of the things in the world. Would the explorer Marco Polo have 4)_ sailed across the ocean in the 13th century without a compass? Most Westerners are familiar 5) with the four inventions. In fact, if people dig a ittle deeper, they will 6)_ uncover a long list of China’s technological achievements, including the first paper currency in the world. That means China was 7) ahead of the time in science and technology in many areas, and that Chinese discoveries and innovations 8) contributed much to the development of world civilization. Today the world has 9) _ witnessed_ China’s greater advances in technology, mostly in the areas of power generation and transportation. It’s safe to say that China’s steady development into an industrial nation does not come as a(n) 10) surprise\nExplore 2We were first introduced to the idea ofvirtual reality (VR) in the 1999 sci-fi film, TheMatrix. In the multimillion-dollar film series,Keanu Reeves’ character, Neo, found himselfliving between two worlds and fighting badguys, generally making the whole concept ofVR seem pretty cool.Entertaining, yes. But realistic?While the 1990s version of VR we werepromised in films like The Matrix and Thelawnmower Man might remain firmly on thesilver screen, VR is the future.And it’s something we need to pay attentionto. As we see, VR isn’t going away. Theclearest sign that VR is the future came inJuly 2014 when Facebook bought OculusVR for a cool $2 billion. VR is growing, andbecoming more accessible by the day. Soon,itll be as commonplace as an iPhone.\nHere are just a few predictions for how VR will change our lives.GamingAs we’ve already touched on the Oculus Rift headset, it makes sense to start withgaming. After all, this is the most obvious - and demonstrated - example of VR in action.Facebook wouldn’t have acquired Oculus had it not seen the potential in VR, anothersign that it’s only going to get bigger.Even before it has gone mainstream, Oculus already supports a vast number of games.And this list is growing all the time. Sony and Samsung are also releasing similar VRheadsets, and the increased competition will force designers to make their games andexperiences more intense, immersive and impressive.Watching films3D films are nothing new, but they’ re not really as exciting and three-dimensional asthe audience were expecting. Just imagine how much the film experience could beenhanced when we throw VR into the mix.We’d be in control of the movie world. We can look around as we want, see the action fromdifferent angles, and choose where to give our full attention. This is all still theoretical atthe moment, but it really could change the way we watch films in the future.\nSeeing the worldWe all get a desire to travel every now and again, but money, responsibilities and dailylife all get in the way of us hopping on a plane and jetting off to sunnier climates.VR could help us see the world, without leaving our living rooms. We could tourmuseums and monuments remotely, take in some amazing scenery, and even just relaxon a “beach” - all without a passport.SurgeryThis is one area where VR is already being used, as it’s safer for trainee surgeons toperfect their techniques in a realistic environment. Fully interactive models can sufferfrom a selection of ailments, and surgeons can learn new techniques and trainees canput theory into practice without an unrealistic plastic model, or the pressure of a real-life situation.Space explorationSpace travel is expensive, not to mention nearly impossible for Joe Bloggs. The chancesof heading off into space are pretty slim even if you’re an astronaut. But VR makes thisexpensive - and sometimes dangerous - exploration, much easier.Scientists can safely explore from ground control, heading out much deeper into spacethan would be humanly possible otherwise. It’s a really exciting way VR could changeour lives.\nTraining and developmentPilots already use flight simulators but, like surgeons, could seriously benefit fromsomething a lot more realistic to help perfect their skills. There are already a wholehost of games where we can develop our skills, but even real pilots could benefit fromthe level of immersion virtual reality has to offer.Improving quality of life Lastly - but by no means least - virtual reality has the potential to transform the livesof those who aren’t capable of living a normal life. It gives them the opportunity toexplore and experience the world - even to do things we take for granted - and that’sthe biggest thing VR has to offer.The possibilities really are endless where virtual reality is concerned. It really doeshave the potential to change our lives and the world we live in. Time will tell whatkind of impact VR has, but one thing’s for sure - there’s so much more to virtual realitythan gaming.\n1 With the DSLR camera (数码单反相机) becoming more and more popular, its video functionhas really broken into the_ mainstream2 Smartphone apps can be brilliant, but | don’t think it___ realistic__ to expect the apps tosolve all our problems.3 As games blend our real and___ virtual_environments, should there be concern thatsome people will be less able to distinguish between the two?4 VR technology allows us to enjoy the___ scenery__ of a place without stepping outof home.5 Facebook is ready to make the application of virtual reality in our lives a(n) commonplace.6 NASA should provide its astronauts with lifetime health care for all ilnesses, even if theirailments_ do not necessarily stem from space.7 Chinese researchers have created a model for the_ prediction_ of cardiovascular (心血管的)disease risk, which will help prevent and manage the disease.8 A___vastnumber of vendors in China use WeChat’s wallet, so even if you buy aroasted sweet potato on the street, you will probably be able to pay with it.\nThough it is a sci-fi movie for children, it is by no means as simple as it may have firstappeared; it runs a strong sense of humor.We should be _ in control of the AI development, reaping its benefits and avoiding itspotential problems.Using technology in the classroom helps teachers satisfy students individually, not to mentionteach them how to find trustworthy sources online.It is said that if airlines saw the benefits of in-flight wi-fi_ in action , they would getplanes equipped faster.For sure__ we can come up with a way for the robot to ask a question when it is notsure of our commands.| resist getting a smartphone because I am afraid it would get in the way of enjoying my life,with all the temptations to waste time in a thousand different ways.\n翻译中国的四大发明，即造纸术、指南针、火药、印刷术，对世界文明的发展产生了巨大影响。( have .an impact on; civilization )\n The four great inventions of China, namely papermaking, the compass,gunpowder and printing, have had a great impact on the development ofthe world civilization.\n高铁给人们带来了极大的便利，也改变着人们的生活方式和工作模式。( pattern )\n High-speed rail has brought much convenience to people, and has alsoaltered people’s lifestyles and work patterns.\n在创新战略的推动下，中国一批具有世界顶尖水平的企业在航天研究、生命科学、金融科技等领域脱颖而出。( world top-level; distinguish )\n Encouraged by the innovation strategy, a number of world top-level Chineseenterprises have distinguished themselves in such fields as space research,life science and financial technologies.\n明代著名医药学家李时珍运用观察和实验、比较和分类、分析和综合的方法，积累了医学研究新经验。( medical expert; classification; synthesis; gather )\nLi Shizhen, the famous medical expert in the Ming Dynasty, adoptedmethods of observation and experiments, comparison and classification, andanalysis and synthesis to gather new experience in medical research.\nUnit 8Explore 1The stereotype of the hard-working Chinese has been around for a long time in theWest. As early as 1894, Arthur Smith, an American who spent 54 years in China, wrotebooks introducing the hard-working Chinese people to the world. In his book ChineseCharacteristics, Smith wrote about the diligence of not just a single group of Chinesepeople, but of all the Chinese: young and old, rich and poor, farmers and scholars.Smith is not the only foreign guest to note that the Chinese are an extremely hard-working people. In 1895, another American in Beiing noted that Chinese people oftenworked from dawn to dusk, seven days a week, tirelessly. Later, in the early 20thcentury, British and American government officials serving in China also commentedthat Chinese people were without rest. Carl Crow, an American newspaperman andbusinessman who opened up the first Western advertising agency in Shanghai, oncesaid:“If it is true that the devil can only find work for idle hands, then China must be aplace of very limited satanic activities.”Chinese literature and folklore have many moral tales about industrious farmers andpeasants. The willingness to work hard and make maximum use of time has beenhighly valued in China since ancient times. There are many stories about farmers whogo to their fields even during holidays, or of peasants who think not only of themselvesand their families, but also of their community and future descendants.The Chinese trait of being unselfish and hard-working continues. Today, unselfishthinking, combined with the willingness to work hard, has given the Chinese a globalreputation of having a stable and industrious workforce. Western employers note thatthe values and beliefs of the Chinese workforce are compelling: The Chinese valueeducation, the virtue of hard work, and self improvement. Whether working in thefields or in the factories, they are willing to do more and go beyond the minimum,\nbecause they assume that their work will benefit them and their families. Because ofthis extended benefit, the Chinese do not complain about working hard.This work ethic is not only for adults. All over China you will find children and youngstudents attending classes outside their regular studies. Students take courses, oftenuntil late at night and during the weekends. Part of these activities may be related tothe intense competition that Chinese students face, but part of them are based upon thedesire to excel academically.Why do Chinese people work so hard, regardless of age or occupation?One answer rests in socialization. Chinese people are socialized differently from召Westerners. They grow up with different values, including a different estimation aboutthe importance of working hard. Hard work is considered a virtue in Chinese culture,as opposed to a necessity in American culture. For youth, Chinese textbooks and socialactivities emphasize this as well.Hard work is also part of the national ethic. The Chinese leadership is committed tobuilding the country into a strong, successful, global nation and the country urges itscitizens to participate in this process. Diligence is part of political awareness. Moreover,this political awareness fits into the economic ethic of Chinese entrepreneurship.\nIn China, an entrepreneur is not just a small-time private business owner. He issomeone who is willing to invest his resources (land, labor, capital) and look towarda long-term goal. The Chinese entrepreneur seeks to improve his life and also thematerial well-being of a group around him - his family, his community, and his nation.True, Chinese entrepreneurs want security. They tend to be conservative and frugal,in opposition to Western risk-takers. They also tend to seek to benefit the group ratherthan themselves alone. This ethic is found not just among businessmen, but in everyoccupation, gender and age. The quest for material gain, a financially secure family,and a peaceful, prosperous nation have been the goals of Chinese people for ages.Today, Chinese culture also has strategies that allow for economic mobility. By diversifyinginvestments and extended study, many Chinese have become not only secure but also verywealthy. Could the Western world learn something from Chinese diligence? CertainlyChina’s current economy reflects cultural values that benefit all people.\na. the truthb. the rainC. cloudsd. friends’ expectationse. enjoying the rainf. spend the afternoon reading and make a pot of teag. damp weather and genuine rainforest\nI’ve got a deep secret few people understand and even fewer will admit to sharing. It’s time totell 1) _ a_ :I love the rain, deeply and more than the sun. At least | live in the rightplace, famous for its 2)_ gGray 3)_ Ccause many people around hereto suffer from emotional disorder. Yet I welcome 4).b_My reason for 5)elies in pure selfishness - when it’s raining outside, | don’t haveto do anything. Ican 6)fMaybe I’ll invite a few friends over to watch an oldmovie or play a board game.7) d (Friends’ expectations) are low and easy to meet.\n1 After graduation, she _ opened up_ a library in the countryside to enrich the local people’scultural life.2 The cultural exchange program will be more effective when combined with lectures andfield trips.3 When he arrived in China, he tried hard to change his habits and customs to___ fit intoChinese culture.4 China is committed to developing a friendly and cooperative relationship with all othercountries in the world.5 The Chinese custom of drinking hot water goes beyond simple preference; hot water isbelieved to lower the body’s temperature and restore the person’s health.6 International students bring differing cultural experiences, expectations, and learning stylesto the classroom thatallow for__ new perspectives to be introduced.7 The real value of this cross-cultural program___ rests in___ teaching our people a realisticatitude toward globalization.\n1 Practicing good corporate social responsibility (企业社会责任) can usuallyqivea company a good_ reputation_.2The Chinese. highly L greatly value_ social harmony and smoothness ofrelationships within the family.3 To protect consumers’ rights and ensure fair competition , the government iscareful to work out the laws about online shopping.4He informed me of the intense competition between students and howthey work hard to hopefully go to a famous university.5For long, the Chinese people have the/ a reputation of being afraid oflosing face or lian in Chinese.6 Ijust can’t stand people who complain loudly / constantly in public places.\nFor a long time, the Chinese trait of being hard-working has been observed in both Western booksand Chinese literature and folklore. The Chinese were described by some Westerners as beingwithout 1)__ rest. Since ancient times, the Chinese have highly valued the virtue of hardwork and making 2)maximum use of time. Today, Chinese work ethic, the 3)_ belief inhard work, continues to win a global respect. The Chinese never 4)_ complain_ about workinghard. Instead, they think of it as a(n) 5)_ virtue__ which benefits them and their families. Thatis why many Western employers nowadays would 6)preferChinese employees. They makeup a(n) 7) stableand industrious workforce. This work ethic is not only for adults. It is acommon phenomenon that children and young students in China attend classes at night or atweekends. They participate in these activities not only because of the intense competition thatthey face, but also because of their desire to 8)___ excel academically. Chinese 9) diligencehas played a vital role in China’s economic development. Thanks to this trait, many Chinese peoplehave become not only financially secure but also 10)_ wealthy\nExplore 2Whether you live in Cambodia or Scotland,Lithuania or America, you have probably heardof dragons. The Eastern dragon, called long inChina, may seem like a completely differentcreature from the Western dragon. Theirbehavior, their symbolism, and what they meanto society are quite different. The East seems tovalue dragons for their magic and beauty andholds them in high respect. However, it is a quitedifferent case in the West where dragons arehistorically viewed as monsters.\n2 In Chinese culture, the dragon is a symbol of virtue. Unlike Western dragons, orientaldragons are usually seen as kind and benevolent. Dragons have long been a symbol inChinese folklore and art. Temples and shrines have been built to honor them. In fact,the Chinese are sometimes referred to as“the descendants of the dragon.”Through the symbol of the dragon, many Chinese see qualities which they desireand value such as heroism, wisdom and power. The dragon is a protector. Legendhas it that the dragon controls the rain, rivers, lakes and the seas; they can protect theinnocent and give them safety. In real life, the Chinese have the Year of the Dragon. Itis said that anyone born in this year will be healthy, wealthy and wise. Historically, thedragon was associated with the emperor of China and used as a symbol to representimperial power. In order to emphasize the association, emperors wore robes with a dragon design, sat on a throne with carved dragons, and had his palace decorated withdragon of various patterns.Dragon idioms are common in China. Chinese idioms are usually made up of fourChinese characters, called chengyu. Many Westerners are familiar with the movieCrouching Tiger, Hidden Dragon, but do not know that this movie title is an idiommeaning “talents in hiding.’Likewise, the Chinese may include the character for dragon (“龙”) when naminga child. The character appears in the names of two famous movie stars that allWesterners know, Jackie Chan (Chenglong, meaning “becoming a dragon”) and BruceLee (Li Xiaolong, implying a “small dragon”).At special festivals, especially the Dragon Boat Festival, also called DuanwuFestival, dragon boat races play an important part. Typically, these are boatspaddled by a team of up to 20 paddlers with a drummer and a steersman. Theboats are generally with decorative dragon heads and tails. Dragon boat racingis also an important part of celebrations by ethnic Chinese outside China. Forexample, the dragon boat races held annually at Echo Park Lake in Los Angeles,California, are very popular.\nWestern dragons have traditionally been a symbol of evil. A typical Western dragonhas wings and sharp claws, and breathes fire. Many legends describe dragons asgreedy, keeping huge amounts of gold and other precious treasure. Dragons aremonsters to be conquered. They are seen to represent the dark side of humanity,including greed, lust, and violence. The conquest of a dragon represents theelimination of those evil instincts.An important English legend is Saint George and the Dragon, a tale of goodovercoming evil. As the story goes, there lived a dragon in a town and it oftenkilled the townspeople. One day when the king’s daughter was offered to thedragon, Saint George happened to travel here. He killed the dragon and rescuedthe princess.But not all Western dragons are considered monsters. To the west of England in Wales,the Red Dragon has long been a national symbol, and is not regarded as evil. TheWelsh myth tells the story of a red dragon that fought a lengthy battle with his foe andwas victorious. The Red Dragon is now depicted on the Welsh national flag.It can be almost impossible to talk about dragons without being influenced by one’scultural heritage. But, regardless of one’s culture, everyone can appreciate the beautyof the Nine Dragon Screen in Beiing’ s Forbidden City.\nFor Chinese people, the Qingming Festival, also known as the Tomb Sweeping Day, is atime to honor ancestors.In the legend of the White Snake, in order torescueher husband Xu Xian, BaiSuzhen used her powers to flood the temple where he was imprisoned.After the_ conquest of the Xiongnu nomads (游牧民), the Han emperor sent Zhang Qianto travel westward on a mission of peace.At some festivals in China, people hang_ decorative_ lanterns outside their doors.The Zhuang ethnic___ minority is China’s largest minority group with a long historyand glorious culture.As the two most-visited cities by foreign tourists, Bejjing and Shanghai boast rich tourismresources and uniqueoriental_charm.\nAs an auspicious (吉祥的) beast, kylin (麒麟) is heldhigh respect in China andis expected to bring harvest, fortune and longevity.You must have heardthe Great Wall in China. Do you know what it wasoriginally used for?Foreigners may know specific Chinese cultural symbols such as panda and green tea, butmore abstract ones like Chinese philosophies and thearts.This set is made uppaper-cut patterns, showing the customs and clothingcharacteristics of different areas in China.The Yellow River is referredas one of the cradles of Chinese civilization, andthe development of the civilization here is closely related to the agricultural production.Ancient Chinese people associated the lion_braveness and strength, andbelieved that the lion could drive away evil and protect humans and farm animals.\n翻译相传屈原投江后，人们划船前去营救，并向江中投放粽子。这就是端午节赛龙舟、吃粽子的由来。( drown )故宫博物院位于北京市中心的天安门广场北侧，建立在明朝和清朝的皇宫紫禁城的基础之.上。( the Palace Museum; the imperial palace )中国是茶叶的原产国，其喝茶的习惯通过古丝绸之路和其他贸易渠道传播到欧洲和很多其他地区。( the Silk Road; channels of trade )中国人讲究吃。吃不仅仅为解渴充饥，更蕴含着中国人认识事物、理解事物的哲理。( beparticular about; satisfy one’s hunger and thirst )\n","plink":"https://dxsummer.gitee.io/posts/30564382/"},{"title":"Step 3　该如何使用进阶的句子？","date":"2020-06-30T12:26:44.000Z","date_formatted":{"ll":"2020年6月30日","L":"2020/06/30","MM-DD":"06-30"},"updated":"2020-07-29T06:10:01.220Z","content":"Day05虚拟语气虚拟语气用来表示说的话不是事实或者是不可能发生的情况，而是一种愿望、建议、假设。虚拟语气有三种基本类型：与现在事实相反，与过去事实相反，与将来事实相反。\n\n\n与现在事实相反\nIf＋一般过去时，主语would＋原形V\n表示与现在事实相反的假设时，句型为“If＋一般过去时，主语＋should / would / might / could＋原形V”\n要特别注意的是，If句中的动词为过去式，如果所使用的是be动词，一律用were。例如：\nIf I were you, I would accept his suggestions.\n（如果我是你，我就会接受他的建议。）\n\n与过去事实相反\nIf＋过去完成时，主语＋would＋have p.p.（过去分词）\n表示与过去的事实相反的假设时，句型为”If＋had＋p.p., 主语＋should / would / might / could＋have＋p.p.“例如：\nIf you had been here yesterday, you would have seen her.\n（如果你昨天在这里，就能见到他了。）\n\n与未来事实相反\n\n几乎不可能发生→If＋一般过去时( did /were to do)，主语would＋原形V\n基本上与与现在事实相反的虚拟语气句型一样，句型为“If＋一般过去时，主语＋should / would / might / could＋原形V”，一样特别注意If句中的be动词，一律用were。例如：\nIf the sun were to disappear, you would win the jackpot.\n（如果太阳消失不见，那你就会赢得大奖。）→太阳不可能不见，所以你不可能赢得大奖\n\n有“万一“的含意→If＋should＋原形V, 主语＋should＋原形V\n如果与未来事实相反的假设句中，带有“万一”或“可能发生”的含意，那么句型请使用“If＋should＋原形V，主要句子用”should (shall) / would (will) / might(may) / could (can)＋原形V”。例如：\nIf Mike would come tomorrow, I will bring him to the best restaurant I have ever been.\n（如果迈克明天来的话，那我就会带他去我去过最好的餐厅。）→迈克明天可能会来，所以我可能会带他去最好的餐厅\nhave been to去过某地have gone to去了某地（没有回来）\n\n延伸用法，事半功倍！Learning Plus!\n虚拟语气的其他形式：\n省略 if 的虚拟语气句型\n句型1 “ Were＋主语，… ”\nWere I young, I would learn English well.\n（如果我还年轻，我要好好学英语。）\n句型2 “ Had＋主语 P. P. , … ”\nHad you been here earlier, you would have seen him.\n（你要是早点到这儿，你就见到他了。）\n句型3（ Should＋主语＋原形V , … ）\nShould that be true, the contract would be canceled.\n（如果那是真的，合约就该取消。）\n\n表示 “ 但愿 ” 的虚拟语气句型\n常使用“ I wish (that) / If only / Would that ” 等开头，\na) 后面接were或者动词过去式，以表示“目前无法实现的愿望”。\nb) 后面接过去完成时，表示“过去不能实现的愿望”。\nI wish that I didn’t have to go to work today.（我今天要能不上班就好了。）\n→目前无法实现的愿望\nWould that she could see her son now!\n（要是她现在能看到她的儿子就好了！）→目前无法实现的愿望\nIf only I knew her address.（我当时要是知道她的地址就好了。）\n→过去无法实现的愿望\nI wish I hadn’t said that.（真希望我当时没有说那些。）\n→过去无法实现的愿望\n\n语法观念例句示范01．If you should happen to see him, please give him my regards.\n如果你万一见到他，请代我向他致敬。\n\n02．If the sun were to disappear, what would the earth be like?\n万一太阳消失了，地球会变成什么样呢？\nwere to do和should do则只表示与将来事实相反，不用来表示和现在事实相反。\nWhat would    将会……样\n\n03．If I were free now, I might to call on him.\n如果我有时间，我可能去看他了。\n\n04．If you were in my shoes, what would you do?\n如果你站在我的立场，你会怎么做？\n\n05．If only she came here earlier.\n如果她当时可以早点来就好了。\n\n06．I could have finished the task if I had had more time.\n如果当时我有多一点时间，我就能完成这项任务。\n\n07．Had he not apologized to her, she would not have forgiven him.\n要不是他道歉，她那时是不会原谅他的。\n\n08．If I had worked hard when young, I would be well off now.\n如果我年轻时多努力一点，现在就能过得舒服些。\n语法观念辨析练习请选出正确的选项。\n01．He described the town as if he________it himself.\nA had seen\nB has seen\nC saw\nD sees\n02．He’s working hard for fear that he________.\nA should fall behind\nB fell behind\nC may fall behind\nD would fall behind\n03．Your advice that________till next week is reasonable.\nA she waits\nB she wait\nC wait she\nD she waited\n04．I’d rather you________anything about it for the time being.\nA do\nB didn’t do\nC don’t\nD didn’t\n05．He was very busy yesterday, otherwise he________to the meeting.\nA would come\nB came\nC would have come\nD had come\n06．If you had told me this information, I________some suggestions for you.\nA might make\nB would made\nC might have made\nD hade made\n07．I hadn’t expected James to apologize but I had hoped________.\nA him calling me\nB that he would call me\nC him to call me\nD that he call me\n08．It’s high time they________this road.\nA mend\nB mended\nC must have mended\nD will mend\n正确答案及题目译文：\n\nDay06被动语态\n英语中有两种语态：主动语态和被动语态。主动语态表示主语是动作的执行者。被动语态表示主语是动作的承受者，即行为动作的物件。\n被动语态的构成及物动词→would be+p.p.\n 英语语法中仅有及物动词有被动形式。其句型结构为“be＋及物动词（或短语）的过去分词”。另外，被动语态可以使用于各种时态，例如：\n 现在式：My mother is not easily deceived.（我妈妈不是容易上当受骗的。）\n 现在式：A new house was built in this town.（有一栋新房子盖在这个城市里。）\n 一般将来时：She will be successed to win this case.（这个案子她将会胜诉。）\n 一般过去将来时：Somebody said that this museum would be built in 5 months.（有人说这栋博物馆五个月内可以盖完。）\n 过去进行时：All the injured visitors were being taken care of by the nurses.（所有受伤的游客都有护士在照顾着。）\n 现在进行时：This subject is being discussed by all the department directors in company now.（所有的公司部门主管都在讨论这个话题。）\n\n“be”动词用于现在进行时表示说话者认为是短暂的、和平常不一样的、甚至是伪装的。He is being foolish. 他在装傻。He is being honest. 他表现得特别老实。She is being rude. 她故意表现粗鲁。I can’t understand why he is being so selfish.我不明白此时他为何如此自私。适合于此种用法的有：foolish愚蠢的，nice好的，kind好心的，careful细心的，patient耐心的，lazy懒惰的，silly傻的，rude粗鲁的，polite礼貌的，impolite无礼的等表示人的特性、性格的形容词。(“be”动词用于现在进行时表示人的行为，纯粹表示心理或生理的状态而不带有行动时或主语不是人时，“be”动词不能用于现在进行时)如： \nI am happy.(表语是纯粹的心理状态，不可用am being) 我很快乐。He’s tired.(表语是纯粹的生理状态，不可用is being) 他很疲倦。It’s hot today.(主语不是人，不可用is being) 今天很热。\n\n 现在完成时：The laundry has been done.（衣服已经都洗好了。）\n\n助动词→助动词＋be＋p.p.\n当句中动词为助动词型态时，转变为被动语态的句型结构为“助动词＋be＋p.p.”，例如：\nAll the players could be found in the gym.（所有的选手都可以在体育馆中被找到。）\n\n双宾语→间接宾语变主语，直接主语变保留宾语\n一个句型结构中，若是存在两个宾语，而需将句中的动词改为被动语态时，通常是将间接宾语往前拉作主语，直接宾语变成了保留宾语。如果主动结构中的直接宾语变为被动结构中的主语，这时在间接宾语前要加介词to（可省去）或for（不可省）。例如：\nThe doctor gave me a prescription.\n＝I was given a prescription by the doctor.\n＝A prescription was given to me by the doctor.\n（医生帮我开了一张处方笺。）\nMickey brought me a gift.\n＝I was brought a gift by Mickey.\n＝A gift was brought for me by Mickey.\n（米奇带了一份礼物给我。）\n\n宾语＋宾语补语→主动结构的宾语变成被动结构的主语，宾语补语不变：\n当句型中含有“宾语和宾语补语”的结构时，要转换为被动语态时，只需将主动结构中的宾语变为被动结构中的主语，宾语补语不变。例如：\nI painted all the wall purple.\n＝All the walls are painted purple by me.（所有的墙壁都被漆成紫色）\n\n被动语态的基本用法动作的执行者没必要提出，可被省略时\nThis plan will be finished next week.（这项计划下周就会完成。）\nFather told us that a swimming pool is being built in our town.\n（爸爸告诉我们镇上正在建造一座游泳池。）\n\n出于礼貌或婉转希望省略执行者时\nJohnny was considered to be a natural leader.\n（强尼被认为是一个天生的领导者。）\nMy brother is said to be a super star in the future.\n（有人说我弟弟日后会成为一个大明星。）\n\n强调动作的承受者时\nAll the desks are cleaned by me this morning.\n（所有的桌子我今天早上都打扫过了。）\nSome of the people in your office are asked to speak with lower voice.\n（你们办公室有些人被要求说话小声一点。）\n\n为了文章通顺\nThe president appeared, and was warmly applauded by the citizens.\n（当总统出现时，市民们给予热烈的掌声。）\n\n正式的通告：\nPassengers are requested to remain seated until the aircraft comes to a complete stop.（飞机停稳前，请乘客不要离开座位。）\n\n语法观念例句示范01．Paper was first made in China.\n纸张首先在中国被制作出来。\n\n02．He was laughed at by all people.\n他被所有人嘲笑。\n\n03．It’s said that this book has been translated into several languages.\n据说这本书被翻译成多种语言。\n\n04．Such questions are settled by us.\n这样的问题被我们解决了。\n\n05．I was frightened by his ghost story.\n我被他的鬼故事吓到了。\n\n06．A new public school will be built up in this town.\n一座新的公立学校将被建在这座城镇里。\n\n07．Plastic bags full of rubbish have been piled in streets.\n人们把装满垃圾的塑料袋堆放在街上。\n\n08．You will be asked a lot of strange questions.\n他们将会问你许多怪问题。\n\n09．It is generally considered impolite to ask one’s age, salary, marriage, etc.\n问别人的年龄、薪水、婚姻状况等通常被认为是不礼貌的。\n\n10．I was given ten minutes to decide whether I should accept the offer.\n我有两分钟来决定是否接受帮助。\n语法观念辨析练习请把下列句子改写成被动语态。\n01．A car knocked him down yesterday.\n\n02．Two doctors and ten nurses make up the medical team.\n\n03．Everybody likes this song.\n\n04．They have sold out all the red lanterns.\n\n05．He made the poor girl work 12 hours a day.\n\n06．Children saw the movie last week.\n\n07．We shouldn’t allow young children to drive.\n\n08．It is thought that he is coming.\n\n09．It is supposed that the ship has been sunk.\n\n10．You mustn’t throw away the old books.\n正确答案及题目译文：\n\n附加问句\n语调附加用句为接在陈述句后的简短问句，用意在加强语意或确认信息内容。\n语调上升→确认讯息→表示发话者不确定信息内容，希望对方给予意见。\n\n   →希望“确认”曼蒂今天“会”过来这里。\n语调下降→强调信息→用于发话者意图强调说明之信息。\n\n   →表示“强调”珊蒂“是”个好女孩。\n否定要缩写附加问句若为否定句（含有not），则通常以缩写形式出现。\nx　Sam is a student, is not he?\no　Sam is a student, isn’t he?\n一致性前后主语需一致\n附加问句的主语需与前面陈述句中的主语一致，且附加问句中的主语需使用与陈述句中相符的人称代名词。\n\n\n前后动词需一致\n附加问句中的时态需与陈述句保持一致。\n陈述句使用be动词，附加问句则使用am / are / is、am not / aren’t / isn’t；\n陈述句使用一般现在时，附加问句则使用do, did, does；\n陈述句使用一般过去时，附加问句则使用did；\n陈述句使用完成时，附加问句则使用have / has、haven’t / hasn’t；\n\n\n\n依目的决定肯定或否定说话者可以依其目的，来决定陈述句为肯定句或否定句。\n肯定（陈述句）＋否定（附加问句）→希望得到肯定答案\nYou love your children, don’t you？你爱你的孩子，不是吗？\nYes, I do．是的，我爱。\n\n否定（陈述句）＋肯定（附加问句）→希望得到否定的答案。\nYour teacher didn’t tell you to cheat, did she?（老师没叫你作弊，对吧？）\nNo, she didn’t.（对的，她没有。）\n\n延伸用法，事半功倍！祈使句\n建议或请求：\nLet’s go to the movies, shall we?（我们一起去看电影，好吗？）\nLet’s not talk about it, all right?（别再谈这件事了，好吗？）\nLet me take a look at this, will you?（让我看看，可以吗？）\nshall we是“我们做某事好吗？”will you是“您允许吗，同意吗？”\nall right (确保对方同意或理解) 如何\n\n命令：\nKeep quiet, will you?（保持安静，好吗？）\n\n邀请：\nHave a seat, won’t you?（坐下来，好吗？）\n\nthere为首的陈述句\nThere are many Japanese restaurants near here, aren’t there?\n（这附近有许多日本餐馆，不是吗？）\n语法观念例句示范01．Steven is the smartest boy in your class, isn’t he?\n史蒂芬是你班上最聪明的男生，对吗？\n\n02．You will not invite him to the party, will you?\n你不会邀请他来派对，对吧？\n\n03．I don’t have to go with you, do I?\n我不必跟你一起去，对吧？\n\n04．Joanna can baby-sit the kids tonight, can’t she?\n乔安娜今晚可以帮忙带小孩，对不对？\n\n05．You have done your homework, haven’t you?\n你们已经把作业做完了，不是吗？\n\n06．Peter was a pilot, wasn’t he?\n彼得曾经是个飞行员，对不对？\n\n07．I am the most beautiful woman in the world, am I not?\n我是世上最美丽的女人，对不对？\n\n08．We must do it by ourselves, mustn’t we?\n我们必须自己做这件事，对吗？\n\n09．Calm down, will you?\n冷静下来，好吗？\n\n10．There isn’t too much water left in the reservoir, is there?\n水库里没有剩下多少水了，是吗？\n语法观念辨析练习请选出题目中附加问句相对应的标准答案。\n01．They hadn’t have chance to talk, had they ?\nA No, they hadn’t.\nB Yes, they did.\n02．You don’t have to work late today, do you ?\nA No, I don’t.\nB Yes, we have.\n03．We have met before, haven’t we ?\nA Yes, we haven’t.\nB Yes, we have.\n04．They didn’t recognize who you are, did they ?\nA No, they didn’t.\nB No, they did.\n05．He will never cheat on me, will he ?\nA No, he won’t.\nB Yes, he won’t.\n06．You are my best friend, aren’t you ?\nA Yes, you are.\nB Yes, I am.\n07．They fell in love with each other at first sight, didn’t they ?\nA Yes, they did.\nB No, they have.\n08．You are invited to Jimmy’s birthday party, aren’t you ?\nA No, I didn’t.\nB Yes, I am.\n09．Mr. and Mrs. Lin have already gone to the airport, haven’t they ?\nA Yes, they have.\nB Yes, they did.\n10．It is a beautiful day, isn’t it ?\nA Yes, it is.\nB Yes, it isn’t.\n正确答案及题目译文：\n\n关系代名词关系代名词是指兼具代名词与连词双重作用的代名词。关系代名词所代表的名词或代名词就做“先行词”，句中该用何种代名词视先行词的种类而定。关系代名词的人称、格、数应该与先行词一致。\n普通关系代名词\n表示人的代名词表示人的关系代名词有who, whom, whose，除了前面有介词的宾格whom之外，who与whom均可用that代替。\n主格→who\n关系代名词who是人的主格，通常后面会直接接一个动作。例如：\n\n\n   （住在公园旁边的那个男孩是我新同学。）\n宾格→whom\n关系代名词whom是人的宾格，通常后面会接主语＋动词，有时会有介词，要视情况而定。例如：\n\n\n   （我不认识你早上在门口遇到的那个人。）\n\n   （和我在教室交谈的那位新同学非常害羞。）\n所有格→whose\n关系代名词whose是人的所有格，通常后面接名词＋动词。\n\n\n   （ 就是那个教授，我这个学期要听他的课。）\n表示物品的代名词表示物的关系代名词有which, whose。其中which可用that代替，但which前面有介词时除外。\n主格→which\n关系代名词which是用来代替没有生命的先行词，如果which后面接的是动词，它就是主格；\n\n\n宾格→which\n如果which后面接的是主语＋动词，它就是宾格。\n\n\n   （我在网上找的那些资讯帮了我很多。）→宾格\n所有格→whose\n关系代名词whose也可以表示物当所有格，whose前面的先行词接事物或动物，后面接名词，可用“of which”代替，但不可用that。\nThe house whose door is red is mine.（门是红色的那栋房子是我的。）\nThe house of which the roof was painted red is my mother’s.（那栋屋顶漆成红色的屋子是我妈妈的。）\n\n表示人和物品的关系代名词－that关系代名词that既可以表示人又可以表示物，可以做主格或宾格，不能为所有格。有些场合关系代名词只能用that，有的场合则不能用that。\n只能用关系代名词that的场合\n先行词同时有人和事物时，例如：\nI know the man and his dog that were dead in the accident.（我认识在事故中失去生命的那个人和他的狗。）\n\n先行词前有限定词，如最高级，序数词，the only, the same, the very, any, no, all, every等。\nThis is the greatest invent that I have ever seen.（这是我见过的最伟大的发明。）\nHe is the first student that goes into the classroom every day.（他是每天第一个到教室的学生。）\nHe is the only student that can answer the question.\n（他是唯一能回答这个问题的学生。）\n\n句首已有疑问词who、which，避免重复。\nWho is the boy that is standing over there?（站在那儿的那个男生是谁？）\n\n不能用关系代名词that的场合介词后面不可使用关系代名词that，例如：\nThis is the house in which he lives.（这是他住的房子。）\n\n逗号后面不可使用关系代名词that，例如：\nMy elder sister, who is in Paris, will come back tomorrow.\n（我那个住在巴黎的姐姐明天就会回来。）→我只有一个姐姐，而且住在巴黎。\n关系代名词与先行词之间有逗号，表示先行词具有唯一性；关系代名词和先行词之间无逗号，表示不止一个。\nMy elder sister who is in Paris will come back tomorrow.（我住在巴黎的姐姐，明天就会回来。）→我不止有一个姐姐，其他姐姐可能在其他地方。\n\n先行词是people, they, those不可使用关系代名词that。例如：\nPeople who can use their time well are happy.（会善用时间的人是快乐的。）\n\n语法观念例句示范01．The toy which belongs to me disappeared.\n那个属于我的玩具不见了。\n\n02．I have a friend whose father is an artist.\n我有一位朋友，他的爸爸是艺术家。\n\n03．The lady whom you talked to is my teacher.\n跟你说话的那位女士是我老师。\n\n04．Amy enjoys the food which her mother cooks.\n艾米喜欢她妈妈做的食物。\n\n05．I like the boy who has short hair.\n我喜欢留短发的那位男孩。\n\n06．The man about whom you were talking is my husband.\n你在谈论的那个人是我的丈夫。\n\n07．The book of which the cover is green is mine.\n那本封面是绿色的书是我的。\n\n08．Take any book that you like.\n碰到喜欢的书，你就带走。\n\n09．He is the first boy that came this morning.\n他是今天早上最先到的男孩。\n\n10．He borrowed a book whose author is a young lady.\n他借的那本书的作者是一位年轻小姐。\n语法观念辨析练习请以适当的关系代名词填入题目空格中。\n01．The kid and his cat________are in the garden are cute.\n02．That is the house in________they live.\n03．Do you know the girl________is crossing the street?\n04．This is the boy________I met at the station yesterday\n05．These are the photographs________I took last month.\n06．I’ve become good friends with several of the people________I met in my English class.\n07．The box________I mailed to my sister was heavy.\n08．The man________answered the phone was polite.\n正确答案及题目译文：\n\nDay07从句（名词从句、形容词从句、副词从句……）\n从句的种类名词从句→可做主语、宾语或补语用\n\n\n形容词从句→用以形容先行词\n\n副词从句→由连词引导的从句。有表示时间、地点、原因等的副词功能。\nAlthough you are young , you still need to show respect to others.\n（就算你还年轻，你还是得尊重别人。）\n\n名词从句的用法以that引导的从句：\n一个完整句子前面加上that使其成为另一个句子的主语、宾语或补语。有以下三种写法。\nthat从句当主语：That he is married is true.（他已婚这件事是真的）\nthat从句当补语：It is true that he is married.\nthat从句当宾语：I found out yesterday that he is married.\n\n以疑问词（who / where / how / when / what）引导的从句：\n通常以动词的宾语形式出现，例如：I’ll tell you where he is.（我会告诉你他在哪里。）→Where is he？作为tell的宾语，以间接问句方式出现。\n\n以if / whether引导的从句：\n也经常以动词的宾语形式出现，例如：\nDo you know if / whether he’s available now?（你知道他现在是否有空吗？）→if / whether… 从句作为know的宾语，以间接问句方式出现。\n\n形容词从句的用法以关系代名词（who / which / that / whom / whose）引导的从句：\nThe woman who is on the phone is my supervisor.（那个讲电话的女人是我的主管。）\n关系代名词who引导出的从句用来修饰前面的名词the woman。\n副词从句的用法以连词引导的具有副词功能的从句：\nWe were shocked when he told us the truth.（当他告诉我们实情时，我们很震惊。）→连词when引导出表示时间的副词从句。\nHe doesn’t like school because he has no friends there.（他因为没有朋友而不喜欢学校。）→连词because引导出表示原因的副词从句。\n语法观念例句示范01．That Jack passed all his exams is unbelievable.\n杰克通过所有的考试真是令人无法相信。\n\n02．I didn’t know that you two are friends.\n我不知道你们两个是朋友。\n\n03．It is exciting that we’re going to have dinner with the super star.\n我们将要和那位巨星共进晚餐，真是令人兴奋。\n\n04．He didn’t tell me whom he will invite to the party.\n他没跟我说会邀请谁来参加派对。\n\n05．I don’t know what you are talking about.\n我不知道你在讲什么。\n\n06．No one cares whether he’s coming or not.\n没人关心他要不要来。\n\n07．The car which he is driving was a gift from his parents.\n他现在开的那辆车是他父母送的礼物。\n语法观念辨析练习依句意填入正确的连词\n（that、which、where、how、what、who、whether、before等）。\n01．____he wants to be a woman terrified his parents.\n02．The man________is talking to Andy is an old friend of mine.\n03．I have no idea________I should believe him or not.\n04．We are all curious to know________Mr. and Mrs. Brown met each other.\n05．The farm________we’re visiting tomorrow is a famous tourist spot here.\n06．It is incredible________a man like him would be the hero of his country.\n07．Please show me the pictures________you took during your trip to London.\n08．You are lucky to find out________he is nothing but a liar before you marry him.\n正确答案及题目译文：\n\n倒装句全部倒装\n英语句子通常有两种语序：一种是自然语序，一种是倒装语序。将谓语的一部分或全部置于主语之前的语序叫做倒装语序。\n句型构成\n将整个谓语提到主语之前。例如：\nYou must on no condition go to Italy alone.\n→On no condition must you go Italy alone.\n（不管怎样你都必须自己去意大利。）\n\n使用时机\n2-1． 以here, there, now, then, out, in, up, down, off, away等方向性副词开头的句子，且句子主语是名词时，句子用完全倒装。例如：\nHere comes the bus.（公共汽车来了。）\n\nTIPS! 但如果主语是代词时，不能用倒装。 例如：Here it is.\n\n2-2． 当表示地点的介词短语放在句首，要倒装。用来强调语气，例如：on the wall, under the tree, in front of the house, in the middle of the room等。\nAt the foot of the hill lies a small river.（山脚下有一条小河。）\n2-3． 主语补语提到句首需用全部倒装。此句型常常是因为主语有较长修饰语，故以倒装呈现。\nAmong the goods are flowers, candies, and toys.（这些商品中有花，糖果，玩具。）\n2-4． 以so, nor, neither开头的句子。以so, nor, neither开头的句子使用倒装，用来表示前句所说的内容也适合另外的人或物。\nHe has been to London, so have I.（他去伦敦了，我也去了。）\n\n部分倒装\n句型构成\n将be动词／使役动词／助动词放在主语之前\nNot until last night did Sammy changed her mind.（直到昨天晚上，珊米才改变了主意。）\n\n使用时机\n2-1． 疑问句：疑问句中，一般须用部分倒装，例如：\nWhat do you think about the movie?（你认为这场电影怎么样？）\n\nTIPS!\n但当对句子的主语提问时，一般不用倒装语序。例如：\nWhat happened last night?\n（昨天晚上发生了什么事？）\n\n2-2． 否定词／半否定词／含有否定意思的短语／频率副词为句首：\n句中若以下列单词或短语为句首时，一般须用部分倒装。\na)否定词，例如：no, none, neither, nor, nobody, nothing, never\n\n","plink":"https://dxsummer.gitee.io/posts/1b9f695a/"},{"title":"Step9 字符串和字符串函数","date":"2020-06-27T06:47:03.000Z","date_formatted":{"ll":"2020年6月27日","L":"2020/06/27","MM-DD":"06-27"},"updated":"2020-07-12T06:09:18.849Z","content":"字符串和字符串函数本章介绍以下内容：\n函数：gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr()\n创建并使用字符串\n使用C库中的字符和字符串函数，并创建自定义的字符串函数\n使用命令行参数\n字符串是C语言中最有用、最重要的数据类型之一。虽然我们一直在使用字符串，但是要学的东西还很多。C 库提供大量的函数用于读写字符串、拷贝字符串、比较字符串、合并字符串、查找字符串等。通过本章的学习，读者将进一步提高自己的编程水平。\n表示字符串和字符串I/O第4章介绍过，字符串是以空字符（\\0）结尾的char类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过，由于字符串十分常用，所以 C提供了许多专门用于处理字符串的函数。本章将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。\n程序清单11.1演示了在程序中表示字符串的几种方式。\n程序清单11.1 strings1.c程序\n1234567891011121314151617//　 strings1.c#include　&lt;stdio.h&gt;#define　MSG　\"I　am　a　symbolic　string　constant.\"#define　MAXLENGTH　81int main(void)&#123;    char　words[MAXLENGTH]　=　\"I　am　a　string　in　an　array.\";    const char *pt1 = \"Something is pointing at me.\";    puts(\"Here　are　some　strings:\");    puts(MSG);    puts(words);    puts(pt1);    words[8]　=　'p';    puts(words);    return 0;&#125;和printf()函数一样，puts()函数也属于stdio.h系列的输入/输出函数。但是，与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。下面是该程序的输出：\n12345Here　are　some　strings:I　am　an　old-fashioned　symbolic　string　constant.I　am　a　string　in　an　array.Something　is　pointing　at　me.I　am　a　spring　in　an　array.我们先分析一下该程序中定义字符串的几种方法，然后再讲解把字符串读入程序涉及的一些操作，最后学习如何输出字符串。\n在程序中定义字符串程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向char的指针）定义字符串。程序应该确保有足够的空间储存字符串，这一点我们稍后讨论。\n字符串字面量（字符串常量）\n 用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\\0字符，都作为字符串储存在内存中，所以&quot;I am a symbolic stringconstant.&quot;、&quot;I am a string in an array.&quot;、&quot;Something is pointed at me.&quot;、&quot;Here are some strings:&quot;都是字符串字面量。\n 从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：\n1char　greeting[50]=\"Hello,　and \"\"how　are\"\"　you\" \"　today!\"; 与下面的代码等价：\n1char greeting[50] = \"Hello, and how are you today!\"; 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\\）：\n1printf(\"\\\"Run, Spot, run!\\\" exclaimed Dick.\\n\"); 输出如下：\n1\"Run, Spot, run!\" exclaimed Dick. 字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。如果确实如此，程序清单11.2中的程序会输出什么？\n 程序清单11.2 strptr.c程序\n12345678/* strptr.c -- 把字符串看作指针 */#include　&lt;stdio.h&gt;int main(void)&#123;    printf(\"%s, %p, %c\\n\", \"We\", \"are\", *\"space farers\");    return 0;&#125; printf()根据%s 转换说明打印 We，根据%p 转换说明打印一个地址。因此，如果”are”代表一个地址，printf()将打印该字符串首字符的地址（如果使用ANSI之前的实现，可能要用%u或%lu代替%p）。最后，*&quot;space farers&quot;表示该字符串所指向地址上储存的值，应该是字符串*&quot;space farers&quot;的首字符。是否真的是这样？下面是该程序的输出：\n1We, 0x100000f61, s\n字符串数组和初始化\n 定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m1：\n1const char m1[40] = \"Limit yourself to one line's worth.\"; const表明不会更改这个字符串。\n 这种形式的初始化比标准的数组初始化形式简单得多：\n1const char m1[40] = &#123; 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l','f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 'n', 'e','\\\",　's',　'　',　'w',　'o',　'r','t',　'h',　'.',　'\\0'&#125;; 注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。\n 在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0），如图11.1所示。\n\n\n通常，让编译器确定数组的大小很方便。回忆一下，省略数组初始化声明中的大小，编译器会自动计算数组的大小：\n\n1const char m2[] = \"If you can't think of anything, fake it.\";\n\n让编译器确定初始化字符数组的大小很合理。因为处理字符串的函数通常都不知道数组的大小，这些函数通过查找字符串末尾的空字符确定字符串在何处结束。\n\n让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式。\n\n12345int n=8;char cookies[1];　　　　// 有效char cakes[2 + 5];\t// 有效，数组大小是整型常量表达式char pies[2*sizeof(long double) + 1]; // 有效char crumbs[n];　　　　 // 在C99标准之前无效，C99标准之后这种数组是变长数组\n\n字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：\n\n1char car[10] = \"Tata\";\n\n那么，以下表达式都为真：\n\n1car == &amp;car[0]、*car == 'T'、*(car+1) == car[1] == 'a'。\n\n还可以使用指针表示法创建字符串。例如，程序清单11.1中使用了下面的声明：\n\n1const char *pt1 = \"Something is pointing at me.\";\n\n该声明和下面的声明几乎相同：\n\n1const char ar1[] = \"Something is pointing at me.\";\n\n以上两个声明表明，`pt1`和`ar1`都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。尽管如此，这两种形式并不完全相同。数组和指针\n 数组形式和指针形式有何不同？以上面的声明为例，数组形式（ar1[]）在计算机的内存中分配为一个内含29个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符&#39;\\0&#39;），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中（第 12 章将详细讲解）。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。\n 此后，编译器便把数组名ar1识别为该数组首元素地址（&amp;ar1[0]）的别名。这里关键要理解，在数组形式中，ar1是地址常量。不能更改ar1，如果改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。\n 指针形式（*pt1）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，++pt1将指向第 2 个字符（o）。\n 字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。\n 总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。程序清单11.3演示了这一点。\n 程序清单11.3 addresses.c程序\n123456789101112131415//　addresses.c　-- 字符串的地址#define　MSG　\"I'm　special\"#include　&lt;stdio.h&gt;int　main()&#123;    char　ar[]　=　MSG;    const char *pt = MSG;    printf(\"address　of　\\\"I'm　special\\\":　%p　\\n\",　\"I'm　special\");    printf(\"　address　ar:　%p\\n\",　ar);    printf(\"　address　pt:　%p\\n\",　pt);    printf(\"　address　of　MSG:　%p\\n\",　MSG);    printf(\"address　of　\\\"I'm　special\\\":　%p　\\n\",　\"I'm　special\");    return　0;&#125; 下面是在我们的系统中运行该程序后的输出：\n12345address　of　\"I'm　special\":　0x100000f10address　ar:　0x7fff5fbff858address　pt:　0x100000f10address　of　MSG:　0x100000f10address　of　\"I'm　special\":　0x100000f10 该程序的输出说明了什么？第一，pt和MSG的地址相同，而ar的地址不同，这与我们前面讨论的内容一致。第二，虽然字符串字面量&quot;I&#39;m special&quot;在程序的两个 printf()函数中出现了两次，但是编译器只使用了一个存储位置，而且与MSG的地址相同。编译器可以把多次使用的相同字面量储存在一处或多处。另一个编译器可能在不同的位置储存3个&quot;I&#39;m special&quot;。第三，静态数据使用的内存与ar使用的动态内存不同。不仅值不同，特定编译器甚至使用不同的位数表示两种内存。\n 数组和指针表示字符串的区别是否很重要？通常不太重要，但是这取决于想用程序做什么。我们来进一步讨论这个主题。\n\n数组和指针的区别\n 初始化字符数组来储存字符串和初始化指针来指向字符串有何区别（“指向字符串”的意思是指向字符串的首字符）？例如，假设有下面两个声明：\n12char heart[] = \"I love Tillie!\";const char *head = \"I love Millie!\"; 两者主要的区别是：数组名heart是常量，而指针名head是变量。那么，实际使用有什么区别？\n 首先，两者都可以使用数组表示法：\n123456for(i　=　0;　i　&lt;　6;　i++)putchar(heart[i]);putchar('\\n');for(i　=　0;　i　&lt;　6;　i++)putchar(head[i]);putchar('\\n'); 上面两段代码的输出是：\n12I　loveI　love 其次，两者都能进行指针加法操作：\n123456for　(i　=　0;　i　&lt;　6;　i++)putchar(*(heart + i));putchar('\\n');for　(i　=　0;　i　&lt;　6;　i++)putchar(*(head + i));putchar('\\n'); 输出如下：\n12I　loveI　love 但是，只有指针表示法可以进行递增操作：\n12while (*(head) != '\\0')　　/* 在字符串末尾处停止*/putchar(*(head++));　　/* 打印字符，指针指向下一个位置 */ 这段代码的输出如下：\n1I love Millie! 假设想让head和heart统一，可以这样做：\n1head = heart;　　 /* head现在指向数组heart */ 这使得head指针指向heart数组的首元素。\n 但是，不能这样做：\n1heart = head;　　 /* 非法构造，不能这样写 */ 这类似于x = 3;和3 = x;的情况。赋值运算符的左侧必须是变量（或概括地说是可修改的左值），如*pt_int。顺带一提，head = heart;不会导致head指向的字符串消失，这样做只是改变了储存在head中的地址。除非已经保存了&quot;I love Millie!&quot;的地址，否则当head指向别处时，就无法再访问该字符串。\n 另外，还可以改变heart数组中元素的信息：\n1heart[7]= 'M';或者 *(heart + 7) = 'M'; 数组的元素是变量（除非数组被声明为const），但是数组名不是变量。\n 我们来看一下未使用const限定符的指针初始化：\n1char *word = \"frame\"; 是否能使用该指针修改这个字符串？\n1word[1] = 'l'; // 是否允许？ 编译器可能允许这样做，但是对当前的C标准而言，这样的行为是未定义的。例如，这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。例如，下面的语句都引用字符串&quot;Klingon&quot;的一个内存位置：\n1234char *p1 = \"Klingon\";p1[0] = 'F'; // ok?printf(\"Klingon\");printf(\": Beware the %ss!\\n\", \"Klingon\"); 也就是说，编译器可以用相同的地址替换每个&quot;Klingon&quot;实例。如果编译器使用这种单次副本表示法，并允许p1[0]修改&#39;F&#39;，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量&quot;Klingon&quot;时实际上显示的是&quot;Flingon&quot;：\n1Flingon: Beware the Flingons! 实际上在过去，一些编译器由于这方面的原因，其行为难以捉摸，而另一些编译器则导致程序异常中断。因此，建议在把指针初始化为字符串字面量时使用const限定符：\n1const char *pl = \"Klingon\";　 // 推荐用法 然而，把非const数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。\n 总之，如果不修改字符串，不要用指针指向字符串字面量。\n\n字符串数组\n 如果创建一个字符数组会很方便，可以通过数组下标访问多个不同的字符串。程序清单11.4演示了两种方法：指向字符串的指针数组和char类型数组的数组。\n 程序清单11.4 arrchar.c程序\n123456789101112131415161718192021222324252627//　arrchar.c -- 指针数组，字符串数组#include　&lt;stdio.h&gt;#define　SLEN　40#define　LIM　5int　main(void)&#123;    const char *mytalents[LIM] = &#123;    \"Adding　numbers　swiftly\",    \"Multiplying　accurately\",　\"Stashing　data\",    \"Following　instructions　to　the　letter\",    \"Understanding　the　C　language\"    &#125;;    char yourtalents[LIM][SLEN]　=　&#123;    \"Walking　in　a　straight　line\",    \"Sleeping\",　\"Watching　television\",    \"Mailing　letters\",　\"Reading　email\"    &#125;;    int i;    puts(\"Let's　compare　talents.\");    printf(\"%-36s　 %-25s\\n\",　\"My　Talents\",　\"Your　Talents\");    for(i　=　0;　i　&lt;　LIM;　i++)    printf(\"%-36s　 %-25s\\n\",　mytalents[i],　yourtalents[i]);    printf(\"\\nsizeof　mytalents:　%zd,　sizeof　yourtalents:　%zd\\n\",    sizeof(mytalents),sizeof(yourtalents));    return　0;&#125; 下面是该程序的输出：\n12345678Let's　compare　talents.My　Talents　　　　　　　　　　　　　　　　　　　　　　　 Your　TalentsAdding　numbers　swiftly　　　　　　　　　　　　　　Walking　in　a　straight　lineMultiplying　accurately　　　　　　　　　　　　　　SleepingStashing　data　　　　　　　　　　　　　　　　　　　　　Watching　televisionFollowing　instructions　to　the　letter　　　Mailing　lettersUnderstanding　the　C　language　　　　　　　　　 Reading　emailsizeof　mytalents:　40,　sizeof　yourtalents:　200 从某些方面来看，mytalents和yourtalents非常相似。两者都代表5个字符串。使用一个下标时都分别表示一个字符串，如mytalents[0]和yourtalents[0]；使用两个下标时都分别表示一个字符，例如 mytalents[1][2]表示 mytalents 数组中第 2 个指针所指向的字符串的第 3 个字符&#39;l&#39;， yourtalents[1][2]表示youttalentes数组的第2个字符串的第3个字符&#39;e&#39;。而且，两者的初始化方式也相同。\n 但是，它们也有区别。mytalents数组是一个内含5个指针的数组，在我们的系统中共占用40字节。而yourtalents是一个内含5个数组的数组，每个数组内含40个char类型的值，共占用200字节。所以，虽然mytalents[0]和yourtalents[0]都分别表示一个字符串，但mytalents和yourtalents的类型并不相同。mytalents中的指针指向初始化时所用的字符串字面量的位置，这些字符串字面量被储存在静态内存中；而 yourtalents 中的数组则储存着字符串字面量的副本，所以每个字符串都被储存了两次。此外，为字符串数组分配内存的使用率较低。yourtalents 中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。\n 我们可以把yourtalents想象成矩形二维数组，每行的长度都是40字节；把mytalents想象成不规则的数组，每行的长度不同。图 11.2 演示了这两种数组的情况（实际上，mytalents 数组的指针元素所指向的字符串不必储存在连续的内存中，图中所示只是为了强调两种数组的不同）。\n\n\n综上所述，如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。mytalents 中的指针指向的字符串字面量不能更改；而yourtalentsde 中的内容可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。\n指针和字符串读者可能已经注意到了，在讨论字符串时或多或少会涉及指针。实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5中的程序。\n程序清单11.5 p_and_s.c程序\n12345678910111213/* p_and_s.c -- 指针和字符串 */#include　&lt;stdio.h&gt;int main(void)&#123;    const char *mesg = \"Don't be a fool!\";    const char *copy;    copy　=　mesg;    printf(\"%s\\n\",copy);    printf(\"mesg　=　%s;　&amp;mesg　=　%p;　value　=　%p\\n\",　mesg,　&amp;mesg,　mesg);    printf(\"copy　=　%s;　&amp;copy　=　%p;　value　=　%p\\n\",　copy,　&amp;copy,　copy);    return 0;&#125;注意\n如果编译器不识别%p，用%u或%lu代替%p。\n你可能认为该程序拷贝了字符串&quot;Don&#39;t be a fool!&quot;，程序的输出似乎也验证了你的猜测：\n123Don't　be　a　fool!mesg　=　Don't　be　a　fool!;　&amp;mesg　=　0x0012ff48;　value　=　0x0040a000copy　=　Don't　be　a　fool!;　&amp;copy　=　0x0012ff44;　value　=　0x0040a000我们来仔细分析最后两个printf()的输出。首先第1项，mesg和copy都以字符串形式输出（%s转换说明）。这里没问题，两个字符串都是&quot;Don&#39;t be a fool!&quot;。\n接着第2项，打印两个指针的地址。如上输出所示，指针mesg和copy分别储存在地址为0x0012ff48和0x0012ff44的内存中。\n注意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。语句copy = mesg;把mesg的值赋给copy，即让copy也指向mesg指向的字符串。\n为什么要这样做？为何不拷贝整个字符串？假设数组有50个元素，考虑一下哪种方法更效率：拷贝一个地址还是拷贝整个数组？通常，程序要完成某项操作只需要知道地址就可以了。如果确实需要拷贝整个数组，可以使用strcpy()或strncpy()函数，本章稍后介绍这两个函数。\n我们已经讨论了如何在程序中定义字符串，接下来看看如何从键盘输入字符串。\n字符串输入如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。\n分配空间要做的第 1 件事是分配空间，以储存稍后读入的字符串。前面提到过，这意味着必须要为字符串分配足够的空间。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间（计算机不会这样做，除非你编写一个处理这些任务的函数）。假设编写了如下代码：\n12char *name;scanf(\"%s\", name);虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。大多数程序员都认为出现这种情况很搞笑，但仅限于评价别人的程序时。\n最简单的方法是，在声明时显式指明数组的大小：\n1char name[81];现在name是一个已分配块（81字节）的地址。还有一种方法是使用C库函数来分配内存，第12章将详细介绍。\n为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的函数：scanf()、gets()和fgets()。我们先讨论最常用gets()函数。\n不幸的gets()函数在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。许多年前，gets()函数就用于处理这种情况。gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。程序清单11.6中演示了这两个函数的用法。\n程序清单11.6 getsputs.c程序\n123456789101112131415/*　getsputs.c　-- 使用 gets() 和 puts() */#include　&lt;stdio.h&gt;#define　STLEN　81int main(void)&#123;    char words[STLEN];    puts(\"Enter　a　string,　please.\");    gets(words);　// 典型用法    printf(\"Your　string　twice:\\n\");    printf(\"%s\\n\",　words);    puts(words);    puts(\"Done.\");    return 0;&#125;下面是该程序在某些编译器（或者至少是旧式编译器）中的运行示例：\n123456Enter　a　string,　please.I　want　to　learn　about　string　theory!Your　string　twice:I　want　to　learn　about　string　theory!I　want　to　learn　about　string　theory!Done.整行输入（除了换行符）都被储存在 words 中，puts(words)和 printf(&quot;%s\\n, words&quot;)的效果相同。\n下面是该程序在另一个编译器中的输出示例：\n1234567Enter　a　string,　please.warning:　this　program　uses　gets(),　which　is　unsafe.Oh,　no!Your　string　twice:Oh,　no!Oh,　no!Done.编译器在输出中插入了一行警告消息。每次运行这个程序，都会显示这行消息。但是，并非所有的编译器都会这样做。其他编译器可能在编译过程中给出警告，但不会引起你的注意。\n这是怎么回事？问题出在 gets()唯一的参数是 words，它无法检查数组是否装得下输入行。上一章介绍过，数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。\n如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止；或者还有其他情况。为了让输入的字符串容易溢出，把程序中的STLEN设置为5，程序的输出如下：\n12345678Enter　a　string,　please.warning:　this　program　uses　gets(),　which　is　unsafe.I　think　I'll　be　just　fine.Your　string　twice:I　think　I'll　be　just　fine.I　think　I'll　be　just　fine.Done.Segmentation　fault:　11“Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的内存。\nC 提供解决某些编程问题的方法可能会导致陷入另一个尴尬棘手的困境。但是，为什么要特别提到gets()函数？因为该函数的不安全行为造成了安全隐患。过去，有些人通过系统编程，利用gets()插入和运行一些破坏系统安全的代码。\n不久，C 编程社区的许多人都建议在编程时摒弃 gets()。制定 C99 标准的委员会把这些建议放入了标准，承认了gets()的问题并建议不要再使用它。尽管如此，在标准中保留gets()也合情合理，因为现有程序中含有大量使用该函数的代码。而且，只要使用得当，它的确是一个很方便的函数。\n好景不长，C11标准委员会采取了更强硬的态度，直接从标准中废除了gets()函数。既然标准已经发布，那么编译器就必须根据标准来调整支持什么，不支持什么。然而在实际应用中，编译器为了能兼容以前的代码，大部分都继续支持gets()函数。不过，我们使用的编译器，可没那么大方。\ngets()的替代品过去通常用fgets()来代替gets()，fgets()函数稍微复杂些，在处理输入方面与gets()略有不同。C11标准新增的gets_s()函数也可代替gets()。该函数与gets()函数更接近，而且可以替换现有代码中的gets()。但是，它是stdio.h输入/输出函数系列中的可选扩展，所以支持C11的编译器也不一定支持它。\n1.fgets()函数（和fputs()）\nfgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。\nfgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。\n如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。\nfgets()函数的第3 个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。\n因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。程序清单11.7演示了fgets()和fputs()函数的用法。\n程序清单11.7 fgets1.c程序\n/*　fgets1.c　– 使用 fgets() 和 fputs() */\n#include　&lt;stdio.h&gt;\n#define　STLEN　14\nint　main(void)\n{\nchar　words[STLEN];\nputs(“Enter　a　string,　please.”);\nfgets(words,　STLEN,　stdin);\nprintf(“Your　string　twice　(puts(),　then　fputs()):\\n”);\nputs(words);\nfputs(words,　stdout);\nputs(“Enter　another　string,　please.”);\nfgets(words,　STLEN,　stdin);\nprintf(“Your　string　twice　(puts(),　then　fputs()):\\n”);\n","thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/c/Step9fengmian.jpg","plink":"https://dxsummer.gitee.io/posts/9e369547/"},{"title":"台儿庄之旅","date":"2020-06-21T15:19:41.000Z","date_formatted":{"ll":"2020年6月21日","L":"2020/06/21","MM-DD":"06-21"},"updated":"2020-06-25T14:06:40.440Z","content":"您好, 这里需要密码.","thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/note/台儿庄.jpg","plink":"https://dxsummer.gitee.io/posts/1dc37cc8/"},{"title":"Step1 Java程序设计概述","date":"2020-06-14T02:35:40.000Z","date_formatted":{"ll":"2020年6月14日","L":"2020/06/14","MM-DD":"06-14"},"updated":"2020-06-14T03:16:20.238Z","content":"Java程序设计平台本书的第1版是这样描写Java的：“作为一种计算机语言，Java的广告词确实有点夸大其辞。然而，Java的确是一种优秀的程序设计语言。作为一个名副其实的程序设计人员，使用Java无疑是一个好的选择。有人认为：Java将有望成为一种最优秀的程序设计语言，但还需要一个相当长的发展时期。一旦一种语言应用于某个领域，与现存代码的相容性问题就摆在了人们的面前。”\n我们的编辑手中有许多这样的广告词。这是Sun公司高层的某位不愿透露姓名的人士提供的（Sun是原先开发Java的公司）。Java有许多非常优秀的语言特性，本章稍后将会详细地讨论这些特性。由于相容性这个严峻的问题确实存在于现实中，所以，或多或少地还是有一些“累赘”被加到语言中，这就导致Java并不如想象中的那么完美无瑕。\n但是，正像我们在第1版中已经指出的那样，Java并不只是一种语言。在此之前出现的那么多种语言也没有能够引起那么大的轰动。Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。\n作为一名程序设计人员，常常希望能够有一种语言，它具有令人赏心悦目的语法和易于理解的语义（C++不是这样的）。与许多其他的优秀语言一样，Java完全满足了这些要求。有些语言提供了可移植性、垃圾收集等，但是，没有提供一个大型的库。如果想要有奇特的绘图功能、网络连接功能和数据库存取功能就必须自己动手编写代码。Java具备所有这些特性，它是一种功能齐全的出色语言，是一个高质量的执行环境，还提供了一个庞大的库。正是因为它集多种优势于一身，所以对广大的程序设计人员有着不可抗拒的吸引力。\nJava“白皮书”的关键术语Java的设计者已经编写了颇有影响力的“白皮书”，用来解释设计的初衷以及完成的情况，并且发布了一个简短的摘要。这个摘要用下面11个关键术语进行组织：\n1）简单性\n2）面向对象\n3）分布式\n4）健壮性\n5）安全性\n6）体系结构中立\n7）可移植性\n8）解释型\n9）高性能\n10）多线程\n11）动态性\n本节将提供一个小结，给出白皮书中相关的说明，这是Java设计者对各个关键术语的论述，另外还会根据我们对Java当前版本的使用经验，给出对这些术语的理解。\n注释：写这本书时，白皮书可以在www.oracle.com/technetwork/java/langenv-140151.html上找到。对于11个关键术语的论述请参看http://horstmann.com/corejava/java-an-overview/7Gosling.pdf。\n简单性人们希望构建一个无须深奥的专业训练就可以进行编程的系统，并且要符合当今的标准惯例。因此，尽管人们发现C++不太适用，但在设计Java的时候还是尽可能地接近C++，以便系统更易于理解。Java剔除了C++中许多很少使用、难以理解、易混淆的特性。在目前看来，这些特性带来的麻烦远远多于其带来的好处。\n的确，Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算（甚至指针语法）、结构、联合、操作符重载、虚基类等（请参阅本书各个章节给出的C++注释，其中比较详细地解释了Java与C++之间的区别）。然而，设计者并没有试图清除C++中所有不适当的特性。例如，switch语句的语法在Java中就没有改变。如果你了解C++就会发现可以轻而易举地转换到Java语法。\nJava发布时，实际上C++并不是最常用的程序设计语言。很多开发人员都在使用Visual Basic和它的拖放式编程环境。这些开发人员并不觉得Java简单。很多年之后Java开发环境才迎头赶上。如今，Java开发环境已经远远超出大多数其他编程语言的开发环境。\n简单的另一个方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。基本的解释器以及类支持大约仅为40KB；再加上基础的标准类库和对线程的支持（基本上是一个自包含的微内核）大约需要增加175KB。\n在当时，这是一个了不起的成就。当然，由于不断的扩展，类库已经相当庞大了。现在有一个独立的具有较小类库的Java微型版（Java Micro Edition），这个版本适用于嵌入式设备。\n面向对象简单地讲，面向对象设计是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。用木匠打一个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象的”木匠首先考虑的是所用的工具。在本质上，Java的面向对象能力与C++是一样的。\n开发Java时面向对象技术已经相当成熟。Java的面向对象特性与C++旗鼓相当。Java与C++的主要不同点在于多重继承，在Java中，取而代之的是更简单的接口概念。与C++相比，Java提供了更丰富的运行时自省功能（有关这部分内容将在第5章中讨论）。\n分布式Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。\n如今，这一点已经得到认可，不过在1995年，主要还是从C++或Visual Basic程序连接Web服务器。\n健壮性Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早期的问题检测、后期动态的（运行时）检测，并消除了容易出错的情况……Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。\nJava编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。至于第二点，对于曾经花费几个小时来检查由于指针bug而引起内存冲突的人来说，一定很喜欢Java的这一特性。\n安全性Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。\n从一开始，Java就设计成能够防范各种攻击，其中包括：\n原先，Java对下载代码的态度是“尽管来吧！”。不可信代码在一个沙箱环境中执行，在这里它不会影响主系统。用户可以确信不会发生不好的事情，因为Java代码不论来自哪里，都不能脱离沙箱。\n不过，Java的安全模型很复杂。Java开发包（Java Development Kit，JDK）的第一版发布之后不久，普林斯顿大学的一些安全专家就发现一些小bug会允许不可信的代码攻击主系统。\n最初，安全bug可以快速修复。遗憾的是，经过一段时间之后，黑客已经很擅长找出安全体系结构实现中的小漏洞。Sun以及之后的Oracle为修复bug度过了一段很是艰难的日子。\n遭遇多次高调攻击之后，浏览器开发商和Oracle都越来越谨慎。Java浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码。\n注释：现在看来，尽管Java安全模型没有原先预想的那么成功，但Java在那个时代确实相当超前。微软提供了一种与之竞争的代码传输机制，其安全性完全依赖于数字签名。显然这是不够的，因为微软自身产品的任何用户都可以证实，知名开发商的程序确实会崩溃并对系统产生危害。\n体系结构中立编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态地翻译成本地机器代码。\n当时，为“虚拟机”生成代码并不是一个新思路。诸如Lisp、Smalltalk和Pascal等编程语言多年前就已经采用了这种技术。\n当然，解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。\nJava虚拟机还有一些其他的优点。它可以检测指令序列的行为，从而增强其安全性。\n可移植性与C和C++不同，Java规范中没有“依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。\n例如，Java中的int永远为32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是int类型的大小不能低于short int，并且不能高于long int。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。\n作为系统组成部分的类库，定义了可移植的接口。例如，有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。\n选择Window类作为例子可能并不太合适。凡是尝试过的人都知道，要编写一个在Windows、Macintosh和10种不同风格的UNIX上看起来都不错的程序有多么困难。Java 1.0就尝试着做了这么一个壮举，发布了一个将常用的用户界面元素映射到不同平台上的简单工具包。遗憾的是，花费了大量的心血，却构建了一个在各个平台上都难以让人接受的库。原先的用户界面工具包已经重写，而且后来又再次重写，不过跨平台的可移植性仍然是个问题。\n不过，除了与用户界面有关的部分外，所有其他Java库都能很好地支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，Java API往往也比原生API质量更高。\n解释型Java解释器可以在任何移植了解释器的机器上执行Java字节码。由于链接是一个增量式且轻量级的过程，所以，开发过程也变得更加快捷，更加具有探索性。\n这看上去很不错。用过Lisp、Smalltalk、Visual Basic、Python、R或Scala的人都知道“快捷而且具有探索性”的开发过程是怎样的。你可以做些尝试，然后就能立即看到结果。Java开发环境并没有将重点放在这种体验上。\n高性能尽管对解释后的字节码性能已经比较满意，但在有些场合下还需要更加高效的性能。字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定CPU的机器码。\n使用Java的头几年，许多用户不同意这样的看法：性能就是“适用性更强”。然而，现在的即时编译器已经非常出色，以至于成了传统编译器的竞争对手。在某些情况下，甚至超越了传统编译器，原因是它们含有更多的可用信息。例如，即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。\n多线程多线程可以带来更好的交互响应和实时行为。\n如今，我们非常关注并发性，因为摩尔定律行将完结。我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。不过，可以看到，大多数编程语言对于这个问题并没有显示出足够的重视。\nJava在当时很超前。它是第一个支持并发程序设计的主流语言。从白皮书中可以看到，它的出发点稍有些不同。当时，多核处理器还很神秘，而Web编程才刚刚起步，处理器要花很长时间等待服务器响应，需要并发程序设计来确保用户界面不会“冻住”。\n并发程序设计绝非易事，不过Java在这方面表现很出色，可以很好地管理这个工作。\n动态性从各种角度看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。\n当需要将某些代码添加到正在运行的程序中时，动态性将是一个非常重要的特性。一个很好的例子是：从Internet下载代码，然后在浏览器上运行。如果使用C或C++，这确实难度很大，不过Java设计者很清楚动态语言可以很容易地实现运行程序的演进。最终，他们将这一特性引入这个主流程序设计语言中。\n注释：Java成功地推出后不久，微软就发布了一个叫做J++的产品，它与Java有几乎相同的编程语言以及虚拟机。现在，微软不再支持J++，取而代之的是另一种名为C#的语言。C#与Java有很多相似之处，然而使用的却是完全不同的虚拟机。本书不准备介绍J++或C#语言。\nJava applet与Internet这里的想法很简单：用户从Internet下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。要使用applet，需要启用Java的Web浏览器执行字节码。不需要安装任何软件。任何时候只要访问包含applet的网页都会得到程序的最新版本。最重要的是，要感谢虚拟机的安全性，它让我们不必再担心来自恶意代码的攻击。\n在网页中插入一个applet就如同在网页中嵌入一幅图片。applet会成为页面的一部分。文本环绕着applet所占据的空间周围。关键的一点是这个图片是活动的。它可以对用户命令做出响应，改变外观，在运行它的计算机与提供它的计算机之间传递数据。\n图1-1展示了一个很好的动态网页的例子。Jmol applet显示了分子结构，这将需要相当复杂的计算。在这个网页中，可以利用鼠标进行旋转，调整焦距等操作，以便更好地理解分子结构。用静态网页就无法实现这种直接的操作，而applet却可以达到此目的（可以在http://jmol.sourceforge.net上找到这个applet）。\n![](https://gitee.com/DxSummer/pic/raw/master/img/java/Jmol applet.png “|block”)\n当applet首次出现时，人们欣喜若狂。许多人相信applet的魅力将会导致Java迅速地流行起来。然而，初期的兴奋很快就淡化了。不同版本的Netscape与Internet Explorer运行不同版本的Java，其中有些早已过时。这种糟糕的情况导致更加难于利用Java的最新版本开发applet。实际上，为了在浏览器中得到动态效果，Adobe的Flash技术变得相当流行。后来，Java遭遇了严重的安全问题，浏览器和Java浏览器插件变得限制越来越多。如今，要在浏览器中使用applet，这不仅需要一定的水平，而且要付出努力。例如，如果访问Jmol网站，可能会看到一个消息，警告你要适当地配置浏览器允许运行applet。\nJava发展简史本节将介绍Java的发展简史。这些内容来自很多出版资料（最重要的是SunWorld的在线杂志1995年7月刊上对Java创建者的专访）。\nJava的历史要追溯到1991年，由Patrick Naughton和James Gosling（一个全能的计算机奇才）带领的Sun公司的工程师小组想要设计一种小型的计算机语言，主要用于像有线电视转换盒这类的消费设备。由于这些消费设备的处理能力和内存都很有限，所以语言必须非常小且能够生成非常紧凑的代码。另外，由于不同的厂商会选择不同的中央处理器（CPU），因此这种语言的关键是不与任何特定的体系结构捆绑在一起。这个项目被命名为“Green”。\n代码短小、紧凑且与平台无关，这些要求促使开发团队设计一个可移植的语言，可以为虚拟机生成中间代码。\n不过，Sun公司的人都有UNIX的应用背景。因此，所开发的语言以C++为基础，而不是Lisp、Smalltalk或Pascal。不过，就像Gosling在专访中谈到的：“毕竟，语言只是实现目标的工具，而不是目标本身”。Gosling把这种语言称为“Oak”（这么起名的原因大概是因为他非常喜欢自己办公室外的橡树）。Sun公司的人后来发现Oak是一种已有的计算机语言的名字，于是，将其改名为Java。事实证明这是一个很有灵感的选择。\n1992年，Green项目发布了它的第一个产品，称之为“*7”。这个产品具有非常智能的远程控制。遗憾的是，Sun公司对生产这个产品并不感兴趣，Green项目组的人员必须找出其他的方法来将他们的技术推向市场。然而，没有一个标准消费品电子公司对此感兴趣。于是，Green项目组竞标了一个提供视频点播等新型服务的有线电视盒的项目，但没有成功（有趣的是，得到这个项目的公司的领导恰恰是开创Netscape公司的Jim Clark。Netscape公司后来对Java的成功给予了很大的帮助）。\nGreen项目（这时换了一个新名字——“First Person公司”）花费了1993年一整年以及1994年的上半年，一直在苦苦寻求其技术的买家。然而，一个也没有找到（Patrick Naughton，项目组的创立人之一，也是完成此项目大多数市场工作的人，声称为了销售这项技术，累计飞行了300000英里）。1994年First Person公司解散了。\n当这一切在Sun公司发生的时候，Internet的万维网也在日渐发展壮大。万维网的关键是把超文本页面转换到屏幕上的浏览器。1994年大多数人都在使用Mosaic，这是一个1993年出自伊利诺斯大学超级计算中心的非商业化的Web浏览器（Mosaic的一部分是由Marc Andreessen编写的。当时，他作为一名参加半工半读项目的本科生，编写了这个软件，每小时的薪水只有6.85美元。他后来成了Netscape公司的创始人之一和技术总监，可谓名利双收）。\n在接受SunWorld采访的时候，Gosling说在1994年中期，Java语言的开发者意识到：“我们能够建立一个相当酷的浏览器。我们已经拥有在客户机/服务器主流模型中所需要的体系结构中立、实时、可靠、安全——这些在工作站环境并不太重要，所以，我们决定开发浏览器。”\n实际的浏览器是由Patrick Naughton和Jonathan Payne开发的，并演变为HotJava浏览器。为了炫耀Java语言超强的能力，HotJava浏览器采用Java编写。设计者让HotJava浏览器具有在网页中执行内嵌代码的能力。这一“技术印证”在1995年5月23日的SunWorld上得到展示，同时引发了人们延续至今的对Java的狂热追逐。\n1996年年初，Sun发布了Java的第1个版本。人们很快地意识到Java1.0不能用来进行真正的应用开发。的确，可以使用Java 1.0来实现在画布上随机跳动的神经质的文本applet，但它却没有提供打印功能。坦率地说，Java 1.0的确没有为其黄金时期的到来做好准备。后来的Java 1.1弥补了其中的大多明显的缺陷，大大改进了反射能力，并为GUI编程增加了新的事件处理模型。不过它仍然具有很大的局限性。\n1998年JavaOne会议的头号新闻是即将发布Java 1.2版。这个版本取代了早期玩具式的GUI，并且它的图形工具箱更加精细而具有可伸缩性，更加接近“一次编写，随处运行”的承诺。在1998年12月Java 1.2发布三天之后，Sun公司市场部将其名称改为更加吸引人的“Java 2标准版软件开发工具箱1.2版”。\n除了“标准版”之外，Sun还推出了两个其他的版本：一个是用于手机等嵌入式设备的“微型版”；另一个是用于服务器端处理的“企业版”。本书主要讲述标准版。标准版的1.3和1.4版本对最初的Java 2版本做出了某些改进，扩展了标准类库，提高系统性能。当然，还修正了一些bug。在此期间，Java applet采用低调姿态，并淡化了客户端的应用，但Java却成为服务器端应用的首选平台。\n5.0版是自1.1版以来第一个对Java语言做出重大改进的版本（这一版本原来被命名为1.5版，在2004年的JavaOne会议之后，版本数字升至5.0）。经历了多年的研究，这个版本添加了泛型类型（generic type）（类似于C++的模板），其挑战性在于添加这一特性并没有对虚拟机做出任何修改。另外，还有几个受C#启发的很有用的语言特性：“for each”循环、自动装箱和注解。\n版本6（没有后缀.0）于2006年年末发布。同样，这个版本没有对语言方面再进行改进。但是，改进了其他性能，并增强了类库。\n随着数据中心越来越依赖于商业硬件而不是专用服务器，Sun Microsystems终于沦陷，于2009年被Oracle收购。Java的开发停滞了很长一段时间。直到2011年Oracle发布了Java的一个新版本，Java 7，其中只做了一些简单的改进。\n2014年，Java 8终于发布，在近20年中这个版本有了最大的改变。Java 8提供了一种“函数式”编程方式，可以很容易地表述并发执行的计算。所有编程语言都必须与时俱进，Java在这方面显示出非凡的能力。\n表1-1展示了Java语言以及类库的发展状况。可以看到，应用程序编程接口（API）的规模发生了惊人的变化。\n\n关于Java的常见误解在结束本章之前，我们列出了一些关于Java的常见误解，同时给出了解释。\n1.Java是HTML的扩展\nJava是一种程序设计语言；HTML是一种描述网页结构的方式。除了用于在网页上放置Java applet的HTML扩展之外，两者没有任何共同之处。\n2.使用XML，所以不需要Java\nJava是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据，而Java API对XML处理提供了很好的支持。此外，许多重要的第三方XML工具采用Java编写。有关这方面更加详细的信息请参看卷Ⅱ。\n3.Java是一种非常容易学习的程序设计语言\n像Java这种功能强大的语言大都不太容易学习。首先，必须将编写玩具式程序的轻松和开发实际项目的艰难区分开来。需要注意的是：本书只用了7章讨论Java语言。在两卷中，其他的章节介绍如何使用Java类库将Java语言应用到实际中去。Java类库包含了数千种类和接口以及数万个函数。幸运的是，并不需要知道它们中的每一个，然而，要想Java解决实际问题，还是需要了解不少内容的。\n4.Java将成为适用于所有平台的通用性编程语言\n从理论上讲，这是完全有可能的。但在实际中，某些领域其他语言有更出色的表现，比如，Objective C和后来的Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。\n5.Java只不过是另外一种程序设计语言\nJava是一种很好的程序设计语言，很多程序设计人员喜欢Java胜过C、C++或C#。有上百种好的程序设计语言没有广泛地流行，而带有明显缺陷的语言，如：C++和Visual Basic却大行其道。\n这是为什么呢？程序设计语言的成功更多地取决于其支撑系统的能力，而不是优美的语法。人们主要关注：是否提供了易于实现某些功能的易用、便捷和标准的库？是否有开发工具提供商能建立强大的编程和调试环境？语言和工具集是否能够与其他计算基础架构整合在一起？Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。例如：联网Web应用和并发。Java减少了指针错误，这是一个额外的好处，因此使用Java编程的效率更高。但这些并不是Java成功的全部原因。\n6.Java是专用的，应该避免使用\n最初创建Java时，Sun为销售者和最终用户提供了免费许可。尽管Sun对Java拥有最终的控制权，不过在语言版本的不断发展和新库的设计过程中还涉及很多其他公司。虚拟机和类库的源代码可以免费获得，不过仅限于查看，而不能修改和再发布。Java是“闭源的，不过可以很好地使用”。\n这种状况在2007年发生了戏剧性的变化，Sun声称Java未来的版本将在General Public License（GPL）下提供。Linux使用的是同一个开放源代码许可。Oracle一直致力于保持Java开源。只有一点美中不足——专利。根据GPL，任何人都可以得到专利许可，允许其使用和修改Java，不过仅限于桌面和服务器平台。如果你想在嵌入式系统中使用Java，就需要另外一个不同的许可，这很可能需要付费。不过，这些专利在未来十年就会到期，那时Java就完全免费了。\n7.Java是解释型的，因此对于关键的应用程序速度太慢了\n早期的Java是解释型的。现在Java虚拟机使用了即时编译器，因此采用Java编写的“热点”代码其运行速度与C++相差无几，有些情况下甚至更快。\n对于Java桌面应用速度慢，人们已经抱怨很多年了。但是，今天的计算机速度远比人们发出抱怨的时候快了很多。一个较慢的Java程序与几年前相当快的C++程序相比还要快一些。\n8.所有的Java程序都是在网页中运行的\n所有的Java applet都是在网页浏览器中运行的。这也恰恰是applet的定义，即一种在浏览器中运行的Java程序。然而，大多数Java程序是运行在Web浏览器之外的独立应用程序。实际上，很多Java程序都在Web服务器上运行并生成用于网页的代码。\n9.Java程序是主要的安全风险\n对于早期的Java，有过关于安全系统失效的报道，曾经一度引起公众哗然。研究人员将这视为一种挑战，即努力找出Java的漏洞，对applet安全模型的强度和复杂度发起挑战。随后，人们很快就解决了引发问题的所有技术因素。后来又发现了更严重的漏洞，而Sun以及后来的Oracle反应却过于迟缓。浏览器制造商则有些反应过度，他们甚至默认禁用了Java。客观地来讲，可以想想针对Windows可执行文件和Word宏有数百万种病毒攻击，并造成了巨大的损害，不过奇怪的是却很少有人批评被攻击平台的脆弱。\n有些系统管理员甚至在公司浏览器中禁用了Java，而同时却允许用户下载可执行文件和Word文档，实际上，这些带来的风险远甚于使用Java。尽管距离Java诞生已经20年之久，与其他常用的执行平台相比，Java还是安全得多。\n10.JavaScript是Java的简易版\nJavaScript是一种在网页中使用的脚本语言，它是由Netscape发明的，原来的名字叫做LiveScript。JavaScript的语法类似Java，除此之外，两者无任何关系。当然，名字有些相像。JavaScript的一个子集已经标准化为ECMA-262。与Java applet相比，JavaScript更紧密地与浏览器集成在一起。特别是JavaScript程序可以修改正在显示的文档，而applet只能在有限的区域内控制外观。\n11.使用Java可以用廉价的Internet设备取代桌面计算机\n当Java刚刚发布的时候，一些人打赌：肯定会有这样的好事情发生。一些公司已经生产出Java网络计算机的原型，不过用户还不打算放弃功能强大而便利的桌面计算机，而去使用没有本地存储而且功能有限的网络设备。当然，如今世界已经发生改变，对于大多数最终用户，常用的平台往往是手机或平板电脑。这些设备大多使用安卓平台，这是Java的衍生产物。学习Java编程肯定也对Android编程很有帮助。\n","plink":"https://dxsummer.gitee.io/posts/1fa13e13/"},{"title":"Step8 数组和指针","date":"2020-06-13T02:39:24.000Z","date_formatted":{"ll":"2020年6月13日","L":"2020/06/13","MM-DD":"06-13"},"updated":"2020-06-27T06:45:37.147Z","content":"本章介绍以下内容：\n关键字：static\n运算符：&amp;、*（一元）\n如何创建并初始化数组\n指针（在已学过的基础上）、指针和数组的关系\n编写处理数组的函数\n二维数组\n人们通常借助计算机完成统计每月的支出、日降雨量、季度销售额等任务。企业借助计算机管理薪资、库存和客户交易记录等。作为程序员，不可避免地要处理大量相关数据。通常，数组能高效便捷地处理这种数据。第 6 章简单地介绍了数组，本章将进一步地学习如何使用数组，着重分析如何编写处理数组的函数。这种函数把模块化编程的优势应用到数组。通过本章的学习，你将明白数组和指针关系密切。\n数组前面介绍过，数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。考虑下面的数组声明：\n123456789/* 一些数组声明*/int main(void)&#123;    float candy[365];　　　 /* 内含365个float类型元素的数组 */    char code[12];　　　　　/*内含12个char类型元素的数组*/    int states[50];　　　　 /*内含50个int类型元素的数组 */    ...&#125;方括号（[]）表明candy、code和states都是数组，方括号中的数字表明数组中的元素个数。\n要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。数组元素的编号从0开始，所以candy[0]表示candy数组的第1个元素，candy[364]表示第365个元素，也就是最后一个元素。读者对这些内容应该比较熟悉，下面我们介绍一些新内容。\n初始化数组数组通常被用来储存程序需要的数据。例如，一个内含12个整数元素的数组可以储存12个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。\n只储存单个值的变量有时也称为标量变量（scalar variable），我们已经很熟悉如何初始化这种变量：\n12int fix　=　1;float flax = PI * 2;代码中的PI已定义为宏。C使用新的语法来初始化数组，如下所示：\n12345int main(void)&#123;    int powers[8] = &#123;1,2,4,6,8,16,32,64&#125;; /* 从ANSI C开始支持这种初始化 */    ...&#125;如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（powers[0]），以此类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关键字static可解决此问题。第12章将详细讨论这个关键字）。\n程序清单10.1演示了一个小程序，打印每个月的天数。\n程序清单10.1 day_mon1.c程序\n123456789101112/* day_mon1.c -- 打印每个月的天数 */#include　&lt;stdio.h&gt;#define　MONTHS　12int　main(void)&#123;    int　days[MONTHS]　=　&#123;　31,　28,　31,　30,　31,　30,　31,　31,　30,　31,　30,　31　&#125;;    int　index;    for　(index　=　0;　index　&lt;　MONTHS;　index++)    \tprintf(\"Month　%2d　has　%2d　days.\\n\",　index　+　1,　days[index]);    return　0;&#125;该程序的输出如下：\n123456789101112Month　1　has　31　days.Month　2　has　28　days.Month　3　has　31　days.Month　4　has　30　days.Month　5　has　31　days.Month　6　has　30　days.Month　7　has　31　days.Month　8　has　31　days.Month　9　has　30　days.Month　10　has　31　days.Month　11　has　30　days.Month　12　has　31　days.这个程序还不够完善，每4年打错一个月份的天数（即，2月份的天数）。该程序用初始化列表初始化days[]，列表（用花括号括起来）中用逗号分隔各值。\n注意该例使用了符号常量 MONTHS 表示数组大小，这是我们推荐且常用的做法。例如，如果要采用一年13个月的记法，只需修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。\n注意 使用const声明数组\n有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。因此，程序清单10.1中初始化数组应改成：\n1const int days[MONTHS] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 const 数据，因为一旦声明为 const，便不能再给它赋值。明确了这一点，就可以在后面的例子中使用const了。\n如果初始化数组失败怎么办？程序清单10.2演示了这种情况。\n程序清单10.2 no_data.c程序\n12345678910111213/* no_data.c -- 为初始化数组 */#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    int no_data[SIZE];　/* 未初始化数组 */    int　i;    printf(\"%2s%14s\\n\",　　　\"i\",　\"no_data[i]\");    for　(i　=　0;　i　&lt;　SIZE;　i++)    \tprintf(\"%2d%14d\\n\",　i,　no_data[i]);    return　0;&#125;该程序的输出如下（系统不同，输出的结果可能不同）：\n12345i　　　no_data[i]0　　　　　　　　　　01　　　　　 42049372　　　　　 42198543　　　2147348480使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。\n注意 存储类别警告\n数组和其他变量类似，可以把数组创建成不同的存储类别（storage class）。第12章将介绍存储类别的相关内容，现在只需记住：本章描述的数组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static。到目前为止，本书所用的变量和数组都是自动存储类别。\n在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不能把本章的内容推广到其他存储类别。对于一些其他存储类别的变量和数组，如果在声明时未初始化，编译器会自动把它们的值设置为0。\n初始化列表中的项数应与数组的大小一致。如果不一致会怎样？我们还是以上一个程序为例，但初始化列表中缺少两个元素，如程序清单10.3所示：\n程序清单10.3 somedata.c程序\n12345678910111213/* some_data.c -- 部分初始化数组 */#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    int some_data[SIZE]　=　&#123;　1492,　1066　&#125;;    int i;    printf(\"%2s%14s\\n\",　　　\"i\",　\"some_data[i]\");    for(i　=　0;　i　&lt;　SIZE;　i++)    \tprintf(\"%2d%14d\\n\",　i,　some_data[i]);    return 0;&#125;下面是该程序的输出：\n12345i　some_data[i]0　　　　　　　14921　　　　　　　10662　　　　　　　　　03　　　　　　　　　0如上所示，编译器做得很好。当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。\n如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会毫不留情地将其视为错误。但是，没必要因此嘲笑编译器。其实，可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数（见程序清单10.4）\n程序清单10.4 day_mon2.c程序\n1234567891011/* day_mon2.c -- 让编译器计算元素个数 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int days[]　=　&#123;　31,　28,　31,　30,　31,　30,　31,　31,　30,　31　&#125;;    int index;    for(index　=　0;　index　&lt;　sizeof　days　/　sizeof　days[0];　index++)    \tprintf(\"Month　%2d　has　%d　days.\\n\",　index　+　1,　days[index]);    return 0;&#125;在程序清单10.4中，要注意以下两点。\n如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。\n注意for循环中的测试条件。由于人工计算容易出错，所以让计算机来计算数组的大小。sizeof运算符给出它的运算对象的大小（以字节为单位）。所以sizeof days是整个数组的大小（以字节为单位），sizeof day[0]是数组中一个元素的大小（以字节为单位）。整个数组的大小除以单个元素的大小就是数组元素的个数。\n下面是该程序的输出：\n12345678910Month　1　has　31　days.Month　2　has　28　days.Month　3　has　31　days.Month　4　has　30　days.Month　5　has　31　days.Month　6　has　30　days.Month　7　has　31　days.Month　8　has　31　days.Month　9　has　30　days.Month　10　has　31　days.我们的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小。我们初始化时用了10个值，结果就只打印了10个值！这就是自动计数的弊端：无法察觉初始化列表中的项数有误。\n还有一种初始化数组的方法，但这种方法仅限于初始化字符数组。我们在下一章中介绍。\n指定初始化器（C99）C99 增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它：\n1int arr[6] = &#123;0,0,0,0,0,212&#125;; // 传统的语法而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：\n1int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。程序清单10.5中的初始化比较复杂。\n程序清单10.5 designate.c程序\n123456789101112// designate.c -- 使用指定初始化器#include　&lt;stdio.h&gt;#define　MONTHS　12int　main(void)&#123;    int days[MONTHS]　=　&#123;　31,　28,　[4]　=　31,　30,　31,　[1]　=　29　&#125;;    int i;    for(i　=　0;　i　&lt;　MONTHS;　i++)    \tprintf(\"%2d　 %d\\n\",　i　+　1,　days[i]);    return 0;&#125;该程序在支持C99的编译器中输出如下：\n1234567891011121　　 312　　 293　　 04　　 05　　 316　　 307　　 318　　 09　　　010　　 011　　 012　　 0以上输出揭示了指定初始化器的两个重要特性。第一，如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：[4] = 31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。也就是说，在days[4]被初始化为31后，days[5]和days[6]将分别被初始化为30和31。第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清单10.5中，初始化列表开始时把days[1]初始化为28，但是days[1]又被后面的指定初始化[1] = 29初始化为29。\n如果未指定元素大小会怎样？\n12int stuff[] = &#123;1, [6] = 23&#125;;　　　　 //会发生什么？int staff[] = &#123;1, [6] = 4, 9, 10&#125;;　//会发生什么？编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为0～6；而staff数组的元素比stuff数组多两个（即有9个元素）。\n给数组元素赋值声明数组后，可以借助数组下标（或索引）给数组元素赋值。例如，下面的程序段给数组的所有元素赋值：\n1234567891011/* 给数组的元素赋值 */#include　&lt;stdio.h&gt;#define　SIZE　50int main(void)&#123;int　counter,　evens[SIZE];for　(counter　=　0;　counter　&lt;　SIZE;　counter++)evens[counter]　=　2　*　counter;...&#125;注意这段代码中使用循环给数组的元素依次赋值。C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。下面的代码段演示了一些错误的赋值形式:\n12345678910/* 一些无效的数组赋值 */#define　SIZE　5int main(void)&#123;int oxen[SIZE] = &#123;5,3,2,8&#125;;　　　　 /* 初始化没问题 */int yaks[SIZE];yaks = oxen;　　　　　　　　　 /* 不允许 */yaks[SIZE] = oxen[SIZE];　　　 /* 数组下标越界 */yaks[SIZE] = &#123;5,3,2,8&#125;;　　　　/* 不起作用 */oxen数组的最后一个元素是oxen[SIZE-1]，所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的末尾。\n数组边界在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明：\n1int doofi[20];那么在使用该数组时，要确保程序中使用的数组下标在0～19的范围内，因为编译器不会检查出这种错误（但是，一些编译器发出警告，然后继续编译程序）。\n考虑程序清单10.6的问题。该程序创建了一个内含4个元素的数组，然后错误地使用了-1～6的下标。\n程序清单10.6 bounds.c程序\n12345678910111213141516171819202122// bounds.c -- 数组下标越界#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    int value1　=　44;    int arr[SIZE];    int value2　=　88;    int i;    printf(\"value1　=　%d,　value2　=　%d\\n\",　value1,　value2);    for(i　=　-1;　i　&lt;=　SIZE;　i++)    \tarr[i] = 2 * i + 1;    for(i　=　-1;　i　&lt;　7;　i++)    \tprintf(\"%2d　%d\\n\",　i,　arr[i]);    printf(\"value1　=　%d,　value2　=　%d\\n\",　value1,　value2);    printf(\"address　of　arr[-1]:　%p\\n\",　&amp;arr[-1]);    printf(\"address　of　arr[4]:　%p\\n\",　&amp;arr[4]);    printf(\"address　of　value1:　%p\\n\",　&amp;value1);    printf(\"address　of　value2:　%p\\n\",　&amp;value2);    return 0;&#125;编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。下面是使用GCC的输出示例：\n1234567891011121314value1　=　44,　value2　=　88-1　-10　11　32　53　74　95　16246784946　32767value1　=　9,　value2　=　-1address　of　arr[-1]:　 0x7fff5fbff8ccaddress　of　arr[4]:　　0x7fff5fbff8e0address　of　value1:　　0x7fff5fbff8e0address　of　value2:　　0x7fff5fbff8cc注意，该编译器似乎把value2储存在数组的前一个位置，把value1储存在数组的后一个位置（其他编译器在内存中储存数据的顺序可能不同）。在上面的输出中，arr[-1]与value2对应的内存地址相同， arr[4]和value1对应的内存地址相同。因此，使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。\nC 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。\n还要记住一点：数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小：\n123456#define　SIZE　4int　main(void)&#123;    int arr[SIZE];    for(i　=　0;　i　&lt;　SIZE;　i++)    \t....这样做能确保整个程序中的数组大小始终一致。\n指定数组的大小本章前面的程序示例都使用整型常量来声明数组：\n123456#define　SIZE　4int　main(void)&#123;    int arr[SIZE];　　　　　// 整数符号常量    double lots[144];　　　 // 整数字面常量    ...在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但是（与C++不同）const值不是。另外，表达式的值必须大于0：\n1234567891011int n　=　5;int m　=　8;float a1[5];　　　　　　　　 // 可以float a2[5*2 + 1];　　　　 //可以float a3[sizeof(int) + 1]; //可以float a4[-4];　　　　　　　　// 不可以，数组大小必须大于0float a5[0];　　　　　　　　 // 不可以，数组大小必须大于0float a6[2.5];　　　　　　　 // 不可以，数组大小必须是整数float a7[(int)2.5];　　　　 // 可以，已被强制转换为整型常量float a8[n];　　　　　　　　 // C99之前不允许float a9[m];　　　　　　　　 // C99之前不允许上面的注释表明，以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为变长数组（variable-length array）或简称 VLA（C11 放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性）。\nC99引入变长数组主要是为了让C成为更好的数值计算语言。例如，VLA简化了把FORTRAN现有的数值计算例程库转换为C代码的过程。VLA有一些限制，例如，声明VLA时不能进行初始化。在充分了解经典的C数组后，我们再详细介绍VLA。\n多维数组气象研究员Tempest Cloud为完成她的研究项目要分析5年内每个月的降水量数据，她首先要解决的问题是如何表示数据。一个方案是创建60个变量，每个变量储存一个数据项（我们曾经提到过这一笨拙的方案，和以前一样，这个方案并不合适）。使用一个内含60个元素的数组比将建60个变量好，但是如果能把各年的数据分开储存会更好，即创建5个数组，每个数组12个元素。然而，这样做也很麻烦，如果Tempest决定研究50年的降水量，岂不是要创建50个数组。是否能有更好的方案？\n处理这种情况应该使用数组的数组。主数组（master array）有5个元素（每个元素表示一年），每个元素是内含12个元素的数组（每个元素表示一个月）。下面是该数组的声明：\n1float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素理解该声明的一种方法是，先查看中间部分（粗体部分）：\n1float rain[5][12]; // rain是一个内含5个元素的数组这说明数组rain有5个元素，至于每个元素的情况，要查看声明的其余部分（粗体部分）：\n1floatrain[5][12] ; // 一个内含12个float类型元素的数组这说明每个元素的类型是float[12]，也就是说，rain的每个元素本身都是一个内含12个float类型值的数组。\n根据以上分析可知，rain的首元素rain[0]是一个内含12个float类型值的数组。所以，rain[1]、rain[2]等也是如此。如果 rain[0]是一个数组，那么它的首元素就是 rain[0][0]，第 2 个元素是rain[0][1]，以此类推。简而言之，数组rain有5个元素，每个元素都是内含12个float类型元素的数组，rain[0]是内含12个float值的数组，rain[0][0]是一个float类型的值。假设要访问位于2行3列的值，则使用rain[2][3]（记住，数组元素的编号从0开始，所以2行指的是第3行）。\n\n该二维视图有助于帮助读者理解二维数组的两个下标。在计算机内部，这样的数组是按顺序储存的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。\n我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数组很直观，实现这些操作也很容易。程序清单10.7演示了这个程序。\n程序清单10.7 rain.c程序\n123456789101112131415161718192021222324252627282930313233343536373839/* rain.c　-- 计算每年的总降水量、年平均降水量和5年中每月的平均降水量 */#include　&lt;stdio.h&gt;#define MONTHS 12　　　// 一年的月份数#define YEARS　 5　　　 // 年数int main(void)&#123;    // 用2010～2014年的降水量数据初始化数组    const float rain[YEARS][MONTHS]　=    &#123;        &#123;　4.3,　4.3,　4.3,　3.0,　2.0,　1.2,　0.2,　0.2,　0.4,　2.4,　3.5,　6.6　&#125;,        &#123;　8.5,　8.2,　1.2,　1.6,　2.4,　0.0,　5.2,　0.9,　0.3,　0.9,　1.4,　7.3　&#125;,        &#123;　9.1,　8.5,　6.7,　4.3,　2.1,　0.8,　0.2,　0.2,　1.1,　2.3,　6.1,　8.4　&#125;,        &#123;　7.2,　9.9,　8.4,　3.3,　1.2,　0.8,　0.4,　0.0,　0.6,　1.7,　4.3,　6.2　&#125;,        &#123;　7.6,　5.6,　3.8,　2.8,　3.8,　0.2,　0.0,　0.0,　0.0,　1.3,　2.6,　5.2　&#125;    &#125;;    int year,month;    float subtot,total;    printf(\"　YEAR　　 RAINFALL　 (inches)\\n\");    for(year　=　0,　total　=　0;　year　&lt;　YEARS;　year++)    &#123;　　　　　　　　　　　　 // 每一年，各月的降水量总和        for(month　=　0,　subtot　=　0;　month　&lt;　MONTHS;　month++)        subtot+=rain[year][month];        printf(\"%5d　%15.1f\\n\",　2010　+　year,　subtot);        total += subtot;　 // 5年的总降水量    &#125;    printf(\"\\nThe　yearly　average　is　%.1f　inches.\\n\\n\",　total　/　YEARS);    printf(\"MONTHLY　AVERAGES:\\n\\n\");    printf(\"　Jan　 Feb　 Mar　 Apr　 May　 Jun　 Jul　 Aug　 Sep　 Oct　\");    printf(\"　Nov　 Dec\\n\");    for(month　=　0;　month　&lt;　MONTHS;　month++)    &#123;　　　　　　　　　　　　 // 每个月，5年的总降水量        for(year　=　0,　subtot　=　0;　year　&lt;　YEARS;　year++)        \tsubtot　+=　rain[year][month];        printf(\"%4.1f　\",　subtot　/　YEARS);    &#125;    printf(\"\\n\");    return 0;&#125;下面是该程序的输出：\n12345678910YEAR　　　RAINFALL　 (inches)2010　　　　　　　 32.42011　　　　　　　 37.92012　　　　　　　 49.82013　　　　　　　 44.02014　　　　　　　 32.9The　yearly　average　is　39.4　inches.MONTHLY　AVERAGES:Jan　Feb　Mar　Apr　May　Jun　Jul　Aug　Sep　Oct　Nov　Dec7.3　7.3　4.9　3.0　2.3　0.6　1.2　0.3　0.5　1.7　3.6　6.7学习该程序的重点是数组初始化和计算方案。初始化二维数组比较复杂，我们先来看较为简单的计算部分。\n程序使用了两个嵌套for循环。第1个嵌套for循环的内层循环，在year不变的情况下，遍历month计算某年的总降水量；而外层循环，改变year的值，重复遍历month，计算5年的总降水量。这种嵌套循环结构常用于处理二维数组，一个循环处理数组的第1个下标，另一个循环处理数组的第2个下标：\n123456for　(year　=　0,　total　=　0;　year　&lt;　YEARS;　year++)&#123; // 处理每一年的数据    for(month　=　0,　subtot　=　0;　month　&lt;　MONTHS;　month++)    ...// 处理每月的数据    ...//处理每一年的数据&#125;第2个嵌套for循环和第1个的结构相同，但是内层循环遍历year，外层循环遍历month。记住，每执行一次外层循环，就完整遍历一次内层循环。因此，在改变月份之前，先遍历完年，得到某月 5 年间的平均降水量，以此类推：\n123456for　(month　=　0;　month　&lt;　MONTHS;　month++)&#123; // 处理每月的数据    for(year　=　0,　subtot　=0;　year　&lt;　YEARS;　year++)    ...// 处理每年的数据    ...// 处理每月的数据&#125;初始化二维数组初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下：\n1sometype ar1[5] = &#123;val1, val2, val3, val4, val5&#125;;这里，val1、val2等表示sometype类型的值。例如，如果sometype是int，那么val1可能是7；如果sometype是double，那么val1可能是11.34，诸如此类。但是rain是一个内含5个元素的数组，每个元素又是内含12个float类型元素的数组。所以，对rain而言，val1应该包含12个值，用于初始化内含12个float类型元素的一维数组，如下所示：\n1&#123;4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6&#125;也就是说，如果sometype是一个内含12个double类型元素的数组，那么val1就是一个由12个double类型值构成的数值列表。因此，为了初始化二维数组rain，要用逗号分隔5个这样的数值列表：\n12345678const float rain[YEARS][MONTHS]　=&#123;    &#123;4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6&#125;,    &#123;8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3&#125;,    &#123;9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4&#125;,    &#123;7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2&#125;,    &#123;7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2&#125;&#125;;这个初始化使用了5个数值列表，每个数值列表都用花括号括起来。第1个列表的数据用于初始化数组的第1行，第2个列表的数据用于初始化数组的第2行，以此类推。前面讨论的数据个数和数组大小不匹配的问题同样适用于这里的每一行。也就是说，如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。\n初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。图10.2演示了这种初始化数组的方法。\n\n因为储存在数组rain中的数据不能修改，所以程序使用了const关键字声明该数组。\n其他多维数组前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组：\n1int box[10][20][30];可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组box想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。\n还有一种理解box的方法是，把box看作数组的数组。也就是说，box内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。或者，可以简单地根据所需的下标值去理解数组。\n通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推。在后面的程序示例中，我们只使用二维数组。\n指针和数组第9章介绍过指针，指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。我们很快就会学到，数组表示法其实是在变相地使用指针。\n我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是说，如果flizny是一个数组，下面的语句成立：\n1flizny == &amp;flizny[0]; // 数组名是该数组首元素的地址flizny 和&amp;flizny[0]都表示数组首元素的内存地址（&amp;是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值，如程序清单10.8所示。注意指针加上一个数时，它的值发生了什么变化（转换说明%p通常以十六进制显示指针的值）。\n程序清单10.8 pnt_add.c程序\n123456789101112131415161718// pnt_add.c -- 指针地址#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    short dates[SIZE];    short * pti;    short index;    double bills[SIZE];    double * ptf;    pti = dates;　// 把数组地址赋给指针    ptf　=　bills;    printf(\"%23s　%15s\\n\",　\"short\",　\"double\");    for(index　=　0;　index　&lt;　SIZE;　index++)    \tprintf(\"pointers　+　%d:　%10p　%10p\\n\",　index,　pti　+　index,　ptf　+　index);    return 0;&#125;下面是该例的输出示例：\n12345short　　　　　　　　doublepointers　+　0:　0x7fff5fbff8dc　0x7fff5fbff8a0pointers　+　1:　0x7fff5fbff8de　0x7fff5fbff8a8pointers　+　2:　0x7fff5fbff8e0　0x7fff5fbff8b0pointers　+　3:　0x7fff5fbff8e2　0x7fff5fbff8b8第2行打印的是两个数组开始的地址，下一行打印的是指针加1后的地址，以此类推。注意，地址是十六进制的，因此dd比dc大1，a1比a0大1。但是，显示的地址是怎么回事？\n120x7fff5fbff8dc + 1是否是0x7fff5fbff8de?0x7fff5fbff8a0 + 1是否是0x7fff5fbff8a8?我们的系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值）。\n\n现在可以更清楚地定义指向int的指针、指向float的指针，以及指向其他数据对象的指针。\n指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变量）通常是该对象第一个字节的地址。\n在指针前面使用*运算符可以得到该指针所指向对象的值。\n指针加1，指针的值递增它所指向类型的大小（以字节为单位）。\n下面的等式体现了C语言的灵活性：\n123dates + 2 == &amp;date[2]　　　 // 相同的地址*(dates + 2) == dates[2]　 // 相同的值以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思是*(ar + n)。可以认为*(ar + n)的意思是“到内存的ar位置，然后移动n个单元，检索储存在那里的值”。\n顺带一提，不要混淆 *(dates+2)和*dates+2。间接运算符（*）的优先级高于+，所以*dates+2相当于(*dates)+2：\n12*(dates + 2)　// dates第3个元素的值*dates + 2　　// dates第1个元素的值加2明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指针表示法。运行程序清单 10.9后输出的结果和程序清单10.1输出的结果相同。\n程序清单10.9 day_mon3.c程序\n12345678910111213/* day_mon3.c -- uses pointer notation */#include　&lt;stdio.h&gt;#define　MONTHS　12int　main(void)&#123;    int days[MONTHS]　=　&#123;　31,　28,　31,　30,　31,　30,　31,　31,　30,　31,　30,　31　&#125;;    int index;    for(index　=　0;　index　&lt;　MONTHS;　index++)    \tprintf(\"Month　%2d　has　%d　days.\\n\",　index　+　1,    *(days + index));　//与 days[index]相同    return 0;&#125;这里，days是数组首元素的地址，days + index是元素days[index]的地址，而*(days + index)则是该元素的值，相当于days[index]。for循环依次引用数组中的每个元素，并打印各元素的内容。\n这样编写程序是否有优势？不一定。编译器编译这两种写法生成的代码相同。程序清单 10.9 要注意的是，指针表示法和数组表示法是两种等效的方法。该例演示了可以用指针表示数组，反过来，也可以用数组表示指针。在使用以数组为参数的函数时要注意这点。\n函数、数组和指针假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。应该如何调用该函数？也许是下面这样：\n1total = sum(marbles); // 可能的函数调用那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向int的指针：\n1int sum(int *ar); // 对应的函数原型sum()从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小：\n12345678int sum(int *ar) // 相应的函数定义&#123;    int i;    int total　=　0;    for(i = 0; i &lt; 10; i++)　　// 假设数组有10个元素    \ttotal += ar[i];　　　　// ar[i] 与 *(ar + i) 相同    return total;&#125;既然能使用指针表示数组名，也可以用数组名表示指针。另外，回忆一下，+=运算符把右侧运算对象加到左侧运算对象上。因此，total是当前数组元素之和。\n该函数定义有限制，只能计算10个int类型的元素。另一个比较灵活的方法是把数组大小作为第2个参数：\n12345678int sum(int *ar,int n)　　　 // 更通用的方法&#123;    int i;    int total　=　0;    for(i = 0; i &lt; n; i++)　　 // 使用 n 个元素    total += ar[i];　　　　// ar[i] 和 *(ar + i) 相同    return total;&#125;这里，第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数。\n关于函数的形参，还有一点要注意。只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar：\n1int sum (int ar[], int n);int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形式参数。第2种形式（int ar[]）提醒读者指针ar指向的不仅仅一个int类型值，还是一个int类型数组的元素。\n注意 声明数组形参\n因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：\n1234int sum(int *ar, int n);int sum(int *, int);int sum(int　ar[],　int　n);int sum(int　[],　int);但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：\n123456789int sum(int *ar, int n)&#123;\t// 其他代码已省略&#125;int sum(int ar[],　int n);&#123;\t//其他代码已省略&#125;可以使用以上提到的任意一种函数原型和函数定义。\n程序清单 10.10 演示了一个程序，使用 sum()函数。该程序打印原始数组的大小和表示该数组的函数形参的大小（如果你的编译器不支持用转换说明%zd打印sizeof返回值，可以用%u或%lu来代替）。\n程序清单10.10 sum_arr1.c程序\n1234567891011121314151617181920212223242526// sum_arr1.c -- 数组元素之和// 如果编译器不支持 %zd，用 %u 或 %lu 替换它#include　&lt;stdio.h&gt;#define　SIZE　10int sum(int　ar[],　int　n);int main(void)&#123;    int marbles[SIZE]　=　&#123;　20,　10,　5,　39,　4,　16,　19,　26,　31,　20　&#125;;    long answer;    answer　=　sum(marbles,　SIZE);    printf(\"The　total　number　of　marbles　is　%ld.\\n\",　answer);    printf(\"The　size　of　marbles　is　%zd　bytes.\\n\",    sizeof　marbles);    return 0;&#125;int sum(int ar[], int n)　　 // 这个数组的大小是？&#123;    int i;    int total　=　0;    for(i　=　0;　i　&lt;　n;　i++)    \ttotal　+=　ar[i];    printf(\"The　size　of　ar　is　%zd　bytes.\\n\",　sizeof　ar);    return total;&#125;该程序的输出如下：\n123The　size　of　ar　is　8　bytes.The　total　number　of　marbles　is　190.The　size　of　marbles　is　40　bytes.注意，marbles的大小是40字节。这没问题，因为marbles内含10个int类型的值，每个值占4字节，所以整个marbles的大小是40字节。但是，ar才8字节。这是因为ar并不是数组本身，它是一个指向 marbles 数组首元素的指针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8字节（其他系统中地址的大小可能不是8字节）。简而言之，在程序清单10.10中，marbles是一个数组， ar是一个指向marbles数组首元素的指针，利用C中数组和指针的特殊关系，可以用数组表示法来表示指针ar。\n使用指针形参函数要处理数组必须知道何时开始、何时结束。sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。程序清单10.11演示了这种方法，同时该程序也表明了指针形参是变量，这意味着可以用索引表明访问数组中的哪一个元素。\n程序清单10.11 sum_arr2.c程序\n123456789101112131415161718192021222324/* sum_arr2.c -- 数组元素之和 */#include　&lt;stdio.h&gt;#define　SIZE　10int sump(int *start, int *end);int main(void)&#123;    int marbles[SIZE]　=　&#123;　20,　10,　5,　39,　4,　16,　19,　26,　31,　20　&#125;;    long answer;    answer　=　sump(marbles,　marbles　+　SIZE);    printf(\"The　total　number　of　marbles　is　%ld.\\n\",　answer);    return 0;&#125;/* 使用指针算法 */int sump(int * start, int * end)&#123;    int total　=　0;    while(start　&lt;　end)    &#123;        total += *start;　 // 把数组元素的值加起来        start++;　　　　　　// 让指针指向下一个元素    &#125;    return total;&#125;指针start开始指向marbles数组的首元素，所以赋值表达式total += *start把首元素（20）加给total。然后，表达式start++递增指针变量start，使其指向数组的下一个元素。因为start是指向int的指针，start递增1相当于其值递增int类型的大小。\n注意，sump()函数用另一种方法结束加法循环。sum()函数把元素的个数作为第2个参数，并把该参数作为循环测试的一部分：\n1for( i = 0; i &lt; n; i++)而sump()函数则使用第2个指针来结束循环：\n1while (start &lt; end)因为while循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素是end所指向位置的前一个元素。这意味着end指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。这使得 while循环的测试条件是有效的，因为 start在循环中最后的值是end。注意，使用这种“越界”指针的函数调用更为简洁：\n1answer = sump(marbles, marbles + SIZE);因为下标从0开始，所以marbles + SIZE指向数组末尾的下一个位置。如果end指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用下面的代码：\n1answer = sump(marbles, marbles + SIZE - 1);这种写法既不简洁也不好记，很容易导致编程错误。顺带一提，虽然C保证了marbles + SIZE有效，但是对marbles[SIZE]（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。\n还可以把循环体压缩成一行代码：\n1total += *start++;一元运算符*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start。也就是说，指针start先递增后指向。使用后缀形式（即start++而不是++start）意味着先把指针指向位置上的值加到total上，然后再递增指针。如果使用*++start，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用(*start)++，则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然*start++的写法比较常用，但是*(start++)这样写更清楚。程序清单10.12的程序演示了这些优先级的情况。\n程序清单10.12 order.c程序\n123456789101112131415/* order.c -- 指针运算中的优先级 */#include　&lt;stdio.h&gt;int data[2]　=　&#123;　100,　200　&#125;;int moredata[2]　=　&#123;　300,　400　&#125;;int main(void)&#123;    int * p1, *p2, *p3;    p1　=　p2　=　data;    p3　=　moredata;    printf(\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\",*p1, *p2, *p3);    printf(\"*p1++ = %d, *++p2 = %d, (*p3)++ = %d\\n\",*p1++, *++p2, (*p3)++);    printf(\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\",*p1, *p2, *p3);    return 0;&#125;下面是该程序的输出：\n123*p1 = 100,　 *p2 = 100,　　　*p3 = 300*p1++ = 100, *++p2 = 200,　(*p3)++ = 300*p1 = 200,　 *p2 = 200,　　　*p3 = 301只有(*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。\n指针表示法和数组表示法从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。如程序清单10.10所示，使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然，如程序清单10.11所示。\n至于C语言，ar[i]和*(ar+1)这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用ar++这样的表达式。\n指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。\n指针操作可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作。为了显示每种操作的结果，该程序打印了指针的值（该指针指向的地址）、储存在指针指向地址上的值，以及指针自己的地址。如果编译器不支持%p 转换说明，可以用%u 或%lu 代替%p；如果编译器不支持用%td转换说明打印地址的差值，可以用%d或%ld来代替。\n程序清单10.13演示了指针变量的 8种基本操作。除了这些操作，还可以使用关系运算符来比较指针。\n程序清单10.13 ptr_ops.c程序\n12345678910111213141516171819202122232425262728293031323334// ptr_ops.c -- 指针操作#include　&lt;stdio.h&gt;int　main(void)&#123;    int　urn[5]　=　&#123;　100,　200,　300,　400,　500　&#125;;    int *ptr1,*ptr2,*ptr3;    ptr1 = urn;　　　　　　　// 把一个地址赋给指针    ptr2 = &amp;urn[2];　　　　 // 把一个地址赋给指针    // 解引用指针，以及获得指针的地址    printf(\"pointer　value,　dereferenced　pointer,　pointer　address:\\n\");    printf(\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\", ptr1, *ptr1, &amp;ptr1);    // 指针加法    ptr3　=　ptr1　+　4;    printf(\"\\nadding　an　int　to　a　pointer:\\n\");    printf(\"ptr1 + 4 = %p, *(ptr1 + 4) = %d\\n\", ptr1 + 4, *(ptr1 + 4));    ptr1++;　　　　　　　　　// 递增指针    printf(\"\\nvalues　after　ptr1++:\\n\");    printf(\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\", ptr1, *ptr1, &amp;ptr1);    ptr2--;　　　　　　　　　// 递减指针    printf(\"\\nvalues　after　--ptr2:\\n\");    printf(\"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\\n\", ptr2, *ptr2, &amp;ptr2);    --ptr1;　　　　　　　　　// 恢复为初始值    ++ptr2;　　　　　　　　　// 恢复为初始值    printf(\"\\nPointers　reset　to　original　values:\\n\");    printf(\"ptr1　=　%p,　ptr2　=　%p\\n\",　ptr1,　ptr2);    // 一个指针减去另一个指针    printf(\"\\nsubtracting　one　pointer　from　another:\\n\");    printf(\"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\\n\",　ptr2,　ptr1,　ptr2　-　ptr1);    // 一个指针减去一个整数    printf(\"\\nsubtracting　an　int　from　a　pointer:\\n\");    printf(\"ptr3　=　%p,　ptr3　-　2　=　%p\\n\",　ptr3,　ptr3　-　2);    return 0;&#125;下面是我们的系统运行该程序后的输出：\n1234567891011121314pointer value, dereferenced pointer, pointer address:ptr1 = 0x7fff5fbff8d0, *ptr1 =100, &amp;ptr1 = 0x7fff5fbff8c8adding an int to a pointer:ptr1 + 4 = 0x7fff5fbff8e0, *(ptr1 + 4) = 500values after ptr1++:ptr1 = 0x7fff5fbff8d4, *ptr1 =200, &amp;ptr1 = 0x7fff5fbff8c8values after --ptr2:ptr2 = 0x7fff5fbff8d4, *ptr2 = 200, &amp;ptr2 = 0x7fff5fbff8c0Pointers reset to original values:ptr1 = 0x7fff5fbff8d0, ptr2 = 0x7fff5fbff8d8subtracting one pointer from another:ptr2 = 0x7fff5fbff8d8, ptr1 = 0x7fff5fbff8d0, ptr2 - ptr1 = 2subtracting an int from a pointer:ptr3 = 0x7fff5fbff8e0, ptr3 - 2 = 0x7fff5fbff8d8下面分别描述了指针变量的基本操作。\n赋值：可以把地址赋给指针。例如，用数组名、带地址运算符（&amp;）的变量名、另一个指针进行赋值。在该例中，把urn数组的首地址赋给了ptr1，该地址的编号恰好是0x7fff5fbff8d0。变量ptr2获得数组urn的第3个元素（urn[2]）的地址。注意，地址应该和指针类型兼容。也就是说，不能把double类型的地址赋给指向int的指针，至少要避免不明智的类型转换。C99/C11已经强制不允许这样做。\n解引用：*运算符给出指针指向地址上储存的值。因此，*ptr1的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。\n取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为 0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地址。因此&amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。\n指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 +4与&amp;urn[4]等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。\n递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。\n\n指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2与&amp;urn[2]等价，因为ptr3指向的是&amp;arn[4]。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。\n递减指针：当然，除了递增指针还可以递减\n递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。\n指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。\n比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。\n注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。\n在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。\n解引用未初始化的指针\n说到注意事项，一定要牢记一点：千万不要解引用未初始化的指针。例如，考虑下面的例子：\n12int *pt;// 未初始化的指针*pt = 5;　　　// 严重的错误为何不行？第2行的意思是把5储存在pt指向的位置。但是pt未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使用第12章将介绍的malloc()函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！\n12345double *pd;　// 未初始化的指针*pd =2.4;　　// 不要这样做假设int urn[3];int *ptr1,*ptr2;下面是一些有效和无效的语句：\n1234有效语句　　　　　　　　　　\t   无效语句ptr1++;　　　　　　　　　　　　  urn++;ptr2　=　ptr1　+　2;　　　　　  ptr2　=　ptr2　+　ptr1;ptr2　=　urn　+　1;　　　　　　 ptr2　=　urn　*　ptr1;基于这些有效的操作，C 程序员创建了指针数组、函数指针、指向指针的指针数组、指向函数的指针数组等。别紧张，接下来我们将根据已学的内容介绍指针的一些基本用法。指针的第 1 个基本用法是在函数间传递信息。前面学过，如果希望在被调函数中改变主调函数的变量，必须使用指针。指针的第 2 个基本用法是用在处理数组的函数中。下面我们再来看一个使用函数和数组的编程示例。\n保护数组中的数据编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。\n传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的。例如，下面的函数给数组的每个元素都加上一个相同的值：\n123456void add_to(double ar[],int n,double val)&#123;    int i;    for(i=0;i&lt;n;i++)    \tar[i]+=val;&#125;因此，调用该函数后，prices数组中的每个元素的值都增加了2.5：\n1add_to(prices, 100, 2.50);该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。\n然而，其他函数并不需要修改数据。例如，下面的函数计算数组中所有元素之和，它不用改变数组的数据。但是，由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。例如，下面示例中的ar[i]++会导致数组中每个元素的值都加1：\n12345678int sum(int ar[], int n) // 错误的代码&#123;    int i;    int total=0;    for(i=0;i&lt;n;i++)    \ttotal += ar[i]++;　// 错误递增了每个元素的值    return total;&#125;对形式参数使用const在K&amp;R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下：\n123456789int sum(const int ar[], int n); /* 函数原型 */int sum(const int ar[], int n) /* 函数定义 */&#123;    int i;    int total　=　0;    for(　i　=　0;　i　&lt;　n;　i++)    \ttotal　+=　ar[i];    return total;&#125;以上代码中的const告诉编译器，该函数不能修改ar指向的数组中的内容。如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕获这个错误，并生成一条错误信息。\n这里一定要理解，这样使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。\n程序清单10.14的程序中，一个函数显示数组的内容，另一个函数给数组每个元素都乘以一个给定值。因为第1个函数不用改变数组，所以在声明数组形参时使用了const；而第2个函数需要修改数组元素的值，所以不使用const。\n程序清单10.14 arf.c程序\n12345678910111213141516171819202122232425262728293031/* arf.c -- 处理数组的函数 */#include　&lt;stdio.h&gt;#define　SIZE　5void show_array(const　double　ar[],　int　n);void mult_array(double　ar[],　int　n,　double　mult);int main(void)&#123;    double dip[SIZE]　=　&#123;　20.0,　17.66,　8.2,　15.3,　22.22　&#125;;    printf(\"The　original　dip　array:\\n\");    show_array(dip,　SIZE);    mult_array(dip,　SIZE,　2.5);    printf(\"The　dip　array　after　calling　mult_array():\\n\");    show_array(dip,　SIZE);    return 0;&#125;/* 显示数组的内容 */void show_array(const　double　ar[],　int　n)&#123;    int i;    for(i　=　0;　i　&lt;　n;　i++)    \tprintf(\"%8.3f　\",　ar[i]);    putchar('\\n');&#125;/* 把数组的每个元素都乘以相同的值 */void mult_array(double　ar[],　int　n,　double　mult)&#123;    int i;    for(i　=　0;　i　&lt;　n;　i++)    \tar[i] *= mult;&#125;下面是该程序的输出：\n1234The　original　dip　array:20.000　　17.660　　　8.200　　　15.300　　22.220The　dip　array　after　calling　mult_array():50.000　　44.150　　　20.500　　38.250　　55.550注意该程序中两个函数的返回类型都是void。虽然mult_array()函数更新了dip数组的值，但是并未使用return机制。\nconst的其他内容我们在前面使用const创建过变量：\n1const double PI = 3.14159;虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const指针和指向const的指针。\n程序清单10.4演示了如何使用const关键字保护数组：\n123#define　MONTHS　12...const int days[MONTHS] =&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息：\n1days[9] = 44;　　 /* 编译错误 */指向const的指针不能用于改变值。考虑下面的代码：\n12double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double *pd = rates;　　 // pd指向数组的首元素第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：\n123*pd = 29.89;　　　// 不允许pd[2] = 222.22;　　//不允许rates[0] = 99.99; // 允许，因为rates未被const限定无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。但是要注意，因为rates并未被声明为const，所以仍然可以通过rates修改元素的值。另外，可以让pd指向别处：\n1pd++; /* 让pd指向rates[1] -- 没问题 */指向 const 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。例如，程序清单 10.14中的show_array()函数原型如下：\n1void show_array(const double *ar, int n);关于指针赋值和const需要注意一些规则。首先，把const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的：\n12345double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double locked[4]　=　&#123;0.08,　0.075,　0.0725,　0.07&#125;;const double *pc = rates; // 有效pc = locked;　　　　　　　　 //有效pc = &amp;rates[3];　　　　　　　//有效然而，只能把非const数据的地址赋给普通指针：\n12345double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double locked[4]　=　&#123;0.08,　0.075,　0.0725,　0.07&#125;;double *pnc = rates;　// 有效pnc = locked;　　　　　 // 无效pnc = &amp;rates[3];　　　　// 有效这个规则非常合理。否则，通过指针就能改变const数组中的数据。\n应用以上规则的例子，如 show_array()函数可以接受普通数组名和 const 数组名作为参数，因为这两种参数都可以用来初始化指向const的指针：\n12show_array(rates,5);　　　 // 有效show_array(locked,4);　　　// 有效因此，对函数的形参使用const不仅能保护数据，还能让函数处理const数组。\n另外，不应该把const数组名作为实参传递给mult_array()这样的函数：\n12mult_array(rates,5,1.2);　　　// 有效mult_array(locked,4,1.2);　　 // 不要这样做C标准规定，使用非const标识符（如，mult_arry()的形参ar）修改const数据（如，locked）导致的结果是未定义的。\n\nconst还有其他的用法。\n\n例如，可以声明并初始化一个不能指向别处的指针，关键是const的位置：\n1234double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;double *const pc = rates; // pc指向数组的开始pc = &amp;rates[2];　　　　　　　// 不允许，因为该指针不能指向别处*pc = 92.99;　　　　　　　 // 没问题 -- 更改rates[0]的值可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。\n\n最后，在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：\n1234double　rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double * const pc = rates;pc = &amp;rates[2];　　//不允许*pc = 92.99;　　　//不允许\n指针和多维数组\n像a[2][3] 这样的数组    a a[0] &amp;a[0][0] 相同    只要未完全说明的数组 像a a[0] a[1]都是地址 无需加&amp;    a[1]+1==&amp;a[1][1] a[0]+1==a[0][1] a==&amp;a[0][0]\n\n\np1  &amp;*p1 是&amp;x的地址    &amp;p1 是指针的地址\n\n指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数组。假设有下面的声明：\n1int zippo[4][2]; /* 内含int数组的数组 */然后数组名zippo是该数组首元素的地址。在本例中，zippo的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。下面，我们从指针的属性进一步分析。\n因为zippo是数组首元素的地址，所以zippo的值和&amp;zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址（即&amp;zippo[0][0]的值）相同。简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo和zippo[0]的值相同。\n给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。\n解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素（zippo[0][0]）的地址，所以*(zippo[0])表示储存在zippo[0][0]上的值（即一个int类型的值）。与此类似，*zippo代表该数组首元素（zippo[0]）的值，但是zippo[0]本身是一个int类型值的地址。该值的地址是&amp;zippo[0][0]，所以*zippo就是&amp;zippo[0][0]。对两个表达式应用解引用运算符表明，**zippo与*&amp;zippo[0][0]等价，这相当于zippo[0][0]，即一个int类型的值。简而言之，zippo是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。\n显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否能用所学的知识解释程序清单10.15中的程序。该程序显示了一些地址值和数组的内容。\n程序清单10.15 zippo1.c程序\n12345678910111213141516/* zippo1.c --　zippo的相关信息 */#include　&lt;stdio.h&gt;int main(void)&#123;    int zippo[4][2]=&#123; &#123;2,4&#125;, &#123;6,8&#125;, &#123;1,3&#125;, &#123;5,7&#125;&#125;;    printf(\" zippo=%p, zippo+1=%p\\n\",zippo,zippo+1);    printf(\"zippo[0]=%p,zippo[0]+1=%p\\n\",zippo[0],zippo[0]+1);    printf(\"*zippo = %p,*zippo+1=%p\\n\",*zippo, *zippo + 1);    printf(\"zippo[0][0]　=　%d\\n\",　zippo[0][0]);    printf(\" *zippo[0] = %d\\n\", *zippo[0]);    printf(\" **zippo = %d\\n\", **zippo);    printf(\" zippo[2][1]　=　%d\\n\",　zippo[2][1]);    printf(\"*(*(zippo+2) + 1) = %d\\n\", *(*(zippo + 2) + 1));    return 0;&#125;下面是我们的系统运行该程序后的输出：\n12345678zippo=0x0064fd38,　　　　 zippo+1　=　0x0064fd40zippo[0]=0x0064fd38,　　zippo[0]+1　=　0x0064fd3c*zippo = 0x0064fd38,　　 *zippo+1 = 0x0064fd3czippo[0][0] =2*zippo[0] =2**zippo =2zippo[2][1]　=3*(*(zippo+2) + 1) = 3其他系统显示的地址值和地址形式可能不同，但是地址之间的关系与以上输出相同。该输出显示了二维数组zippo的地址和一维数组zippo[0]的地址相同。它们的地址都是各自数组首元素的地址，因而与&amp;zippo[0][0]的值也相同。\n尽管如此，它们也有差别。在我们的系统中，int是4 字节。前面讨论过，zippo[0]指向一个4 字节的数据对象。zippo[0]加1，其值加4（十六进制中，38+4得3c）。数组名zippo 是一个内含2个int类型值的数组的地址，所以zippo指向一个8字节的数据对象。因此，zippo加1，它所指向的地址加8字节（十六进制中，38+8得40）。\n该程序演示了zippo[0]和*zippo完全相同，实际上确实如此。然后，对二维数组名解引用两次，得到储存在数组中的值。使用两个间接运算符（*）或者使用两对方括号（[]）都能获得该值（还可以使用一个*和一对[]，但是我们暂不讨论这么多情况）。\n要特别注意，与 zippo[2][1]等价的指针表示法是((zippo+2) + 1)。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：\n\n12345678910int zippo[3][3]=&#123;&#123;5,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;zippo  : 000000000062FDF0 zippo+2: 000000000062FE08 \t// zippo + 2个 * 3个数 * int大小4B == &amp;zippo[2]    *(zippo+2)\t: 000000000062FE08 //zippo[2]*(zippo+2)+1: 000000000062FE0C   // zippo[2]+1 即&amp;zippo[2][1]*(*(zippo+2)+1): 0000000000000008   // zippo[2][1]*zippo[0]==zippo[0][0]*zippo[0]+1==zippo[0][0]+1以上分析并不是为了说明用指针表示法（*(*(zippo+2) + 1)）代替数组表示法（zippo[2][1]），而是提示读者，如果程序恰巧使用一个指向二维数组的指针，而且要通过该指针获取值时，最好用简单的数组表示法，而不是指针表示法。\n图10.5以另一种视图演示了数组地址、数组内容和指针之间的关系。\n\n指向多维数组的指针如何声明一个指针变量pz指向一个二维数组（如，zippo）？在编写处理类似zippo这样的二维数组时会用到这样的指针。把指针声明为指向int的类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指向一个int类型值，其声明如下：\n1int (* pz)[2];　　// pz指向一个内含两个int类型值的数组以上代码把pz声明为指向一个数组的指针，该数组内含两个int类型值。\n*先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针\n为什么要在声明中使用圆括号？因为[]的优先级高于*。考虑下面的声明：\n1int *pax[2];　　 // pax是一个内含两个指针元素的数组，每个元素都指向int的指针由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号的版本，*先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针。程序清单10.16演示了如何使用指向二维数组的指针。\n程序清单10.16 zippo2.c程序\n123456789101112131415161718/* zippo2.c --　通过指针获取zippo的信息 */#include　&lt;stdio.h&gt;int main(void)&#123;    int zippo[4][2]　=　&#123;　&#123;2,4&#125;,　&#123;6,8&#125;,　&#123;1,3&#125;,　&#123;5,7&#125;　&#125;;    int(*pz)[2];    pz　=　zippo;    printf(\"　pz　=　%p,　pz　+　1　=　%p\\n\",pz,　pz　+　1);    printf(\"pz[0]　=　%p,　pz[0]　+　1　=　%p\\n\",　 pz[0],　pz[0]　+　1);    printf(\"　*pz = %p,　 *pz + 1 = %p\\n\",　 *pz, *pz + 1);    printf(\"pz[0][0]　=　%d\\n\",　pz[0][0]);    printf(\"　*pz[0] = %d\\n\", *pz[0]);    printf(\"　**pz = %d\\n\", **pz);    printf(\"　pz[2][1]　=　%d\\n\",　pz[2][1]);    printf(\"*(*(pz+2) + 1) = %d\\n\", *(*(pz + 2) + 1));    return 0;&#125;下面是该程序的输出：\n12345678pz　=　0x0064fd38,\t\tpz　+　1　=　0x0064fd40pz[0]　=　0x0064fd38,\t\tpz[0]　+　1　=　0x0064fd3c*pz = 0x0064fd38,\t\t*pz + 1 = 0x0064fd3cpz[0][0]　=　2*pz[0] = 2**pz = 2pz[2][1]　=　3*(*(pz+2) + 1) = 3系统不同，输出的地址可能不同，但是地址之间的关系相同。如前所述，虽然pz是一个指针，不是数组名，但是也可以使用 pz[2][1]这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：\n12zippo[m][n] == *(*(zippo + m) + n)pz[m][n] == *(*(pz + m) + n)指针的兼容性指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 int 类型的值赋给double类型的变量，但是两个类型的指针不能这样做。\n123456int　n=5;double　x;int *p1=&amp;n;double *pd=&amp;x;x = n;　　　　　　　// 隐式类型转换pd = p1;　　　　　　// 编译时错误更复杂的类型也是如此。假设有如下声明：\n12345int *pt;int (*pa)[3];int ar1[2][3];int ar2[3][2];int **p2; // 一个指向指针的指针有如下的语句：\n12345678pt = &amp;ar1[0][0];　// 都是指向int的指针pt = ar1[0];　　　 // 都是指向int的指针pt = ar1;　　　　　 // 无效pa = ar1;　　　　　 // 都是指向内含3个int类型元素数组的指针pa = ar2;　　　　　 // 无效p2 = &amp;pt;　　　　 // both pointer-to-int **p2 = ar2[0];　　 // 都是指向int的指针p2 = ar2;　　　　　 // 无效 解释加粗注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类型。例如，pt 指向一个 int类型值，而ar1指向一个内含3和int类型元素的数组。类似地，pa指向一个内含2个int类型元素的数组，所以它与ar1的类型兼容，但是ar2指向一个内含2个int类型元素的数组，所以pa与ar2不兼容。\n上面的最后两个例子有些棘手。变量p2是指向指针的指针，它指向的指针指向int，而ar2是指向数组的指针，该数组内含2个int类型的元素。所以，p2和ar2的类型不同，不能把ar2赋给p2。但是，*p2是指向int的指针，与ar2[0]兼容。因为ar2[0]是指向该数组首元素（ar2[0][0]）的指针，所以ar2[0]也是指向int的指针。\n一般而言，多重解引用让人费解。例如，考虑下面的代码：\n12345678int　x=20;const　int　y=23;int *p1 = &amp;x;const int *p2=&amp;y;const int **pp2;p1 = p2;　　　 // 不安全 -- 把const指针赋给非const指针p2 = p1;　　　 // 有效 -- 把非const指针赋给const指针pp2 = &amp;p1;　　// 不安全 –- 嵌套指针类型赋值前面提到过，把const指针赋给非const指针不安全，因为这样可以使用新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非const指针赋给const指针没问题，前提是只进行一级解引用：\n1p2 = p1; // 有效 -- 把非const指针赋给const指针但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代码：\n123456const int **pp2; //pp2是p1指针的地址&amp;p1, *pp2是p1指向值的地址，即p1 **pp2是*p1的值int *p1;const int n=13;pp2 = &amp;p1;　　// 允许，但是这导致const限定符失效（根据第1行代码，不能通过*pp2修改它所指向的内容）*pp2 = &amp;n;　　// 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修改）*p1 = 10;//有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）发生了什么？如前所示，标准规定了通过非const指针更改const数据是未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编译包含以上代码的小程序，导致n最终的值是13，但是在相同系统下使用clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果都是未定义的。\nC const和C++ const\nC和C++中const的用法很相似，但是并不完全相同。区别之一是，C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是，C++的指针赋值检查更严格：\n1234const int y;const int *p2=&amp;y;int *p1;p1=p2; // C++中不允许这样做，但是C可能只给出警告C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果通过p1更改y，其行为是未定义的。\n函数和多维数组如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。\n下面，我们编写一个处理二维数组的函数。一种方法是，利用for循环把处理一维数组的函数应用到二维数组的每一行。如下所示：\n12345int junk[3][4]　=　&#123;　&#123;2,4,5,8&#125;,　&#123;3,5,6,9&#125;,　&#123;12,10,8,6&#125;　&#125;;int i,j;int total=0;for(i=0;i&lt;3;i++)total += sum(junk[i], 4); // junk[i]是一维数组记住，如果 junk 是二维数组，junk[i]就是一维数组，可将其视为二维数组的一行。这里，sum()函数计算二维数组的每行的总和，然后for循环再把每行的总和加起来。\n然而，这种方法无法记录行和列的信息。用这种方法计算总和，行和列的信息并不重要。但如果每行代表一年，每列代表一个月，就还需要一个函数计算某列的总和。该函数要知道行和列的信息，可以通过声明正确类型的形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组 junk 是一个内含 3个数组元素的数组，每个元素是内含4个int类型值的数组（即junk是一个3行4列的二维数组）。通过前面的讨论可知，这表明junk是一个指向数组（内含4个int类型值）的指针。可以这样声明函数的形参：\n1void somefunction(int (*pt)[4]);另外，如果当且仅当pt是一个函数的形式参数时，可以这样声明：\n1void somefunction(int pt[][4] );注意，第1个方括号是空的。空的方括号表明pt是一个指针。这样的变量稍后可以用作相同方法作为junk。下面的程序示例中就是这样做的，如程序清单10.17所示。注意该程序清单演示了3种等价的原型语法。\n程序清单10.17 array2d.c程序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// array2d.c -- 处理二维数组的函数#include　&lt;stdio.h&gt;#define　ROWS　3#define　COLS　4void sum_rows(int ar[][COLS],int rows);void sum_cols(int [][COLS],int);　　　　// 省略形参名，没问题int sum2d(int(*ar)[COLS], int rows);　　// 另一种语法int main(void)&#123;    int junk[ROWS][COLS]　=　&#123; &#123;2,4,6,8&#125;,&#123;3,5,7,9&#125;,&#123;12,10,8,6&#125;&#125;;    sum_rows(junk,ROWS);    sum_cols(junk,　ROWS);    printf(\"Sum　of　all　elements　=　%d\\n\",　sum2d(junk,　ROWS));    return 0;&#125;void sum_rows(int ar[][COLS],int rows)&#123;    int r;    int c;    int tot;    for(r=0;r&lt;rows;r++)    &#123;        tot　=　0;        for(c=0;c&lt;COLS;c++)        \ttot+=ar[r][c];        printf(\"row　%d:　sum　=　%d\\n\",r,tot);    &#125;&#125;void sum_cols(int ar[][COLS],int rows)&#123;    int r;    int c;    int tot;    for(c=0;c&lt;COLS;c++)    &#123;        tot=0;        for(r=0;r&lt;rows;r++)        \ttot+=ar[r][c];        printf(\"col　%d:　sum　=　%d\\n\",c,tot);    &#125;&#125;int sum2d(int　ar[][COLS],　int　rows)&#123;    int r;    int c;    int tot　=　0;    for(r=0;r&lt;rows;r++)    \tfor(c=0;c&lt;COLS;c++)    \t\ttot+=ar[r][c];    return tot;&#125;该程序的输出如下：\n12345678row 0: sum = 20row 1: sum = 24row 2: sum = 36col 0: sum = 17col 1: sum = 19col 2: sum = 21col 3: sum = 23Sum of all elements = 80程序清单10.17中的程序把数组名junk（即，指向数组首元素的指针，首元素是子数组）和符号常量ROWS（代表行数3）作为参数传递给函数。每个函数都把ar视为内含数组元素（每个元素是内含4个int类型值的数组）的数组。列数内置在函数体中，但是行数靠函数传递得到。如果传入函数的行数是12，那么函数要处理的是12×4的数组。因为rows是元素的个数，然而，因为每个元素都是数组，或者视为一行，rows也可以看成是行数。\n注意，ar和main()中的junk都使用数组表示法。因为ar和junk的类型相同，它们都是指向内含4个int类型值的数组的指针。\n注意，下面的声明不正确：\n1int sum2(int ar[][], int rows); // 错误的声明前面介绍过，编译器会把数组表示法转换成指针表示法。例如，编译器会把 ar[1]转换成 ar+1。编译器对ar+1求值，要知道ar所指向的对象大小。下面的声明：\n1int sum2(int ar[][4], int rows);　　// 有效声明表示ar指向一个内含4个int类型值的数组（在我们的系统中，ar指向的对象占16字节），所以ar+1的意思是“该地址加上16字节”。如果第2对方括号是空的，编译器就不知道该怎样处理。\n也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：\n1int sum2(int ar[3][4], int rows); // 有效声明，但是3将被忽略与使用typedef（第5章和第14章中讨论）相比，这种形式方便得多：\n12345typedef int arr4[4];　　　　　　　　　// arr4是一个内含 4 个int的数组typedef arr4 arr3x4[3];　　　　　　　 // arr3x4 是一个内含3个 arr4的数组int sum2(arr3x4 ar, int rows);　　　// 与下面的声明相同int sum2(int ar[3][4], int rows);　 // 与下面的声明相同int sum2(int ar[][4], int rows);　　// 标准形式一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：\n1int sum4d(int ar[][12][20][30],int rows);因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：\n1int sum4d(int (*ar)[12][20][30], int rows); // ar是一个指针这里，ar指向一个12×20×30的int数组。\n变长数组（VLA）读者在学习处理二维数组的函数中可能不太理解，为何只把数组的行数作为函数的形参，而列数却内置在函数体内。例如，函数定义如下：\n1234567891011#define　COLS　4int sum2d(int ar[][COLS],int rows)&#123;    int r;    int c;    int tot=0;    for(r=0;r&lt;rows;r++)    \tfor(c=0;c&lt;COLS;c++)    \t\ttot+=ar[r][c];    return tot;&#125;假设声明了下列数组：\n123int array1[5][4];int array2[100][4];int array3[2][4];可以用sum2d()函数分别计算这些数组的元素之和：\n123tot = sum2d(array1, 5);　　// 5×4 数组的元素之和tot = sum2d(array2, 100);　// 100×4数组的元素之和tot = sum2d(array3, 2);　　// 2×4数组的元素之和sum2d()函数之所以能处理这些数组，是因为这些数组的列数固定为4，而行数被传递给形参rows， rows是一个变量。但是如果要计算6×5的数组（即6行5列），就不能使用这个函数，必须重新创建一个CLOS为5的函数。因为C规定，数组的维数必须是常量，不能用变量来代替COLS。\n要创建一个能处理任意大小二维数组的函数，比较繁琐（必须把数组作为一维数组传递，然后让函数计算每行的开始处）。而且，这种方法不好处理FORTRAN的子例程，这些子例程都允许在函数调用中指定两个维度。虽然 FORTRAN 是比较老的编程语言，但是在过去的几十年里，数值计算领域的专家已经用FORTRAN开发出许多有用的计算库。C正逐渐替代FORTRAN，如果能直接转换现有的FORTRAN库就好了。\n鉴于此，C99新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：\n123int quarters　=　4;int regions　=　5;double sales[regions][quarters];　　// 一个变长数组（VLA）前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern存储类别说明符（第12章介绍）。而且，不能在声明中初始化它们。最终，C11把变长数组作为一个可选特性，而不是必须强制实现的特性。\n注意 变长数组不能改变大小\n变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。\n由于变长数组是C语言的新特性，目前完全支持这一特性的编译器不多。下面我们来看一个简单的例子：如何编写一个函数，计算int的二维数组所有元素之和。\n首先，要声明一个带二维变长数组参数的函数，如下所示：\n1int sum2d(int rows,int cols,int ar[rows][cols]); // ar是一个变长数组（VLA）注意前两个形参（rows和cols）用作第3个形参二维数组ar的两个维度。因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前先声明这两个形参。因此，下面的原型是错误的：\n1int sum2d(int ar[rows][cols],int rows,int cols); // 无效的顺序C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：\n1int sum2d(int,int,int ar[*][*]); // ar是一个变长数组（VLA），省略了维度形参名其次，该函数的定义如下：\n12345678910int sum2d(int rows,int cols,int ar[rows][cols])&#123;    int r;    int c;    int tot=0;    for(r=0;r&lt;rows;r++)    \tfor(c=0;c&lt;cols;c++)    \t\ttot+=ar[r][c];    return tot;&#125;该函数除函数头与传统的C函数（程序清单10.17）不同外，还把符号常量COLS替换成变量cols。这是因为在函数头中使用了变长数组。由于用变量代表行数和列数，所以新的sum2d()现在可以处理任意大小的二维int数组，如程序清单10.18所示。但是，该程序要求编译器支持变长数组特性。另外，该程序还演示了以变长数组作为形参的函数既可处理传统C数组，也可处理变长数组。\n程序清单10.18 vararr2d.c程序\n123456789101112131415161718192021222324252627282930313233343536//vararr2d.c -- 使用变长数组的函数#include　&lt;stdio.h&gt;#define　ROWS　3#define　COLS　4int sum2d(int　rows,　int　cols,　int　ar[rows][cols]);int main(void)&#123;    int i,j;    int rs=3;    int cs=10;    int junk[ROWS][COLS]=&#123; &#123;2,4,6,8&#125;,&#123;3,5,7,9&#125;,&#123;12,10,8,6&#125;&#125;;    int morejunk[ROWS-1][COLS + 2]=&#123;&#123;20,30,40,50,60,70&#125;,&#123;5,6,7,8,9,10&#125;&#125;;    int varr[rs][cs];　// 变长数组（VLA）    for(i=0;i&lt;rs;i++)    \tfor(j=0;j&lt;cs;j++)    \t\tvarr[i][j] = i * j + j;    printf(\"3x5　array\\n\");    printf(\"Sum　of　all　elements　=　%d\\n\",sum2d(ROWS,COLS,　junk));    printf(\"2x6　array\\n\");    printf(\"Sum　of　all　elements　=　%d\\n\",sum2d(ROWS　-　1,　COLS　+　2,　morejunk));    printf(\"3x10　VLA\\n\");    printf(\"Sum　of　all　elements　=　%d\\n\",　sum2d(rs,　cs,　varr));    return 0;&#125;// 带变长数组形参的函数int sum2d(int rows,int cols,int ar[rows][cols])&#123;    int r;    int c;    int tot　=　0;    for(r　=　0;　r　&lt;　rows;　r++)    \tfor(c　=　0;　c　&lt;　cols;　c++)    \t\ttot　+=　ar[r][c];    return tot;&#125;下面是该程序的输出：\n1234563x5　arraySum　of　all　elements　=　802x6　arraySum　of　all　elements　=　3153x10　VLASum　of　all　elements　=　270需要注意的是，在函数定义的形参列表中声明的变长数组并未实际创建数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。下面的代码段指出指针和实际数组是何时声明的：\n12345678910int thing[10][6];twoset(10,6,thing);...&#125;void twoset (int n, int m, int ar[n][m]) // ar是一个指向数组（内含m个int类型的值）的指针&#123;    int temp[n][m];　　// temp是一个n×m的int数组    temp[0][0] = 2;　　// 设置temp的一个元素为2    ar[0][0] = 2;　　　// 设置thing[0][0]为2&#125;如上代码所示调用twoset()时，ar成为指向thing[0]的指针，temp被创建为10×6的数组。因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0]访问的数据位置相同。\nconst和数组大小\n是否可以在声明数组时使用const变量？\n123const int SZ　=　80;...double ar[SZ]; // 是否允许？C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如20、sizeof表达式或其他不是const的内容。由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用const，但是这种代码可能无法移植。\nC99/C11 标准允许在声明变长数组时使用 const 变量。所以该数组的定义必须是声明在块中的自动存储类别数组。\n变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通 C数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。第12章将详细介绍动态内存分配。\n复合字面量假设给带int类型形参的函数传递一个值，要传递int类型的变量，但是也可以传递int类型常量，如5。在C99 标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量（compound literal）。字面量是除符号常量外的常量。例如，5是int类型字面量， 81.3是double类型的字面量，&#39;Y&#39;是char类型的字面量，&quot;elephant&quot;是字符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。\n对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：\n1int diva[2] = &#123;10, 20&#125;;下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：\n1(int [2])&#123;10, 20&#125;　　　// 复合字面量注意，去掉声明中的数组名，留下的int [2]即是复合字面量的类型名。\n初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：\n1(int [])&#123;50, 20, 90&#125; // 内含3个元素的复合字面量因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。使用指针记录地址就是一种用法。也就是说，可以这样用：\n12int *pt1;pt1 = (int [2]) &#123;10, 20&#125;;注意，该复合字面量的字面常量与上面创建的 diva 数组的字面常量完全相同。与有数组名的数组类似，复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向int的指针。然后便可使用这个指针。例如，本例中*pt1是10，pt1[1]是20。\n还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：\n1234int sum(const int ar[],int n);...int total3;total3 = sum((int [])&#123;4,4,4,5,5,5&#125;, 6);这里，第1个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。\n可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：\n12int (*pt2)[4];　　 // 声明一个指向二维数组的指针，该数组内含2个数组元素，每个元素是内含4个int类型值的数组pt2　=　(int　[2][4])　&#123;　&#123;1,2,3,-9&#125;,　&#123;4,5,6,-8&#125;　&#125;;如上所示，该复合字面量的类型是int [2][4]，即一个2×4的int数组。\n程序清单10.19把上述例子放进一个完整的程序中。\n程序清单10.19 flc.c程序\n123456789101112131415161718192021222324252627282930313233343536373839// flc.c -- 有趣的常量#include　&lt;stdio.h&gt;#define　COLS　4int sum2d(const int ar[][COLS],int rows);int sum(const int ar[],int n);int main(void)&#123;    int total1,total2,total3;    int * pt1;    int(*pt2)[COLS];    pt1　=　(int[2])　&#123;　10,　20　&#125;;    pt2　=　(int[2][COLS])　&#123;　&#123;1,　2,　3,　-9&#125;,　&#123;　4,　5,　6,　-8　&#125;　&#125;;    total1　=　sum(pt1,　2);    total2　=　sum2d(pt2,　2);    total3　=　sum((int　[])&#123;　4,　4,　4,　5,　5,　5　&#125;,　6);    printf(\"total1　=　%d\\n\",　total1);    printf(\"total2　=　%d\\n\",　total2);    printf(\"total3　=　%d\\n\",　total3);    return 0;&#125;int sum(const　int　ar　[],　int　n)&#123;    int i;    int total　=　0;    for(i　=　0;　i　&lt;　n;　i++)    \ttotal　+=　ar[i];    return total;&#125;int sum2d(const int ar[][COLS],int rows)&#123;    int r;    int c;    int tot　=　0;    for(r　=　0;　r　&lt;　rows;　r++)    \tfor(c　=　0;　c　&lt;　COLS;　c++)    \t\ttot　+=　ar[r][c];    return tot;&#125;要支持C99的编译器才能正常运行该程序示例（目前并不是所有的编译器都支持），其输出如下：\n123total1　=　30total2　=　4total3　=　27记住，复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域（第12章将介绍相关内容），这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。\n关键概念数组用于储存相同类型的数据。C 把数组看作是派生类型，因为数组是建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型，如int类型的数组、float类型的数组，或其他类型的数组。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组的数组（或称为二维数组）。\n通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组地址提供了“地址”，“元素个数”可以内置在函数中或作为单独的参数传递。第 2 种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。\n数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。\n对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11新增了变长数组，可以用变量表示数组大小。这意味着变长数组的大小延迟到程序运行时才确定。\n本章小结数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过整数下标（或索引）可以访问各元素。在C中，数组首元素的下标是0，所以对于内含n个元素的数组，其最后一个元素的下标是n-1。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。\n声明一个简单的一维数组形式如下：\n1type name [ size ];这里，type是数组中每个元素的数据类型，name是数组名，size是数组元素的个数。对于传统的C数组，要求size是整型常量表达式。但是C99/C11允许使用整型非常量表达式。这种情况下的数组被称为变长数组。\nC把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果ar是一个数组，那么表达式ar[i]和*(ar+i)等价。\n对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字const。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。\n指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果pd指向一个数组的8字节double类型值，那么pd加1意味着其值加8，以便它指向该数组的下一个元素。\n二维数组即是数组的数组。例如，下面声明了一个二维数组：\n1double sales[5][12];该数组名为sales，有5个元素（一维数组），每个元素都是一个内含12个double类型值的数组。第1个一维数组是sales[0]，第2个一维数组是sales[1]，以此类推，每个元素都是内含12个double类型值的数组。使用第2个下标可以访问这些一维数组中的特定元素。例如，sales[2][5]是slaes[2]的第6个元素，而sales[2]是sales的第3个元素。\nC 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第1个维度。传递的第1个维度通常作为第2个参数。例如，为了处理前面声明的sales数组，函数原型和函数调用如下：\n123void display(double ar[][12],int rows);...display(sales, 5);变长数组提供第2种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：\n123void display(int rows,int cols,double ar[rows][cols]);...display(5, 12, sales);虽然上述讨论中使用的是int类型的数组和double类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在第11章中详细介绍。\n","plink":"https://dxsummer.gitee.io/posts/87e8ce91/"},{"title":"Inside Front-Matter","date":"2020-06-12T13:08:56.000Z","date_formatted":{"ll":"2020年6月12日","L":"2020/06/12","MM-DD":"06-12"},"updated":"2020-06-13T06:25:09.613Z","content":"Hexo 默认12345678title: 标题date:updated:comments:tags:categories:layout:permalink: 永久链接详见 hexo.io/docs/front-matter。\n主题扩展同时适用于 page 和 post123456789# 当前文章是否显示目录导航，用于覆盖全局设置toc: false# 当前文章是否显示打赏，用于覆盖全局设置reward: false# 当前文章是否显示版权声明信息，用于覆盖全局设置# 支持设置为对象，同 &#x2F;theme-inside&#x2F;docs&#x2F;content addons#copyright。copyright: false适用于 post123456789101112# 设置缩略图thumbnail: landscape.jpg# 设置缩略图底色color: &#39;#111&#39;# 可联合设置，如：thumbnail: &#39;landscape.jpg #111&#39;# post 列表置顶# 优先按 top 值排序（缺省值为 0），其次按 datetop: 1文章加密Post\n12345678910---title: Hello Worldtags:- 作为日记加密date: 2016-03-30 21:12:21password: mikemessiabstract: 有东西被加密了, 请输入密码查看.message: 您好, 这里需要密码.wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.config\n12345678910# Securityencrypt: # hexo-blog-encrypt  abstract: 有东西被加密了, 请输入密码查看.  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  template: &lt;div id&#x3D;&quot;hexo-blog-encrypt&quot; data-wpm&#x3D;&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot; data-whm&#x3D;&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div class&#x3D;&quot;hbe-input-container&quot;&gt;&lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;hbePass&quot; placeholder&#x3D;&quot;&#123;&#123;hbeMessage&#125;&#125;&quot; &#x2F;&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;&#x2F;label&gt;&lt;div class&#x3D;&quot;bottom-line&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script id&#x3D;&quot;hbeData&quot; type&#x3D;&quot;hbeData&quot; data-hmacdigest&#x3D;&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;div&gt;  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.适用于 page12# 在 page 标题下方显示信息，目前只会显示 date。meta: true折叠选项卡\n  无辣不欢\n   🌶️ 可以直接嚼辣椒\n   🍲 钟情麻辣香锅、四川重庆火锅\n   \n\n  无辣不欢\n   🌶️ 可以直接嚼辣椒\n   🍲 钟情麻辣香锅、四川重庆火锅\n   \n123456&lt;details style=\"padding-left:12px;padding-bottom:10px\"&gt;  &lt;summary&gt;无辣不欢&lt;/summary&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🌶️ 可以直接嚼辣椒&lt;/p&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🍲 钟情麻辣香锅、四川重庆火锅&lt;/p&gt;  &lt;p style=\"line-height:10px\"&gt; &lt;/p&gt;&lt;/details&gt;123456&lt;details style=\"padding-left:12px;padding-bottom:10px\" open=\"\"&gt;  &lt;summary&gt;无辣不欢&lt;/summary&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🌶️ 可以直接嚼辣椒&lt;/p&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🍲 钟情麻辣香锅、四川重庆火锅&lt;/p&gt;  &lt;p style=\"line-height:10px\"&gt; &lt;/p&gt;&lt;/details&gt;","plink":"https://dxsummer.gitee.io/posts/5a6efaf9/"},{"title":"动画详解十大经典排序算法（C语言版）","date":"2020-06-12T10:26:57.000Z","date_formatted":{"ll":"2020年6月12日","L":"2020/06/12","MM-DD":"06-12"},"updated":"2020-10-11T14:26:48.577Z","content":"排序算法是程序员必备的基础知识，弄明白它们的原理和实现很有必要。本文中将通过非常细节的动画展示出算法的原理，配合代码更容易理解。\n概述由于待排序的元素数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两类：一类是内部排序，指的是待排序列存放在计算机随机存储器中进行的排序过程；另一类是外部排序，指的是待排序的元素的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。\n我们可以将常见的内部排序算法可以分成两类：\n\n比较类排序：通过比较来决定元素间的相对次序，时间复杂度为 O(nlogn)～O(n²)。属于比较类的有：\n\n排序算法时间复杂度最差情况最好情况空间复杂度排序方式稳定性\n\n冒泡排序O(n²)O(n²)O(n)O(1)In-place✔\n\n快速排序O(nlogn)O(n²)O(nlogn)O(logn)In-place✘\n\n插入排序O(n²)O(n²)O(n)O(1)In-place✔\n\n希尔排序O(nlog²n)O(n²)O(n)O(1)In-place✘\n\n选择排序O(n²)O(n²)O(n²)O(1)In-place✘\n\n堆排序O(nlogn)O(nlogn)O(nlogn)O(1)In-place✘\n\n归并排序O(nlogn)O(nlogn)O(nlogn)O(n)Out-place✔\n非比较类排序：不通过比较来决定元素间的相对次序，其时间复杂度可以突破 O(nlogn)，以线性时间运行。属于非比较类的有：\n\n排序算法时间复杂度最差情况最好情况空间复杂度排序方式稳定性\n\n桶排序O(n+nlog(n/r))O(n²)O(n)O(n+r)Out-place✔\n\n计数排序O(n+r)O(n+r)O(n+r)O(n+r)Out-place✔\n\n基数排序O(d(n+r))O(d(n+r))O(d(n+r))O(n+r)Out-place✔\n名词解释：\n时间/空间复杂度：描述一个算法执行时间/占用空间与数据规模的增长关系\nn：待排序列的个数\nr：“桶”的个数（上面的三种非比较类排序都是基于“桶”的思想实现的）\nd：待排序列的最高位数\nIn-place：原地算法，指的是占用常用内存，不占用额外内存。空间复杂度为 O(1) 的都可以认为是原地算法\nOut-place：非原地算法，占用额外内存\n稳定性：假设待排序列中两元素相等，排序前后这两个相等元素的相对位置不变，则认为是稳定的。\n冒泡排序冒泡排序（Bubble Sort），顾名思义，就是指越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法原理从左到右，依次比较相邻的元素大小，更大的元素交换到右边；\n从第一组相邻元素比较到最后一组相邻元素，这一步结束最后一个元素必然是参与比较的元素中最大的元素；\n按照大的居右原则，重新从左到后比较，前一轮中得到的最后一个元素不参与比较，得出新一轮的最大元素；\n按照上述规则，每一轮结束会减少一个元素参与比较，直到没有任何一组元素需要比较。\n动图演示\n代码实现12345678910void bubble_sort(int arr[], int n) &#123;    int i, j;    for (i = 0; i &lt; n - 1; i++) &#123;        for (j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr, j, j+1);            &#125;        &#125;    &#125;&#125;算法分析冒泡排序属于交换排序，是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n但是我们常看到冒泡排序的最优时间复杂度是 O(n)，那要如何优化呢？\n我们可以用一个 flag 参数记录新一轮的排序中元素是否做过交换，如果没有，说明前面参与比较过的元素已经是正序，那就没必要再从头比较了。代码实现如下：\n12345678910111213void bubble_sort_quicker(int arr[], int n) &#123;    int i, j, flag;    for (i = 0; i &lt; n - 1; i++) &#123;        flag = 0;        for (j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr, j, j+1);                flag = 1;            &#125;        &#125;        if (!flag) return;    &#125;&#125;快速排序快速排序（Quick Sort），是冒泡排序的改进版，之所以“快速”，是因为使用了分治法。它也属于交换排序，通过元素之间的位置交换来达到排序的目的。\n基本思想在序列中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。\n一趟快速排序的具体做法是：\n设两个指针 i 和 j，分别指向序列的头部和尾部；\n先从 j 所指的位置向前搜索，找到第一个比基准小的值，把它与基准交换位置；\n再从 i 所指的位置向后搜索，找到第一个比基准大的值，把它与基准交换位置；\n重复 2、3 两步，直到 i = j。\n仔细研究一下上述算法我们会发现，在排序过程中，对基准的移动其实是多余的，因为只有一趟排序结束时，也就是 i = j 的位置才是基准的最终位置。\n由此可以优化一下算法：\n设两个指针 i 和 j，分别指向序列的头部和尾部；\n先从 j 所指的位置向前搜索，找到第一个比基准小的数值后停下来，再从 i 所指的位置向后搜索，找到第一个比基准大的数值后停下来，把 i 和 j 指向的两个值交换位置；\n重复步骤 2，直到 i = j，最后将相遇点指向的值与基准交换位置。\n动图演示\n代码实现这里取序列的第一个元素为基准。\n123456789101112131415161718192021/* 选取序列的第一个元素作为基准 */int select_pivot(int arr[], int low) &#123;    return arr[low];&#125;void quick_sort(int arr[], int low, int high) &#123;    int i, j, pivot;    if (low &gt;= high) return;    pivot = select_pivot(arr, low);    i = low;    j = high;    while (i != j) &#123;        while (arr[j] &gt;= pivot &amp;&amp; i &lt; j) j--;        while (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;        if (i &lt; j) swap(arr, i, j);    &#125;    arr[low] = arr[i];    arr[i] = pivot;    quick_sort(arr, low, i - 1);    quick_sort(arr, i + 1, high);&#125;算法分析快速排序是不稳定排序，它的平均时间复杂度为 O(nlogn)，平均空间复杂度为 O(logn)。\n快速排序中，基准的选取非常重要，它将影响排序的效率。举个例子，假如序列本身顺序随机，快速排序是所有同数量级时间复杂度的排序算法中平均性能最好的，但如果序列本身已经有序或基本有序，直接选取固定位置，例如第一个元素作为基准，会使快速排序就会沦为冒泡排序，时间复杂度为 O(n²)。为了避免发生这种情况，引入下面两种获取基准的方法：\n随机选取\n就是选取序列中的任意一个数为基准的值。\n12345678/* 随机选择基准的位置，区间在 low 和 high 之间 */int select_pivot_random(int arr[], int low, int high) &#123;    srand((unsigned)time(NULL));    int pivot = rand()%(high - low) + low;    swap(arr, pivot, low);        return arr[low];&#125;三者取中\n就是取起始位置、中间位置、末尾位置指向的元素，对这三个元素排序后取中间数作为基准。\n1234567891011/* 取起始位置、中间位置、末尾位置指向的元素三者的中间值作为基准 */int select_pivot_median_of_three(int arr[], int low, int high) &#123;    // 计算数组中间的元素的下标    int mid = low + ((high - low) &gt;&gt; 1);    // 排序，使 arr[mid] &lt;= arr[low] &lt;= arr[high]    if (arr[mid] &gt; arr[high]) swap(arr, mid, high);    if (arr[low] &gt; arr[high]) swap(arr, low, high);    if (arr[mid] &gt; arr[low]) swap(arr, low, mid);    // 使用 low 位置的元素作为基准    return arr[low];&#125;经验证明，三者取中的规则可以大大改善快速排序在最坏情况下的性能。\n插入排序直接插入排序（Straight Insertion Sort），是一种简单直观的排序算法，它的基本操作是不断地将尚未排好序的数插入到已经排好序的部分，好比打扑克牌时一张张抓牌的动作。在冒泡排序中，经过每一轮的排序处理后，序列后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，序列前端的数都是排好序的。\n基本思想先将第一个元素视为一个有序子序列，然后从第二个元素起逐个进行插入，直至整个序列变成元素非递减有序序列为止。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入大相等元素的后面。整个排序过程进行 n-1 趟插入。\n动图演示\n代码实现123456789void insertion_sort(int arr[], int n) &#123;    int i, j, temp;    for (i = 1; i &lt; n; i++) &#123;        temp = arr[i];        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; j--)            arr[j] = arr[j - 1];        arr[j] = temp;    &#125;&#125;算法分析插入排序是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n希尔排序希尔排序（Shell’s Sort）是第一个突破 O(n²) 的排序算法，是直接插入排序的改进版，又称“缩小增量排序”（Diminishing Increment Sort）。它与直接插入排序不同之处在于，它会优先比较距离较远的元素。\n基本思想先将整个待排序列分割成若干个字序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。\n子序列的构成不是简单地“逐段分割”，将相隔某个增量的记录组成一个子序列，让增量逐趟缩短，直到增量为 1 为止。\n动图演示\n代码实现增量序列可以有各种取法，例如上面动图所示，增量序列满足 [n / 2, n / 2 / 2, …, 1]，n 是序列本身的长度，这也是一种比较流行的增量序列定义方式。这时希尔排序的算法可以通过下面的代码实现：\n1234567891011void shell_sort_split_half(int arr[], int n) &#123;    int i, j, dk, temp;    for (dk = n &gt;&gt; 1; dk &gt; 0; dk = dk &gt;&gt; 1) &#123;        for (i = dk; i &lt; n; i++) &#123;            temp = arr[i];            for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= dk)                arr[j + dk] = arr[j];            arr[j + dk] = temp;        &#125;    &#125;&#125;增量序列也可以有其它的定义方式，那么希尔排序的实现可以归纳成这样：\n1234567891011121314151617181920void shell_insert(int arr[], int n, int dk) &#123;    int i, j, temp;    for (i = dk; i &lt; n; i += dk) &#123;        temp = arr[i];        j = i - dk;        while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123;            arr[j + dk] = arr[j];            j -= dk;        &#125;        arr[j + dk] = temp;    &#125;&#125;void shell_sort(int arr[], int n, int dlta[], int t) &#123;    int k;    for (k = 0; k &lt; t; ++k) &#123;        // 一趟增量为 dlta[k] 的插入排序        shell_insert(arr, n, dlta[k]);    &#125;&#125;算法分析希尔排序是不稳定排序，它的分析是一个复杂的问题，因为它的运行时间依赖于增量序列的选择，它的平均时间复杂度为 O(n^1.3)，最好情况是 O(n)，最差情况是 O(n²)。空间复杂度为 O(1)。\n选择排序选择排序（Selection Sort）是一种简单直观的排序算法。它的基本思想就是，每一趟 n-i+1(i=1,2,…,n-1) 个记录中选取关键字最小的记录作为有序序列的第 i 个记录。\n算法步骤简单选择排序：\n在未排序序列中找到最小（大）元素，存放到排序序列的起始位置;\n在剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾;\n重复步骤 2，直到所有元素排序完毕。\n动图演示\n代码实现1234567891011void selection_sort(int arr[], int n) &#123;    int i, j;    for (i = 0; i &lt; n - 1; i++) &#123;        int min = i;        for (j = i + 1; j &lt; n; j++) &#123;            if (arr[j] &lt; arr[min])                min = j;        &#125;        swap(arr, min, i);    &#125;&#125;算法分析选择排序是不稳定排序，时间复杂度固定为 O(n²)，因此它不适用于数据规模较大的序列。不过它也有优点，就是不占用额外的内存空间。\n堆排序堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆的特点：\n一颗完全二叉树（也就是会所生成节点的顺序是：从上往下、从左往右）\n每一个节点必须满足父节点的值不大于/不小于子节点的值\n基本思想实现堆排序需要解决两个问题：\n如何将一个无序序列构建成堆？\n如何在输出堆顶元素后，调整剩余元素成为一个新的堆？\n以升序为例，算法实现的思路为：\n建立一个 build_heap 函数，将数组 tree[0,…n-1] 建立成堆，n 表示数组长度。函数里需要维护的是所有节点的父节点，最后一个子节点下标为 n-1，那么它对应的父节点下标就是 (n-1-1)/2。\n构建完一次堆后，最大元素就会被存放在根节点 tree[0]。将 tree[0] 与最后一个元素交换，每一轮通过这种不断将最大元素后移的方式，来实现排序。\n而交换后新的根节点可能不满足堆的特点了，因此需要一个调整函数 heapify 来对剩余的数组元素进行最大堆性质的维护。如果 tree[i] 表示其中的某个节点，那么 tree[2i+1] 是左孩子，tree[2i+2] 是右孩子，选出三者中的最大元素的下标，存放于 max 值中，若 max 不等于 i，则将最大元素交换到 i 下标的位置。但是，此时以 tree[max] 为根节点的子树可能不满足堆的性质，需要递归调用自身。\n动图演示\n代码实现12345678910111213141516171819202122232425262728293031323334353637void heapify(int tree[], int n, int i) &#123;    // n 表示序列长度，i 表示父节点下标    if (i &gt;= n) return;    // 左侧子节点下标    int left = 2 * i + 1;    // 右侧子节点下标    int right = 2 * i + 2;    int max = i;    if (left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left;    if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right;    if (max != i) &#123;        swap(tree, max, i);        heapify(tree, n, max);    &#125;&#125;void build_heap(int tree[], int n) &#123;    // 树最后一个节点的下标    int last_node = n - 1;    // 最后一个节点对应的父节点下标    int parent = (last_node - 1) / 2;    int i;    for (i = parent; i &gt;= 0; i--) &#123;        heapify(tree, n, i);    &#125;&#125;void heap_sort(int tree[], int n) &#123;    build_heap(tree, n);    int i;    for (i = n - 1; i &gt;= 0; i--) &#123;        // 将堆顶元素与最后一个元素交换        swap(tree, i, 0);        // 调整成大顶堆        heapify(tree, i, 0);    &#125;&#125;算法分析堆排序是不稳定排序，适合数据量较大的序列，它的平均时间复杂度为 Ο(nlogn)，空间复杂度为 O(1)。堆排序仅需一个记录大小供交换用的辅助存储空间。\n归并排序归并排序（Merge Sort）是建立在归并操作上的一种排序算法。它和快速排序一样，采用了分治法。\n基本思想归并的含义是将两个或两个以上的有序表组合成一个新的有序表。也就是说，从几个数据段中逐个选出最小的元素移入新数据段的末尾，使之有序。\n那么归并排序的算法我们可以这样理解：\n假如初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1。然后两两归并，得到 n/2 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直到得到一个长度为 n 的有序序列为止，这种排序方法称为 二路归并排序，下文介绍的也是这种排序方式。\n动图演示\n代码实现123456789101112131415161718192021222324252627/* 将 arr[L..M] 和 arr[M+1..R] 归并 */void merge(int arr[], int L, int M, int R) &#123;    int LEFT_SIZE = M - L + 1;    int RIGHT_SIZE = R - M;    int left[LEFT_SIZE];    int right[RIGHT_SIZE];    int i, j, k;    // 以 M 为分割线，把原数组分成左右子数组    for (i = L; i &lt;= M; i++) left[i - L] = arr[i];    for (i = M + 1; i &lt;= R; i++) right[i - M - 1] = arr[i];    // 再合并成一个有序数组（从两个序列中选出最小值依次插入）    i = 0; j = 0; k = L;    while (i &lt; LEFT_SIZE &amp;&amp; j &lt; RIGHT_SIZE) arr[k++] = left[i] &lt; right[j] ? left[i++] : right[j++];    while (i &lt; LEFT_SIZE) arr[k++] = left[i++];    while (j &lt; RIGHT_SIZE) arr[k++] = right[j++];&#125;void merge_sort(int arr[], int L, int R) &#123;    if (L == R) return;    // 将 arr[L..R] 平分为 arr[L..M] 和 arr[M+1..R]    int M = (L + R) / 2;    // 分别递归地将子序列排序为有序数列    merge_sort(arr, L, M);    merge_sort(arr, M + 1, R);    // 将两个排序后的子序列再归并到 arr    merge(arr, L, M, R);&#125;算法分析归并排序是稳定排序，它和选择排序一样，性能不受输入数据的影响，但表现比选择排序更好，它的时间复杂度始终为 O(nlogn)，但它需要额外的内存空间，空间复杂度为 O(n)。\n桶排序桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（也有可能是使用别的排序算法或是以递归方式继续用桶排序进行排序）。\n算法步骤设置固定数量的空桶；\n把数据放在对应的桶内；\n分别对每个非空桶内数据进行排序；\n拼接非空的桶内数据，得到最终的结果。\n动图演示\n代码实现123456789101112131415161718192021222324252627282930313233void bucket_sort(int arr[], int n, int r) &#123;    if (arr == NULL || r &lt; 1) return;    // 根据最大/最小元素和桶数量，计算出每个桶对应的元素范围    int max = arr[0], min = arr[0];    int i, j;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    int range = (max - min + 1) / r + 1;    // 建立桶对应的二维数组，一个桶里最多可能出现 n 个元素    int buckets[r][n];    memset(buckets, 0, sizeof(buckets));    int counts[r];    memset(counts, 0, sizeof(counts));    for (i = 0; i &lt; n; i++) &#123;        int k = (arr[i] - min) / range;        buckets[k][counts[k]++] = arr[i];    &#125;    int index = 0;    for (i = 0; i &lt; r; i++) &#123;        // 分别对每个非空桶内数据进行排序，比如计数排序        if (counts[i] == 0) continue;        counting_sort(buckets[i], counts[i]);        // 拼接非空的桶内数据，得到最终的结果        for (j = 0; j &lt; counts[i]; j++) &#123;            arr[index++] = buckets[i][j];        &#125;    &#125;&#125;算法分析桶排序是稳定排序，但仅限于桶排序本身，假如桶内排序采用了快速排序之类的非稳定排序，那么就是不稳定的。\n时间复杂度桶排序的时间复杂度可以这样看：\nn 次循环，每个数据装入桶\nr 次循环，每个桶中的数据进行排序（每个桶中平均有 n/r 个数据）\n假如桶内排序用的是选择排序这类时间复杂度较高的排序，整个桶排序的时间复杂度就是 O(n)+O(n²)，视作 O(n²)，这是最差的情况；\n假如桶内排序用的是比较先进的排序算法，时间复杂度为 O(nlogn)，那么整个桶排序的时间复杂度为 O(n)+O(r(n/r)log(n/r))=O(n+nlog(n/r))。k=nlog(n/r)，桶排序的平均时间复杂度为 O(n+k)。当 r 接近于 n 时，k 趋近于 0，这时桶排序的时间复杂度是最优的，就可以认为是 O(n)。也就是说如果数据被分配到同一个桶中，排序效率最低；但如果数据可以均匀分配到每一个桶中，时间效率最高，可以线性时间运行。但同样地，桶越多，空间就越大。\n空间复杂度占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以桶排序的空间复杂度为 O(n+r)。\n计数排序计数排序（Counting Sort）是一种非比较性质的排序算法，利用了桶的思想。它的核心在于将输入的数据值转化为键存储在额外开辟的辅助空间中，也就是说这个辅助空间的长度取决于待排序列中的数据范围。\n如何转化成桶思想来理解呢？我们设立 r 个桶，桶的键值分别对应从序列最小值升序到最大值的所有数值。接着，按照键值，依次把元素放进对应的桶中，然后统计出每个桶中分别有多少元素，再通过对桶内数据的计算，即可确定每一个元素最终的位置。\n算法步骤找出待排序列中最大值 max 和最小值 min，算出序列的数据范围 r = max - min + 1，申请辅助空间 C[r]；\n遍历待排序列，统计序列中每个值为 i 的元素出现的次数，记录在辅助空间的第 i 位；\n对辅助空间内的数据进行计算（从空间中的第一个元素开始，每一项和前一项相加），以确定值为 i 的元素在数组中出现的位置；\n反向填充目标数组：将每个元素 i 放在目标数组的第 C[i] 位，每放一个元素就将 C[i] 减 1，直到 C 中所有值都是 0\n动图演示\n代码实现1234567891011121314151617181920212223void counting_sort(int arr[], int n) &#123;    if (arr == NULL) return;    // 定义辅助空间并初始化    int max = arr[0], min = arr[0];    int i;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    int r = max - min + 1;    int C[r];    memset(C, 0, sizeof(C));    // 定义目标数组    int R[n];    // 统计每个元素出现的次数    for (i = 0; i &lt; n; i++) C[arr[i] - min]++;    // 对辅助空间内数据进行计算    for (i = 1; i &lt; r; i++) C[i] += C[i - 1];    // 反向填充目标数组    for (i = n - 1; i &gt;= 0; i--) R[--C[arr[i] - min]] = arr[i];    // 目标数组里的结果重新赋值给 arr    for (i = 0; i &lt; n; i++) arr[i] = R[i];&#125;算法分析计数排序属于非交换排序，是稳定排序，适合数据范围不显著大于数据数量的序列。\n时间复杂度它的时间复杂度是线性的，为 O(n+r)，r 表示待排序列中的数据范围，也就是桶的个数。可以这样理解：将 n 个数据依次放进对应的桶中，再从 r 个桶中把数据按顺序取出来。\n空间复杂度占用额外内存，还需要 r 个桶，因此空间复杂度是 O(n+r)，计数排序快于任何比较排序算法，但这是通过牺牲空间换取时间来实现的。\n基数排序基数排序（Radix Sort）是非比较型排序算法，它和计数排序、桶排序一样，利用了“桶”的概念。基数排序不需要进行记录关键字间的比较，是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。比如数字 100，它的个位、十位、百位就是不同的关键字。\n那么，对于一组乱序的数字，基数排序的实现原理就是将整数按位数（关键字）切割成不同的数字，然后按每个位数分别比较。对于关键字的选择，有最高位优先法（MSD 法）和最低位优先法（LSD 法）两种方式。MSD 必须将序列先逐层分割成若干子序列，然后再对各子序列进行排序；而 LSD 进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序。\n算法步骤以 LSD 法为例：\n将所有待比较数值（非负整数）统一为同样的数位长度，数位不足的数值前面补零\n从最低位（个位）开始，依次进行一次排序\n从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n如果要支持负数参加排序，可以将序列中所有的值加上一个常数，使这些值都成为非负数，排好序后，所有的值再减去这个常数。\n动图演示\n代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 基数，范围0~9#define RADIX 10void radix_sort(int arr[], int n) &#123;    // 获取最大值和最小值    int max = arr[0], min = arr[0];    int i, j, l;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    // 假如序列中有负数，所有数加上一个常数，使序列中所有值变成正数    if (min &lt; 0) &#123;        for (i = 0; i &lt; n; i++) arr[i] -= min;        max -= min;    &#125;    // 获取最大值位数    int d = 0;    while (max &gt; 0) &#123;        max /= RADIX;        d ++;    &#125;    int queue[RADIX][n];    memset(queue, 0, sizeof(queue));    int count[RADIX] = &#123;0&#125;;    for (i = 0; i &lt; d; i++) &#123;        // 分配数据        for (j = 0; j &lt; n; j++) &#123;            int key = arr[j] % (int)pow(RADIX, i + 1) / (int)pow(RADIX, i);            queue[key][count[key]++] = arr[j];        &#125;        // 收集数据        int c = 0;        for (j = 0; j &lt; RADIX; j++) &#123;            for (l = 0; l &lt; count[j]; l++) &#123;                arr[c++] = queue[j][l];                queue[j][l] = 0;            &#125;            count[j] = 0;        &#125;    &#125;    // 假如序列中有负数，收集排序结果时再减去前面加上的常数    if (min &lt; 0) &#123;        for (i = 0; i &lt; n; i++) arr[i] += min;    &#125;&#125;算法分析基数排序是稳定排序，适用于关键字取值范围固定的排序。\n时间复杂度基数排序可以看作是若干次“分配”和“收集”的过程。假设给定 n 个数，它的最高位数是 d，基数（也就是桶的个数）为 r，那么可以这样理解：共进行 d 趟排序，每趟排序都要对 n 个数据进行分配，再从 r 个桶中收集回来。所以算法的时间复杂度为 O(d(n+r))，在整数的排序中，r = 10，因此可以简化成 O(dn)，是线性阶的排序。\n空间复杂度占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以基数排序的空间复杂度为 O(n+r)。\n计数排序 &amp; 桶排序 &amp; 基数排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n桶排序：每个桶存储一定范围的数值，适用于元素尽可能分布均匀的排序；\n计数排序：每个桶只存储单一键值，适用于最大值和最小值尽可能接近的排序；\n基数排序：根据键值的每位数字来分配桶，适用于非负整数间的排序，且最大值和最小值尽可能接近。\n\n本文关联项目地址\n","thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/c/fm.png","plink":"https://dxsummer.gitee.io/posts/942e5b03/"},{"title":"Step7 函数","date":"2020-06-10T12:21:48.000Z","date_formatted":{"ll":"2020年6月10日","L":"2020/06/10","MM-DD":"06-10"},"updated":"2020-06-12T09:59:08.522Z","content":"本章介绍以下内容：\n关键字：return\n运算符：*（一元）、&amp;（一元）\n函数及其定义方式\n如何使用参数和返回值\n如何把指针变量用作函数参数\n函数类型\nANSI C原型\n递归\n如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C标准库的函数，如printf()、scanf()、getchar()、putchar()和 strlen()。现在要进一步学习如何创建自己的函数。前面章节中已大致介绍了相关过程，本章将巩固以前学过的知识并做进一步的拓展。\n复习函数首先，什么是函数？函数（function）是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如printf()把数据打印到屏幕上；一些函数找出一个值供程序使用，如strlen()把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。\n为什么要使用函数？首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用putchar()一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。例如，假设要编写一个程序完成以下任务：\n读入一系列数字；\n分类这些数字；\n找出这些数字的平均值；\n打印一份柱状图。\n可以使用下面的程序：\n1234567891011#include　&lt;stdio.h&gt;#define　SIZE　50int main(void)&#123;    float list[SIZE];    readlist(list,SIZE);    sort(list,SIZE);    average(list,SIZE);    bargraph(list,SIZE);    returnb 0;&#125;当然，还要编写4个函数readlist()、sort()、average()和bargraph()的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。\n许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及 printf()生成的输出，无需了解 printf()的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。\n如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何建立函数间的通信。我们从一个简单的程序示例开始，帮助读者理清这些内容，然后再详细讲解。\n创建并使用简单函数我们的第1个目标是创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数。如程序清单9.1所示，该程序由main()和starbar()组成。\n程序清单9.1 lethead1.c程序\n1234567891011121314151617181920212223/* lethead1.c */#include　&lt;stdio.h&gt;#define NAME　\"GIGATHINK, INC.\"#define ADDRESS　\"101　Megabuck　Plaza\"#define PLACE　\"Megapolis,　CA　94904\"#define WIDTH　40void starbar(void);　/* 函数原型 */int main(void)&#123;    starbar();    printf(\"%s\\n\",NAME);    printf(\"%s\\n\",ADDRESS);    printf(\"%s\\n\",PLACE);    starbar();　　　/* 使用函数 */    return　0;&#125;void starbar(void)　/* 定义函数　 */&#123;    int　count;    for(count=1;count&lt;=WIDTH;count++)    putchar('*');    putchar('\\n');&#125;该程序的输出如下：\n12345****************************************GIGATHINK,　INC.101　Megabuck　PlazaMegapolis,　CA　94904****************************************分析程序该程序要注意以下几点。\n程序在3处使用了starbar标识符：函数原型（function prototype）告诉编译器函数starbar()的类型；函数调用（function call）表明在此处执行函数；函数定义（function definition）明确地指定了函数要做什么。\n函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。因此，在main()函数定义的前面出现了下面的ANSI C风格的函数原型：\n1void starbar(void);圆括号表明starbar是一个函数名。第1个void是函数类型，void类型表明函数没有返回值。第2个void（在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为starbar()、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。对于不识别ANSI C风格原型的编译器，只需声明函数的类型，如下所示：\n1void starbar();注意，一些老版本的编译器甚至连void都识别不了。如果使用这种编译器，就要把没有返回值的函数声明为int类型。当然，最好还是换一个新的编译器。\n一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。对于starbar()函数而言，其签名是该函数没有返回值，没有参数。\n程序把 starbar()原型置于 main()的前面。当然，也可以放在 main()里面的声明变量处。放在哪个位置都可以。\n在main()中，执行到下面的语句时调用了starbar()函数：\n1starbar();这是调用void类型函数的一种形式。当计算机执行到starbar();语句时，会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调函数（calling function）继续执行下一行（本例中，主调函数是main()），见图9.1（更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码）。\n\n程序中strarbar()和main()的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束（见图9.2）。注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()，而不是调用函数或声明函数原型。\n\n程序把 starbar()和 main()放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把#define 和#include 指令也放入该文件。我们稍后会讨论使用多个文件的情况。现在，先把所有的函数都放在一个文件中。main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数。\nstarbar()函数中的变量count是局部变量（local variable），意思是该变量只属于starbar()函数。可以在程序中的其他地方（包括main()中）使用count，这不会引起名称冲突，它们是同名的不同变量。\n如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号。不用给该函数提供任何输入，因为调用它不需要其他信息。而且，它没有返回值，所以也不给 main()提供（或返回）任何信息。简而言之，starbar()不需要与主调函数通信。\n接下来介绍一个函数间需要通信的例子。\n函数参数在程序清单9.1的输出中，如果文字能居中，信头会更加美观。可以通过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号（starbar()函数）类似，只不过现在要打印的是一定数量的空格。虽然这是两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个更通用的函数，可以在两种情况下使用。我们设计一个新的函数show_n_char()（显示一个字符n次）。唯一要改变的是使用内置的值来显示字符和重复的次数，show_n_char()将使用函数参数来传递这些值。\n我们来具体分析。假设可用的空间是40个字符宽。调用show_n_char(&#39;*&#39;, 40)应该正好打印一行40个星号，就像starbar()之前做的那样。第2行GIGATHINK, INT.的空格怎么处理？GIGATHINK, INT.是15个字符宽，所以第1个版本中，文字后面有25个空格。为了让文字居中，文字的左侧应该有12个空格，右侧有13个空格。因此，可以调用show_n_char(&#39;*&#39;, 12)。\nshow_n_char()与starbar()很相似，但是show_n_char()带有参数。从功能上看，前者不会添加换行符，而后者会，因为show_n_char()要把空格和文本打印成一行。程序清单9.2是修改后的版本。为强调参数的工作原理，程序使用了不同的参数形式。\n程序清单9.2 lethead2.c程序\n123456789101112131415161718192021222324252627282930313233/* lethead2.c */#include　&lt;stdio.h&gt;#include &lt;string.h&gt;　　　　　/* 为strlen()提供原型 */#define　NAME　\"GIGATHINK,　INC.\"#define　ADDRESS　\"101　Megabuck　Plaza\"#define　PLACE　\"Megapolis,　CA　94904\"#define　WIDTH　40#define　SPACE　'　'void show_n_char(char　ch,　int　num);int main(void)&#123;    int spaces;    show_n_char('*', WIDTH);　　　　　　　　/* 用符号常量作为参数 */    putchar('\\n');    show_n_char(SPACE, 12);　　　　　　　　 /* 用符号常量作为参数 */    printf(\"%s\\n\",　NAME);    spaces = (WIDTH - strlen(ADDRESS))/2; /* 计算要跳过多少个空格*/    show_n_char(SPACE, spaces);　　　　　　 /* 用一个变量作为参数*/    printf(\"%s\\n\",　ADDRESS);    show_n_char(SPACE,(WIDTH-strlen(PLACE))/2);    printf(\"%s\\n\", PLACE);　　　　　　　　　/* 用一个表达式作为参数　 */    show_n_char('*', WIDTH);    putchar('\\n');    return 0;&#125;/* show_n_char()函数的定义 */void show_n_char(char ch,int num)&#123;    int count;    for(count=1;count&lt;=num;count++)    putchar(ch);&#125;该函数的运行结果如下：\n12345**************************************\t\tGIGATHINK,　INC.\t  101　Megabuck　Plaza\t Megapolis,　CA　94904****************************************下面我们回顾一下如何编写一个带参数的函数，然后介绍这种函数的用法。\n定义带形式参数的函数函数定义从下面的ANSI C风格的函数头开始：\n1void show_n_char(char ch,int num)该行告知编译器show_n_char()使用两个参数ch和num，ch是char类型，num是int类型。这两个变量被称为形式参数（formal argument，但是最近的标准推荐使用formal parameter），简称形参。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。\n注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：\n12void dibs(int x, y, z)　　　　 /* 无效的函数头 */void dubs(int x, int y, int z) /* 有效的函数头 */ANSI C也接受ANSI C之前的形式，但是将其视为废弃不用的形式：\n123void show_n_char(ch,num)char ch;int num;这里，圆括号中只有参数名列表，而参数的类型在后面声明。注意，普通的局部变量在左花括号之后声明，而上面的变量在函数左花括号之前声明。如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：\n12void dibs(x,y,z)int x,y,z;　　　/* 有效 */当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序，但是自己编写程序时应使用现在的标准形式（C99和C11标准继续警告这些过时的用法即将被淘汰）。\n虽然show_n_char()接受来自main()的值，但是它没有返回值。因此，show_n_char()的类型是void。\n下面，我们来学习如何使用函数。\n声明带形式参数函数的原型在使用函数之前，要用ANSI C形式声明函数原型：\n1void show_n_char(char ch, int num);当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：\n1void show_n_char(char, int);在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。再次提醒读者注意，ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：\n1void show_n_char();这种形式最终会从标准中剔除。即使没有被剔除，现在函数原型的设计也更有优势（稍后会介绍）。了解这种形式的写法是为了以后读得懂以前写的代码。\n调用带实际参数的函数在函数调用中，实际参数（actual argument，简称实参）提供了ch和num的值。考虑程序清单9.2中第1次调用show_n_char()：\n1show_n_char(SPACE,12);实际参数是空格字符和12。这两个值被赋给show_n_char()中相应的形式参数：变量ch和num。简而言之，形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。以程序清单 9.2 中最后一次调用show_n_char()为例：\n1show_n_char(SPACE,(WIDTH - strlen(PLACE))/2);构成该函数第2个实际参数的是一个很长的表达式，对该表达式求值为10。然后，10被赋给变量num。被调函数不知道也不关心传入的数值是来自常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋给作为形式参数的变量（见图 9.3）。因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。\n注意 实际参数和形式参数\n\n实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。程序清单 9.2 中，&#39;*&#39;和WIDTH都是第1次调用show_n_char()时的实际参数，而SPACE和11是第2次调用show_n_char()时的实际参数。在函数定义中，ch和num都是该函数的形式参数。\n黑盒视角从黑盒的视角看 show_n_char()，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在 main()中使用该函数。而且，这也可以作为编写该函数的设计说明。\n黑盒方法的核心部分是：ch、num和count都是show_n_char()私有的局部变量。如果在main()中使用同名变量，那么它们相互独立，互不影响。也就是说，如果main()有一个count变量，那么改变它的值不会改变show_n_char()中的count，反之亦然。黑盒里发生了什么对主调函数是不可见的。\n使用return从函数中返回值前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理int类型的值，所以被命名为imin()。另外，还要创建一个简单的main()，用于检查imin()是否正常工作。这种被设计用于测试函数的程序有时被称为驱动程序（driver），该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。程序清单9.3演示了这个驱动程序和返回最小值的函数。\n程序清单9.3 lesser.c程序\n1234567891011121314151617181920212223242526/* lesser.c -- 找出两个整数中较小的一个 */#include　&lt;stdio.h&gt;int imin(int,int);int main(void)&#123;    int evil1,evil2;    printf(\"Enter　a　pair　of　integers　(q　to　quit):\\n\");    while(scanf(\"%d　%d\",&amp;evil1,&amp;evil2)　==　2)    &#123;        printf(\"The　lesser　of　%d　and　%d　is　%d.\\n\",        evil1,evil2,imin(evil1,evil2));        printf(\"Enter　a　pair　of　integers　(q　to　quit):\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;int imin(int　n,　int　m)&#123;    int min;    if(n　&lt;　m)    \tmin　=　n;    else    \tmin　=　m;    return min;&#125;回忆一下，scanf()返回成功读数据的个数，所以如果输入不是两个整数会导致循环终止。下面是一个运行示例：\n123456789Enter　a　pair　of　integers　(q　to　quit):509　333The　lesser　of　509　and　333　is　333.Enter　a　pair　of　integers　(q　to　quit):-9393　6The　lesser　of　-9393　and　6　is　-9393.Enter　a　pair　of　integers　(q　to　quit):qBye.关键字return后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量min的值。因为min是int类型的变量，所以imin()函数的类型也是int。\n变量min属于imin()函数私有，但是return语句把min的值传回了主调函数。下面这条语句的作用是把min的值赋给lesser:\n1lesser = imin(n,m);是否能像写成下面这样：\n12imin(n,m);lesser = min;不能。因为主调函数甚至不知道min的存在。记住，imin()中的变量是imin()的局部变量。函数调用imin(evil1, evil2)只是把两个变量的值拷贝了一份。\n返回值不仅可以赋给变量，也可以被用作表达式的一部分。例如，可以这样：\n12answer = 2 * imin(z, zstar) + 25;printf(\"%d\\n\", imin(-32 + answer, LIMIT));返回值不一定是变量的值，也可以是任意表达式的值。例如，可以用以下的代码简化程序示例：\n12345/* 返回最小值的函数，第2个版本 */imin(int n,int m)&#123;return (n&lt;m)?n:m;&#125;条件表达式的值是n和m中的较小者，该值要被返回给主调函数。虽然这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。\n如果函数返回值的类型与函数声明的类型不匹配会怎样？\n12345int what_if(int n)&#123;    double z=100.0/(double)n;    return z; // 会发生什么？&#125;实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：\n1result=what_if(64);虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。\n使用 return 语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。因此，可以这样编写imin()：\n123456789/*返回最小值的函数，第3个版本*/imin(int n,int m)&#123;    if(n　&lt;　m)    \treturn　n;    else    \treturn　m;&#125;许多C程序员都认为只在函数末尾使用一次return语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个return语句也没有错。无论如何，对用户而言，这3个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：\n12345678910/*返回最小值的函数，第4个版本*/imin(int　n,int　m)&#123;    if(n&lt;m)    \treturn　n;    else    \treturn　m;    printf(\"Professor　Fleppard　is　like　totally　a　fopdoodle.\\n\");&#125;return语句导致printf()语句永远不会被执行。如果Fleppard教授在自己的程序中使用这个版本的函数，可能永远不知道编写这个函数的学生对他的看法。\n另外，还可以这样使用return：\n1return;这条语句会导致终止函数，并把控制返回给主调函数。因为 return 后面没有任何表达式，所以没有返回值，只有在void函数中才会用到这种形式。\n函数类型声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int。这一惯例源于C的早期，那时的函数绝大多数都是int类型。然而，C99标准不再支持int类型函数的这种假定设置。\n类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。例如，下面的函数头定义了一个带两个int类型参数的函数，但是其返回值是double类型。\n1double klink(int a, int b)要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。例如，程序清单 9.3 中的main()函数包含以下几行代码：\n12345#include　&lt;stdio.h&gt;int imin(int,int);int main(void)&#123;    int evil1,evil2,lesser;第2行代码说明imin是一个函数名，有两个int类型的形参，且返回int类型的值。现在，编译器在程序中调用imin()函数时就知道应该如何处理。\n在程序清单9.3中，我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。例如，重写lesser.c（程序清单9.3）的开头部分：\n12345#include　&lt;stdio.h&gt;int main(void)&#123;    int imin(int, int); /* 声明imin()函数的原型*/    int evil1,evil2,lesser;注意在这两种情况中，函数原型都声明在使用函数之前。\nANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，stdio.h 头文件包含了标准 I/O 库函数（如，printf()和scanf()）的声明。math.h头文件包含了各种数学函数的声明。例如，下面的声明：\n1double sqrt(double);告知编译器sqrt()函数有一个double类型的形参，而且返回double类型的值。不要混淆函数的声明和定义。函数声明告知编译器函数的类型，而函数定义则提供实际的代码。在程序中包含 math.h 头文件告知编译器：sqrt()返回double类型，但是sqrt()函数的代码在另一个库函数的文件中。\nANSI C函数原型在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。\n下面是ANSI之前的函数声明，告知编译器imin()返回int类型的值：\n1int imin();然而，以上函数声明并未给出imin()函数的参数个数和类型。因此，如果调用imin()时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。\n问题所在我们看看与imax()函数相关的一些示例，该函数与imin()函数关系密切。程序清单9.4演示了一个程序，用过去声明函数的方式声明了imax()函数，然后错误地使用该函数。\n12345678910111213141516程序清单9.4 misuse.c程序/* misuse.c -- 错误地使用函数 */#include　&lt;stdio.h&gt;int imax();　　 /* 旧式函数声明 */int　main(void)&#123;    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",3,　5,　imax(3));    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",3,　5,　imax(3.0,　5.0));    return 0;&#125;int imax(n,m)int n,m;&#123;\treturn (n&gt;m?n:m);&#125;第1次调用printf()时省略了imax()的一个参数，第2次调用printf()时用两个浮点参数而不是整数参数。尽管有些问题，但程序可以编译和运行。\n下面是使用Xcode 4.6运行的输出示例：\n12The maximum　of　3　and　5　is　1606416656.The　maximum　of　3　and　5　is　3886.使用gcc运行该程序，输出的值是1359379472和1359377160。这两个编译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用函数原型。\n到底是哪里出了问题？由于不同系统的内部机制不同，所以出现问题的具体情况也不同。下面介绍的是使用P C和VA X的情况。主调函数把它的参数储存在被称为栈（stack）的临时存储区，被调函数从栈中读取这些参数。对于该例，这两个过程并未相互协调。主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值。因此，函数调用imax(3)把一个整数放在栈中。当imax()函数开始执行时，它从栈中读取两个整数。而实际上栈中只存放了一个待读取的整数，所以读取的第 2 个值是当时恰好在栈中的其他值。\n第2次使用imax()函数时，它传递的是float类型的值。这次把两个double类型的值放在栈中（回忆一下，当float类型被作为参数传递时会被升级为double类型）。在我们的系统中，两个double类型的值就是两个64位的值，所以128位的数据被放在栈中。当imax()从栈中读取两个int类型的值时，它从栈中读取前64位。在我们的系统中，每个int类型的变量占用32位。这些数据对应两个整数，其中较大的是3886。\nANSI的解决方案针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用函数原型（function prototype）来声明函数的返回类型、参数的数量和每个参数的类型。未标明 imax()函数有两个 int 类型的参数，可以使用下面两种函数原型来声明：\n12int imax(int, int);int imax(int a, int b);第1种形式使用以逗号分隔的类型列表，第2种形式在类型后面添加了变量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。\n有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以 imax()为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，imax(3.0, 5.0)会被转换成imax(3, 5)。我们用函数原型替换程序清单9.4中的函数声明，如程序清单9.5所示。\n程序清单9.5 proto.c程序\n12345678910111213141516/* proto.c -- 使用函数原型 */#include　&lt;stdio.h&gt;int imax(int, int);　　　 /* 函数原型 */int main(void)&#123;    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",    3,　5,　imax(3));    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",    3,　5,　imax(3.0,　5.0));    return 0;&#125;int imax(int　n,　int　m)&#123;\treturn (n　&gt;　m　?　n　:　m);&#125;编译程序清单9.5时，我们的编译器给出调用的imax()函数参数太少的错误消息。\n如果是类型不匹配会怎样？为探索这个问题，我们用imax(3, 5)替换imax(3)，然后再次编译该程序。这次编译器没有给出任何错误信息，程序的输出如下：\n12The maximum of 3 and 5 is 5.The maximum of 3 and 5 is 5.如上文所述，第2次调用中的3.0和5.0被转换成3和5，以便函数能正确地处理输入。\n虽然没有错误消息，但是我们的编译器还是给出了警告：double转换成int可能会导致丢失数据。例如，下面的函数调用：\n1imax(3.9, 5.4)相当于:\n1imax(3, 5)错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时的详细程度。\n无参数和未指定参数假设有下面的函数原型：\n1void print_name();一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用void关键字：\n1void print_name(void);支持ANSI C的编译器解释为print_name()不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。\n一些函数接受（如，printf()和scanf()）许多参数。例如对于printf()，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C允许使用部分原型。例如，对于printf()可以使用下面的原型：\n1int printf(const char *, ...);这种原型表明，第1个参数是一个字符串（第11章中将详细介绍），可能还有其他未指定的参数。\nC库通过stdarg.h头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。第16章中详细介绍相关内容。\n函数原型的优点函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不用声明任何形参），但是这样做的弊大于利。\n有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第1次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：\n// 下面这行代码既是函数定义，也是函数原型\n12345678int　imax(int　a,　int　b)　&#123;　return　a　&gt;　b　?　a　:　b;　&#125;int　main()&#123;int　x,　z;...z　=　imax(x,　50);...&#125;递归C允许函数调用它自己，这种调用过程称为递归（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。\n可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。\n演示递归我们通过一个程序示例，来学习什么是递归。程序清单 9.6 中的 main()函数调用 up_and_down()函数，这次调用称为“第1级递归”。然后up_and_down()调用自己，这次调用称为“第2级递归”。接着第2级递归调用第3级递归，以此类推。该程序示例共有4级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量n的值，还显示了储存n的内存地址&amp;n（。本章稍后会详细讨论&amp;运算符，printf()函数使用%p转换说明打印地址，如果你的系统不支持这种格式，请使用%u或%lu代替%p）。\n程序清单9.6 recur.c程序\n12345678910111213141516/* recur.c -- 递归演示 */#include　&lt;stdio.h&gt;void up_and_down(int);int main(void)&#123;    up_and_down(1);    return 0;&#125;void up_and_down(int n)&#123;    printf(\"Level　%d:　n　location　%p\\n\",　n,　&amp;n);　//　#1    if(n　&lt;　4)    up_and_down(n　+　1);    printf(\"LEVEL　%d:　n　location　%p\\n\",　n,　&amp;n);　//　#2&#125;下面是在我们系统中的输出：\n12345678Level　1:　n　location　0x0012ff48Level　2:　n　location　0x0012ff3cLevel　3:　n　location　0x0012ff30Level　4:　n　location　0x0012ff24LEVEL　4:　n　location　0x0012ff24LEVEL　3:　n　location　0x0012ff30LEVEL　2:　n　location　0x0012ff3cLEVEL　1:　n　location　0x0012ff48我们来仔细分析程序中的递归是如何工作的。首先，main()调用了带参数1的up_and_down()函数，执行结果是up_and_down()中的形式参数n的值是1，所以打印语句#1打印Level 1。然后，由于n小于4，up_and_down()（第1级）调用实际参数为n + 1（或2）的up_and_down()（第2级）。于是第2级调用中的n的值是2，打印语句#1打印Level 2。与此类似，下面两次调用打印的分别是Level 3和Level 4。\n当执行到第4级时，n的值是4，所以if测试条件为假。up_and_down()函数不再调用自己。第4级调用接着执行打印语句#2，即打印LEVEL 4，因为n的值是4。此时，第4级调用结束，控制被传回它的主调函数（即第3级调用）。在第3级调用中，执行的最后一条语句是调用if语句中的第4级调用。被调函数（第4级调用）把控制返回在这个位置，因此，第3级调用继续执行后面的代码，打印语句#2打印LEVEL 3。然后第3级调用结束，控制被传回第2级调用，接着打印LEVEL 2，以此类推。\n注意，每级递归的变量 n 都属于本级递归私有。这从程序输出的地址值可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意，Level 1和LEVEL 1的地址相同，Level 2和LEVEL 2的地址相同，等等）。\n如果觉得不好理解，可以假设有一条函数调用链——fun1()调用 fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。\n递归的基本原理初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程序清单9.6为例讲解几个要点。\n第1，每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各不相同。当程序最终返回 up_and_down()的第1 级调用时，最初的n仍然是它的初值1（见图9.4）。\n\n第2，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回上一级的up_and_down()，不能跳级回到main()中的第1级调用。\n第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的顺序：第1级、第2级、第3级和第4级，被执行了4次。\n第4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。\n第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。\n最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。例如，程序清单9.6中的up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试条件(n &lt; 4)为假。\n尾递归最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。\n下面要介绍的程序示例中，分别用循环和尾递归计算阶乘。一个正整数的阶乘（factorial）是从1到该整数的所有整数的乘积。例如，3的阶乘（写作3！）是1×2×3。另外，0！等于1，负数没有阶乘。程序清单9.7中，第1个函数使用for循环计算阶乘，第2个函数使用递归计算阶乘。\n程序清单9.7 factor.c程序\n1234567891011121314151617181920212223242526272829303132333435363738394041424344// factor.c -- 使用循环和递归计算阶乘#include　&lt;stdio.h&gt;long fact(int n);long rfact(int n);int main(void)&#123;    int num;    printf(\"This　program　calculates　factorials.\\n\");    printf(\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\");    while　(scanf(\"%d\",　&amp;num)　==　1)    &#123;        if　(num　&lt;　0)        \tprintf(\"No　negative　numbers,　please.\\n\");        else　if　(num　&gt;　12)        \tprintf(\"Keep　input　under　13.\\n\");        else        &#123;            printf(\"loop:　%d　factorial　=　%ld\\n\",            num,　fact(num));            printf(\"recursion:　%d　factorial　=　%ld\\n\",            num,　rfact(num));        &#125;        printf(\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\");        &#125;    printf(\"Bye.\\n\");    return　0;&#125;long fact(int n)　　 // 使用循环的函数&#123;    long ans;    for(ans=1;n&gt;1;n--)    \tans*=n;    return　ans;&#125;long rfact(int n)　　// 使用递归的函数&#123;    long　ans;    if　(n　&gt;　0)    \tans = n * rfact(n - 1);    else    \tans　=　1;    return ans;&#125;测试驱动程序把输入限制在0~12。因为12!已快接近5亿，而13!比62亿还大，已超过我们系统中long类型能表示的范围。要计算超过12的阶乘，必须使用能表示更大范围的类型，如double或long long。\n下面是该程序的运行示例：\n123456789101112This　program　calculates　factorials.Enter　a　value　in　the　range　0-12　(q　to　quit):5loop:　5　factorial　=　120recursion:　5　factorial　=　120Enter　a　value　in　the　range　0-12　(q　to　quit):10loop:　10　factorial　=　3628800recursion:　10　factorial　=　3628800Enter　a　value　in　the　range　0-12　(q　to　quit):qBye.使用循环的函数把ans初始化为1，然后把ans与从n~2的所有递减整数相乘。根据阶乘的公式，还应该乘以1，但是这并不会改变结果。\n现在考虑使用递归的函数。该函数的关键是n! = n×(n-1)!。可以这样做是因为(n-1)!是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。阶乘的这一特性很适合使用递归。如果调用函数rfact()，rfact(n)是 n*rfact(n-1)。因此，通过调用 rfact(n-1)来计算rfact(n)，如程序清单9.7中所示。当然，必须要在满足某条件时结束递归，可以在n等于0时把返回值设为1。\n程序清单9.7中使用递归的输出和使用循环的输出相同。注意，虽然rfact()的递归调用不是函数的最后一行，但是当n&gt;0时，它是该函数执行的最后一条语句，因此它也是尾递归。\n既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归，因此读者还是要好好理解递归。\n递归和倒序计算递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表示法根据 2 的幂来表示数字。例如，十进制数 234 实际上是2×102+3×101+4×100，所以二进制数101实际上是1×22+0×21+1×20。二进制数由0和1表示。\n我们要设计一个以二进制形式表示整数的方法或算法（algorithm）。例如，如何用二进制表示十进制数5？在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以通过5 % 2即可确定5的二进制数的最后一位是1还是0。一般而言，对于数字n，其二进制的最后一位是n % 2。因此，计算的第一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归函数的递归调用之前计算n % 2，在递归调用之后打印计算结果。这样，计算的第1个值正好是最后一个打印的值。\n要获得下一位数字，必须把原数除以 2。这种计算方法相当于在十进制下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是0；如果是奇数，就是1。例如，5/2得2（整数除法），2是偶数（2%2 得 0），所以下一位二进制数是 0。到目前为止，我们已经获得 01。继续重复这个过程。2/2得1，1%2得1，所以下一位二进制数是1。因此，我们得到5的等价二进制数是101。那么，程序应该何时停止计算？当与2相除的结果小于2时停止计算，因为只要结果大于或等于2，就说明还有二进制位。每次除以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，可以拿十进制数来做类比：628%10得8，因此8就是该数最后一位；而628/10得62，而62%10得2，所以该数的下一位是2，以此类推）。程序清单9.8演示了上述算法。\n程序清单9.8 binary.c程序\n123456789101112131415161718192021222324252627/* binary.c -- 以二进制形式打印制整数 */#include　&lt;stdio.h&gt;void to_binary(unsigned long n);int main(void)&#123;    unsigned long number;    printf(\"Enter　an　integer　(q　to　quit):\\n\");    while(scanf(\"%lu\",&amp;number)　==　1)    &#123;        printf(\"Binary　equivalent:　\");        to_binary(number);        putchar('\\n');        printf(\"Enter　an　integer　(q　to　quit):\\n\");    &#125;    printf(\"Done.\\n\");    return　0;&#125;void to_binary(unsigned long n)　/* 递归函数 */&#123;    int r;    r=n%2;    if(n&gt;=2)    \tto_binary(n/2);    putchar(r==0?'0':'1');    return;&#125;在该程序中，如果r的值是0，to_binary()函数就显示字符’0’；如果r的值是1，to_binary()函数则显示字符’1’。条件表达式r == 0 ? &#39;0&#39; : &#39;1&#39;用于把数值转换成字符。\n下面是该程序的运行示例：\n123456789101112Enter　an　integer　(q　to　quit):9Binary　equivalent:　1001Enter　an　integer　(q　to　quit):255Binary　equivalent:　11111111Enter　an　integer　(q　to　quit):1024Binary　equivalent:　10000000000Enter　an　integer　(q　to　quit):qdone.不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。第 15 章中会介绍一个不用递归实现该算法的例子。\n递归的优缺点递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。我们用一个例子来说明递归的优缺点。\n斐波那契数列的定义如下：第1 个和第2 个数字都是1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数 n，返回相应的斐波那契数值。\n首先，来看递归。递归提供一个简单的定义。如果把函数命名为Fibonacci()，那么如果n是1或2， Fibonacci(n)应返回1；对于其他数值，则应返回Fibonacci(n-1)+Fibonacci(n-2)：\n1234567unsigned　long　Fibonacci(unsigned　n)&#123;    if　(n　&gt;　2)    return　Fibonacci(n-1)　+　Fibonacci(n-2);    else    return　1;&#125;这个递归函数只是重述了数学定义的递归。该函数使用了双递归（double recursion），即函数每一级递归都要调用本身两次。这暴露了一个问题。\n为了说明这个问题，假设调用 Fibonacci(40)。这是第1 级递归调用，将创建一个变量 n。然后在该函数中要调用Fibonacci()两次，在第2级递归中要分别创建两个变量n。这两次调用中的每次调用又会进行两次调用，因而在第3级递归中要创建4个名为n的变量。此时总共创建了7个变量。由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5 章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。\n虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注意，尤其是效率优先的程序。\n所有的C函数皆平等\n程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。\nmain()函数是否与其他函数不同？是的，main()的确有点特殊。当 main()与程序中的其他函数放在一起时，最开始执行的是main()函数中的第1条语句，但是这也是局限之处。main()也可以被自己或其他函数递归调用——尽管很少这样做。\n编译多源代码文件的程序使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明。\nUNIX假定在UNIX系统中安装了UNIX C编译器cc（最初的cc已经停用，但是许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc或clang）。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为a.out的可执行文件：\n1cc file1.c file2.c另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：\n1cc file1.c file2.oUNIX系统的make命令可自动管理多文件程序，但是这超出了本书的讨论范围。\n注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下载命令行编译器（GCC和Clang）。\nLinux假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文件：\n1gcc file1.c file2.c另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：\n1gcc file1.c file2.oDOS命令行编译器绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj，而不是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。\nWindows和苹果的IDE编译器Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的。项目（project）描述的是特定程序使用的资源。资源包括源代码文件。这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件（即扩展名为.h的文件），因为项目只管理使用的源代码文件，源代码文件中的#include指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文件。\n使用头文件如果把main()放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把I/O函数原型放在stdio.h中，把数学函数原型放在math.h中。你也可以这样用自定义的函数文件。\n另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些包含#define指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用#define指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了#define 定义的值，就必须在每个文件中修改。更好的做法是，把#define 指令放进头文件，然后在每个源文件中使用#include指令包含该文件即可。\n总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。我们考虑一个例子：假设要管理 4 家酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的房价相同。对于预订住宿多天的客户，第2天的房费是第1天的95%，第3天是第2天的95%，以此类推（暂不考虑这种策略的经济效益）。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。\n程序清单9.9、程序清单9.10和程序清单9.11演示了如何编写这样的程序。第1个程序清单包含main()函数，提供整个程序的组织结构。第 2 个程序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清单9.11列出了一个头文件，包含了该程序所有源文件中使用的自定义符号常量和函数原型。前面介绍过，在UNIX和DOS环境中，#include &quot;hotels.h&quot;指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）。如果使用IDE，需要知道如何把头文件合并成一个项目。\n程序清单9.9 usehotel.c控制模块\n1234567891011121314151617181920212223242526272829303132/* usehotel.c -- 房间费率程序 *//* 与程序清单9.10一起编译　　 */#include　&lt;stdio.h&gt;#include \"hotel.h\" /* 定义符号常量，声明函数 */int main(void)&#123;    int nights;    double hotel_rate;    int code;    while((code　=　menu())　!=　QUIT)    &#123;        switch(code)        &#123;            case　1:　 hotel_rate　=　HOTEL1;            break;            case　2:　 hotel_rate　=　HOTEL2;            break;            case　3:　 hotel_rate　=　HOTEL3;            break;            case　4:　 hotel_rate　=　HOTEL4;            break;            default: hotel_rate　=　0.0;            printf(\"Oops!\\n\");            break;        &#125;        nights　=　getnights();        showprice(hotel_rate,　nights);    &#125;    printf(\"Thank　you　and　goodbye.\\n\");    return 0;&#125;程序清单9.10 hotel.c函数支持模块\n123456789101112131415161718192021222324252627282930313233343536373839404142/* hotel.c -- 酒店管理函数 */#include　&lt;stdio.h&gt;#include　\"hotel.h\"int menu(void)&#123;    int code,status;    printf(\"\\n%s%s\\n\",　STARS,　STARS);    printf(\"Enter　the　number　of　the　desired　hotel:\\n\");    printf(\"1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic\\n\");    printf(\"3)　Chertworthy　Plaza　　　　　4)　The　Stockton\\n\");    printf(\"5)　quit\\n\");    printf(\"%s%s\\n\",　STARS,　STARS);    while((status　=　scanf(\"%d\",&amp;code))　!=　1　||    (code　&lt;　1　||　code　&gt;　5))    &#123;        if　(status　!=　1)            scanf(\"%*s\");　// 处理非整数输入        printf(\"Enter　an　integer　from　1　to　5,　please.\\n\");    &#125;    return code;&#125;int getnights(void)&#123;    int nights;    printf(\"How　many　nights　are　needed?　\");    while(scanf(\"%d\",　&amp;nights)　!=　1)    &#123;        scanf(\"%*s\");　　　// 处理非整数输入        printf(\"Please　enter　an　integer,　such　as　2.\\n\");    &#125;    return　nights;&#125;void showprice(double rate,int nights)&#123;    int　n;    double　total　=　0.0;    double　factor　=　1.0;    for (n = 1; n &lt;= nights; n++, factor *= DISCOUNT)    \ttotal += rate * factor;    printf(\"The　total　cost　will　be　$%0.2f.\\n\",　total);&#125;程序清单9.11 hotel.h头文件\n12345678910111213141516/* hotel.h -- 符号常量和 hotel.c 中所有函数的原型 */#define　QUIT　　　　　5#define　HOTEL1　　180.00#define　HOTEL2　　225.00#define　HOTEL3　　255.00#define　HOTEL4　　355.00#define　DISCOUNT　 0.95#define STARS \"**********************************\"// 显示选择列表int menu(void);// 返回预订天数int getnights(void);// 根据费率、入住天数计算费用// 并显示结果void showprice(double rate,int nights);下面是这个多文件程序的运行示例：\n1234567891011121314151617181920212223242526******************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************3How　many　nights　are　needed?　1The　total　cost　will　be　$255.00.********************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************4How　many　nights　are　needed?　3The　total　cost　will　be　$1012.64.********************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************5Thank　you　and　goodbye.顺带一提，该程序中有几处编写得很巧妙。尤其是，menu()和getnights()函数通过测试scanf()的返回值来跳过非数值数据，而且调用 scanf(&quot;%*s&quot;)跳至下一个空白字符。注意，menu()函数中是如何检查非数值输入和超出范围的数据：\n1while((status=scanf(\"%d\",&amp;code))!= 1||(code&lt;1||code&gt;5))以上代码段利用了C语言的两个规则：从左往右对逻辑表达式求值；一旦求值结果为假，立即停止求值。在该例中，只有在scanf()成功读入一个整数值后，才会检查code的值。\n用不同的函数处理不同的任务时应检查数据的有效性。当然，首次编写menu()或getnights()函数时可以暂不添加这一功能，只写一个简单的scanf()即可。待基本版本运行正常后，再逐步改善各模块。\n查找地址：&amp;运算符指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的scanf()函数中就使用地址作为参数。概括地说，如果主调函数不使用return返回的值，则必须通过地址才能修改主调函数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元&amp;运算符的用法。\n一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：\n1pooh = 24;假设pooh的存储地址是0B76（PC地址通常用十六进制形式表示）。那么，下面的语句：\n1printf(\"%d %p\\n\", pooh, &amp;pooh);将输出如下内容（%p是输出地址的转换说明）：\n124 0B76程序清单9.12中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。\n程序清单9.12 loccheck.c程序\n123456789101112131415161718/* loccheck.c　-- 查看变量被储存在何处　*/#include　&lt;stdio.h&gt;void mikado(int);　　　　　　　/* 函数原型 */int main(void)&#123;    int pooh = 2, bah = 5; /* main()的局部变量 */    printf(\"In　main(),　pooh　=　%d　and　&amp;pooh　=　%p\\n\",　pooh,&amp;pooh);    printf(\"In　main(),　bah　=　%d　and　&amp;bah　=　%p\\n\",　bah,　&amp;bah);    mikado(pooh);    return 0;&#125;void mikado(int bah)　　　　　 /* 定义函数 */&#123;    int pooh = 10;　　　　　　 /* mikado()的局部变量 */    printf(\"In　mikado(),　pooh　=　%d　and　&amp;pooh　=　%p\\n\",　pooh,　&amp;pooh);    printf(\"In　mikado(),　bah　=　%d　and　&amp;bah　=　%p\\n\",　 bah,　&amp;bah);&#125;程序清单9.12中使用ANSI C的%p格式打印地址。我们的系统输出如下：\n1234In　main(),　pooh　=　2　and　&amp;pooh　=　0x7fff5fbff8e8In　main(),　bah　=　5　and　&amp;bah　=　0x7fff5fbff8e4In　mikado(),　pooh　=　10　and　&amp;pooh　=　0x7fff5fbff8b8In　mikado(),　bah　=　2　and　&amp;bah　=　0x7fff5fbff8bc实现不同，%p表示地址的方式也不同。然而，许多实现都如本例所示，以十六进制显示地址。顺带一提，每个十六进制数对应4位，该例显示12个十六进制数，对应48位地址。\n该例的输出说明了什么？首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值（2）传递给形式参数（mikado()中的bah）。注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。\n我们强调第2 点，是因为这并不是在所有语言中都成立。例如，在 FORTRAN中，子例程会影响主调例程的原始变量。子例程的变量名可能与原始变量不同，但是它们的地址相同。但是，在 C语言中不是这样。每个C函数都有自己的变量。这样做更可取，因为这样做可以防止原始变量被被调函数中的副作用意外修改。然而，正如下节所述，这也带来了一些麻烦。\n更改主调函数中的变量有时需要在一个函数中更改其他函数的变量。例如，普通的排序任务中交换两个变量的值。假设要交换两个变量x和y的值。简单的思路是：\n12x　=　y;y　=　x;这完全不起作用，因为执行到第2行时，x的原始值已经被y的原始值替换了。因此，要多写一行代码，储存x的原始值：\n123temp　=　x;x　=　y;y　=　temp;上面这 3 行代码便可实现交换值的功能，可以编写成一个函数并构造一个驱动程序来测试。在程序清单9.13中，为清楚地表明变量属于哪个函数，在main()中使用变量x和y，在intercharge()中使用u和v。\n程序清单9.13 swap1.c程序\n12345678910111213141516171819/* swap1.c -- 第1个版本的交换函数 */#include　&lt;stdio.h&gt;void interchange(int u, int v); /* 声明函数 */int main(void)&#123;    int x　=　5,　y　=　10;    printf(\"Originally　x　=　%d　and　y　=　%d.\\n\",　x,　y);    interchange(x,　y);    printf(\"Now　x　=　%d　and　y　=　%d.\\n\",　x,　y);    return 0;&#125;void interchange(int u, int v)　/* 定义函数　*/&#123;    int temp;    temp=u;    u=v;    v=temp;&#125;运行该程序后，输出如下：\n12Originally　x　=　5　and　y　=　10.Now　x　=　5　and　y　=　10.两个变量的值并未交换！我们在interchange()中添加一些打印语句来检查错误（见程序清单9.14）。\n程序清单9.14 swap2.c程序\n123456789101112131415161718192021/* swap2.c -- 查找swap1.c的问题 */#include　&lt;stdio.h&gt;void interchange(int　u,　int　v);int main(void)&#123;    int x=5,y=10;    printf(\"Originally　x　=　%d　and　y　=　%d.\\n\",　x,　y);    interchange(x,　y);    printf(\"Now　x　=　%d　and　y　=　%d.\\n\",　x,　y);    return 0;&#125;void interchange(int　u,　int　v)&#123;    int temp;    printf(\"Originally　u　=　%d　and　v　=　%d.\\n\",　u,　v);    temp　=　u;    u　=　v;    v　=　temp;    printf(\"Now　u　=　%d　and　v　=　%d.\\n\",　u,　v);&#125;下面是该程序的输出：\n1234Originally　x　=　5　and　y　=　10.Originally　u　=　5　and　v　=　10.Now　u　=　10　and　v　=　5.Now　x　=　5　and　y　=　10.看来，interchange()没有问题，它交换了 u 和 v 的值。问题出在把结果传回 main()时。interchange()使用的变量并不是main()中的变量。因此，交换u和v的值对x和y的值没有影响！是否能用return语句把值传回main()？当然可以，在interchange()的末尾加上下面一行语句：\n1return(u);然后修改main()中的调用：\n1x = interchange(x,y);这只能改变x的值，而y的值依旧没变。用return语句只能把被调函数中的一个值传回主调函数，但是现在要传回两个值。这没问题！不过，要使用指针。\n指针简介指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。在C语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。\n假设一个指针变量名是ptr，可以编写如下语句：\n1ptr=&amp;pooh; // 把pooh的地址赋给ptr对于这条语句，我们说ptr“指向”pooh。ptr和&amp;pooh的区别是ptr是变量，而&amp;pooh是常量。或者，ptr是可修改的左值，而&amp;pooh是右值。还可以把ptr指向别处：\n1ptr = &amp;bah; // 把ptr指向bah，而不是pooh现在ptr的值是bah的地址。\n要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存int类型变量地址的指针，就要使用下面介绍的新运算符。\n间接运算符：*假设已知ptr指向bah，如下所示：\n1ptr = &amp;bah;然后使用间接运算符*（indirection operator）找出储存在bah中的值，该运算符有时也称为解引用运算符（dereferencing operator）。不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。\n1val = *ptr; // 找出ptr指向的值语句ptr = &amp;bah;和val = *ptr;放在一起相当于下面的语句：\n1val = bah;由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。\n小结：与指针相关的运算符\n地址运算符：&amp;\n一般注解：\n后跟一个变量名时，&amp;给出该变量的地址。\n示例：\n&amp;nurse表示变量nurse的地址。\n地址运算符：*\n一般注解：\n后跟一个指针名或地址时，*给出储存在指针指向地址上的值。\n示例：\n123nurse　=　22;ptr = &amp;nurse; // 指向nurse的指针val = *ptr;　 // 把ptr指向的地址上的值赋给val执行以上3条语句的最终结果是把22赋给val。\n声明指针相信读者已经很熟悉如何声明int类型和其他基本类型的变量，那么如何声明指针变量？你也许认为是这样声明：\n1pointer ptr; // 不能这样声明指针为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long和float可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些指针的声明示例：\n12345int *pi;　　 // pi是指向int类型变量的指针char *pc;　　　　// pc是指向char类型变量的指针float *pf, *pg; // pf、pg都是指向float类型变量的指针类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。int *pi;声明的意思是pi是一个指针，*pi是int类型（见图9.5）。\n\n*和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。\npc指向的值（*pc）是char类型。pc本身是什么类型？我们描述它的类型是“指向char类型的指针”。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。\n使用指针在函数间通信我们才刚刚接触指针，指针的世界丰富多彩。本节着重介绍如何使用指针解决函数间的通信问题。请看程序清单9.15，该程序在interchange()函数中使用了指针参数。稍后我们将对该程序做详细分析。\n程序清单9.15 swap3.c程序\n12345678910111213141516171819/* swap3.c -- 使用指针解决交换函数的问题 */#include　&lt;stdio.h&gt;void interchange(int * u, int * v);int　main(void)&#123;    int　x　=　5,　y　=　10;    printf(\"Originally　x　=　%d　and　y　=　%d.\\n\",　x,　y);    interchange(&amp;x, &amp;y);　 // 把地址发送给函数    printf(\"Now　x　=　%d　and　y　=　%d.\\n\",　x,　y);    return 0;&#125;void interchange(int *u, int *v)&#123;    int　temp;    temp = *u;　　// temp获得 u 所指向对象的值    *u = *v;    *v = temp;&#125;该程序是否能正常运行？下面是程序的输出：\n12Originally　x　=　5　and　y　=　10.Now　x　=　10　and　y　=　5.没问题，一切正常。接下来，我们分析程序清单9.15的运行情况。首先看函数调用：\n1interchange(&amp;x, &amp;y);该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把地址作为它们的值。因此，应把它们声明为指针。由于x和y是整数，所以u和v是指向整数的指针，其声明如下：\n1void interchange (int *u, int * v)接下来，在函数体中声明了一个交换值时必需的临时变量：\n1int temp;通过下面的语句把x的值储存在temp中：\n1temp = *u;记住，u的值是&amp;x，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。不要写成这样：\n1temp = u; /* 不要这样做 */因为这条语句赋给temp的是x的地址（u的值就是x的地址），而不是x的值。函数要交换的是x和y的值，而不是它们的地址。\n与此类似，把y的值赋给x，要使用下面的语句：\n1*u = *v;这条语句相当于：\n1x = y;我们总结一下该程序示例做了什么。我们需要一个函数交换x和y的值。把x和y的地址传递给函数，我们让interchange()访问这两个函数。使用指针和*运算符，该函数可以访问储存在这些位置的值并改变它们。\n可以省略ANSI C风格的函数原型中的形参名，如下所示：\n1void interchange(int *,int *);一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函数调用，那么传递的是x的值：\n1function1(x);如果下面形式的函数调用，那么传递的是x的地址：\n1function2(&amp;x);第1种形式要求函数定义中的形式参数必须是一个与x的类型相同的变量：\n1int function1(int num)第2种形式要求函数定义中的形式参数必须是一个指向正确类型的指针：\n1int function2(int *ptr)如果要计算或处理值，那么使用第 1 种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第2种形式的函数调用。我们用过的scanf()函数就是这样。当程序要把一个值读入变量时（如本例中的num），调用的是scanf(&quot;%d&quot;, &amp;num)。scanf()读取一个值，然后把该值储存到指定的地址上。\n对本例而言，指针让interchange()函数通过自己的局部变量改变main()中变量的值。\n熟悉Pascal和Modula-2的读者应该看出第1种形式和Pascal的值参数相同，第2种形式和Pascal的变量参数类似。C++程序员可能认为，既然C和C++都使用指针变量，那么C应该也有引用变量。让他们失望了，C没有引用变量。对BASIC程序员而言，可能很难理解整个程序。如果觉得本节的内容晦涩难懂，请多做一些相关的编程练习，你会发现指针非常简单实用（见图9.6）。\n\n变量：名称、地址和值\n通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。我们来进一步分析。\n编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。\n在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。例如，&amp;barn表示变量barn的地址，使用函数名即可获得变量的数值。例如，printf(&quot;%d\\n&quot;, barn)打印barn的值，使用*运算符即可获得储存在地址上的值。如果pbarn=&amp;barn;，那么*pbarn表示的是储存在&amp;barn地址上的值。\n简而言之，普通变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。\n虽然打印地址可以满足读者好奇心，但是这并不是&amp;运算符的主要用途。更重要的是使用&amp;、*和指针可以操纵地址和地址上的内容，如swap3.c程序（程序清单9.15）所示。\n小结：函数\n形式：\n典型的ANSI C函数的定义形式为：\n返回类型 名称（形参声明列表）\n函数体\n形参声明列表是用逗号分隔的一系列变量声明。除形参变量外，函数的其他变量均在函数体的花括号之内声明。\n示例：\n123456int diff(int x,int y)　//　ANSI　C&#123; // 函数体开始    int z;　　　　 // 声明局部变量    z=x-y;    return z; // 返回一个值&#125; // 函数体结束传递值：\n实参用于把值从主调函数传递给被调函数。如果变量a和b的值分别是5和2，那么调用：\n1c = diff(a,b);把5和2分别传递给变量x和y。5和2称为实际参数（简称实参），diff()函数定义中的变量x和y称为形式参数（简称形参）。使用关键字return把被调函数中的一个值传回主调函数。本例中， c接受z的值3。被调函数一般不会改变主调函数中的变量，如果要改变，应使用指针作为参数。如果希望把更多的值传回主调函数，必须这么做。\n函数的返回类型：\n函数的返回类型指的是函数返回值的类型。如果返回值的类型与声明的返回类型不匹配，返回值将被转换成函数声明的返回类型。\n函数签名：\n函数的返回类型和形参列表构成了函数签名。因此，函数签名指定了传入函数的值的类型和函数返回值的类型。\n示例：\n123456789101112131415double duff(double, int);　// 函数原型int main(void)&#123;    double　q,　x;    int　n;    ...    q = duff(x,n);　　　　　//函数调用    ...&#125;double duff(double u, int k)　　//函数定义&#123;    double　tor;    ...    return tor;　 //返回double类型的值&#125;关键概念如果想用C编出高效灵活的程序，必须理解函数。把大型程序组织成若干函数非常有用，甚至很关键。如果让一个函数处理一个任务，程序会更好理解，更方便调试。要理解函数是如何把信息从一个函数传递到另一函数，也就是说，要理解函数参数和返回值的工作原理。另外，要明白函数形参和其他局部变量都属于函数私有，因此，声明在不同函数中的同名变量是完全不同的变量。而且，函数无法直接访问其他函数中的变量。这种限制访问保护了数据的完整性。但是，当确实需要在函数中访问另一个函数的数据时，可以把指针作为函数的参数。\n本章小结函数可以作为组成大型程序的构件块。每个函数都应该有一个单独且定义好的功能。使用参数把值传给函数，使用关键字return把值返回函数。如果函数返回的值不是int类型，则必须在函数定义和函数原型中指定函数的类型。如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数。\nANSI C提供了一个强大的工具——函数原型，允许编译器验证函数调用中使用的参数个数和类型是否正确。\nC 函数可以调用本身，这种调用方式被称为递归。一些编程问题要用递归来解决，但是递归不仅消耗内存多，效率不高，而且费时。\n","plink":"https://dxsummer.gitee.io/posts/71adb096/"},{"title":"Step6 字符输入/输出和输入验证","date":"2020-06-07T09:52:44.000Z","date_formatted":{"ll":"2020年6月7日","L":"2020/06/07","MM-DD":"06-07"},"updated":"2020-06-09T10:13:34.075Z","content":"本章介绍以下内容：\n更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别\n如何通过键盘模拟文件结尾条件\n如何使用重定向把程序和文件相连接\n创建更友好的用户界面\n在涉及计算机的话题时，我们经常会提到输入（input）和输出（output）。我们谈论输入和输出设备（如键盘、U盘、扫描仪和激光打印机），讲解如何处理输入数据和输出数据，讨论执行输入和输出任务的函数。本章主要介绍用于输入和输出的函数（简称I/O函数）。\nI/O函数（如printf()、scanf()、getchar()、putchar()等）负责把信息传送到程序中。前几章简单介绍过这些函数，本章将详细介绍它们的基本概念。同时，还会介绍如何设计与用户交互的界面。\n最初，输入/输出函数不是C定义的一部分，C把开发这些函数的任务留给编译器的实现者来完成。在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型。ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些我们曾经用过的。由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数。其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面。这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序。本章只着重讲解所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统。处理文件输入/输出的程序也可以使用这些函数。\n许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配。本章将演示一些与输入验证相关的问题和解决方案。\n单字符I/O：getchar()和putchar()第 7 章中提到过，getchar()和 putchar()每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本（即，普通文字）处理程序所用的核心方法。为了帮助读者回忆这些函数的工作方式，请看程序清单8.1。该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用 while 循环，当读到#字符时停止。\n程序清单8.1 echo.c程序\n12345678910/* echo.c -- 重复输入 */#include　&lt;stdio.h&gt;int　main(void)&#123;    char　ch;    while　((ch　=　getchar())　!=　'#')        putchar(ch);    return　0;&#125;自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联，这就是为什么程序中要包含这个头文件的原因（其实，getchar()和 putchar()都不是真正的函数，它们被定义为供预处理器使用的宏，我们在第16章中再详细讨论）。运行该程序后，与用户的交互如下：\n1234Hello,　there.　I　would[enter]Hello,　there.　I　wouldlike　a　#3　bag　of　potatoes.[enter]like　a读者可能好奇，为何输入的字符能直接显示在屏幕上？如果用一个特殊字符（如，#）来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解 C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。\n缓冲区如果在老式系统运行程序清单8.1，你输入文本时可能显示如下：\n12HHeelllloo,, tthheerree..II wwoouulldd[enter]lliikkee aa #以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。图8.1比较了这两种输入。\n\n为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。\n虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。\n缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。\n那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入是缓冲的，不过最初K&amp;R把这个决定权交给了编译器的编写者。读者可以运行echo.c程序观察输出的情况，了解所用的输出类型。\nANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数（回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击键后对应的字符不显示）。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl()函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用setbuf()和setvbuf()函数（详见第13章）控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。在这里要对使用无缓冲输入的朋友说声抱歉，本书假设所有的输入都是缓冲输入。\n结束键盘输入在echo.c程序（程序清单8.1）中，只要输入的字符中不含#，那么程序在读到#时才会结束。但是， #也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C 的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。\n文件、流和键盘输入文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译储存在名为 echo.c 文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。\nC 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包（standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。\n上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。\n如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 if (ch ==&#39;\\n&#39;)检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。\n从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。\n第13章将更详细地讨论文件。本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()和scanf()函数都是标准I/O包的成员，处理这两个流。\n以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如，程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文件。\n文件结尾计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不一定有嵌入的Ctrl+Z，但是如果有，该操作系统会将其视为一个文件结尾标记。图8.2演示了这种方法。\n\n操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符，包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。\n无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义在stdio.h文件中：\n1#define EOF (-1)为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。\n某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。\n那么，如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表达式：\n1while ((ch = getchar()) != EOF)如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全部）都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序，如程序清单8.2所示。\n程序清单8.2 echo_eof.c程序\n12345678910/* echo_eof.c -- 重复输入，直到文件结尾 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　ch;    while　((ch　=　getchar())　!=　EOF)    putchar(ch);    return　0;&#125;注意下面几点。\n不用定义EOF，因为stdio.h中已经定义过了。\n不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值。\n变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数，但是EOF的值是-1。还好，getchar()函数实际返回值的类型是int，所以它可以读取EOF字符。如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式。\n由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据。\nch是整数不会影响putchar()，该函数仍然会打印等价的字符。\n使用该程序进行键盘输入，要设法输入EOF字符。不能只输入字符EOF，也不能只输入-1（输入-1会传送两个字符：一个连字符和一个数字1）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号。许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置的Ctrl+Z解释成文件结尾信号。\n下面是在UNIX系统下运行echo_eof.c程序的缓冲示例：\n1234567She　walks　in　beauty,　like　the　nightShe　walks　in　beauty,　like　the　nightOf　cloudless　climes　and　starry　skies...Of　cloudless　climes　and　starry　skies...Lord　ByronLord　Byron[Ctrl+D]每次按下Enter键，系统便会处理缓冲区中储存的字符，并在下一行打印该输入行的副本。这个过程一直持续到以UNIX风格模拟文件结尾（按下Ctrl+D）。在PC中，要按下Ctrl+Z。\n我们暂停一会。既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c 来储存在文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。这个小程序有查看文件内容、创建一个新文件、拷贝文件的潜力，没想到一个小程序竟然如此多才多艺！关键是要控制输入流和输出流，这是我们下一个要讨论的主题。\n注意 模拟EOF和图形界面\n模拟EOF的概念是在使用文本界面的命令行环境中产生的。在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号。但是在一些实际应用中，却不能很好地转换成图形界面（如Windows和Macintosh），这些用户界面包含更复杂的鼠标移动和按钮点击。程序要模拟EOF的行为依赖于编译器和项目类型。例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的设置。\n重定向和文件输入和输出涉及函数、数据和设备。例如，考虑 echo_eof.c，该程序使用输入函数 getchar()。输出设备（我们假设）是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入？\n在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。\n程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。我们在第13章中再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。\n重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来我们介绍UNIX、Linux和Windows的重定向。\nUNIX、Linux和DOS重定向UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示（模仿旧式DOS命令行环境）都能重定向输入、输出。重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。\n重定向输入\n假设已经编译了echo_eof.c 程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。运行该程序，输入可执行文件名：\n1echo_eof该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words的文本文件。文本文件（text file）是内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内含机器语言指令的文件（如储存可执行程序的文件）不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。只需用下面的命令代替上面的命令即可：\n1echo_eof &lt; words&lt;符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道（或不关心）输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备。试试看！\n注意 重定向\n对于UNIX、Linux和Windows命令提示，&lt;两侧的空格是可选的。一些系统，如AmigaDOS（那些喜欢怀旧的人使用的系统），支持重定向，但是在重定向符号和文件名之间不允许有空格。\n下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符。在Windows/DOS系统中见到的DOS提示可能是A&gt;或C&gt;。\n123456$　echo_eof　&lt;　wordsThe　world　is　too　much　with　us:　late　and　soon,Getting　and　spending,　we　lay　waste　our　powers:Little　we　see　in　Nature　that　is　ours;We　have　given　our　hearts　away,　a　sordid　boon!$重定向输出\n现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。然后，输入以下命令并开始输入：\n1echo_eof&gt;mywords\\&gt;符号是第2个重定向运算符。它创建了一个名为mywords的新文件，然后把echo_eof的输出（即，你输入字符的副本）重定向至该文件中。重定向把stdout从显示设备（即，显示器）赋给mywords文件。如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容（但是，许多操作系统有保护现有文件的选项，使其成为只读文件）。所有出现在屏幕的字母都是你刚才输入的，其副本储存在文件中。在下一行的开始处按下Ctrl+D（UNIX）或Ctrl+Z（DOS）即可结束该程序。如果不知道输入什么内容，可参照下面的示例。这里，我们使用UNIX提示符$。记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序。\n1234567$　echo_eof　&gt;　mywordsYou　should　have　no　problem　recalling　which　redirectionoperator　does　what.　Just　remember　that　each　operator　pointsin　the　direction　the　information　flows.　Think　of　it　asa　funnel.[Ctrl+D]$按下Ctrl+D或Ctrl+Z后，程序会结束，你的系统会提示返回。程序是否起作用了？UNIX的ls命令或Windows命令行提示模式的dir命令可以列出文件名，会显示mywords文件已存在。可以使用UNIX或Linux的cat或DOS的type命令检查文件中的内容，或者再次使用echo_eof，这次把文件重定向到程序：\n123456$　echo_eof　&lt;　mywordsYou　should　have　no　problem　recalling　which　redirectionoperator　does　what.　Just　remember　that　each　operator　pointsin　the　direction　the　information　flows.　Think　of　it　as　afunnel.$组合重定向\n现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：\n1echo_eof &lt; mywords &gt; savewords下面的命令也起作用，因为命令与重定向运算符的顺序无关：\n1echo_eof &gt; savewords &lt; mywords注意：在一条命令中，输入文件名和输出文件名不能相同。\n1echo_eof &lt; mywords &gt; mywords....&lt;--错误原因是&gt; mywords在输入之前已导致原mywords的长度被截断为0。\n总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;）时，要遵循以下原则。\n重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。\n\n使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。\n\n通常，文件名和运算符之间的空格不是必须的，除非是偶尔在UNIX shell、Linux shell或Windows命令行提示模式中使用的有特殊含义的字符。例如，我们用过的echo_eof&lt;words。\n以上介绍的都是正确的例子，下面来看一下错误的例子，addup和count是两个可执行程序，fish和beets是两个文本文件：\n1234fish &gt; beets　　　　　　　　←违反第1条规则addup &lt; count　　　　　　　 ←违反第1条规则addup &lt; fish &lt; beets　　　　←违反第2条规则count &gt; beets fish　　　　　←违反第2条规则UNIX、Linux或Windows/DOS 还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输入。欲了解所有相关运算符的内容，请参阅 UNIX 的相关书籍，如UNIX Primer Plus，Third Edition（Wilson、Pierce和Wessler合著）。\n注释\n重定位让你能使用键盘输入程序文件。要完成这一任务，程序要测试文件的末尾。例如，第 7 章演示的统计单词程序（程序清单7.7），计算单词个数直至遇到第1个|字符。把ch的char类型改成int类型，把循环测试中的|替换成EOF，便可用该程序来计算文本文件中的单词量。\n重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指令。如果不使用命令行环境，也可以使用重定向。首先，一些集成开发环境提供了菜单选项，让用户指定重定向。其次，对于 Windows系统，可以打开命令提示窗口，并在命令行运行可执行文件。Microsoft Visual Studio的默认设置是把可执行文件放在项目文件夹的子文件夹，称为Debug。文件名和项目名的基本名相同，文件名的扩展名为.exe。默认情况下，Xcode在给项目命名后才能命名可执行文件，并将其放在Debug文件夹中。在UNIX系统中，可以通过Terminal工具运行可执行文件。从使用上看，Terminal比命令行编译器（GCC或Clang）简单。\n如果用不了重定向，可以用程序直接打开文件。程序清单8.3演示了一个注释较少的示例。我们学到第13章时再详细讲解。待读取的文件应该与可执行文件位于同一目录。\n123456789101112131415161718192021222324程序清单8.3 file_eof.c程序// file_eof.c --打开一个文件并显示该文件#include　&lt;stdio.h&gt;#include &lt;stdlib.h&gt;　　　　　　　// 为了使用exit()int　main()&#123;    int　ch;    FILE * fp;    char fname[50];　　　　　　　// 储存文件名    printf(\"Enter　the　name　of　the　file:　\");    scanf(\"%s\",　fname);    fp = fopen(fname, \"r\");　　 // 打开待读取文件    if (fp == NULL)　　　　　　　// 如果失败    &#123;        printf(\"Failed　to　open　file.　Bye\\n\");        exit(1);　　　　　　　　　// 退出程序    &#125;    // getc(fp)从打开的文件中获取一个字符    while　((ch　=　getc(fp))　!=　EOF)    \tputchar(ch);    fclose(fp);　　　　　　　　　 // 关闭文件    return　0;&#125;小结：如何重定向输入和输出\n绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序，或只在C编译器允许的情况下重定向C程序。假设prog是可执行程序名，file1和file2是文件名。\n1234567891011把输出重定向至文件：&gt;prog &gt;file1    把输入重定向至文件：&lt;prog &lt;file2    组合重定向：prog　&lt;file2　&gt;file1prog　&gt;file1　&lt;file2    这两种形式都是把file2作为输入、file1作为输出。留白：\n一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。\n创建更友好的用户界面大部分人偶尔会写一些中看不中用的程序。还好，C提供了大量工具让输入更顺畅，处理过程更顺利。不过，学习这些工具会导致新的问题。本节的目标是，指导读者解决这些问题并创建更友好的用户界面，让交互数据输入更方便，减少错误输入的影响。\n使用缓冲输入缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面示例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。查看程序清单8.4，这是猜谜程序的最初版本，后面我们会改进。\n程序清单8.4 guess.c程序\n123456789101112131415/* guess.c -- 一个拖沓且错误的猜数字程序 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　guess　=　1;    printf(\"Pick　an　integer　from　1　to　100.　I　will　try　to　guess　\");    printf(\"it.\\nRespond　with　a　y　if　my　guess　is　right　and　with\");    printf(\"\\nan　n　if　it　is　wrong.\\n\");    printf(\"Uh...is　your　number　%d?\\n\",　guess);    while (getchar() != 'y')　　 /* 获取响应，与 y 做对比 */    \tprintf(\"Well,　then,　is　it　%d?\\n\",　++guess);    printf(\"I　knew　I　could　do　it!\\n\");    return　0;&#125;下面是程序的运行示例：\n123456789101112Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?Well,　then,　is　it　3?nWell,　then,　is　it　4?Well,　then,　is　it　5?yI　knew　I　could　do　it!撇开这个程序糟糕的算法不谈，我们先选择一个数字。注意，每次输入 n 时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。\n一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。程序清单8.4的版本会把no当作两个响应。下面用循环修正char response;这个问题：\n123456while (getchar() != 'y')　 /* 获取响应，与 y 做对比*/&#123;    printf(\"Well,　then,　is　it　%d?\\n\",　++guess);    while　(getchar()　!=　'\\n')    \tcontinue;　　　　 /* 跳过剩余的输入行 */&#125;使用以上循环后，该程序的输出示例如下：\n1234567891011121314Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?noWell,　then,　is　it　3?no　sirWell,　then,　is　it　4?forget　itWell,　then,　is　it　5?yI knew I could do it!这的确是解决了换行符的问题。但是，该程序还是会把f被视为n。我们用if语句筛选其他响应。首先，添加一个char类型的变量储存响应：\n修改后的循环如下：\n123456789while ((response = getchar()) != 'y') /* 获取响应 */&#123;    if　(response　==　'n')    \tprintf(\"Well,　then,　is　it　%d?\\n\",　++guess);    else    \tprintf(\"Sorry,　I　understand　only　y　or　n.\\n\");    while　(getchar()　!=　'\\n')    \tcontinue; /* 跳过剩余的输入行 */&#125;现在，程序的运行示例如下：\n12345678910111213141516Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?noWell,　then,　is　it　3?no　sirWell,　then,　is　it　4?forget　itSorry,　I　understand　only　y　or　n.nWell,　then,　is　it　5?yI　knew　I　could　do　it!在编写交互式程序时，应该事先预料到用户可能会输入错误，然后设计程序处理用户的错误输入。在用户出错时通知用户再次输入。\n当然，无论你的提示写得多么清楚，总会有人误解，然后抱怨这个程序设计得多么糟糕。\n混合数值和字符输入假设程序要求用 getchar()处理字符输入，用 scanf()处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为 getchar()读取每个字符，包括空格、制表符和换行符；而 scanf()在读取数字时则会跳过空格、制表符和换行符。\n我们通过程序清单8.5来解释这种情况导致的问题。该程序读入一个字符和两个数字，然后根据输入的两个数字指定的行数和列数打印该字符。\n程序清单8.5 showchar1.c程序\n1234567891011121314151617181920212223242526272829/* showchar1.c -- 有较大 I/O 问题的程序 */#include　&lt;stdio.h&gt;void display(char cr,int lines,int width);int main(void)&#123;    int ch;　　　　　　　　/* 待打印字符　 */    int rows, cols;　　　　/* 行数和列数 */    printf(\"Enter　a　character　and　two　integers:\\n\");    while((ch=getchar())!='\\n')    &#123;        scanf(\"%d　%d\",&amp;rows,&amp;cols);        display(ch,rows,cols);        printf(\"Enter　another　character　and　two　integers;\\n\");        printf(\"Enter　a　newline　to　quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void display(char cr,int lines,int width)&#123;    int row,col;    for(row=1;row&lt;=lines;row++)    &#123;        for(col=1;col&lt;=width;col++)        \tputchar(cr);        putchar('\\n');/* 结束一行并开始新的一行 */    &#125;&#125;注意，该程序以 int 类型读取字符（这样做可以检测 EOF），但是却以 char 类型把字符传递给display()函数。因为char比int小，一些编译器会给出类型转换的警告。可以忽略这些警告，或者用下面的强制类型转换消除警告：\n1display(char(ch), rows, cols);在该程序中，main()负责获取数据，display()函数负责打印数据。下面是该程序的一个运行示例，看看有什么问题：\n1234567Enter　a　character　and　two　integers:c　2　3ccccccEnter　another　character　and　two　integers;Enter　a　newline　to　quit.Bye.该程序开始时运行良好。你输入c 2 3，程序打印c字符2行3列。然后，程序提示输入第2组数据，还没等你输入数据程序就退出了！这是什么情况？又是换行符在捣乱，这次是输入行中紧跟在 3 后面的换行符。scanf()函数把这个换行符留在输入队列中。和 scanf()不同，getchar()不会跳过换行符，所以在进入下一轮迭代时，你还没来得及输入字符，它就读取了换行符，然后将其赋给ch。而ch是换行符正式终止循环的条件。\n要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格。另外，如果该程序不在getchar()测试时，而在scanf()阶段终止程序会更好。修改后的版本如程序清单8.6所示。\n程序清单8.6 showchar2.c程序\n1234567891011121314151617181920212223242526272829303132/* showchar2.c -- 按指定的行列打印字符 */#include　&lt;stdio.h&gt;void display(char cr,int lines,int width);int　main(void)&#123;    int ch;　　　　　　　　/* 待打印字符*/    int rows, cols;　　　　/* 行数和列数 */    printf(\"Enter　a　character　and　two　integers:\\n\");    while((ch=getchar())!='\\n')    &#123;        if(scanf(\"%d　%d\",&amp;rows,&amp;cols)!=2)        \tbreak;        display(ch,rows,cols);        while(getchar()!='\\n')        \tcontinue;        printf(\"Enter　another　character　and　two　integers;\\n\");        printf(\"Enter　a　newline　to　quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void display(char cr,int lines,int width)&#123;    int row,col;    for(row　=　1;　row　&lt;=　lines;　row++)    &#123;        for(col　=　1;　col　&lt;=　width;　col++)        putchar(cr);        putchar('\\n');　　/* 结束一行并开始新的一行 */    &#125;&#125;while循环实现了丢弃scanf()输入后面所有字符（包括换行符）的功能，为循环的下一轮读取做好了准备。该程序的运行示例如下：\n123456789101112Enter　a　character　and　two　integers:c　1　2ccEnter　another　character　and　two　integers;Enter　a　newline　to　quit.!　3　6!!!!!!!!!!!!!!!!!!Enter　another　character　and　two　integers;Enter　a　newline　to　quit.Bye.在if语句中使用一个break语句，可以在scanf()的返回值不等于2时终止程序，即如果一个或两个输入值不是整数或者遇到文件结尾就终止程序。\n输入验证在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。\n例如，假设你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况：\n1234567long　n;scanf(\"%ld\", &amp;n);　　　// 获取第1个值while (n &gt;= 0)　　　　　// 检测不在范围内的值&#123;    // 处理n    scanf(\"%ld\", &amp;n);　// 获取下一个值&#125;另一类潜在的陷阱是，用户可能输入错误类型的值，如字符 q。排除这种情况的一种方法是，检查scanf()的返回值。回忆一下，scanf()返回成功读取项的个数。因此，下面的表达式当且仅当用户输入一个整数时才为真：\n1scanf(\"%ld\",　&amp;n)　==　1结合上面的while循环，可改进为：\n12345long　n;while(scanf(\"%ld\",&amp;n)==1&amp;&amp;n&gt;=0)&#123;//处理n&#125;while循环条件可以描述为“当输入是一个整数且该整数为正时”。\n对于最后的例子，当用户输入错误类型的值时，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入，甚至可以把这些想法都结合在一个函数中，如下所示：\n12345678910111213long get_long(void)&#123;    long input;    char ch;    while(scanf(\"%ld\",&amp;input)!=1)    &#123;        while((ch=getchar())!='\\n')        \tputchar(ch); // 处理错误的输入        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;    return input;&#125;该函数要把一个int类型的值读入变量input中。如果读取失败，函数则进入外层while循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1。\n在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序检查第1个值是否大于第2个值（通常假设第1个值是较小的那个值），除此之外还要检查这些值是否在允许的范围内。例如，当前的档案查找一般不会接受 1958 年以前和2014年以后的查询任务。这个限制可以在一个函数中实现。\n假设程序中包含了stdbool.h 头文件。如果当前系统不允许使用_Bool，把bool替换成int，把true 替换成 1，把 false 替换成 0 即可。注意，如果输入无效，该函数返回 true，所以函数名为bad_limits()：\n1234567891011121314151617181920bool bad_limits(long begin,long end,long low,long high)&#123;    bool not_good=false;    if (begin&gt;end)    &#123;        printf(\"%ld　isn't　smaller　than　%ld.\\n\",　begin,　end);        not_good=true;    &#125;    if(begin&lt;low||end&lt;low)    &#123;        printf(\"Values　must　be　%ld　or　greater.\\n\",　low);        not_good=true;    &#125;    if(begin&gt;high||end&gt;high)    &#123;        printf(\"Values　must　be　%ld　or　less.\\n\",　high);        not_good=true;    &#125;    return not_good;&#125;程序清单8.7使用了上面的两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000，下限是-10000000。\n程序清单8.7 checking.c程序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// checking.c -- 输入验证#include　&lt;stdio.h&gt;#include　&lt;stdbool.h&gt;// 验证输入是一个整数long get_long(void);// 验证范围的上下限是否有效bool bad_limits(long　begin,　long　end,long low,long high);// 计算a～b之间的整数平方和double sum_squares(long a,long b);int　main(void)&#123;    const long MIN=-10000000L;　　// 范围的下限    const long MAX=+10000000L;　　// 范围的上限    long start;　　　　　　　　　　　　// 用户指定的范围最小值    long stop;　　　　　　　　　　　　 // 用户指定的范围最大值    double　answer;    printf(\"This　program　computes　the　sum　of　the　squares　of　\"    \"integers　in　a　range.\\nThe　lower　bound　should　not　\"    \"be　less　than　-10000000　and\\nthe　upper　bound　\"    \"should　not　be　more　than　+10000000.\\nEnter　the　\"    \"limits　(enter　0　for　both　limits　to　quit):\\n\"    \"lower　limit:　\");    start=get_long();    printf(\"upper　limit:　\");    stop=get_long();    while(start!=0||stop!=0)    &#123;        if(bad_limits(start,stop,MIN,MAX))        \tprintf(\"Please　try　again.\\n\");        else        &#123;            answer=sum_squares(start,stop);            printf(\"The　sum　of　the　squares　of　the　integers　\");            printf(\"from　%ld　to　%ld　is　%g\\n\",            start,stop,answer);        &#125;        printf(\"Enter　the　limits　(enter　0　for　both　\"        \"limits　to　quit):\\n\");        printf(\"lower　limit:　\");        start=get_long();        printf(\"upper　limit:　\");        stop=get_long();\t&#125;\tprintf(\"Done.\\n\");\treturn　0;&#125;long get_long(void)&#123;    long input;    char ch;    while(scanf(\"%ld\",&amp;input)!=1)    &#123;        while((ch=getchar())!='\\n')        \tputchar(ch);　　　　　　 // 处理错误输入        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;\treturn input;&#125;double sum_squares(long a,long b)&#123;    double total=0;    long i;    for(i=a;i&lt;=b;i++)    \ttotal+=(double)i*(double) i;    return total;&#125;bool bad_limits(long begin,long end,long low,long high)&#123;    bool not_good=false;    if(begin&gt;end)    &#123;        printf(\"%ld　isn't　smaller　than　%ld.\\n\",　begin,　end);        not_good=true;    &#125;    if(begin&lt;low||end&lt;low)    &#123;        printf(\"Values　must　be　%ld　or　greater.\\n\",　low);        not_good=true;    &#125;    if(begin&gt;high||end&gt;high)    &#123;        printf(\"Values　must　be　%ld　or　less.\\n\",　high);        not_good=true;    &#125;    return not_good;&#125;下面是该程序的输出示例：\n1234567891011121314151617181920This　program　computes　the　sum　of　the　squares　of　integers　in　a　range.The　lower　bound　should　not　be　less　than　-10000000　andthe　upper　bound　should　not　be　more　than　+10000000.Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　lowlow　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　3upper　limit:　a　big　numbera　big　number　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　12The　sum　of　the　squares　of　the　integers　from　3　to　12　is　645Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　80upper　limit:　1080　isn't　smaller　than　10.Please　try　again.Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　0upper　limit:　0Done.分析程序虽然checking.c程序的核心计算部分（sum_squares()函数）很短，但是输入验证部分比以往程序示例要复杂。接下来分析其中的一些要素，先着重讨论程序的整体结构。\n程序遵循模块化的编程思想，使用独立函数（模块）来验证输入和管理显示。程序越大，使用模块化编程就越重要。\nmain()函数管理程序流，为其他函数委派任务。它使用 get_long()获取值、while 循环处理值、badlimits()函数检查值是否有效、sum_squres()函数处理实际的计算：\n1234567891011121314151617181920start=get_long();printf(\"upper　limit:　\");stop=get_long();while(start!=0||stop!=0)&#123;    if　(bad_limits(start,　stop,　MIN,　MAX))    \tprintf(\"Please　try　again.\\n\");    else    &#123;        answer　=　sum_squares(start,　stop);        printf(\"The　sum　of　the　squares　of　the　integers　\");        printf(\"from　%ld　to　%ld　is　%g\\n\",　start,　stop,　answer);    &#125;    printf(\"Enter　the　limits　(enter　0　for　both　\"    \"limits　to　quit):\\n\");    printf(\"lower　limit:　\");    start=get_long();    printf(\"upper　limit:　\");    stop=get_long();&#125;输入流和数字在编写处理错误输入的代码时（如程序清单8.7），应该很清楚C是如何处理输入的。考虑下面的输入：\n1is 28 12.4在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对 C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：\n12while ((ch=getchar())!='\\n')putchar(ch); // 处理错误的输入虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如，考虑下面的输入：\n142如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。\n简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。\n菜单浏览许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。\n菜单给用户提供了一份响应程序的选项。假设有下面一个例子：\n123Enter　the　letter　of　your　choice:a.　advice　　　　　　　b.　bellc.　count　　　　　　　　q.　quit理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第1个目标是：当用户遵循指令时程序顺利运行；第2个目标是：当用户没有遵循指令时，程序也能顺利运行。显而易见，要实现第 2 个目标难度较大，因为很难预料用户在使用程序时的所有错误情况。\n现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们示例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。\n任务我们来更具体地分析一个菜单程序需要执行哪些任务。它要获取用户的响应，根据响应选择要执行的动作。另外，程序应该提供返回菜单的选项。C 的 switch 语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签。使用while语句可以实现重复访问菜单的功能。因此，我们写出以下伪代码：\n1234获取选项当选项不是'q'时转至相应的选项并执行获取下一个选项使执行更顺利当你决定实现这个程序时，就要开始考虑如何让程序顺利运行（顺利运行指的是，处理正确输入和错误输入时都能顺利运行）。例如，你能做的是让“获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch。这表明需要为输入过程提供一个只返回正确响应的函数。结合while循环和switch语句，其程序结构如下：\n12345678910111213141516171819202122#include　&lt;stdio.h&gt;char　get_choice(void);void　count(void);int　main(void)&#123;    int choice;    while((choice　=　get_choice())　!=　'q')    &#123;        switch　(choice)        &#123;            case 'a':　printf(\"Buy　low,　sell　high.\\n\");            \tbreak;            case 'b': putchar('\\a'); /* ANSI */            \tbreak;            case 'c':　count();            \tbreak;            default:　 printf(\"Program　error!\\n\");            \tbreak;    \t&#125;    &#125;    return　0;&#125;定义get_choice()函数只能返回&#39;a&#39;、&#39;b&#39;、&#39;c&#39;和&#39;q&#39;。get_choice()的用法和getchar()相同，两个函数都是获取一个值，并与终止值（该例中是&#39;q&#39;）作比较。我们尽量简化实际的菜单选项，以便读者把注意力集中在程序结构上。稍后再讨论 count()函数。default 语句可以方便调试。如果get_choice()函数没能把返回值限制为菜单指定的几个选项值，default语句有助于发现问题所在。\nget_choice()函数\n下面的伪代码是设计这个函数的一种方案：\n显示选项\n获取用户的响应\n当响应不合适时\n提示用户再次输入\n获取用户的响应\n下面是一个简单而笨拙的实现：\n1234567891011121314char　get_choice(void)&#123;    int　ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　　b.　bell\\n\");    printf(\"c.　count　　　　　　　　 q.　quit\\n\");    ch=getchar();    while　((ch　&lt;　'a'　||　ch　&gt;　'c')　&amp;&amp;　ch　!=　'q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=getchar();    &#125;    return　ch;&#125;缓冲输入依旧带来些麻烦，程序把用户每次按下 Return 键产生的换行符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。\n这类问题有多种解决方案。一种是用名为get_first()的新函数替换getchar()函数，读取一行的第1个字符并丢弃剩余的字符。这种方法的优点是，把类似act这样的输入视为简单的a，而不是继续把act中的c作为选项c的一个有效的响应。我们重写输入函数如下：\n12345678910111213141516171819202122char get_choice(void)&#123;    int ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　　 b.　bell\\n\");    printf(\"c.　count　　　　　　　　　 q.　quit\\n\");    ch=get_first();    while((ch&lt;'a'||ch&gt;'c')&amp;&amp;ch!='q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=getfirst();    &#125;    return　ch;&#125;char get_first(void)&#123;    int ch;    ch=getchar();　 /* 读取下一个字符 */    while(getchar()!='\\n')    continue; /* 跳过该行剩下的内容 */    return　ch;&#125;混合字符和数值输入前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的问题。例如，假设count()函数（选择c）的代码如下：\n12345678void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    scanf(\"%d\",&amp;n);    for(i=1;i&lt;=n;i++)    \tprintf(\"%d\\n\",i);&#125;如果输入3作为响应，scanf()会读取3并把换行符留在输入队列中。下次调用 get_choice()将导致get_first()返回这个换行符，从而导致我们不希望出现的行为。\n重写 get_first()，使其返回下一个非空白字符而不仅仅是下一个字符，即可修复这个问题。我们把这个任务留给读者作为练习。另一种方法是，在count()函数中清理换行符，如下所示：\n12345678910void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    n=get_int();    for(i=1;i&lt;=n;i++)    \tprintf(\"%d\\n\",i);    while(getchar()!='\\n')    \tcontinue;&#125;该函数借鉴了程序清单8.7中的get_long()函数，将其改为get_int()获取int类型的数据而不是long类型的数据。回忆一下，原来的get_long()函数如何检查有效输入和让用户重新输入。程序清单8.8演示了菜单程序的最终版本。\n程序清单8.8 menuette.c程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* menuette.c -- 菜单程序 */#include　&lt;stdio.h&gt;char　get_choice(void);char　get_first(void);int　get_int(void);void　count(void);int　main(void)&#123;    int choice;    void count(void);    while((choice　=　get_choice())　!=　'q')    &#123;        switch(choice)        &#123;            case 'a':　printf(\"Buy　low,　sell　high.\\n\");            \tbreak;            case 'b':　putchar('\\a');　 /* ANSI */            \tbreak;            case 'c':　count();            \tbreak;            default:　　printf(\"Program　error!\\n\");            \tbreak;        &#125;    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    n=get_int();    for(i　=　1;　i　&lt;=　n;　i++)    \tprintf(\"%d\\n\",　i);    while(getchar()　!=　'\\n')    \tcontinue;&#125;char get_choice(void)&#123;    int ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　b.　bell\\n\");    printf(\"c.　count　　　　　　　　q.　quit\\n\");    ch=get_first();    while((ch　&lt;　'a'　||　ch　&gt;　'c')　&amp;&amp;　ch　!=　'q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=get_first();    &#125;    return ch;&#125;char get_first(void)&#123;    int　ch;    ch=getchar();    while　(getchar()　!=　'\\n')    continue;&#125;int get_int(void)&#123;    int input;    char ch;    while(scanf(\"%d\",　&amp;input)　!=　1)    &#123;        while　((ch　=　getchar())　!=　'\\n')        putchar(ch);　// 处理错误输出        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;    return input;&#125;下面是该程序的一个运行示例：\n123456789101112131415161718192021222324Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitaBuy　low,　sell　high.Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitcountCount　how　far?　Enter　an　integer:twotwo　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　512345Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitdPlease　respond　with　a,　b,　c,　or　q.q要写出一个自己十分满意的菜单界面并不容易。但是，在开发了一种可行的方案后，可以在其他情况下复用这个菜单界面。\n学完以上程序示例后，还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数。这样让程序更模块化。\n关键概念C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。\n程序通常接受特殊形式的输入。可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况，让程序更强健更友好。\n对于一个小型程序，输入验证可能是代码中最复杂的部分。处理这类问题有多种方案。例如，如果用户输入错误类型的信息，可以终止程序，也可以给用户提供有限次或无限次机会重新输入。\n本章小结许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入，即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准。\n通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一。getchar()和 scanf()函数也属于这一系列。当检测到文件结尾时，这两个函数都返回 EOF（被定义在stdio.h头文件中）。在不同系统中模拟文件结尾条件的方式稍有不同。在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件；而在DOS系统中则使用Ctrl+Z。\n许多操作系统（包括UNIX和DOS）都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出。读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件。\n混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程序中妥善处理。\n编写程序时，要认真设计用户界面。事先预料一些用户可能会犯的错误，然后设计程序妥善处理这些错误情况。\n","plink":"https://dxsummer.gitee.io/posts/86602531/"},{"title":"Step5 C控制语句：分支和跳转","date":"2020-06-06T02:30:50.000Z","date_formatted":{"ll":"2020年6月6日","L":"2020/06/06","MM-DD":"06-06"},"updated":"2020-06-08T01:44:18.717Z","content":"本章介绍以下内容：\n关键字：if、else、switch、continue、break、case、default、goto\n运算符：&amp;&amp;、||、?、:\n函数：getchar()、putchar()、ctype.h系列\n如何使用if和if else语句，如何嵌套它们\n在更复杂的测试表达式中用逻辑运算符组合关系表达式\nC的条件运算符\nswitch语句\nbreak、continue和goto语句\n使用C的字符I/O函数：getchar()和putchar()\nctype.h头文件提供的字符分析函数系列\n随着越来越熟悉C，可以尝试用C程序解决一些更复杂的问题。这时候，需要一些方法来控制和组织程序，为此C提供了一些工具。前面已经学过如何在程序中用循环重复执行任务。本章将介绍分支结构（如， if和switch），让程序根据测试条件执行相应的行为。另外，还将介绍C语言的逻辑运算符，使用逻辑运算符能在 while 或 if 的条件中测试更多关系。此外，本章还将介绍跳转语句，它将程序流转换到程序的其他部分。学完本章后，读者就可以设计按自己期望方式运行的程序。\nif语句我们从一个有if语句的简单示例开始学习，请看程序清单7.1。该程序读取一列数据，每个数据都表示每日的最低温度（℃），然后打印统计的总天数和最低温度在0℃以下的天数占总天数的百分比。程序中的循环通过scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的if语句负责判断0℃以下的温度并单独统计相应的天数。\n程序清单7.1 colddays.c程序\n123456789101112131415161718192021222324// colddays.c -- 找出0℃以下的天数占总天数的百分比#include &lt;stdio.h&gt;int main(void)&#123;    const int FREEZING=0;    float temperature;    int cold_days=0;    int all_days=0;    printf(\"Enter the list of daily low temperatures.\\n\");    printf(\"Use Celsius, and enter q to quit.\\n\");    while(scanf(\"%f\",&amp;temperature)==1)    &#123;        all_days++;        if(temperature&lt;FREEZING)        cold_days++;    &#125;    if (all_days!=0)   \t\tprintf(\"%d days total: %.1f%% were below freezing.\\n\",  \t\tall_days,100.0*(float)cold_days/all_days);    if (all_days==0) \t   printf(\"No data entered!\\n\");    return 0;&#125;下面是该程序的输出示例：\n1234Enter the list of daily low temperatures.Use Celsius, and enter q to quit.12 5 -2.5 0 6 8 -3 -10 5 10 q10 days total: 30.0% were below freezing.while循环的测试条件利用scanf()的返回值来结束循环，因为scanf()在读到非数字字符时会返回0。temperature的类型是float而不是int，这样程序既可以接受-2.5这样的值，也可以接受8这样的值。\nwhile循环中的新语句如下：\n12if(temperature&lt;FREEZING)cold_days++;if 语句指示计算机，如果刚读取的值（remperature）小于 0，就把 cold_days 递增 1；如果temperature不小于0，就跳过cold_days++;语句，while循环继续读取下一个温度值。\n接着，该程序又使用了两次if语句控制程序的输出。如果有数据，就打印结果；如果没有数据，就打印一条消息（稍后将介绍一种更好的方法来处理这种情况）。\n为避免整数除法，该程序示例把计算后的百分比强制转换为 float类型。其实，也不必使用强制类型转换，因为在表达式100.0 * cold_days / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支语句（branching statement）或选择语句（selection statement），因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：\n12if(expression)statement如果对expression求值为真（非0），则执行statement；否则，跳过statement。与while循环一样，statement可以是一条简单语句或复合语句。if语句的结构和while语句很相似，它们的主要区别是：如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次。\n通常，expression 是关系表达式，即比较两个量的大小（如，表达式 x &gt; y 或 c == 6）。如果expression为真（即x大于y，或c == 6），则执行statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。\nstatement部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句（或块）：\n1234567if (score &gt; big)    printf(\"Jackpot!\\n\");　// 简单语句if (joe &gt; ron)&#123;　　　　　　　　　　　　　 // 复合语句    joecash++;    printf(\"You lose, Ron.\\n\");&#125;注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。\nif else语句简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else形式，可以在两条语句之间作选择。我们用if else形式修正程序清单7.1中的程序段。\n12345if (all_days != 0)\tprintf(\"%d days total: %.1f%% were below freezing.\\n\",\tall_days, 100.0 * (float) cold_days / all_days);if (all_days == 0)\tprintf(\"No data entered!\\n\");如果程序发现all_days不等于0，那么它应该知道另一种情况一定是all_days等于0。用if else形式只需测试一次。重写上面的程序段如下：\n12345if (all_days!= 0)    printf(\"%d days total: %.1f%% were below freezing.\\n\",    all_days, 100.0 * (float) cold_days / all_days);else    printf(\"No data entered!\\n\");如果if语句的测试表达式为真，就打印温度数据；如果为假，就打印警告消息。\n注意，if else语句的通用形式是：\n1234if ( expression )statement1elsestatement2如果expression为真（非0），则执行statement1；如果expression为假或0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。\n如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。下面的代码结构违反了C语法，因为在if和else之间只允许有一条语句（简单语句或复合语句）：\n12345if (x &gt; 0)\tprintf(\"Incrementing x:\\n\");x++;else　　　// 将产生一个错误\tprintf(\"x &lt;= 0 \\n\");编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句，它不是if语句的一部分。然后，编译器发现else并没有所属的if，这是错误的。上面的代码应该这样写：\n1234567if (x &gt; 0)&#123;    printf(\"Incrementing x:\\n\");    x++;&#125;else    printf(\"x &lt;= 0 \\n\");if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择。图7.1比较了这两种语句。\n\n另一个示例：介绍getchar()和putchar()到目前为止，学过的大多数程序示例都要求输入数值。接下来，我们看看输入字符的示例。相信读者已经熟悉了如何用 scanf()和 printf()根据%c 转换说明读写字符，我们马上要讲解的示例中要用到一对字符输入/输出函数：getchar()和putchar()。\ngetchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：\n1ch = getchar();该语句与下面的语句效果相同：\n1scanf(\"%c\", &amp;ch);putchar()函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：\n1putchar(ch);该语句与下面的语句效果相同：\n1printf(\"%c\", ch);由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。而且，注意 getchar()和 putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在 stdio.h头文件中（而且，它们通常是预处理宏，而不是真正的函数，第16章会讨论类似函数的宏）。\n接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中的下一个字符，空格不变。这一过程可描述为“如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符”。\nC代码看上去和上面的描述很相似，请看程序清单7.2。\n1234567891011121314151617181920程序清单7.2 cypher1.c程序// cypher1.c -- 更改输入，空格不变#include &lt;stdio.h&gt;#define SPACE ' '　　　　　　　 // SPACE表示单引号-空格-单引号int main(void)&#123;    char ch;    ch = getchar();　　　　　　 // 读取一个字符    while (ch != '\\n')　　　　 // 当一行未结束时    &#123;        if (ch == SPACE)　　　 // 留下空格     \t   putchar(ch);　　　 // 该字符不变        else     \t   putchar(ch + 1);　 // 改变其他字符        ch = getchar();　　　　// 获取下一个字符    &#125;    putchar(ch);　　　　　　　　// 打印换行符    return 0;&#125;（如果编译器警告因转换可能导致数据丢失，不用担心。第8章在讲到EOF时再解释。）\n下面是该程序的输入示例：\n12CALL ME HAL.DBMM NF IBM/把程序清单7.1中的循环和该例中的循环作比较。前者使用scanf()返回的状态值判断是否结束循环，而后者使用输入项的值来判断是否结束循环。这使得两程序所用的循环结构略有不同：程序清单7.1中在循环前面有一条“读取语句”，程序清单7.2中在每次迭代的末尾有一条“读取语句”。不过，C的语法比较灵活，读者也可以模仿程序清单7.1，把读取和测试合并成一个表达式。也就是说，可以把这种形式的循环：\n123456ch = getchar();　　　 /* 读取一个字符 */while (ch != '\\n')　　/* 当一行未结束时 */&#123;    ...　　　　　　　/* 处理字符 */    ch = getchar();　 /* 获取下一个字符 */&#125;替换成下面形式的循环：\n1234while ((ch = getchar()) != '\\n')&#123;\t...　　　　　　　/* 处理字符 */&#125;关键的一行代码是：\n1while ((ch = getchar()) != '\\n')这体现了C特有的编程风格——把两个行为合并成一个表达式。C对代码的格式要求宽松，这样写让其中的每个行为更加清晰：\n123while ((ch = getchar())　　　　　　 // 给ch赋一个值!= '\\n')　 // 把ch和\\n作比较以上执行的行为是赋值给ch和把ch的值与换行符作比较。表达式ch = getchar()两侧的圆括号使之成为!=运算符的左侧运算对象。要对该表达式求值，必须先调用getchar()函数，然后把该函数的返回值赋给 ch。因为赋值表达式的值是赋值运算符左侧运算对象的值，所以 ch = getchar()的值就是 ch 的新值，因此，读取ch的值后，测试条件相当于是ch != &#39;\\n&#39;（即，ch不是换行符）。\n这种独特的写法在C编程中很常见，应该多熟悉它。还要记住合理使用圆括号组合子表达式。上面例子中的圆括号都必不可少。假设省略ch = getchar()两侧的圆括号：\n1while (ch = getchar() != '\\n')!=运算符的优先级比=高，所以先对表达式getchar() != &#39;\\n&#39;求值。由于这是关系表达式，所以其值不是1就是0（真或假）。然后，把该值赋给ch。省略圆括号意味着赋给ch的值是0或1，而不是 getchar()的返回值。这不是我们的初衷。\n下面的语句：\n1putchar(ch + 1); /* 改变其他字符 */再次演示了字符实际上是作为整数储存的。为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()，该函数只根据最后一个字节确定显示哪个字符。\nctype.h系列的字符函数注意到程序清单7.2的输出中，最后输入的点号（.）被转换成斜杠（/），这是因为斜杠字符对应的ASCII码比点号的 ASCII 码多 1。如果程序只转换字母，保留所有的非字母字符（不只是空格）会更好。本章稍后讨论的逻辑运算符可用来测试字符是否不是空格、不是逗号等，但是列出所有的可能性太繁琐。C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值（真）；否则，返回0（假）。例如，如果isalpha()函数的参数是一个字母，则返回一个非零值。程序清单7.3在程序清单7.2的基础上使用了这个函数，还使用了刚才精简后的循环。\n123456789101112131415161718程序清单7.3 cypher2.c程序// cypher2.c -- 替换输入的字母，非字母字符保持不变#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;　　　　　　　// 包含isalpha()的函数原型int main(void)&#123;    char ch;    while ((ch = getchar()) != '\\n')    &#123;        if (isalpha(ch))　　　 // 如果是一个字符，\t\t\tputchar(ch + 1);　 // 显示该字符的下一个字符        else　　　　　　　　　　// 否则，\t\t\tputchar(ch);　　　 // 原样显示    &#125;    putchar(ch);　　　　　　　 // 显示换行符    return 0;&#125;下面是该程序的一个输出示例，注意大小写字母都被替换了，除了空格和标点符号：\n12Look! It's a programmer!Mppl! Ju't b qsphsbnnfs!表7.1和表7.2列出了ctype.h头文件中的一些函数。有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具（例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为123,45）。注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值。也就是说，下面的语句不改变ch的值：\n1tolower(ch); // 不影响ch的值这样做才会改变ch的值：\n1ch = tolower(ch); // 把ch转换成小写字母\nctype.h头文件中的字符测试函数\n\n\n\nctype.h头文件中的字符映射函数\n\n\n多重选择else if现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结构模拟这种情况。来看一个特殊的例子。电力公司通常根据客户的总用电量来决定电费。下面是某电力公司的电费清单，单位是千瓦时（kWh）：\n1234首 360kWh:　　　　 $0.13230/kWh续 108kWh:　　　　 $0.15040/kWh续 252kWh:　　　　 $0.30025/kWh超过 720kWh:　　　 $0.34025/kWh如果对用电管理感兴趣，可以编写一个计算电费的程序。程序清单7.4是完成这一任务的第1步。\n程序清单7.4 electric.c程序\n123456789101112131415161718192021222324252627282930313233// electric.c -- 计算电费#include &lt;stdio.h&gt;#define RATE1　 0.13230　　　　　　　// 首次使用 360 kwh 的费率#define RATE2　 0.15040　　　　　　　// 接着再使用 108 kwh 的费率#define RATE3　 0.30025　　　　　　　// 接着再使用 252 kwh 的费率#define RATE4　 0.34025　　　　　　　// 使用超过 720kwh 的费率#define BREAK1　360.0　　　　　　　　// 费率的第1个分界点#define BREAK2　468.0　　　　　　　　// 费率的第2个分界点#define BREAK3　720.0　　　　　　　　// 费率的第3个分界点#define BASE1　(RATE1 * BREAK1)// 使用360kwh的费用#define BASE2 (BASE1 + (RATE2 * (BREAK2 - BREAK1)))// 使用468kwh的费用#define BASE3　(BASE1 + BASE2 + (RATE3 *(BREAK3 - BREAK2)))// 使用720kwh的费用int main(void)&#123;    double kwh;　　　　　　　　　　 // 使用的千瓦时    double bill;　　　　　　　　　　// 电费    printf(\"Please enter the kwh used.\\n\");    scanf(\"%lf\", &amp;kwh);　　　　　　 // %lf对应double类型    if (kwh &lt;= BREAK1)\t\tbill = RATE1 * kwh;    else if (kwh &lt;= BREAK2)　　　　 // 360～468 kwh\t\tbill = BASE1 + (RATE2 * (kwh - BREAK1));    else if (kwh &lt;= BREAK3)　　　　 // 468～720 kwh\t\tbill = BASE2 + (RATE3 * (kwh - BREAK2));    else　　　　　　　　　　　　　　// 超过 720 kwh\t\tbill = BASE3 + (RATE4 * (kwh - BREAK3));    printf(\"The charge for %.1f kwh is $%1.2f.\\n\", kwh, bill);    return 0;&#125;该程序的输出示例如下：\n123Please enter the kwh used.580The charge for 580.0 kwh is $97.50.程序清单 7.4 用符号常量表示不同的费率和费率分界点，以便把常量统一放在一处。这样，电力公司在更改费率以及费率分界点时，更新数据非常方便。BASE1和BASE2根据费率和费率分界点来表示。一旦费率或分界点发生了变化，它们也会自动更新。预处理器是不进行计算的。程序中出现BASE1的地方都会被替换成 0.13230*360.0。不用担心，编译器会对该表达式求值得到一个数值（47.628），以便最终的程序代码使用的是47.628而不是一个计算式。\n程序流简单明了。该程序根据kwh的值在3个公式之间选择一个。特别要注意的是，如果kwh大于或等于360，程序只会到达第1个else。因此，else if(kwh&lt;=BREAK2)这行相当于要求kwh在360～482之间，如程序注释所示。类似地，只有当kwh的值超过720时，才会执行最后的else。最后，注意BASE1、BASE2和BASE3分别代表360、468和720千瓦时的总费用。因此，当电量超过这些值时，只需要加上额外的费用即可。\n实际上，else if 是已学过的 if else 语句的变式。例如，该程序的核心部分只不过是下面代码的另一种写法：\n12345678910if (kwh &lt;= BREAK1)\tbill=RATE1*kwh;else\tif (kwh &lt;= BREAK2)　　　　 // 360～468 kwh\t\tbill = BASE1 + (RATE2 * (kwh - BREAK1));\telse\t\tif (kwh &lt;= BREAK3)　　 // 468～720 kwh\t\t\tbill = BASE2 + (RATE3 * (kwh - BREAK2));\t\telse　　　　　　　　　　// 超过720 kwh\t\t\tbill = BASE3 + (RATE4 * (kwh - BREAK3));也就是说，该程序由一个if else语句组成，else部分包含另一个if else语句，该if else语句的else部分又包含另一个if else语句。第2个if else语句嵌套在第 1个if else语句中，第3个if else语句嵌套在第2个if else语句中。回忆一下，整个if else语句被视为一条语句，因此不必把嵌套的if else语句用花括号括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。\n这两种形式完全等价。唯一不同的是使用空格和换行的位置不同，不过编译器会忽略这些。尽管如此，第1种形式还是好些，因为这种形式更清楚地显示了有4种选择。在浏览程序时，这种形式让读者更容易看清楚各项选择。在需要时要缩进嵌套的部分，例如，必须测试两个单独的量时。本例中，仅在夏季对用电量超过720kWh的用户加收10%的电费，就属于这种情况。\n可以把多个else if语句连成一串使用，如下所示（当然，要在编译器的限制范围内）：\n12345678910if (score &lt; 1000)\tbonus = 0;else if (score &lt; 1500)\tbonus = 1;else if (score &lt; 2000)\tbonus = 2;else if (score &lt; 2500)\tbonus = 4;else\tbonus = 6;（这可能是一个游戏程序的一部分，bonus表示下一局游戏获得的光子炸弹或补给。）\n对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌。\nelse与if配对如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？例如，考虑下面的程序段：\n12345if (number &gt; 6)\tif (number &lt; 12)\t\tprintf(\"You're close!\\n\");\telse\t\tprintf(\"Sorry, you lose a turn!\\n\");何时打印Sorry, you lose a turn!？当number小于或等于6时，还是number大于12时？换言之，else与第1个if还是第2个if匹配？答案是，else与第2个if匹配。也就是说，输入的数字和匹配的响应如下：\n1234数字　　　 响应5　　　　 None10　　　　You’re close!15　　　　Sorry, you lose a turn!规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来（见图7.2）。\n\n第1个例子的缩进使得else看上去与第1个if相匹配，但是记住，编译器是忽略缩进的。如果希望else与第1个if匹配，应该这样写：\n1234567if (number &gt; 6)&#123;    if (number &lt; 12)    printf(\"You're close!\\n\");&#125;else\tprintf(\"Sorry, you lose a turn!\\n\");这样改动后，响应如下：\n1234数字　　　 响应5　　　　 Sorry, you lose a turn!10　　　　You’re close!15　　　　None多层嵌套的if语句前面介绍的if...else if...else序列是嵌套if的一种形式，从一系列选项中选择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使用另一种嵌套 if。例如，程序可以使用 if else选择男女，if else的每个分支里又包含另一个if else来区分不同收入的群体。\n我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所有能整除它的约数。如果没有约数，则报告该数是一个素数。\n在编写程序的代码之前要先规划好。首先，要总体设计一下程序。为方便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试一个新的数字时不必每次都要重新运行程序。下面是我们为这种循环开发的一个模型（伪代码）：\n1234提示用户输入数字当scanf()返回值为1分析该数并报告结果提示用户继续输入回忆一下在测试条件中使用scanf()，把读取数字和判断测试条件确定是否结束循环合并在一起。\n下一步，设计如何找出约数。也许最直接的方法是：\n123for (div = 2; div &lt; num; div++)if (num % div == 0)printf(\"%d is divisible by %d\\n\", num, div);该循环检查2～num之间的所有数字，测试它们是否能被num整除。但是，这个方法有点浪费时间。我们可以改进一下。例如，考虑如果144%2得0，说明2是144的约数；如果144除以2得72，那么72也是144的一个约数。所以，num % div测试成功可以获得两个约数。为了弄清其中的原理，我们分析一下循环中得到的成对约数：2和72、2和48、4和36、6和24、8和18、9和16、12和12、16和9、18和8，等等。在得到12和12这对约数后，又开始得到已找到的相同约数（次序相反）。因此，不用循环到143，在达到12以后就可以停止循环。这大大地节省了循环时间！\n分析后发现，必须测试的数只要到num的平方根就可以了，不用到num。对于9这样的数字，不会节约很多时间，但是对于10000这样的数，使用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以这样编写测试条件：\n123for (div = 2; (div * div) &lt;= num; div++)\tif (num % div == 0)\t\tprintf(\"%d is divisible by %d and %d.\\n\",num, div, num / div);如果num是144，当div = 12时停止循环。如果num是145，当div = 13时停止循环。\n不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求平方根快。其二，我们还没有正式介绍平方根函数。\n还要解决两个问题才能准备编程。第1个问题，如果待测试的数是一个完全平方数怎么办？报告144可以被12和12整除显得有点傻。可以使用嵌套if语句测试div是否等于num /div。如果是，程序只打印一个约数：\n12345678910for (div = 2; (div * div) &lt;= num; div++)&#123;    if (num % div == 0)    &#123;        if (div * div != num)        \tprintf(\"%d is divisible by %d and %d.\\n\",num, div, num / div);        else        \tprintf(\"%d is divisible by %d.\\n\", num, div);    &#125;&#125;注意\n从技术角度看，if else语句作为一条单独的语句，不必使用花括号。外层if也是一条单独的语句，也不必使用花括号。但是，当语句太长时，使用花括号能提高代码的可读性，而且还可防止今后在if循环中添加其他语句时忘记加花括号。\n第2个问题，如何知道一个数字是素数？如果num是素数，程序流不会进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值（如，1），然后在if语句中把该变量重新设置为0。循环完成后，检查该变量是否是1，如果是，说明没有进入if语句，那么该数就是素数。这样的变量通常称为标记（flag）。\n一直以来，C都习惯用int作为标记的类型，其实新增的_Bool类型更合适。另外，如果在程序中包含了stdbool.h头文件，便可用bool代替_Bool类型，用true和false分别代替1和0。\n程序清单7.5体现了以上分析的思路。为扩大该程序的应用范围，程序用long类型而不是int类型（如果系统不支持_Bool类型，可以把isPrime的类型改为int，并用1和0分别替换程序中的true和false）。\n程序清单7.5 divisors.c程序\n12345678910111213141516171819202122232425262728293031323334// divisors.c -- 使用嵌套if语句显示一个数的约数#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int main(void)&#123;    unsigned long num;　　　　 // 待测试的数    unsigned long div;　　　　 // 可能的约数    bool isPrime;　　　　　　　// 素数标记    printf(\"Please enter an integer for analysis; \");    printf(\"Enter q to quit.\\n\");    while (scanf(\"%lu\", &amp;num) == 1)    &#123;    \tfor (div = 2, isPrime = true; (div * div) &lt;= num; div++)        &#123;            if (num % div == 0)            &#123;                if ((div * div) != num)                    printf(\"%lu is divisible by %lu and %lu.\\n\",                    num, div, num / div);                else                    printf(\"%lu is divisible by %lu.\\n\",                    num, div);                isPrime = false;　 // 该数不是素数            &#125;    \t&#125;        if (isPrime)            printf(\"%lu is prime.\\n\", num);        printf(\"Please enter another integer for analysis; \");        printf(\"Enter q to quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return 0;&#125;注意，该程序在for循环的测试表达式中使用了逗号运算符，这样每次输入新值时都可以把isPrime设置为true。\n下面是该程序的一个输出示例：\n123456789101112131415161718Please enter an integer for analysis; Enter q to quit.123456789123456789 is divisible by 3 and 41152263.123456789 is divisible by 9 and 13717421.123456789 is divisible by 3607 and 34227.123456789 is divisible by 3803 and 32463.123456789 is divisible by 10821 and 11409.Please enter another integer for analysis; Enter q to quit.149149 is prime.Please enter another integer for analysis; Enter q to quit.20132013 is divisible by 3 and 671.2013 is divisible by 11 and 183.2013 is divisible by 33 and 61.Please enter another integer for analysis; Enter q to quit.qBye.该程序会把1认为是素数，其实它不是。下一节将要介绍的逻辑运算符可以排除这种特殊的情况。\n小结：用if语句进行选择\n关键字：if、else\n一般注解：\n下面各形式中，statement可以是一条简单语句或复合语句。表达式为真说明其值是非零值。\n形式1：\n123if (expression)statement如果expression为真，则执行statement部分。形式2：\n12345if (expression)statement1elsestatement2如果expression为真，执行statement1部分；否则，执行statement2部分。形式3：\n123456if (expression1)statement1else if (expression2)statement2elsestatement3如果expression1为真，执行statement1部分；如果expression2为真，执行statement2部分；否则，执行statement3部分。\n示例：\n123456789if (legs == 4)\tprintf(\"It might be a horse.\\n\");else if (legs &gt; 4)\tprintf(\"It is not a horse.\\n\");else　　 /* 如果legs &lt; 4 */&#123;\tlegs++;\tprintf(\"Now it has one more leg.\\n\");&#125;逻辑运算符读者已经很熟悉了，if 语句和 while 语句通常使用关系表达式作为测试条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情况下可以使用逻辑运算符，并使用句点（.）标识句子的末尾。程序清单7.6用一个简短的程序进行演示。\n程序清单7.6 chcount.c程序\n12345678910111213141516// chcount.c　-- 使用逻辑与运算符#include &lt;stdio.h&gt;#define PERIOD '.'int main(void)&#123;    char ch;    int charcount = 0;    while((ch = getchar()) != PERIOD)    &#123;        if (ch != '\"' &amp;&amp; ch != '\\'')        \tcharcount++;    &#125;    printf(\"There are %d non-quote characters.\\n\", charcount);    return 0;&#125;下面是该程序的一个输出示例：\n12I didn't read the \"I'm a Programming Fool\" best seller.There are 50 non-quote characters.程序首先读入一个字符，并检查它是否是一个句点，因为句点标志一个句子的结束。接下来，if语句的测试条件中使用了逻辑与运算符&amp;&amp;。该 if 语句翻译成文字是“如果待测试的字符不是双引号，并且它也不是单引号，那么charcount递增1”。\n逻辑运算符两侧的条件必须都为真，整个表达式才为真。逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号。\nC有3种逻辑运算符，见表7.3。\n\n假设exp1和exp2是两个简单的关系表达式（如car &gt; rat或debt == 1000），那么：\n当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真；\n如果exp1或exp2为真，则exp1 || exp2为真；\n如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。\n下面是一些具体的例子：\n5 &gt; 2 &amp;&amp; 4 &gt; 7为假，因为只有一个子表达式为真；\n5 &gt; 2 || 4 &gt; 7为真，因为有一个子表达式为真；\n!(4 &gt; 7)为真，因为4不大于7。\n顺带一提，最后一个表达式与下面的表达式等价：\n14 &lt;= 7如果不熟悉逻辑运算符或者觉得很别扭，请记住：(练习&amp;&amp;时间)== 完美。\n备选拼写：iso646.h头文件C 是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用and代替&amp;&amp;、or代替||、not代替!。例如，可以把下面的代码：\n12if (ch != '\"' &amp;&amp; ch != '\\'')charcount++;改写为：\n12if (ch != '\"' and ch != '\\'')charcount++;表7.4列出了逻辑运算符对应的拼写，很容易记。读者也许很好奇，为何C不直接使用and、or和not？因为C一直坚持尽量保持较少的关键字。参考资料V“新增C99和C11的标准ANSI C库”列出了一些运算符的备选拼写，有些我们还没见过。\n优先级\n算数运算符&gt;关系运算符&gt;赋值运算符\n\n!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。因此，表达式a&gt;b &amp;&amp; b&gt;c || b&gt;d相当于((a&gt;b) &amp;&amp; (b&gt;c)) || (b&gt;d)。\n也就是说，b介于a和c之间，或者b大于d。\n尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第 2 种写法。这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚。\n求值顺序除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可能先对表达式9 + 6求值：\n1apples = (5 + 3) * (9 + 6);C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。正是由于有这些规定，才能写出这样结构的代码：\n1while((c = getchar()) != ' ' &amp;&amp; c != '\\n')如上代码所示，读取字符直至遇到第1 个空格或换行符。第1 个子表达式把读取的值赋给c，后面的子表达式会用到c的值。如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值。\n这里还有一个例子：\n12if (number != 0 &amp;&amp; 12/number == 2)\tprintf(\"The number is 5 or 6.\\n\");如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值。这样避免了把0作为除数。许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件。\n最后，考虑这个例子：\n1while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前，已经递增了x。\n小结：逻辑运算符和表达式\n逻辑运算符：\n逻辑运算符的运算对象通常是关系表达式。!运算符只需要一个运算对象，其他两个逻辑运算符都需要两个运算对象，左侧一个，右侧一个。\n\n逻辑表达式：\n当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真。如果 expression1 或 expression2 为真，expression1 || expression2 为真。如果expression为假，!expression则为真，反之亦然。\n求值顺序：\n逻辑表达式的求值顺序是从左往右。一旦发现有使整个表达式为假的因素，立即停止求值。\n示例：\n1236 &gt; 2 &amp;&amp; 3 == 3　　　　 真!(6 &gt; 2 &amp;&amp; 3 == 3)　　　假x != 0 &amp;&amp; (20 / x) &lt; 5 只有当x不等于0时，才会对第2个表达式求值范围&amp;&amp;运算符可用于测试范围。例如，要测试score是否在90～100的范围内，可以这样写：\n12if (range &gt;= 90 &amp;&amp; range &lt;= 100)\tprintf(\"Good show!\\n\");千万不要模仿数学上的写法：\n12if (90 &lt;= range &lt;= 100)　　// 千万不要这样写！\tprintf(\"Good show!\\n\");这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题（虽然可能会给出警告）。由于&lt;=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：\n1(90 &lt;= range) &lt;= 100子表达式90 &lt;= range的值要么是1（为真），要么是0（为假）。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&amp;&amp;。\n许多代码都用范围测试来确定一个字符是否是小写字母。例如，假设ch是char类型的变量：\n12if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')printf(\"That's a lowercase character.\\n\");该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相邻数字一一对应。但是，对于像EBCDIC这样的代码就没用了。相应的可移植方法是，用ctype.h系列中的islower()函数（参见表7.1）：\n12if (islower(ch))printf(\"That's a lowercase character.\\n\");无论使用哪种特定的字符编码，islower()函数都能正常运行（不过，一些早期的编译器没有ctype.h系列）。\n一个统计单词的程序现在，我们可以编写一个统计单词数量的程序（即，该程序读取并报告单词的数量）。该程序还可以计算字符数和行数。先来看看编写这样的程序要涉及那些内容。\n首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序能识别并计算这些内容：字符、行数和单词。据此我们编写的伪代码如下：\n1234567891011读取一个字符当有更多输入时递增字符计数如果读完一行，递增行数计数如果读完一个单词，递增单词计数读取下一个字符前面有一个输入循环的模型：while ((ch = getchar()) != STOP)&#123;...&#125;这里，STOP表示能标识输入末尾的某个值。以前我们用过换行符和句点标记输入的末尾，但是对于一个通用的统计单词程序，它们都不合适。我们暂时选用一个文本中不常用的字符（如，|）作为输入的末尾标记。第8章中会介绍更好的方法，以便程序既能处理文本文件，又能处理键盘输入。\n现在，我们考虑循环体。因为该程序使用getchar()进行输入，所以每次迭代都要通过递增计数器来计数。为了统计行数，程序要能检查换行字符。如果输入的字符是一个换行符，该程序应该递增行数计数器。这里要注意 STOP 字符位于一行的中间的情况。是否递增行数计数？我们可以作为特殊行计数，即没有换行符的一行字符。可以通过记录之前读取的字符识别这种情况，即如果读取时发现 STOP 字符的上一个字符不是换行符，那么这行就是特殊行。\n最棘手的部分是识别单词。首先，必须定义什么是该程序识别的单词。我们用一个相对简单的方法，把一个单词定义为一个不含空白（即，没有空格、制表符或换行符）的字符序列。因此，“glymxck”和“r2d2”都算是一个单词。程序读取的第 1 个非空白字符即是一个单词的开始，当读到空白字符时结束。判断非空白字符最直接的测试表达式是：\n1c != ' ' &amp;&amp; c != '\\n' &amp;&amp; c != '\\t' /* 如果c不是空白字符，该表达式为真*/检测空白字符最直接的测试表达式是：\n1c == ' ' || c == '\\n' || c == '\\t' /*如果c是空白字符，该表达式为真*/然而，使用ctype.h头文件中的函数isspace()更简单，如果该函数的参数是空白字符，则返回真。所以，如果c是空白字符，isspace(c)为真；如果c不是空白字符，!isspace(c)为真。\n要查找一个单词里是否有某个字符，可以在程序读入单词的首字符时把一个标记（名为 inword）设置为1。也可以在此时递增单词计数。然后，只要inword为1（或true），后续的非空白字符都不记为单词的开始。下一个空白字符，必须重置标记为0（或false），然后程序就准备好读取下一个单词。我们把以上分析写成伪代码：\n1234如果c不是空白字符，且inword为假设置inword为真，并给单词计数如果c是空白字符，且inword为真设置inword为假这种方法在读到每个单词的开头时把inword设置为1（真），在读到每个单词的末尾时把inword设置为0（假）。只有在标记从0设置为1时，递增单词计数。如果能使用_Bool类型，可以在程序中包含stdbool.h头文件，把inword的类型设置为bool，其值用true和false表示。如果编译器不支持这种用法，就把inword的类型设置为int，其值用1和0表示。\n如果使用布尔类型的变量，通常习惯把变量自身作为测试条件。如下所示：\n12用if (inword)代替if (inword == true)用if (!inword)代替if (inword == false)可以这样做的原因是，如果 inword为true，则表达式 inword == true为true；如果 inword为false，则表达式inword == true为false。所以，还不如直接用inword作为测试条件。类似地，!inword的值与表达式inword == false的值相同（非真即false，非假即true）。\n程序清单7.7把上述思路（识别行、识别不完整的行和识别单词）翻译了成C代码。\n程序清单7.7 wordcnt.c程序\n1234567891011121314151617181920212223242526272829303132333435363738// wordcnt.c -- 统计字符数、单词数、行数#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;　　　　 // 为isspace()函数提供原型#include &lt;stdbool.h&gt;　　　 // 为bool、true、false提供定义#define STOP '|'int main(void)&#123;    char c;　　　　　　　　// 读入字符    char prev;　　　　　　 // 读入的前一个字符    long n_chars = 0L;// 字符数    int n_lines = 0;　　　 // 行数    int n_words = 0;　　　 // 单词数    int p_lines = 0;　　　 // 不完整的行数    bool inword = false;　 // 如果c在单词中，inword 等于 true    printf(\"Enter text to be analyzed (| to terminate):\\n\");    prev = '\\n';　　　　　 // 用于识别完整的行    while ((c = getchar()) != STOP)    &#123;        n_chars++;　　　　 // 统计字符        if (c == '\\n')        \tn_lines++;　　 // 统计行        if (!isspace(c) &amp;&amp; !inword)        &#123;            inword = true;// 开始一个新的单词            n_words++;　　 // 统计单词    \t&#125;        if (isspace(c) &amp;&amp; inword)\t\t\tinword = false;　　// 打到单词的末尾        prev = c;　　　　　// 保存字符的值    &#125;    if (prev != '\\n')\t\tp_lines = 1;    printf(\"characters = %ld, words = %d, lines = %d, \",    n_chars, n_words, n_lines);    printf(\"partial lines = %d\\n\", p_lines);    return 0;&#125;下面是运行该程序后的一个输出示例：\n123456Enter text to be analyzed (| to terminate):Reason is apowerful servant butan inadequate master.|characters = 55, words = 9, lines = 3, partial lines = 0该程序使用逻辑运算符把伪代码翻译成C代码。例如，把下面的伪代码：\n如果c不是空白字符，且inword为假\n翻译成如下C代码：\n1if (!isspace(c) &amp;&amp;!inword)再次提醒读者注意，!inword 与 inword == false 等价。上面的整个测试条件比单独判断每个空白字符的可读性高：\n1if (c != ' ' &amp;&amp; c != '\\n' &amp;&amp; c != '\\t' &amp;&amp; !inword)上面的两种形式都表示“如果c不是空白字符，且如果c不在单词里”。如果两个条件都满足，则一定是一个新单词的开头，所以要递增n_words。如果位于单词中，满足第1个条件，但是inword为true，就不递增 n_word。当读到下一个空白字符时，inword 被再次设置为 false。检查代码，查看一下如果单词之间有多个空格时，程序是否能正常运行。第 8 章讲解了如何修正这个问题，让该程序能统计文件中的单词量。\n条件运算符：?:C提供条件表达式（conditional expression）作为表达if else语句的一种便捷方式，该表达式使用?:条件运算符。该运算符分为两部分，需要 3 个运算对象。回忆一下，带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符。以此类推，带 3 个运算对象的运算符称为三元运算符。条件运算符是C语言中唯一的三元运算符。下面的代码得到一个数的绝对值：\n1x = (y &lt; 0) ? -y : y;在=和;之间的内容就是条件表达式，该语句的意思是“如果y小于0，那么x = -y;否则，x = y”。用if else可以这样表达：\n1234if (y &lt; 0)\tx = -y;else\tx = y;条件表达式的通用形式如下：\n1expression1 ? expression2 : expression3如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2 的值相同；如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。\n需要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子是，把两个值中的最大值赋给变量：\n1max = (a &gt; b) ? a : b;如果a大于b，那么将max设置为a；否则，设置为b。\n通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。\n我们来看程序清单7.8中的油漆程序，该程序计算刷给定平方英尺的面积需要多少罐油漆。基本算法很简单：用平方英尺数除以每罐油漆能刷的面积。但是，商店只卖整罐油漆，不会拆分来卖，所以如果计算结果是1.7罐，就需要两罐。因此，该程序计算得到带小数的结果时应该进1。条件运算符常用于处理这种情况，而且还要根据单复数分别打印can和cans。\n程序清单7.8 paint.c程序\n12345678910111213141516171819/* paint.c -- 使用条件运算符 */#include &lt;stdio.h&gt;#define COVERAGE 350　　　// 每罐油漆可刷的面积（单位：平方英尺）int main(void)&#123;    int sq_feet;    int cans;    printf(\"Enter number of square feet to be painted:\\n\");    while (scanf(\"%d\", &amp;sq_feet) == 1)    &#123;        cans = sq_feet / COVERAGE;        cans += ((sq_feet % COVERAGE == 0)) ? 0 : 1;        printf(\"You need %d %s of paint.\\n\", cans,        cans == 1 ? \"can\" : \"cans\");        printf(\"Enter next value (q to quit):\\n\");    &#125;    return 0;&#125;下面是该程序的运行示例：\n12345678Enter number of square feet to be painted:349You need 1 can of paint.Enter next value (q to quit):351You need 2 cans of paint.Enter next value (q to quit):q该程序使用的变量都是int类型，除法的计算结果（sq_feet / COVERAGE）会被截断。也就是说， 351/350得1。所以，cans被截断成整数部分。如果sq_feet % COVERAGE得0，说明sq_feet被COVERAGE整除，cans的值不变；否则，肯定有余数，就要给cans加1。这由下面的语句完成：\n1cans += ((sq_feet % COVERAGE == 0)) ? 0 : 1;该语句把+=右侧表达式的值加上cans，再赋给cans。右侧表达式是一个条件表达式，根据sq_feet是否能被COVERAGE整除，其值为0或1。\nprintf()函数中的参数也是一个条件表达式：\n1cans == 1 ? \"can\" : \"cans\");如果cans的值是1，则打印can；否则，打印cans。这也说明了条件运算符的第2个和第3个运算对象可以是字符串。\n小结：条件运算符\n条件运算符：?:\n一般注解：\n条件运算符需要3个运算对象，每个运算对象都是一个表达式。其通用形式如下：\n1expression1 ? expression2 : expression3如果expression1为真，整个条件表达式的值是expression2的值；否则，是expression3的值。\n示例：\n123(5 &gt; 3) ? 1 : 2 值为1(3 &gt; 5) ? 1 : 2 值为2(a &gt; b) ? a : b 如果a &gt;b，则取较大的值循环辅助：continue和break一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue 和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。\ncontinue语句3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。程序清单7.9中的简短程序演示了如何使用continue。\n程序清单7.9 skippart.c程序\n123456789101112131415161718192021222324252627282930313233343536/* skippart.c -- 使用continue跳过部分循环 */#include &lt;stdio.h&gt;int main(void)&#123;    const float MIN = 0.0f;    const float MAX = 100.0f;    float score;    float total = 0.0f;    int n = 0;    float min = MAX;    float max = MIN;    printf(\"Enter the first score (q to quit): \");    while (scanf(\"%f\", &amp;score) == 1)    &#123;        if (score &lt; MIN || score &gt; MAX)        &#123;            printf(\"%0.1f is an invalid value.Try again: \",score);            continue;　 // 跳转至while循环的测试条件    \t&#125;        printf(\"Accepting %0.1f:\\n\", score);        min = (score &lt; min) ? score : min;        max = (score &gt; max) ? score : max;        total += score;        n++;        printf(\"Enter next score (q to quit): \");    &#125;    if (n &gt; 0)    &#123;        printf(\"Average of %d scores is %0.1f.\\n\", n, total / n);        printf(\"Low = %0.1f, high = %0.1f\\n\", min, max);    &#125;    else\t\tprintf(\"No valid scores were entered.\\n\");    return 0;&#125;在程序清单7.9中，while循环读取输入，直至用户输入非数值数据。循环中的if语句筛选出无效的分数。假设输入 188，程序会报告：188 is an invalid value。在本例中，continue 语句让程序跳过处理有效输入部分的代码。程序开始下一轮循环，准备读取下一个输入值。\n注意，有两种方法可以避免使用continue，一是省略continue，把剩余部分放在一个else块中：\n123456if (score &lt; 0 || score &gt; 100)\t/* printf()语句 */else&#123;\t/* 语句*/&#125;另一种方法是，用以下格式来代替：\n1234if (score &gt;= 0 &amp;&amp; score &lt;= 100)&#123;/* 语句 */&#125;这种情况下，使用continue的好处是减少主语句组中的一级缩进。当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。\ncontinue还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾：\n12while (getchar() != '\\n');当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便。问题是，一般很难注意到一个单独的分号。如果使用continue，可读性会更高：\n12while (getchar() != '\\n')continue;如果用了continue没有简化代码反而让代码更复杂，就不要使用continue。例如，考虑下面的程序段：\n123456while ((ch = getchar() ) != '\\n')&#123;    if (ch == '\\t')\t\tcontinue;    putchar(ch);&#125;该循环跳过制表符，并在读到换行符时退出循环。以上代码这样表示更简洁：\n123while ((ch = getchar()) != '\\n')if (ch != '\\t')putchar(ch);通常，在这种情况下，把if的测试条件的关系反过来便可避免使用continue。\n以上介绍了continue语句让程序跳过循环体的余下部分。那么，从何处开始继续循环？对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值。考虑下面的循环：\n123456789count = 0;while (count &lt; 10)&#123;    ch = getchar();    if (ch == '\\n')\t\tcontinue;    putchar(ch);    count++;&#125;该循环读取10个字符（除换行符外，因为当ch是换行符时，程序会跳过count++;语句）并重新显示它们，其中不包括换行符。执行continue后，下一个被求值的表达式是循环测试条件。\n对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。例如，考虑下面的循环：\n1234567for (count = 0; count &lt; 10; count++)&#123;    ch = getchar();    if (ch == '\\n')\t\tcontinue;    putchar(ch);&#125;该例中，执行完continue后，首先递增count，然后将递增后的值和10作比较。因此，该循环与上面while循环的例子稍有不同。while循环的例子中，除了换行符，其余字符都显示；而本例中，换行符也计算在内，所以读取的10个字符中包含换行符。\nbreak语句程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。把程序清单7.9中的continue替换成break，在输入188时，不是跳至执行下一轮循环，而是导致退出当前循环。图7.3比较了break和continue。如果break语句位于嵌套循环内，它只会影响包含它的当前循环。\n\nbreak还可用于因其他原因退出循环的情况。程序清单7.10用一个循环计算矩形的面积。如果用户输入非数字作为矩形的长或宽，则终止循环。\n程序清单7.10 break.c程序\n1234567891011121314151617181920/* break.c -- 使用 break 退出循环 */#include &lt;stdio.h&gt;int main(void)&#123;    float length, width;    printf(\"Enter the length of the rectangle:\\n\");    while (scanf(\"%f\", &amp;length) == 1)    &#123;        printf(\"Length = %0.2f:\\n\", length);        printf(\"Enter its width:\\n\");        if (scanf(\"%f\", &amp;width) != 1)        \tbreak;        printf(\"Width = %0.2f:\\n\", width);        printf(\"Area = %0.2f:\\n\", length * width);        printf(\"Enter the length of the rectangle:\\n\");    &#125;    printf(\"Done.\\n\");    return 0;&#125;可以这样控制循环：\n1while (scanf(\"%f %f\", &amp;length, &amp;width) == 2)但是，用break可以方便显示用户输入的值。\n和continue一样，如果用了break代码反而更复杂，就不要使用break。例如，考虑下面的循环：\n123456while ((ch = getchar()) != '\\n')&#123;    if (ch == '\\t')        break;    putchar(ch);&#125;如果把两个测试条件放在一起，逻辑就更清晰了：\n12while ((ch = getchar() ) != '\\n' &amp;&amp; ch != '\\t')\tputchar(ch);break语句对于稍后讨论的switch语句而言至关重要。\n在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break：\n1234567891011121314151617int p, q;scanf(\"%d\", &amp;p);while (p &gt; 0)&#123;    printf(\"%d\\n\", p);    scanf(\"%d\", &amp;q);    while (q &gt; 0)    &#123;        printf(\"%d\\n\", p*q);        if (q &gt; 100)\t\t\tbreak; // 跳出内层循环        scanf(\"%d\", &amp;q);    &#125;    if (q &gt; 100)  \t  break; // 跳出外层循环    scanf(\"%d\", &amp;p);&#125;多重选择：switch和break使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else  if...else来完成。但是，大多数情况下使用switch语句更方便。程序清单7.11演示了如何使用switch语句。该程序读入一个字母，然后打印出与该字母开头的动物名。\n程序清单7.11 animals.c程序\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* animals.c -- 使用switch语句 */#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(void)&#123;    char ch;    printf(\"Give me a letter of the alphabet, and I will give \");    printf(\"an animal name\\nbeginning with that letter.\\n\");    printf(\"Please type in a letter; type # to end my act.\\n\");    while ((ch = getchar()) != '#')    &#123;        if ('\\n' == ch)        \tcontinue;        if (islower(ch))　　/* 只接受小写字母*/            switch (ch)            &#123;                case 'a':                \tprintf(\"argali, a wild sheep of Asia\\n\");                \tbreak;                case 'b':                \tprintf(\"babirusa, a wild pig of Malay\\n\");                \tbreak;                case 'c':                \tprintf(\"coati, racoonlike mammal\\n\");                \tbreak;                case 'd':                \tprintf(\"desman, aquatic, molelike critter\\n\");               \t\tbreak;                case 'e':                \tprintf(\"echidna, the spiny anteater\\n\");                \tbreak;                case 'f':                \tprintf(\"fisher, brownish marten\\n\");                \tbreak;                default:                \tprintf(\"That's a stumper!\\n\");            &#125;　　　　　　　　/* switch结束　　　　*/        else        \tprintf(\"I recognize only lowercase letters.\\n\");        while (getchar() != '\\n')        \tcontinue;　　 /* 跳过输入行的剩余部分　*/        printf(\"Please type another letter or a #.\\n\");    &#125;　　　　　　　　　 /* while循环结束　　　*/    printf(\"Bye!\\n\");    return 0;&#125;篇幅有限，我们只编到f，后面的字母以此类推。在进一步解释该程序之前，先看看输出示例：\n1234567891011121314151617Give me a letter of the alphabet, and I will give an animal namebeginning with that letter.Please type in a letter; type # to end my act.a [enter]argali, a wild sheep of AsiaPlease type another letter or a #.dab [enter]desman, aquatic, molelike critterPlease type another letter or a #.r [enter]That's a stumper!Please type another letter or a #.Q [enter]I recognize only lowercase letters.Please type another letter or a #.# [enter]Bye!该程序的两个主要特点是：使用了switch语句和它对输出的处理。我们先分析switch的工作原理。\nswitch语句要对紧跟在关键字 switch 后圆括号中的表达式求值。在程序清单 7.11 中，该表达式是刚输入给 ch的值。然后程序扫描标签（这里指，case &#39;a&#39; :、case &#39;b&#39; :等）列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default :标签行，就跳转至该行；否则，程序继续执行在switch后面的语句。\nbreak语句在其中起什么作用？它让程序离开switch语句，跳至switch语句后面的下一条语句（见图7.4）。如果没有break语句，就会从匹配标签开始执行到switch末尾。例如，如果删除该程序中的所有break语句，运行程序后输入d，其交互的输出结果如下：\n\n1234567891011Give me a letter of the alphabet, and I will give an animal namebeginning with that letter.Please type in a letter; type # to end my act.d [enter]desman, aquatic, molelike critterechidna, the spiny anteaterfisher, a brownish martenThat's a stumper!Please type another letter or a #.\\# [enter]Bye!如上所示，执行了从case &#39;d&#39;:到switch语句末尾的所有语句。\n顺带一提，break语句可用于循环和switch语句中，但是continue只能用于循环中。尽管如此，如果switch语句在一个循环中，continue便可作为switch语句的一部分。这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。\n如果读者熟悉Pascal，会发现switch语句和Pascal的case语句类似。它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句。另外，C语言的case一般都指定一个值，不能使用一个范围。\nswitch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。switch的构造如下：\n123456789switch ( 整型表达式)&#123;    case 常量1:    \t语句　　　&lt;--可选    case 常量2:    \t语句　　　&lt;--可选    default :　　 &lt;--可选    \t语句　　　&lt;--可选&#125;只读每行的首字符animals.c（程序清单7.11）的另一个独特之处是它读取输入的方式。运行程序时读者可能注意到了，当输入dab时，只处理了第1个字符。这种丢弃一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面的代码实现这样的行为：\n12while (getchar() != '\\n')\tcontinue;　　　　/* 跳过输入行的其余部分 */循环从输入中读取字符，包括按下Enter键产生的换行符。注意，函数的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢弃的字符是换行符，所以下一个被读取的字符是下一行的首字母。在外层的while循环中，getchar()读取首字母并赋给ch。\n假设用户一开始就按下Enter键，那么程序读到的首个字符就是换行符。下面的代码处理这种情况：\n12if (ch == '\\n')\tcontinue;多重标签如程序清单7.12所示，可以在switch语句中使用多重case标签。\n123456789101112131415161718192021222324252627282930313233343536程序清单7.12 vowels.c程序// vowels.c -- 使用多重标签#include &lt;stdio.h&gt;int main(void)&#123;    char ch;    int a_ct, e_ct, i_ct, o_ct, u_ct;    a_ct = e_ct = i_ct = o_ct = u_ct = 0;    printf(\"Enter some text; enter # to quit.\\n\");    while ((ch = getchar()) != '#')    &#123;        switch (ch)        &#123;            case 'a':            case 'A':　a_ct++;            \tbreak;            case 'e':            case 'E':　e_ct++;            \tbreak;            case 'i':            case 'I':　i_ct++;            \tbreak;            case 'o':            case 'O':　o_ct++;            \tbreak;            case 'u':            case 'U':　u_ct++;            \tbreak;            default:　 break;        &#125;　　　　　　　　　// switch结束    &#125;　　　　　　　　　　　 // while循环结束    printf(\"number of vowels:　 A　 E　 I　 O　 U\\n\");    printf(\"%4d %4d %4d %4d %4d\\n\",a_ct, e_ct, i_ct, o_ct, u_ct);    return 0;&#125;假设如果ch是字母i，switch语句会定位到标签为case &#39;i&#39; :的位置。由于该标签没有关联break语句，所以程序流直接执行下一条语句，即i_ct++;。如果 ch是字母I，程序流会直接定位到case &#39;I&#39; :。本质上，两个标签都指的是相同的语句。\n严格地说，case &#39;U&#39;的 break 语句并不需要。因为即使删除这条 break 语句，程序流会接着执行switch中的下一条语句，即default : break;。所以，可以把case &#39;U&#39;的break语句去掉以缩短代码。但是从另一方面看，保留这条break语句可以防止以后在添加新的case（例如，把y作为元音）时遗漏break语句。\n下面是该程序的运行示例：\n1234Enter some text; enter # to quit.I see under the overseer.#number of vowels:　　 A　 E　 I　 O　 U0　　7　 1　 1　 1在该例中，如果使用ctype.h系列的toupper()函数（参见表7.2）可以避免使用多重标签，在进行测试之前就把字母转换成大写字母：\n123456789101112131415161718while ((ch = getchar()) != '#')&#123;    ch = toupper(ch);    switch (ch)    &#123;        case 'A': a_ct++;        \tbreak;        case 'E': e_ct++;        \tbreak;        case 'I': i_ct++;        \tbreak;        case 'O': o_ct++;        \tbreak;        case 'U': u_ct++;        \tbreak;        default: break;    &#125; // switch结束&#125; // while循环结束或者，也可以先不转换ch，把toupper(ch)放进switch的测试条件中：switch(toupper(ch))。\n小结：带多重选择的switch语句\n关键字：switch\n一般注解：\n程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果有的话）；否则，将转至执行紧跟在switch语句后面的语句。\n形式：\n123456switch ( expression )&#123;    case label1 : statement1//使用break跳出switch    case label2 : statement2    default　　 : statement3&#125;可以有多个标签语句，default语句可选。\n示例：\n12345678switch (choice)&#123;    case 1 :    case 2 : printf(\"Darn tootin'!\\n\"); break;    case 3 : printf(\"Quite right!\\n\");    case 4 : printf(\"Good show!\\n\"); break;    default: printf(\"Have a nice day.\\n\");&#125;如果choice的值是1或2，打印第1条消息；如果choice的值是3，打印第2条和第3条消息（程序继续执行后续的语句，因为case 3后面没有break语句）；如果choice的值是4，则打印第3条消息；如果choice的值是其他值只打印最后一条消息。\nswitch和if else何时使用switch？何时使用if else？你经常会别无选择。如果是根据浮点类型的变量或表达式来选择，就无法使用 switch。如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦，这种情况用if就很方便：\n1if (integer &lt; 1000 &amp;&amp; integer &gt; 2)使用switch要涵盖以上范围，需要为每个整数（3～999）设置case标签。但是，如果使用switch，程序通常运行快一些，生成的代码少一些。\ngoto语句早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但是C和其他两种语言不同，没有goto语句C程序也能运行良好。Kernighan和Ritchie提到goto语句“易被滥用”，并建议“谨慎使用，或者根本不用”。首先，介绍一下如何使用goto语句；然后，讲解为什么通常不需要它。\ngoto语句有两部分：goto和标签名。标签的命名遵循变量命名规则，如下所示：\n1goto part2;要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句以标签名后紧跟一个冒号开始：\n1part2: printf(\"Refined analysis:\\n\");避免使用goto原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过FORTRAN或BASIC（goto对这两种语言而言都必不可少），可能还会依赖用goto来编程。为了帮助你克服这个习惯，我们先概述一些使用goto的常见情况，然后再介绍C的解决方案。\n处理包含多条语句的if语句：\n123456if (size &gt; 12)\tgoto a;goto b;a: cost = cost * 1.05;flag = 2;b: bill = cost * flag;对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if，不能使用块或复合语句。我们把以上模式转换成等价的C代码，标准C用复合语句或块来处理这种情况：\n123456if (size &gt; 12)&#123;    cost = cost * 1.05;    flag = 2;&#125;bill = cost * flag;二选一：\n123456if (ibex &gt; 14)\tgoto a;sheds = 2;goto b;a: sheds= 3;b: help = 2 * sheds;C通过if else表达二选一更清楚：\n12345if (ibex &gt; 14)sheds = 3;elsesheds = 2;help = 2 * sheds;实际上，新版的BASIC和FORTRAN已经把else纳入新的语法中。\n创建不确定循环：\n123456readin: scanf(\"%d\", &amp;score);if (score &lt; O)\tgoto stage2;lots of statementsgoto readin;stage2: more stuff;C用while循环代替：\n1234567scanf(\"%d\", &amp;score);while (score &lt;= 0)&#123;    lots of statements    scanf(\"%d\", &amp;score);&#125;more stuff;跳转至循环末尾，并开始下一轮迭代。C使用continue语句代替。\n跳出循环。C使用break语句。实际上，break和continue是goto的特殊形式。使用break和 continue 的好处是：其名称已经表明它们的用法，而且这些语句不使用标签，所以不用担心把标签放错位置导致的危险。\n胡乱跳转至程序的不同部分。简而言之，不要这样做！\n但是，C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）：\n1234567891011121314151617while (funct &gt; 0)&#123;    for (i = 1, i &lt;= 100; i++)    &#123;        for (j = 1; j &lt;= 50; j++)        &#123;            其他语句            if (问题)            goto help;        \t其他语句        &#125;        其他语句    &#125;    其他语句&#125;其他语句help: 语句从其他例子中也能看出，程序中使用其他形式比使用goto的条理更清晰。当多种情况混在一起时，这种差异更加明显。哪些goto语句可以帮助if语句？哪些可以模仿if else？哪些控制循环？哪些是因为程序无路可走才不得已放在那里？过度地使用 goto 语句，会让程序错综复杂。如果不熟悉goto语句，就不要使用它。如果已经习惯使用goto语句，试着改掉这个毛病。讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用，因为C允许在标签中使用描述性的单词而不是数字。\n小结：程序跳转\n关键字：break、continue、goto\n一般注解：\n这3种语句都能使程序流从程序的一处跳转至另一处。\nbreak语句：\n所有的循环和switch语句都可以使用break语句。它使程序控制跳出当前循环或switch语句的剩余部分，并继续执行跟在循环或switch后面的语句。\n示例：\n12345678switch (number)&#123;    case 4: printf(\"That's a good choice.\\n\");    \tbreak;    case 5: printf(\"That's a fair choice.\\n\");    \tbreak;    default: printf(\"That's a poor choice.\\n\");&#125;continue语句：\n所有的循环都可以使用continue语句，但是switch语句不行。continue语句使程序控制跳出循环的剩余部分。对于while或for循环，程序执行到continue语句后会开始进入下一轮迭代。对于do while循环，对出口条件求值后，如有必要会进入下一轮迭代。\n示例：\n1234567while ((ch = getchar()) != '\\n')&#123;    if (ch == ' ')    \tcontinue;    putchar(ch);    chcount++;&#125;以上程序段把用户输入的字符再次显示在屏幕上，并统计非空格字符。\ngoto语句：\ngoto语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语句。标签名遵循变量命名规则。标签语句可以出现在goto的前面或后面。\n形式：\n12goto label;label: statement示例：\n123top: ch=getchar();if (ch!='y')goto top;关键概念智能的一个方面是，根据情况做出相应的响应。所以，选择语句是开发具有智能行为程序的基础。C语言通过if、if else和switch语句，以及条件运算符（?:）可以实现智能选择。\nif 和 if else 语句使用测试条件来判断执行哪些语句。所有非零值都被视为 true，零被视为false。测试通常涉及关系表达式（比较两个值）、逻辑表达式（用逻辑运算符组合或更改其他表达式）。\n要记住一个通用原则，如果要测试两个条件，应该使用逻辑运算符把两个完整的测试表达式组合起来。例如，下面这些是错误的：\n1234if (a &lt; x &lt; z)　　　　　　 // 错误，没有使用逻辑运算符…if (ch != 'q' &amp;&amp; != 'Q')　 // 错误，缺少完整的测试表达式…正确的方式是用逻辑运算符连接两个关系表达式：\n1234if (a &lt; x &amp;&amp; x &lt; z)　　　　　　 // 使用&amp;&amp;组合两个表达式…if (ch != 'q' &amp;&amp; ch != 'Q')　　// 使用&amp;&amp;组合两个表达式…对比这两章和前几章的程序示例可以发现：使用第6章、第7章介绍的语句，可以写出功能更强大、更有趣的程序。\n本章小结本章介绍了很多内容，我们来总结一下。if语句使用测试条件控制程序是否执行测试条件后面的一条简单语句或复合语句。如果测试表达式的值是非零值，则执行语句；如果测试表达式的值是零，则不执行语句。if else语句可用于二选一的情况。如果测试条件是非零，则执行else前面的语句；如果测试表达式的值是零，则执行else后面的语句。在else后面使用另一个if语句形成else if，可构造多选一的结构。\n测试条件通常都是关系表达式，即用一个关系运算符（如，&lt;或==）的表达式。使用C的逻辑运算符，可以把关系表达式组合成更复杂的测试条件。\n在多数情况下，用条件运算符（?:）写成的表达式比if else语句更简洁。\nctype.h系列的字符函数（如，issapce()和isalpha()）为创建以分类字符为基础的测试表达式提供了便捷的工具。\nswitch 语句可以在一系列以整数作为标签的语句中进行选择。如果紧跟在 switch 关键字后的测试条件的整数值与某标签匹配，程序就转至执行匹配的标签语句，然后在遇到break之前，继续执行标签语句后面的语句。\nbreak、continue和goto语句都是跳转语句，使程序流跳转至程序的另一处。break语句使程序跳转至紧跟在包含break语句的循环或switch末尾的下一条语句。continue语句使程序跳出当前循环的剩余部分，并开始下一轮迭代。\n","plink":"https://dxsummer.gitee.io/posts/3e5d0fae/"},{"title":"emoji符号大全","date":"2020-06-05T04:14:30.000Z","date_formatted":{"ll":"2020年6月5日","L":"2020/06/05","MM-DD":"06-05"},"updated":"2020-06-13T06:58:26.569Z","content":"emoji符号大全🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥\nemoji表情😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠\nemoji人物👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪\nemoji手势💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍\nemoji日常👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂\nemoji手机📱📲📶📳📴☎📞📟📠\nemoji公共♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈\nemoji动物🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🦏🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋\nemoji植物💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃\nemoji自然🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊\nemoji饮食🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴\nemoji文体🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬\nemoji恐怖😈👿👹👺💀☠👻👽👾💣\nemoji旅游🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅\nemoji物品💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨\nemoji标志♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵\nemoji生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖\nemoji星座♈♉♊♋♌♍♎♏♐♑♒♓⛎\nemoji钟表🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰\nemoji心形💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣\nemoji花草💐🌸💮🌹🌺🌻🌼🌷🌱🌿🍀\nemoji树叶🌿🍀🍁🍂🍃\nemoji月亮🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝\nemoji水果🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓\nemoji钱币💴💵💶💷💰💸💳\nemoji交通🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀\nemoji建筑🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🌆🌇🌉\nemoji办公📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑\nemoji箭头⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝\n","plink":"https://dxsummer.gitee.io/posts/e193db5d/"},{"title":"疫情期间基层党员如何发挥先锋模范作用","date":"2020-06-03T08:01:38.000Z","date_formatted":{"ll":"2020年6月3日","L":"2020/06/03","MM-DD":"06-03"},"updated":"2020-06-08T01:55:56.782Z","content":"参与调查问卷 即可参与抽奖，领取一下其一🍎微信10元红包\n🍖微信20元红包\n🍼安慕希酸奶6瓶\n🍬200元中小学名师课\n🍺感谢参与\n","plink":"https://dxsummer.gitee.io/posts/91d5787c/"},{"title":"Step4 C控制语句：循环","date":"2020-06-03T04:33:48.000Z","date_formatted":{"ll":"2020年6月3日","L":"2020/06/03","MM-DD":"06-03"},"updated":"2020-06-08T01:44:33.693Z","content":"C控制语句：循环本章介绍以下内容：\n关键字：for、while、do while\n运算符：&lt;、&gt;、&gt;=、&lt;=、!=、==、+=、*=、-=、/=、%=\n函数：fabs()\nC语言有3种循环：for、while、do while\n使用关系运算符构建控制循环的表达式\n其他运算符\n循环常用的数组\n编写有返回值的函数\n大多数人都希望自己是体格强健、天资聪颖、多才多艺的能人。虽然有时事与愿违，但至少我们用 C能写出这样的程序。诀窍是控制程序流。对于计算机科学（是研究计算机，不是用计算机做研究）而言，一门语言应该提供以下3种形式的程序流：\n执行语句序列；\n如果满足某些条件就重复执行语句序列（循环通过测试选择执行哪一个语句序列（分支）。\n读者对第一种形式应该很熟悉，前面学过的程序中大部分都是由语句序列组成。while循环属于第二种形式。本章将详细讲解while循环和其他两种循环：for和do while。第三种形式用于在不同的执行方案之间进行选择，让程序更“智能”，且极大地提高了计算机的用途。不过，要等到下一章才介绍这部分的内容。本章还将介绍数组，可以把新学的知识应用在数组上。另外，本章还将继续介绍函数的相关内容。首先，我们从while循环开始学习。\n再探while循环经过上一章的学习，读者已经熟悉了 while 循环。这里，我们用一个程序来回顾一下，程序清单 6.1根据用户从键盘输入的整数进行求和。程序利用了scanf()的返回值来结束循环。\n程序清单6.1 summing.c程序\n1234567891011121314151617181920/* summing.c -- 根据用户键入的整数求和 */#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;　　　　 /* 把sum初始化为0　*/    int status;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    status=scanf(\"%ld\",&amp;num);    while (status == 1)　　/* == 的意思是“等于”　*/    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        status=scanf(\"%ld\",&amp;num);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;该程序使用long类型以储存更大的整数。尽管C编译器会把0自动转换为合适的类型，但是为了保持程序的一致性，我们把sum初始化为0L（long类型的0），而不是0（int类型的0）。\n该程序的运行示例如下：\n123456Please　enter　an　integer　to　be　summed　(q　to　quit):　44Please　enter　next　integer　(q　to　quit):　33Please　enter　next　integer　(q　to　quit):　88Please　enter　next　integer　(q　to　quit):　121Please　enter　next　integer　(q　to　quit):　qThose　integers　sum　to　286.程序注释先看while循环，该循环的测试条件是如下表达式：\n1status==1==运算符是C的相等运算符（equality operator），该表达式判断status是否等于1。不要把status== 1与status = 1混淆，后者是把1赋给status。根据测试条件status == 1，只要status等于1，循环就会重复。每次循环，num的当前值都被加到sum上，这样sum的值始终是当前整数之和。当status的值不为1时，循环结束。然后程序打印sum的最终值。\n要让程序正常运行，每次循环都要获取num的一个新值，并重置status。程序利用scanf()的两个不同的特性来完成。首先，使用scanf()读取num的一个新值；然后，检查scanf()的返回值判断是否成功获取值。第4章中介绍过，scanf()返回成功读取项的数量。如果scanf()成功读取一个整数，就把该数存入num并返回1，随后返回值将被赋给status（注意，用户输入的值储存在num中，不是status中）。这样做同时更新了num和status的值，while循环进入下一次迭代。如果用户输入的不是数字（如， q），scanf()会读取失败并返回0。此时，status的值就是0，循环结束。因为输入的字符q不是数字，所以它会被放回输入队列中（实际上，不仅仅是 q，任何非数值的数据都会导致循环终止，但是提示用户输入q退出程序比提示用户输入一个非数字字符要简单）。\n如果 scanf()在转换值之前出了问题（例如，检测到文件结尾或遇到硬件问题），会返回一个特殊值EOF（其值通常被定义为-1）。这个值也会引起循环终止。\n如何告诉循环何时停止？该程序利用 scanf()的双重特性避免了在循环中交互输入时的这个棘手的问题。例如，假设scanf()没有返回值，那么每次循环只会改变num的值。虽然可以使用num的值来结束循环，比如把num &gt; 0（num大于0）或num ！= 0（num不等于0）作为测试条件，但是这样用户就不能输入某些值，如-3或0。也可以在循环中添加代码，例如每次循环时询问用户“是否继续循环？&lt;y/n&gt;”，然后判断用户是否输入y。这个方法有些笨拙，而且还减慢了输入的速度。使用scanf()的返回值，轻松地避免了这些问题。\n现在，我们来看看该程序的结构。总结如下：\n把sum初始化为0\n\n提示用户输入数据\n\n读取用户输入的数据\n\n当输入的数据为整数时，\n\n输入添加给sum，\n\n提示用户进行输入，\n\n然后读取下一个输入\n\n输入完成后，打印sum的值\n\n顺带一提，这叫作伪代码（pseudocode），是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应。伪代码有助于设计程序的逻辑。确定程序的逻辑无误之后，再把伪代码翻译成实际的编程代码。使用伪代码的好处之一是，可以把注意力集中在程序的组织和逻辑上，不用在设计程序时还要分心如何用编程语言来表达自己的想法。例如，可以用缩进来代表一块代码，不用考虑C的语法要用花括号把这部分代码括起来。\n总之，因为while循环是入口条件循环，程序在进入循环体之前必须获取输入的数据并检查status的值，所以在 while 前面要有一个 scanf()。要让循环继续执行，在循环内需要一个读取数据的语句，这样程序才能获取下一个status的值，所以在while循环末尾还要有一个scanf()，它为下一次迭代做好了准备。可以把下面的伪代码作为while循环的标准格式：\n获得第1个用于测试的值\n当测试为真时\n处理值\n获取下一个值\nC风格读取循环根据伪代码的设计思路，程序清单6.1可以用Pascal、BASIC或FORTRAN来编写。但是C更为简洁，下面的代码：\n1234567891011status=scanf(\"%ld\",　&amp;num);while(status　==　1)&#123;/* 循环行为 */status　=　scanf(\"%ld\",　&amp;num);&#125;可以用这些代码替换：while(scanf(\"%ld\",&amp;num)==1)&#123;/*循环行为*/&#125;第二种形式同时使用scanf()的两种不同的特性。首先，如果函数调用成功，scanf()会把一个值存入num。然后，利用scanf()的返回值（0或1，不是num的值）控制while循环。因为每次迭代都会判断循环的条件，所以每次迭代都要调用scanf()读取新的num值来做判断。换句话说，C的语法特性让你可以用下面的精简版本替换标准版本：\n当获取值和判断值都成功\n处理该值\n接下来，我们正式地学习while语句。\nwhile语句while循环的通用形式如下：\n12while(expression)statementstatement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。\n到目前为止，程序示例中的expression部分都使用关系表达式。也就是说，expression是值之间的比较，可以使用任何表达式。如果expression为真（或者更一般地说，非零），执行 statement部分一次，然后再次判断expression。在expression为假（0）之前，循环的判断和执行一直重复进行。每次循环都被称为一次迭代（iteration），如图6.1所示。\n\n终止while循环while循环有一点非常重要：在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假。否则，循环就不会终止（实际上，可以使用break和if语句来终止循环，但是你尚未学到）。考虑下面的例子：\n123index=1;while(index&lt;5)printf(\"Good　morning!\\n\");上面的程序段将打印无数次Good　morning!。为什么？因为循环中index的值一直都是原来的值1，不曾变过。\n现在，考虑下面的程序段：\n123index=1;while(--index&lt;5)printf(\"Good　morning!\\n\");这段程序也好不到哪里去。虽然改变了index的值，但是改错了！不过，这个版本至少在index减少到其类型到可容纳的最小负值并变成最大正值时会终止循环（第3章3.4.2节中的toobig.c程序解释过，最大正值加1一般会得到一个负值；类似地，最小负值减1一般会得到最大正值）。\n何时终止循环要明确一点：只有在对测试条件求值时，才决定是终止还是继续循环。例如，考虑程序清单6.2中的程序。\n程序清单6.2 when.c程序\n123456789101112131415// when.c -- 何时退出循环#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=5;    while (n&lt;7)　　　　　　　　　　　// 第7行    &#123;        printf(\"n=%d\\n\",n);        n++;　　　　　　　　　　　　　 // 第10行        printf(\"Now n=%d\\n\", n); // 第11行    &#125;    printf(\"The　loop　has　finished.\\n\");    return　0;&#125;运行程序清单6.2，输出如下：\n12345n = 5Now n = 6n = 6Now n = 7The loop has finished.在第2次循环时，变量n在第10行首次获得值7。但是，此时程序并未退出，它结束本次循环（第11行），并在对第7行的测试条件求值时才退出循环（变量n在第1次判断时为5，第2次判断时为6）。\nwhile：入口条件循环while循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)。该表达式是一个入口条件（entry condition），因为必须满足条件才能进入循环体。在下面的情况中，就不会进入循环体，因为条件一开始就为假：\n123index=10;while(index++&lt;5)printf(\"Have　a　fair　day　or　better.\\n\");把第1行改为：\n1index = 3;就可以运行这个循环了。\n语法要点使用while时，要牢记一点：只有在测试条件后面的单独语句（简单语句或复合语句）才是循环部分。程序清单6.3演示了忽略这点的后果。缩进是为了让读者阅读方便，不是计算机的要求。\n1234567891011121314程序清单6.3 while1.c程序/* while1.c -- 注意花括号的使用 *//* 糟糕的代码创建了一个无限循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=0;    while(n&lt;3)        printf(\"n　is　%d\\n\",　n);    n++;    printf(\"That's　all　this　program　does\\n\");    return　0;&#125;该程序的输出如下：\n123456n　is　0n　is　0n　is　0n　is　0n　is　0...屏幕上会一直输出以上内容，除非强行关闭这个程序。\n虽然程序中缩进了n++;这条语句，但是并未把它和上一条语句括在花括号内。因此，只有直接跟在测试条件后面的一条语句是循环的一部分。变量n的值不会改变，条件n&lt;3一直为真。该循环会一直打印n is 0，除非强行关闭程序。这是一个无限循环（infinite loop）的例子，没有外部干涉就不会退出。\n记住，即使while语句本身使用复合语句，在语句构成上，它也是一条单独的语句。该语句从while开始执行，到第1个分号结束。在使用了复合语句的情况下，到右花括号结束。\n要注意放置分号的位置。例如，考虑程序清单6.4。\n123456789101112程序清单6.4 while2.c程序/* while2.c -- 注意分号的位置 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=0;    while(n++&lt;3);　　　　　 /* 第7行 */    printf(\"n is %d\\n\", n); /* 第8行 */    printf(\"That's　all　this　program　does.\\n\");    return　0;&#125;该程序的输出如下：\n12n is 4That's all this program does.如前所述，循环在执行完测试条件后面的第 1 条语句（简单语句或复合语句）后进入下一轮迭代，直到测试条件为假才会结束。该程序中第7行的测试条件后面直接跟着一个分号，循环在此进入下一轮迭代，因为单独一个分号被视为一条语句。虽然n的值在每次循环时都递增1，但是第8行的语句不是循环的一部分，因此只会打印一次循环结束后的n值。\n在该例中，测试条件后面的单独分号是空语句（null statement），它什么也不做。在C语言中，单独的分号表示空语句。有时，程序员会故意使用带空语句的while语句，因为所有的任务都在测试条件中完成了，不需要在循环体中做什么。例如，假设你想跳过输入到第1个非空白字符或数字，可以这样写：\n12while(scanf(\"%d\",&amp;num)==1); /* 跳过整数输入 */只要scanf()读取一个整数，就会返回1，循环继续执行。注意，为了提高代码的可读性，应该让这个分号独占一行，不要直接把它放在测试表达式同行。这样做一方面让读者更容易看到空语句，一方面也提醒自己和读者空语句是有意而为之。处理这种情况更好的方法是使用下一章介绍的continue语句。\n用关系运算符和表达式比较大小while循环经常依赖测试表达式作比较，这样的表达式被称为关系表达式（relational expression），出现在关系表达式中间的运算符叫做关系运算符（relational operator）。前面的示例中已经用过一些关系运算符，表 6.1 列出了 C 语言的所有关系运算符。该表也涵盖了所有的数值关系（数字之间的关系再复杂也没有人与人之间的关系复杂）。\n\n关系运算符常用于构造while语句和其他C语句（稍后讨论）中用到的关系表达式。这些语句都会检查关系表达式为真还是为假。下面有3个互不相关的while语句，其中都包含关系表达式。\n123456789101112while(number&lt;6)&#123;    printf(\"Your　number　is　too　small.\\n\");    scanf(\"%d\",　&amp;number);&#125;while(ch!='$')&#123;    count++;    scanf(\"%c\",　&amp;ch);&#125;while(scanf(\"%f\",&amp;num)==1)sum=sum+num;注意，第2个while语句的关系表达式还可用于比较字符。比较时使用的是机器字符码（假定为ASCII）。但是，不能用关系运算符比较字符串。第11章将介绍如何比较字符串。\n虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用&lt;和&gt;。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。例如，3乘以1/3的积是1.0。如果用把1/3表示成小数点后面6位数字，乘积则是.999999，不等于1。使用fabs()函数（声明在math.h头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符号的值）。\n例如，可以用类似程序清单6.5的方法来判断一个数是否接近预期结果。\n12345678910111213141516171819程序清单6.5 cmpflt.c程序// cmpflt.c -- 浮点数比较#include　&lt;math.h&gt;#include　&lt;stdio.h&gt;int　main(void)&#123;    const　double　ANSWER　=　3.14159;    double　response;    printf(\"What　is　the　value　of　pi?\\n\");    scanf(\"%lf\",&amp;response);    while(fabs(response-ANSWER)&gt;0.0001)    &#123;        printf(\"Try　again!\\n\");        scanf(\"%lf\",&amp;response);    &#125;    printf(\"Close　enough!\\n\");    return　0;&#125;循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差0.0001：\n12345What　is　the　value　of　pi?3.14Try　again!3.1416Close enough!什么是真这是一个古老的问题，但是对C而言还不算难。在C中，表达式一定有一个值，关系表达式也不例外。程序清单6.6中的程序用于打印两个关系表达式的值，一个为真，一个为假。\n程序清单6.6 t_and_f.c程序\n/* t_and_f.c – C中的真和假的值 */\n#include　&lt;stdio.h&gt;\nint　main(void)\n{\nint　true_val,　false_val;\ntrue_val = (10 &gt; 2);　　　　// 关系为真的值\nfalse_val = (10 == 2); // 关系为假的值\nprintf(“true　=　%d;　false　=　%d　\\n”,　true_val,　false_val);\nreturn　0;\n}\n程序清单6.6把两个关系表达式的值分别赋给两个变量，即把表达式为真的值赋给true_val，表达式为假的值赋给false_val。运行该程序后输出如下：\ntrue = 1; false = 0\n原来如此！对C而言，表达式为真的值是1，表达式为假的值是0。一些C程序使用下面的循环结构，由于1为真，所以循环会一直进行。\nwhile　(1)\n{\n…\n}\n其他真值既然1或0可以作为while语句的测试表达式，是否还可以使用其他数字？如果可以，会发生什么？我们用程序清单6.7来做个实验。\n12345678910111213141516程序清单6.7 truth.c程序// truth.c -- 哪些值为真#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=3;    while(n)        printf(\"%2d　is　true\\n\",　n--);    printf(\"%2d　is　false\\n\",　n);    n=-3;    while(n)        printf(\"%2d　is　true\\n\",　n++);    printf(\"%2d　is　false\\n\",　n);    return　0;&#125;该程序的输出如下：\n123456783　is　true2　is　true1　is　true0　is　false-3　is　true-2　is　true-1　is　true0　is　false执行第1个循环时，n分别是3、2、1，当n等于0时，第1个循环结束。与此类似，执行第2个循环时，n分别是-3、-2和-1，当n等于0时，第2个循环结束。一般而言，所有的非零值都视为真，只有0被视为假。在C中，真的概念还真宽！\n也可以说，只要测试条件的值为非零，就会执行 while 循环。这是从数值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0。因此，这些表达式实际上相当于数值。\n许多C程序员都会很好地利用测试条件的这一特性。例如，用while (goats)替换while (goats !=0)，因为表达式goats != 0和goats都只有在goats的值为0时才为0或假。第1种形式（while (goats != 0)）对初学者而言可能比较清楚，但是第2种形式（while (goats)）才是C程序员最常用的。要想成为一名C程序员，应该多熟悉while (goats)这种形式。\n真值的问题C对真的概念约束太少会带来一些麻烦。例如，我们稍微修改一下程序清单6.1，修改后的程序如程序清单6.8所示。\n123456789101112131415161718192021程序清单6.8 trouble.c程序// trouble.c -- 误用=会导致无限循环#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;    int status;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    status=scanf(\"%ld\",&amp;num);    while(status=1)    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        status　=　scanf(\"%ld\",　&amp;num);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;运行该程序，其输出如下：\n12345678Please　enter　an　integer　to　be　summed　(q　to　quit):　20Please　enter　next　integer　(q　to　quit):　5Please　enter　next　integer　(q　to　quit):　30Please　enter　next　integer　(q　to　quit):　qPlease　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):（„„屏幕上会一直显示最后的提示内容，除非强行关闭程序。也许你根本不想运行这个示例。）\n这个麻烦的程序示例改动了while循环的测试条件，把status == 1替换成status = 1。后者是一个赋值表达式语句，所以 status 的值为 1。而且，整个赋值表达式的值就是赋值运算符左侧的值，所以status = 1的值也是1。这里，while (status = 1)实际上相当于while (1)，也就是说，循环不会退出。虽然用户输入q，status被设置为0，但是循环的测试条件把status又重置为1，进入了下一次迭代。\n读者可能不太理解，程序的循环一直运行着，用户在输入q后完全没机会继续输入。如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取。当scanf()把q作为整数读取时失败了，它把 q 留下。在下次循环时，scanf()从上次读取失败的地方（q）开始读取，scanf()把q作为整数读取，又失败了。因此，这样修改后不仅创建了一个无限循环，还创建了一个无限失败的循环，真让人沮丧。好在计算机觉察不出来。对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样。\n不要在本应使用==的地方使用=。一些计算机语言（如，BASIC）用相同的符号表示赋值运算符和关系相等运算符，但是这两个运算符完全不同（见图 6.2）。赋值运算符把一个值赋给它左侧的变量；而关系相等运算符检查它左侧和右侧的值是否相等，不会改变左侧变量的值（如果左侧是一个变量）。\n\n示例如下：\n12canoes=5\t\t←把5赋给canoescanoes==5\t\t←检查canoes的值是否为5要注意使用正确的运算符。编译器不会检查出你使用了错误的形式，得出也不是预期的结果（误用=的人实在太多了，以至于现在大多数编译器都会给出警告，提醒用户是否要这样做）。如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：\n125=canoes\t←语法错误5==canoes\t←检查canoes的值是否为5可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。\n总之，关系运算符用于构成关系表达式。关系表达式为真时值为1，为假时值为0。通常用关系表达式作为测试条件的语句（如while和if）可以使用任何表达式作为测试条件，非零为真，零为假。\n新的_Bool类型在C语言中，一直用int类型的变量表示真/假值。C99专门针对这种类型的变量新增了_Bool类型。该类型是以英国数学家George Boole的名字命名的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变量被称为布尔变量（Boolean variable），所以_Bool是C语言中布尔变量的类型名。_Bool类型的变量只能储存1（真）或0（假）。如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1。这反映了C把所有的非零值都视为真。\n程序清单6.9修改了程序清单6.8中的测试条件，把int类型的变量status替换为_Bool类型的变量input_is_good。给布尔变量取一个能表示真或假值的变量名是一种常见的做法。\n123456789101112131415161718192021程序清单6.9 boolean.c程序// boolean.c -- 使用_Bool类型的变量 variable#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;    _Bool input_is_good;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    input_is_good=(scanf(\"%ld\",&amp;num)==1);    while(input_is_good)    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        input_is_good=(scanf(\"%ld\",&amp;num)==1);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;注意程序中把比较的结果赋值给_Bool类型的变量input_is_good：\n1input_is_good=(scanf(\"%ld\", &amp;num) == 1);这样做没问题，因为==运算符返回的值不是1就是0。顺带一提，从优先级方面考虑的话，并不需要用圆括号把scanf(&quot;%ld&quot;,&amp;num)==1括起来。但是，这样做可以提高代码可读性。还要注意，如何为变量命名才能让while循环的测试简单易懂：\n1while (input_is_good)C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0的符号常量。包含该头文件后，写出的代码可以与C++兼容，因为C++把bool、true和false定义为关键字。\n如果系统不支持_Bool类型，导致无法运行该程序，可以把_Bool替换成int即可。\n优先级和关系运算符关系运算符的优先级比算术运算符低（包括+和-），比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。\n关系运算符比赋值运算符的优先级高，因此，x_bigger=x&gt;y;相当于x_bigger=(x &gt; y);。\n关系运算符之间有两种不同的优先级。\n高优先级组： &lt;&lt;= &gt;&gt;=\n低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：\nex!=wye==zee与(ex != wye) == zee相同\n首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。\n表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算符”中列出了全部运算符的完整优先级表。\n\n小结：while语句\n关键字：while\n一般注解：\nwhile语句创建了一个循环，重复执行直到测试表达式为假或0。while语句是一种入口条件循环，也就是说，在执行多次循环之前已决定是否执行循环。因此，循环有可能不被执行。循环体可以是简单语句，也可以是复合语句。\n形式：\n12while(expression)statement在expression部分为假或0之前，重复执行statement部分。\n示例：\n1234567while(n++&lt;100)printf(\" %d %d\\n\",n,2*n+1); // 简单语句while(fargo&lt;1000)&#123; // 复合语句    fargo=fargo+step;    step=2*step;&#125;小结：关系运算符和表达式\n关系运算符：\n每个关系运算符都把它左侧的值和右侧的值进行比较。\n123456&lt;　　　　　小于&lt;=　　　　 小于或等于==　　　　 等于&gt;=　　　　 大于或等于&gt;　　　　　大于!=　　　　 不等于关系表达式：\n简单的关系表达式由关系运算符及其运算对象组成。如果关系为真，关系表达式的值为 1；如果关系为假，关系表达式的值为0。\n示例：\n5 &gt; 2为真，关系表达式的值为1\n(2 + a) == a 为假，关系表达式的值为0\n不确定循环和计数循环一些while循环是不确定循环（indefinite loop）。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。例如，程序清单6.1通过与用户交互获得数据来计算整数之和。我们事先并不知道用户会输入什么整数。另外，还有一类是计数循环（counting loop）。这类循环在执行循环之前就知道要重复执行多少次。程序清单6.10就是一个简单的计数循环。\n123456789101112131415程序清单6.10 sweetie1.c程序// sweetie1.c -- 一个计数循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const　int　NUMBER　=　22;    int count = 1;　　　　　　　　　　　　　// 初始化    while(count&lt;=NUMBER)　　　　　　　 // 测试    &#123;        printf(\"Be my Valentine!\\n\");　 // 行为        count++;　　　　　　　　　　　　　　// 更新计数    &#125;    return　0;&#125;虽然程序清单6.10运行情况良好，但是定义循环的行为并未组织在一起，程序的编排并不是很理想。我们来仔细分析一下。\n在创建一个重复执行固定次数的循环中涉及了3个行为：\n必须初始化计数器；\n\n计数器与有限的值作比较；\n\n每次循环时递增计数器。\n\nwhile循环的测试条件执行比较，递增运算符执行递增。程序清单6.10中，递增发生在循环的末尾，这可以防止不小心漏掉递增。因此，这样做比将测试和更新组合放在一起（即使用count++ &lt;= NUMBER）要好，但是计数器的初始化放在循环外，就有可能忘记初始化。实践告诉我们可能会发生的事情终究会发生，所以我们来学习另一种控制语句，可以避免这些问题。\nfor循环for循环把上述3个行为（初始化、测试和更新）组合在一处。程序清单6.11使用for循环修改了程序清单6.10的程序。\n123456789101112程序清单6.11 sweetie2.c程序// sweetie2.c -- 使用for循环的计数循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const int NUMBER=22;    int count;    for(count=1;count&lt;=NUMBER;count++)        printf(\"Be　my　Valentine!\\n\");    return　0;&#125;关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。\n第1个表达式是初始化，只会在for循环开始时执行一次。\n第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假（本例中，count大于NUMBER时），循环结束。\n第3个表达式执行更新，在每次循环结束时求值。程序清单6.10用这个表达式递增count 的值，更新计数。\n完整的for语句还包括后面的简单语句或复合语句。for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。图6.3演示了for循环的结构。\n\n程序清单6.12 for_cube.c程序\n1234567891011/* for_cube.c -- 使用for循环创建一个立方表 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int num;    printf(\"n　　n　cubed\\n\");    for(num=1;num&lt;=6;num++)        printf(\"%5d %5d\\n\",num,num*num*num);    return　0;&#125;程序清单6.12打印整数1～6及其对应的立方，该程序的输出如下：\n1234567n　　　 n　cubed1　　　　　　　12　　　　　　　83　　　　　　 274　　　　　　 645　　　　　 1256　　　　　 216for循环的第1行包含了循环所需的所有信息：num的初值，num的终值和每次循环num的增量。\n利用for的灵活性虽然for循环看上去和FORTRAN的DO循环、Pascal的FOR循环、BASIC的FOR...NEXT循环类似，但是for循环比这些循环灵活。这些灵活性源于如何使用for循环中的3个表达式。以前面程序示例中的for循环为例，第1个表达式给计数器赋初值，第2个表达式表示计数器的范围，第3个表达式递增计数器。这样使用for循环确实很像其他语言的循环。除此之外，for循环还有其他9种用法。\n可以使用递减运算符来递减计数器：\n1234567891011/* for_down.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int secs;    for(secs=5;secs&gt;0;secs--)        printf(\"%d　seconds!\\n\",secs);    printf(\"We　have　ignition!\\n\");    return　0;&#125;该程序输出如下：\n1234565 seconds!4 seconds!3 seconds!2 seconds!1 seconds!We have ignition!可以让计数器递增2、10等：\n12345678910/* for_13s.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n; // 从2开始，每次递增13    for　(n=2;n&lt;60;n=n+13)        printf(\"%d　\\n\",　n);    return　0;&#125;每次循环n递增13，程序的输出如下：\n12345215284154可以用字符代替数字计数：\n12345678910/* for_char.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    char ch;    for(ch='a';ch&lt;='z';ch++)    printf(\"The　ASCII　value　for　%c　is　%d.\\n\",　ch,　ch);    return　0;&#125;该程序假定系统用ASCII码表示字符。由于篇幅有限，省略了大部分输出：\n123456The　ASCII　value　for　a　is　97.The　ASCII　value　for　b　is　98....The　ASCII　value　for　x　is　120.The　ASCII　value　for　y　is　121.The　ASCII　value　for　z　is　122.该程序能正常运行是因为字符在内部是以整数形式储存的，因此该循环实际上仍是用整数来计数。\n除了测试迭代次数外，还可以测试其他条件。在for_cube程序中，可以把：\n1for(num=1;num&lt;=6;num++)替换成：\n1for(num=1;num*num*num&lt;=216;num++)如果与控制循环次数相比，你更关心限制立方的大小，就可以使用这样的测试条件。\n可以让递增的量几何增长，而不是算术增长。也就是说，每次都乘上而不是加上一个固定的量：\n12345678910/* for_geo.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    double　debt;    for (debt = 100.0; debt &lt; 150.0; debt = debt * 1.1)\t    printf(\"Your　debt　is　now　$%.2f.\\n\",　debt);    return　0;&#125;该程序中，每次循环都把debt乘以1.1，即debt的值每次都增加10%，其输出如下：\n12345Your　debt　is　now　$100.00.Your　debt　is　now　$110.00.Your　debt　is　now　$121.00.Your　debt　is　now　$133.10.Your　debt　is　now　$146.41.第3个表达式可以使用任意合法的表达式。无论是什么表达式，每次迭代都会更新该表达式的值。\n1234567891011/* for_wild.c */#include　&lt;stdio.h&gt;int main(void)&#123;    int x;    int y=55;    for(x=1;y&lt;=75;y=(++x*5)+50)        printf(\"%10d　%10d\\n\",　x,　y);    return　0;&#125;该循环打印x的值和表达式++x * 5 + 50的值，程序的输出如下：\n123451　　　　　 552　　　　　 603　　　　　 654　　　　　 705　　　　　 75注意，测试涉及y，而不是x。for循环中的3个表达式可以是不同的变量（注意，虽然该例可以正常运行，但是编程风格不太好。如果不在更新部分加入代数计算，程序会更加清楚）。\n可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。\n123456789101112/* for_none.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int ans,n;    ans=2;    for(n=3;ans&lt;=25;)\t\tans=ans*n;    printf(\"n　=　%d;　ans　=　%d.\\n\",　n,　ans);    return　0;&#125;该程序的输出如下：\n1n=3;ans=54.该循环保持n的值为3。变量ans开始的值为2，然后递增到6和18，最终是54（18比25小，所以for循环进入下一次迭代，18乘以3得54）。顺带一提，省略第2个表达式被视为真，所以下面的循环会一直运行：\n12for　(;　;　)printf(\"I　want　some　action\\n\");第1个表达式不一定是给变量赋初值，也可以使用printf()。记住，在执行循环的其他部分之前，只对第1个表达式求值一次或执行一次。\n1234567891011/* for_show.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int num　=　0;    for(printf(\"Keep　entering　numbers!\\n\");num!=6;)  \t  scanf(\"%d\",　&amp;num);    printf(\"That's　the　one　I　want!\\n\");    return　0;&#125;该程序打印第1行的句子一次，在用户输入6之前不断接受数字：\n123456Keep　entering　numbers!3586That's the one I want!循环体中的行为可以改变循环头中的表达式。例如，假设创建了下面的循环：\n1for(n=1;n&lt;10000;n=n+delta)如果程序经过几次迭代后发现delta太小或太大，循环中的if语句（详见第7章）可以改变delta的大小。在交互式程序中，用户可以在循环运行时才改变 delta 的值。这样做也有危险的一面，例如，把delta设置为0就没用了。\n总而言之，可以自己决定如何使用for循环头中的表达式，这使得在执行固定次数的循环外，还可以做更多的事情。接下来，我们将简要讨论一些运算符，使for循环更加有用。\n小结：for语句\n关键字：for\n一般注解：\nfor语句使用3个表达式控制循环过程，分别用分号隔开。initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真（或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。\n形式：\n12for(initialize;test;update　)statement在test为假或0之前，重复执行statement部分。\n示例：\n12for(n=0;n&lt;10;n++)printf(\" %d %d\\n\", n, 2 * n + 1);其他赋值运算符：+=、-=、*=、/=、%=C有许多赋值运算符。最基本、最常用的是=，它把右侧表达式的值赋给左侧的变量。其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式。赋给变量的新值是根据右侧表达式的值调整后的值。确切的调整方案取决于具体的运算符。例如：\n12345scores+=20\t\t与\t\tscores=scores+20\t\t相同dimes-=2\t\t与\t\tdimes=dimes-2\t\t\t相同bunnies*=2\t\t与\t\tbunnies=bunnies*2\t\t相同time/=2.73\t\t与\t\ttime=time/2.73\t\t\t相同reduce%=3\t\t与\t\treduce=reduce%3\t\t\t相同上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式，例如：\n1x*=3*y+12\t与\tx=x*(3*y+12) \t相同以上提到的赋值运算符与=的优先级相同，即比+或*优先级低。上面最后一个例子也反映了赋值运算符的优先级，3 *y先与12相加，再把计算结果与x相乘，最后再把乘积赋给x。\n并非一定要使用这些组合形式的赋值运算符。但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效。当需要在for循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用。\n逗号运算符逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。例如，程序清单6.13演示了一个打印一类邮件资费（first-class postage rate）的程序（在撰写本书时，邮资为首重40美分/盎司，续重20美分/盎司，可以在互联网上查看当前邮资）。\n程序清单6.13 postage.c程序\n12345678910111213// postage.c -- 一类邮资#include　&lt;stdio.h&gt;int　main(void)&#123;const int FIRST_OZ = 46;　　// 2013邮资const int NEXT_OZ = 20;　　 // 2013邮资int ounces,　cost;printf(\"　ounces　 cost\\n\");for(ounces=1,cost=FIRST_OZ;ounces&lt;=16;ounces++,cost+=NEXT_OZ)\tprintf(\"%5d　　$%4.2f\\n\",　ounces,　cost　/　100.0);return　0;&#125;该程序的前5行输出如下：\n12345ounces　\tcost1　　　　 $0.462　　　　 $0.663　　　　 $0.864　　　　 $1.06该程序在初始化表达式和更新表达式中使用了逗号运算符。初始化表达式中的逗号使ounces和cost都进行了初始化，更新表达式中的逗号使每次迭代ounces递增1、cost递增20（NEXT_Z的值是20）。绝大多数计算都在for循环头中进行（见图6.4）。\n\n逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值（换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生）。因此，ounces在cost之前被初始化。在该例中，顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要。例如，假设有下面的表达式：\n1ounces++,cost=ounces*FIRST_OZ在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值。作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生。\n其次，整个逗号表达式的值是右侧项的值。例如，下面语句\n1x=(y=3,(z=++y+2)+5);的效果是：先把3赋给y，递增y为4，然后把4加2之和（6）赋给z，接着加上5，最后把结果11赋给 x。至于为什么有人编写这样的代码，在此不做评价。另一方面，假设在写数字时不小心输入了逗号：\n1houseprice=249,500;这不是语法错误，C 编译器会将其解释为一个逗号表达式，即 houseprice = 249 是逗号左侧的子表达式，500 是右侧的子表达式。因此，整个逗号表达式的值是逗号右侧表达式的值，而且左侧的赋值表达式把249赋给变量houseprice。因此，这与下面代码的效果相同：\n1houseprice　=　249;500;记住，任何表达式后面加上一个分号就成了表达式语句。所以，500;也是一条语句，但是什么也不做。\n另外，下面的语句\n1houseprice &#x3D; (249,500);赋给houseprice的值是逗号右侧子表达式的值，即500。\n逗号也可用作分隔符。在下面语句中的逗号都是分隔符，不是逗号运算符：\n12char ch, date;printf(\"%d %d\\n\", chimps, chumps);小结：新的运算符\n赋值运算符：\n下面的运算符用右侧的值，根据指定的操作更新左侧的变量：\n12345+=\t\t\t把右侧的值加到左侧的变量上-=\t\t\t从左侧的变量中减去右侧的值*=\t\t\t把左侧的变量乘以右侧的值/=\t\t\t把左侧的变量除以右侧的值%=\t\t\t左侧变量除以右侧值得到的余数示例：\n1rabbits*=1.6;\t与\trabbits=rabbits*1.6;\t相同这些组合赋值运算符与普通赋值运算符的优先级相同，都比算术运算符的优先级低。因此，\n1contents*=old_rate+1.2;最终的效果与下面的语句相同：\n1contents = contents * (old_rate + 1.2);逗号运算符：\n逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。逗号运算符通常在for循环头的表达式中用于包含更多的信息。整个逗号表达式的值是逗号右侧表达式的值。\n示例：\n12for(step = 2, fargo = 0;fargo&lt;1000;step*=2)fargo+=step;当Zeno遇到for循环接下来，我们看看 for 循环和逗号运算符如何解决古老的悖论。希腊哲学家 Zeno 曾经提出箭永远不会达到它的目标。首先，他认为箭要到达目标距离的一半，然后再达到剩余距离的一半，然后继续到达剩余距离的一半，这样就无穷无尽。Zeno认为箭的飞行过程有无数个部分，所以要花费无数时间才能结束这一过程。不过，我们怀疑Zeno是自愿甘做靶子才会得出这样的结论。\n我们采用一种定量的方法，假设箭用1秒钟走完一半的路程，然后用1/2秒走完剩余距离的一半，然后用1/4秒再走完剩余距离的一半，等等。可以用下面的无限序列来表示总时间：\n11 + 1/2 + 1/4 + 1/8 + 1/16 +....程序清单6.14中的程序求出了序列前几项的和。变量power_of_two的值分别是1.0、2.0、4.0、8.0等。\n程序清单6.14 zeno.c程序\n1234567891011121314151617/* zeno.c -- 求序列的和 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int t_ct;　　　 // 项计数    double time,power_of_2;    int limit;    printf(\"Enter　the　number　of　terms　you　want:　\");    scanf(\"%d\",&amp;limit);    for(time=0,power_of_2=1,t_ct=1;t_ct&lt;=limit;t_ct++,power_of_2*=2.0)    &#123;        time+=1.0/power_of_2;        printf(\"time=%f　when　terms　=　%d.\\n\",time,t_ct);    &#125;    return　0;&#125;下面是序列前15项的和：\n12345678910111213141516Enter　the　number　of　terms　you　want:　15time　=　1.000000　when　terms　=　1.time　=　1.500000　when　terms　=　2.time　=　1.750000　when　terms　=　3.time　=　1.875000　when　terms　=　4.time　=　1.937500　when　terms　=　5.time　=　1.968750　when　terms　=　6.time　=　1.984375　when　terms　=　7.time　=　1.992188　when　terms　=　8.time　=　1.996094　when　terms　=　9.time　=　1.998047　when　terms　=　10.time　=　1.999023　when　terms　=　11.time　=　1.999512　when　terms　=　12.time　=　1.999756　when　terms　=　13.time　=　1.999878　when　terms　=　14.time　=　1.999939　when　terms　=　15.不难看出，尽管不断添加新的项，但是总和看起来变化不大。就像程序输出显示的那样，数学家的确证明了当项的数目接近无穷时，总和无限接近2.0。假设S表示总和，下面我们用数学的方法来证明一下：\n1S = 1 + 1/2 + 1/4 + 1/8 + ...这里的省略号表示“等等”。把S除以2得：\n1S/2 = 1/2 + 1/4 + 1/8 + 1/16 + ...第1个式子减去第2个式子得：\n1S - S/2 = 1 +1/2 -1/2 + 1/4 -1/4 +...除了第1个值为1，其他的值都是一正一负地成对出现，所以这些项都可以消去。只留下：\n1S/2 = 1然后，两侧同乘以2，得：\n1S = 2从这个示例中得到的启示是，在进行复杂的计算之前，先看看数学上是否有简单的方法可用。\n程序本身是否有需要注意的地方？该程序演示了在表达式中可以使用多个逗号运算符，在for循环中，初始化了time、power_of_2和count。构建完循环条件之后，程序本身就很简短了。\n出口条件循环：do whilewhile循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。这种循环被称为 do while循环。程序清单6.15 演示了一个示例。\n程序清单6.15 do_while.c程序\n12345678910111213141516/* do_while.c -- 出口条件循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int secret_code=13;    int code_entered;    do    &#123;        printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");        printf(\"please　enter　the　secret　code　number:　\");        scanf(\"%d\",&amp;code_entered);    &#125;while(code_entered!=secret_code);    printf(\"Congratulations!　You　are　cured!\\n\");    return　0;&#125;程序清单6.15在用户输入13之前不断提示用户输入数字。下面是一个运行示例：\n1234567To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　12To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　14To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　13Congratulations!　You　are　cured!使用while循环也能写出等价的程序，但是长一些，如程序清单6.16所示。\n程序清单6.16 entry.c程序\n12345678910111213141516171819/* entry.c -- 出口条件循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int secret_code=13;    int code_entered;    printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");    printf(\"please　enter　the　secret　code　number:　\");    scanf(\"%d\",　&amp;code_entered);    while(code_entered!=secret_code)    &#123;        printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");        printf(\"please　enter　the　secret　code　number:　\");        scanf(\"%d\",&amp;code_entered);    &#125;    printf(\"Congratulations!　You　are　cured!\\n\");    return　0;&#125;下面是do while循环的通用形式：\n123dostatementwhile(expression);statement可以是一条简单语句或复合语句。注意，do while循环以分号结尾，其结构见图6.5。\n\ndo while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次；而for循环或while循环都是在执行循环体之前先执行测试条件。do while循环适用于那些至少要迭代一次的循环。例如，下面是一个包含do while循环的密码程序伪代码：\n123456789101112do&#123;提示用户输入密码读取用户输入的密码&#125; while (用户输入的密码不等于密码);避免使用这种形式的do　while结构：do&#123;询问用户是否继续其他行为&#125; while (回答是yes);这样的结构导致用户在回答“no”之后，仍然执行“其他行为”部分，因为测试条件执行晚了。\n小结：do while语句\n关键字：do while\n一般注解：\ndo while 语句创建一个循环，在 expression 为假或 0 之前重复执行循环体中的内容。do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环。因此，该循环至少必须执行一次。statement部分可是一条简单语句或复合语句。\n形式：\n123dostatementwhile(expression);在test为假或0之前，重复执行statement部分。\n示例：\n123doscanf(\"%d\",&amp;number);while　(number!=20);如何选择循环如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条件循环。通常，入口条件循环用得比较多，有几个原因。其一，一般原则是在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读性更高。另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。\n那么，假设需要一个入口条件循环，用for循环还是while循环？这取决于个人喜好，因为二者皆可。要让for循环看起来像while循环，可以省略第1个和第3个表达式。例如：\n1for ( ; test ; )与下面的while效果相同：\n1while ( test )要让while循环看起来像for循环，可以在while循环的前面初始化变量，并在while循环体中包含更新语句。例如：\n初始化;\n12345while ( 测试 )&#123;    其他语句    更新语句&#125;与下面的for循环效果相同：\n12for ( 初始化 ;测试 ; 更新 )其他语句一般而言，当循环涉及初始化和更新变量时，用for循环比较合适，而在其他情况下用while循环更好。对于下面这种条件，用while循环就很合适：\n1while (scanf(\"%ld\", &amp;num) == 1)对于涉及索引计数的循环，用for循环更适合。例如：\n1for (count = 1; count &lt;= 100; count++)嵌套循环嵌套循环（nested loop）指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行。程序清单6.17演示了一个简单的示例。\n程序清单6.17 rows1.c程序\n1234567891011121314151617/* rows1.c -- 使用嵌套循环 */#include　&lt;stdio.h&gt;#define ROWS 6#define　CHARS　10int　main(void)&#123;    int row;    char ch;    for(row=0;row&lt;ROWS;row++)　　　　　　　　 /* 第10行 */    &#123;        for (ch='A';ch&lt;('A'+CHARS);ch++)　　 /* 第12行 */        \tprintf(\"%c\",ch);        printf(\"\\n\");    &#125;    return　0;&#125;运行该程序后，输出如下：\n123456ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ程序分析第10行开始的for循环被称为外层循环（outer loop），第12行开始的for循环被称为内层循环（inner loop）。外层循环从row为0开始循环，到row为6时结束。因此，外层循环要执行6次，row的值从0变为5。每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J；第2条语句是外层循环的printf(&quot;\\n&quot;);，该语句的效果是另起一行，这样在下一次运行内层循环时，将在下一行打印的字符。\n注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环。在程序清单6.17中，内层循环一行打印10个字符，外层循环创建6行。\n嵌套变式上一个实例中，内层循环和外层循环所做的事情相同。可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务。把程序清单6.17稍微修改后，如程序清单6.18所示。内层循环开始打印的字符取决于外层循环的迭代次数。该程序的第 1 行使用了新的注释风格，而且用 const 关键字代替#define，有助于读者熟悉这两种方法。\n程序清单6.18 rows2.c程序\n1234567891011121314151617// rows2.c -- 依赖外部循环的嵌套循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const　int　ROWS　=　6;    const　int　CHARS　=　6;    int　row;    char　ch;    for(row　=　0;　row　&lt;　ROWS;　row++)    &#123;        for(ch　=　('A'　+　row);　ch　&lt;　('A'　+　CHARS);　ch++)        printf(\"%c\",　ch);        printf(\"\\n\");    &#125;    return　0;&#125;该程序的输出如下：\n123456ABCDEFBCDEFCDEFDEFEFF因为每次迭代都要把row的值与‘A’相加，所以ch在每一行都被初始化为不同的字符。然而，测试条件并没有改变，所以每行依然是以F结尾，这使得每一行打印的字符都比上一行少一个。\n数组简介在许多程序中，数组很重要。数组可以作为一种储存多个相关项的便利方式。我们在第10章中将详细介绍数组，但是由于循环经常用到数组，所以在这里先简要地介绍一下。\n数组（array）是按顺序储存的一系列类型相同的值，如10个char类型的字符或15个int类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素（element）。例如，以下声明：\n1float debts[20];声明debts是一个内含20个元素的数组，每个元素都可以储存float类型的值。数组的第1个元素是debts[0]，第2个元素是debts[1]，以此类推，直到debts[19]。注意，数组元素的编号从0开始，不是从1开始。可以给每个元素赋float类型的值。例如，可以这样写：\n12debts[5] = 32.54;debts[6] = 1.2e+21;实际上，使用数组元素和使用同类型的变量一样。例如，可以这样把值读入指定的元素中：\n1scanf(\"%f\", &amp;debts[4]); // 把一个值读入数组的第5个元素这里要注意一个潜在的陷阱：考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确。下面的代码，都不正确：\n12debts[20] = 88.32;　　 // 该数组元素不存在debts[33] = 828.12;　　// 该数组元素不存在编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。\n数组的类型可以是任意数据类型。\n123int nannies[22];　/* 可储存22个int类型整数的数组 */char actors[26];　/* 可储存26个字符的数组 */long big[500];　　/* 可储存500个long类型整数的数组 */我们在第4章中讨论过字符串，可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。如果char类型的数组末尾包含一个表示字符串末尾的空字符\\0，则该数组中的内容就构成了一个字符串（见图6.6）。\n\n用于识别数组元素的数字被称为下标（subscript）、索引（indice）或偏移量（offset）。下标必须是整数，而且要从0开始计数。数组的元素被依次储存在内存中相邻的位置，如图6.7所示。\n\n在for循环中使用数组程序中有许多地方要用到数组，程序清单6.19是一个较为简单的例子。该程序读取10个高尔夫分数，稍后进行处理。使用数组，就不用创建10个不同的变量来储存10个高尔夫分数。而且，还可以用for循环来读取数据。程序打印总分、平均分、差点（handicap，它是平均分与标准分的差值）。\n程序清单6.19 scores_in.c程序\n123456789101112131415161718192021222324// scores_in.c -- 使用循环处理数组#include　&lt;stdio.h&gt;#define　SIZE　10#define　PAR　72int　main(void)&#123;    int index,score[SIZE];    int sum=0;    float average;    printf(\"Enter　%d　golf　scores:\\n\",SIZE);    for(index=0;index&lt;SIZE;index++)        scanf(\"%d\",&amp;score[index]);　　 // 读取10个分数    printf(\"The　scores　read　in　are　as　follows:\\n\");    for(index=0;index&lt;SIZE;index++)   \t\t printf(\"%5d\", score[index]);　　// 验证输入    printf(\"\\n\");    for(index=0;index&lt;SIZE;index++)   \t\t sum+=score[index];　　　　　　　// 求总分数    average=(float) sum/SIZE;　　　　// 求平均分    printf(\"Sum　of　scores　=　%d,　average　=　%.2f\\n\",　sum,　average);    printf(\"That's　a　handicap　of　%.0f.\\n\",　average　-　PAR);    return　0;&#125;先看看程序清单6.19是否能正常工作，接下来再做一些解释。下面是程序的输出：\n1234567Enter　10　golf　scores:99　95　109　105　10096　98　93　99　97　98The　scores　read　in　are　as　follows:99　95　109　105　100　96　98　93　99　97Sum　of　scores　=　991,　average　=　99.10That's　a　handicap　of　27.程序运行没问题，我们来仔细分析一下。首先，注意程序示例虽然打印了11个数字，但是只读入了10个数字，因为循环只读了10个值。由于scanf()会跳过空白字符，所以可以在一行输入10个数字，也可以每行只输入一个数字，或者像本例这样混合使用空格和换行符隔开每个数字（因为输入是缓冲的，只有当用户键入Enter键后数字才会被发送给程序）。\n然后，程序使用数组和循环处理数据，这比使用10个单独的scanf()语句和10个单独的printf()语句读取10个分数方便得多。for循环提供了一个简单直接的方法来使用数组下标。注意，int类型数组元素的用法与int类型变量的用法类似。要读取int类型变量fue，应这样写 scanf(&quot;&amp;d&quot;,&amp;fue)。程序清单6.19中要读取int类型的元素 score[index]，所以这样写scanf(&quot;%d&quot;,&amp;score[index]。\n该程序示例演示了一些较好的编程风格。第一，用#define 指令创建的明示常量（SIZE）来指定数组的大小。这样就可以在定义数组和设置循环边界时使用该明示常量。如果以后要扩展程序处理20个分数，只需简单地把SIZE重新定义为20即可，不用逐一修改程序中使用了数组大小的每一处。\n第二，下面的代码可以很方便地处理一个大小为SIZE的数组：\n1for(index=0;index&lt;SIZE;index++)设置正确的数组边界很重要。第1个元素的下标是0，因此循环开始时把index设置为0。因为从0开始编号，所以数组中最后一个元素的下标是SIZE - 1。也就是说，第10个元素是score[9]。通过测试条件index &lt; SIZE来控制循环中使用的最后一个index的值是SIZE - 1。\n第三，程序能重复显示刚读入的数据。这是很好的编程习惯，有助于确保程序处理的数据与期望相符。\n最后，注意该程序使用了3个独立的for循环。这是否必要？是否可以将其合并成一个循环？当然可以，读者可以动手试试，合并后的程序显得更加紧凑。但是，调整时要注意遵循模块化（modularity）的原则。模块化隐含的思想是：应该把程序划分为一些独立的单元，每个单元执行一个任务。这样做提高了程序的可读性。也许更重要的是，模块化使程序的不同部分彼此独立，方便后续更新或修改程序。在掌握如何使用函数后，可以把每个执行任务的单元放进函数中，提高程序的模块化。\n使用函数返回值的循环示例本章最后一个程序示例要用一个函数计算数的整数次幂（math.h库提供了一个更强大幂函数pow()，可以使用浮点指数）。该示例有3个主要任务：设计算法、在函数中表示算法并返回计算结果、提供一个测试函数的便利方法。\n首先分析算法。为简化函数，我们规定该函数只处理正整数的幂。这样，把n与n相乘p次便可计算n的p次幂。这里自然会用到循环。先把变量pow设置为1，然后将其反复乘以n：\n12for(i=1;i&lt;=p;i++)pow*=n;回忆一下，*=运算符把左侧的项乘以右侧的项，再把乘积赋给左侧的项。第1次循环后，pow的值是1乘以n，即n；第2次循环后，pow的值是上一次的值（n）乘以n，即n的平方；以此类推。这种情况使用for循环很合适，因为在执行循环之前已预先知道了迭代的次数（已知p）。\n现在算法已确定，接下来要决定使用何种数据类型。指数p是整数，其类型应该是int。为了扩大n及其幂的范围，n和pow的类型都是double。\n接下来，考虑如何把以上内容用函数来实现。要使用两个参数（分别是double类型和int类型）才能把所需的信息传递给函数，并指定求哪个数的多少次幂。而且，函数要返回一个值。如何把函数的返回值返回给主调函数？编写一个有返回值的函数，要完成以下内容：\n定义函数时，确定函数的返回类型；\n\n使用关键字return表明待返回的值。\n\n例如，可以这样写：\n12345678double power(double n,int p) // 返回一个double类型的值&#123;    double pow=1;    int i;    for(i=1;i&lt;=p;i++)    pow*=n;    return pow; // 返回pow的值&#125;要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量那样。关键字 return 表明该函数将把它后面的值返回给主调函数。根据上面的代码，函数返回一个变量的值。返回值也可以是表达式的值，如下所示：\n1return 2*x+b;函数将计算表达式的值，并返回该值。在主调函数中，可以把返回值赋给另一个变量、作为表达式中的值、作为另一个函数的参数（如，printf(&quot;%f&quot;,power(6.28,3)），或者忽略它。\n现在，我们在一个程序中使用这个函数。要测试一个函数很简单，只需给它提供几个值，看它是如何响应的。这种情况下可以创建一个输入循环，选择 while 循环很合适。可以使用 scanf()函数一次读取两个值。如果成功读取两个值，scanf()则返回2，所以可以把scanf()的返回值与2作比较来控制循环。还要注意，必须先声明power()函数（即写出函数原型）才能在程序中使用它，就像先声明变量再使用一样。程序清单6.20演示了这个程序。\n程序清单6.20 powwer.c程序\n12345678910111213141516171819202122232425262728// power.c -- 计算数的整数幂#include　&lt;stdio.h&gt;double power(double n,int p); // ANSI函数原型int main(void)&#123;    double x,xpow;    int exp;    printf(\"Enter　a　number　and　the　positive　integer　power\");    printf(\"　to　which\\n the　number　will　be　raised.　Enter　q\");    printf(\"　to　quit.\\n\");    while(scanf(\"%lf%d\",&amp;x,&amp;exp)==2)    &#123;        xpow=power(x,exp);　// 函数调用        printf(\"%.3g　to　the　power　%d　is　%.5g\\n\",　x,　exp,　xpow);        printf(\"Enter　next　pair　of　numbers　or　q　to　quit.\\n\");    &#125;    printf(\"Hope　you　enjoyed　this　power　trip　--　bye!\\n\");    return　0;&#125;double power(double n,int p)　 // 函数定义&#123;    double pow=1;    int i;    for(i=1;i&lt;=p;i++)    pow*=n;    return pow;　　　　　　　　　 // 返回pow的值&#125;运行该程序后，输出示例如下：\n1234567891011Enter　a　number　and　the　positive　integer　power　to　whichthe　number　will　be　raised.　Enter　q　to　quit.1.2　121.2　to　the　power　12　is　8.9161Enter　next　pair　of　numbers　or　q　to　quit.2162　to　the　power　16　is　65536Enter　next　pair　of　numbers　or　q　to　quit.qHope　you　enjoyed　this　power　trip　--　bye!程序分析该程序示例中的main()是一个驱动程序（driver），即被设计用来测试函数的小程序。\n该例的while循环是前面讨论过的一般形式。输入1.2  12，scanf()成功读取两值，并返回2，循环继续。因为scanf()跳过空白，所以可以像输出示例那样，分多行输入。但是输入q会使scanf()的返回值为0，因为q与scanf()中的转换说明%1f不匹配。scanf()将返回0，循环结束。类似地，输入2.8 q会使scanf()的返回值为1，循环也会结束。\n现在分析一下与函数相关的内容。power()函数在程序中出现了3次。首次出现是：\n1double power(double n,int p); // ANSI函数原型这是power()函数的原型，它声明程序将使用一个名为power()的函数。开头的关键字double表明power()函数返回一个double类型的值。编译器要知道power()函数返回值的类型，才能知道有多少字节的数据，以及如何解释它们。这就是为什么必须声明函数的原因。圆括号中的 double n,int p表示power()函数的两个参数。第1个参数应该是double类型的值，第2个参数应该是int类型的值。\n第2次出现是：\n1xpow=power(x,exp); // 函数调用程序调用power()，把两个值传递给它。该函数计算x的exp次幂，并把计算结果返回给主调函数。在主调函数中，返回值将被赋给变量xpow。\n第3次出现是：\n1double power(double n, int p) // 函数定义这里，power()有两个形参，一个是double类型，一个是int类型，分别由变量n和变量p表示。注意，函数定义的末尾没有分号，而函数原型的末尾有分号。在函数头后面花括号中的内容，就是power()完成任务的代码。\npower()函数用for循环计算n的p次幂，并把计算结果赋给pow，然后返回pow的值，如下所示：\n1return pow; //返回pow的值使用带返回值的函数声明函数、调用函数、定义函数、使用关键字return，都是定义和使用带返回值函数的基本要素。\n这里，读者可能有一些问题。例如，既然在使用函数返回值之前要声明函数，那么为什么在使用scanf()的返回值之前没有声明scanf()？为什么在定义中说明了power()的返回类型为double，还要单独声明这个函数？\n我们先回答第2 个问题。编译器在程序中首次遇到power()时，需要知道power()的返回类型。此时，编译器尚未执行到power()的定义，并不知道函数定义中的返回类型是double。因此，必须通过前置声明（forward declaration）预先说明函数的返回类型。前置声明告诉编译器，power()定义在别处，其返回类型为double。如果把power()函数的定义置于main()的文件顶部，就可以省略前置声明，因为编译器在执行到main()之前已经知道power()的所有信息。但是，这不是C的标准风格。因为main()通常只提供整个程序的框架，最好把 main()放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。\n接下来，为什么不用声明 scanf()函数就可以使用它？其实，你已经声明了。stdio.h 头文件中包含了scanf()、printf()和其他I/O函数的原型。scanf()函数的原型表明，它返回的类型是int。\n关键概念循环是一个强大的编程工具。在创建循环时，要特别注意以下3个方面：\n注意循环的测试条件要能使循环结束；\n确保循环测试中的值在首次使用之前已初始化；\n确保循环在每次迭代都更新测试的值。\nC通过求值来处理测试条件，结果为0表示假，非0表示真。带关系运算符的表达式常用于循环测试，它们有些特殊。如果关系表达式为真，其值为1；如果为假，其值为0。这与新类型_Bool的值保持一致。\n数组由相邻的内存位置组成，只储存相同类型的数据。记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1。C编译器不会检查数组下标值是否有效，自己要多留心。\n使用函数涉及3个步骤：\n通过函数原型声明函数；\n在程序中通过函数调用使用函数；\n定义函数。\n函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义描述了函数如何工作。现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义。接口部分描述了如何使用一个特性，也就是函数原型所做的；实现部分描述了具体的行为，这正是函数定义所做的。\n本章小结本章的主题是程序控制。C语言为实现结构化的程序提供了许多工具。while语句和for语句提供了入口条件循环。for语句特别适用于需要初始化和更新的循环。使用逗号运算符可以在for循环中初始化和更新多个变量。有些场合也需要使用出口条件循环，C为此提供了do while语句。\n典型的while循环设计的伪代码如下：\n12345678910/*获得初值*/while(值满足测试条件)&#123;    处理该值    获取下一个值&#125;/*for循环也可以完成相同的任务：*/for(获得初值; 值满足测试条件; 获得下一个值)处理该值这些循环都使用测试条件来判断是否继续执行下一次迭代。一般而言，如果对测试表达式求值为非0，则继续执行循环；否则，结束循环。通常，测试条件都是关系表达式（由关系运算符和表达式构成）。表达式的关系为真，则表达式的值为1；如果关系为假，则表达式的值为0。C99新增了_Bool类型，该类型的变量只能储存1或0，分别表示真或假。\n除了关系运算符，本章还介绍了其他的组合赋值运算符，如+=或*=。这些运算符通过对其左侧运算对象执行算术运算来修改它的值。\n接下来还简单地介绍了数组。声明数组时，方括号中的值指明了该数组的元素个数。数组的第 1 个元素编号为0，第2个元素编号为1，以此类推。例如，以下声明：\n1double hippos[20];创建了一个有20个元素的数组hippos，其元素从hippos[0]～hippos[19]。利用循环可以很方便地操控数组的下标。\n最后，本章演示了如何编写和使用带返回值的函数。\n","plink":"https://dxsummer.gitee.io/posts/287f677b/"},{"title":"Step3 运算符、表达式和语句","date":"2020-05-30T08:10:08.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"updated":"2020-06-08T01:44:44.883Z","content":"[运算符、表达式和语句]本章介绍以下内容：\n关键字：while、typedef\n运算符：=、-、*、/、%、++、--、(类型名)\nC语言的各种运算符，包括用于普通数学运算的运算符\n运算符优先级以及语句、表达式的含义\nwhile循环\n复合语句、自动类型转换和强制类型转换\n如何编写带有参数的函数\n现在，读者已经熟悉了如何表示数据，接下来我们学习如何处理数据。C 语言为处理数据提供了大量的操作，可以在程序中进行算术运算、比较值的大小、修改变量、逻辑地组合关系等。我们先从基本的算术运算（加、减、乘、除）开始。\n组织程序是处理数据的另一个方面，让程序按正确的顺序执行各个步骤。C 有许多语言特性，帮助你完成组织程序的任务。循环就是其中一个特性，本章中你将窥其大概。循环能重复执行行为，让程序更有趣、更强大。\n循环简介程序清单5.1是一个简单的程序示例，该程序进行了简单的运算，计算穿9码男鞋的脚长（单位：英寸）。为了让读者体会循环的好处，程序的第1个版本演示了不使用循环编程的局限性。\n123456789101112131415程序清单5.1 shoes1.c程序/* shoes1.c -- 把鞋码转换成英寸 */#include　&lt;stdio.h&gt;#define ADJUST 7.31　　　　　　　　　　// 字符常量int　main(void)&#123;    const double SCALE = 0.333;// const变量    double　shoe,　foot;    shoe　=　9.0;    foot = SCALE * shoe + ADJUST;    printf(\"Shoe　size　(men's)　　 foot　length\\n\");    printf(\"%10.1f　%15.2f　inches\\n\",　shoe,　foot);    return　0;&#125;该程序的输出如下：\n12Shoe　size　(men's)　foot　length\t9.0　　　　10.31　inches该程序演示了用#define 指令创建符号常量和用 const 限定符创建在程序运行过程中不可更改的变量。程序使用了乘法和加法，假定用户穿9码的鞋，以英寸为单位打印用户的脚长。你可能会说：“这太简单了，我用笔算比敲程序还要快。”说得没错。写出来的程序只使用一次（本例即只根据一只鞋的尺码计算一次脚长），实在是浪费时间和精力。如果写成交互式程序会更有用，但是仍无法利用计算机的优势。\n应该让计算机做一些重复计算的工作。毕竟，需要重复计算是使用计算机的主要原因。C 提供多种方法做重复计算，我们在这里简单介绍一种——while循环。它能让你对运算符做更有趣地探索。程序清单5.2演示了用循环改进后的程序。\n程序清单5.2 shoes2.c程序\n12345678910111213141516171819/* shoes2.c -- 计算多个不同鞋码对应的脚长 */#include　&lt;stdio.h&gt;#define ADJUST 7.31　　　　　　　　　　// 字符常量int　main(void)&#123;    const double SCALE = 0.333;// const变量    double　shoe,　foot;    printf(\"Shoe size (men's) foot length\\n\");    shoe　=　3.0;    while (shoe &lt; 18.5)　　　　　　/* while循环开始 */    &#123;　　　　　　　　　　　　　　　/* 块开始　*/        foot = SCALE * shoe + ADJUST;        printf(\"%10.1f　%15.2f　inches\\n\",　shoe,　foot);        shoe　=　shoe　+　1.0;    &#125;　　　　　　　　　　　　　　　/* 块结束　　　 */    printf(\"If　the　shoe　fits,　wear　it.\\n\");    return　0;&#125;下面是shoes2.c程序的输出（…表示并未显示完整，有删节）：\n12345678910Shoe　size　(men's)　foot　length3.0　　　　　　 8.31　inches4.0　　　　　　 8.64　inches5.0　　　　　　 8.97　inches6.0　　　　　　 9.31　inches...16.0　　　　　12.64　inches17.0　　　　　12.97　inches18.0　　　　　13.30　inchesIf　the　shoe　fits,　wear　it.（如果读者对此颇有研究，应该知道该程序不符合实际情况。程序中假定了一个统一的鞋码系统。）\n下面解释一下while循环的原理。当程序第1次到达while循环时，会检查圆括号中的条件是否为真。该程序中，条件表达式如下：\n1shoe &lt; 18.5符号&lt;的意思是小于。变量shoe被初始化为3.0，显然小于18.5。因此，该条件为真，程序进入块中继续执行，把尺码转换成英寸。然后打印计算的结果。下一条语句把 shoe增加1.0，使shoe的值为4.0：\n1shoe = shoe + 1.0;此时，程序返回while入口部分检查条件。为何要返回while的入口部分？因为上面这条语句的下面是右花括号（}），代码使用一对花括号（{}）来标出while循环的范围。花括号之间的内容就是要被重复执行的内容。花括号以及被花括号括起来的部分被称为块（block）。现在，回到程序中。因为4小于18.5，所以要重复执行被花括号括起来的所有内容（用计算机术语来说就是，程序循环这些语句）。该循环过程一直持续到shoe的值为19.0。此时，由于19.0小于18.5，所以该条件为假：\n1shoe &lt; 18.5出现这种情况后，控制转到紧跟while循环后面的第1条语句。该例中，是最后的printf()语句。\n可以很方便地修改该程序用于其他转换。例如，把SCALE设置成1.8、ADJUST设置成32.0，该程序便可把摄氏温度转换成华氏温度；把SCALE设置成0.6214、ADJUST设置成0，该程序便可把公里转换成英里。注意，修改了设置后，还要更改打印的消息，以免前后表述不一。\n通过while循环能便捷灵活地控制程序。现在，我们来学习程序中会用到的基本运算符。\n基本运算符C用运算符（operator）表示算术运算。例如，+运算符使在它两侧的值加在一起。如果你觉得术语“运算符”很奇怪，那么请记住东西总得有个名称。与其叫“那些东西”或“运算处理符”，还不如叫“运算符”。现在，我们介绍一下用于基本算术运算的运算符：=、+、-、*和/（C 没有指数运算符。不过，C 的标准数学库提供了一个pow()函数用于指数运算。例如，pow(3.5, 2.2)返回3.5的2.2次幂）。\n赋值运算符：=在C语言中，=并不意味着“相等”，而是一个赋值运算符。下面的赋值表达式语句：\n1bmw = 2002;把值2002赋给变量bmw。也就是说，=号左侧是一个变量名，右侧是赋给该变量的值。符号=被称为赋值运算符。另外，上面的语句不读作“bmw等于2002”，而读作“把值2002赋给变量bmw”。赋值行为从右往左进行。\n也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用的语句：\n1i = i + 1;对数学而言，这完全行不通。如果给一个有限的数加上 1，它不可能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句的意思是：找出变量 i 的值，把该值加 1，然后把新值赋值变量i（见图5.1）。\n\n在C语言中，类似这样的语句没有意义（实际上是无效的）：\n12002 = bmw;因为在这种情况下，2002 被称为右值（rvale），只能是字面常量。不能给常量赋值，常量本身就是它的值。因此，在编写代码时要记住，=号左侧的项必须是一个变量名。实际上，赋值运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。不过，后面章节还会介绍“指针”，可用于指向一个存储位置。概括地说，C 使用可修改的左值（modifiable lvalue）标记那些可赋值的实体。也许“可修改的左值”不太好懂，我们再来看一些定义。\n几个术语：数据对象、左值、右值和运算符\n赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象（data object）。C 标准只有在提到这个概念时才会用到对象这个术语。使用变量名是标识对象的一种方法。除此之外，还有其他方法，但是要在后面的章节中才学到。例如，可以指定数组的元素、结构的成员，或者使用指针表达式（指针中储存的是它所指向对象的地址）。左值（lvalue）是 C 语言的术语，用于标识特定数据对象的名称或表达式。因此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。\n对于早期的C语言，提到左值意味着：\n1.它指定一个对象，所以引用内存中的地址；\n2.它可用在赋值运算符的左侧，左值（lvalue）中的l源自left。\n但是后来，标准中新增了const限定符。用const创建的变量不可修改。因此，const标识符满足上面的第1项，但是不满足第2项。一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧。有些左值不能用于赋值运算符的左侧。此时，标准对左值的定义已经不能满足当前的状况。\n为此，C标准新增了一个术语：可修改的左值（modifiable lvalue），用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语对象定位值（object locator value）更好。\n右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。例如，考虑下面的语句：\n1bmw = 2002;这里，bmw是可修改的左值，2002是右值。读者也许猜到了，右值中的r源自right。右值可以是常量、变量或其他可求值的表达式（如，函数调用）。实际上，当前标准在描述这一概念时使用的是表达式的值（value of an expression），而不是右值。\n我们看几个简单的示例：\n1234567int　ex;int　why;int　zee;const　int　TWO　=　2;why　=　42;zee = why;ex = TWO * (why + zee);这里，ex、why和zee都是可修改的左值（或对象定位值），它们可用于赋值运算符的左侧和右侧。TWO是不可改变的左值，它只能用于赋值运算符的右侧（在该例中，TWO被初始化为2，这里的=运算符表示初始化而不是赋值，因此并未违反规则）。同时，42 是右值，它不能引用某指定内存位置。另外，why和 zee 是可修改的左值，表达式(why + zee)是右值，该表达式不能表示特定内存位置，而且也不能给它赋值。它只是程序计算的一个临时值，在计算完毕后便会被丢弃。\n在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是运算对象（operand）。运算对象是运算符操作的对象。例如，可以把吃汉堡描述为：“吃”运算符操作“汉堡”运算对象。类似地可以说，=运算符的左侧运算对象应该是可修改的左值。\nC的基本赋值运算符有些与众不同，请看程序清单5.3。\n123456789101112程序清单5.3 golf.c程序/* golf.c -- 高尔夫锦标赛记分卡 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　jane,　tarzan,　cheeta;    cheeta=tarzan=jane=68;    printf(\"cheeta　　tarzan　　 jane\\n\");    printf(\"First　round　score　%4d　%8d　%8d\\n\",　cheeta,　tarzan,　jane);    return　0;&#125;许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值的顺序是从右往左：首先把68赋给jane，然后再赋给tarzan，最后赋给cheeta。因此，程序的输出如下：\n12cheetah　　tarzan　　　　janeFirst　round　score　　68　　　　　　68　　　　　　68加法运算符：+加法运算符（addition operator）用于加法运算，使其两侧的值相加。例如，语句：\n1printf(\"%d\", 4 + 20);打印的是24，而不是表达式\n14 + 20相加的值（运算对象）可以是变量，也可以是常量。因此，执行下面的语句：\n1income = salary + bribes;计算机会查看加法运算符右侧的两个变量，把它们相加，然后把和赋给变量income。\n在此提醒读者注意，income、salary和bribes都是可修改的左值。因为每个变量都标识了一个可被赋值的数据对象。但是，表达式salary + brives是一个右值。\n减法运算符：-减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。例如，下面的语句把200.0赋给takehome：\n1takehome = 224.00 – 24.00;+和-运算符都被称为二元运算符（binary operator），即这些运算符需要两个运算对象才能完成操作。\n符号运算符：-和+减号还可用于标明或改变一个值的代数符号。例如，执行下面的语句后，smokey的值为12：\n12rocky = –12;smokey = –rocky;以这种方式使用的负号被称为一元运算符（unary operator）。一元运算符只需要一个运算对象（见图5.2）。\nC90标准新增了一元+运算符，它不会改变运算对象的值或符号，只能这样使用：\n1dozen &#x3D; +12;编译器不会报错。但是在以前，这样做是不允许的。\n乘法运算符：*符号*表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm：\n1cm = 2.54 * inch;C没有平方函数，如果要打印一个平方表，怎么办？如程序清单5.4所示，可以使用乘法来计算平方。\n程序清单5.4 squares.c程序\n12345678910111213/* squares.c -- 计算1～20的平方 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　num　=　1;    while　(num　&lt;　21)    &#123;        printf(\"%4d %6d\\n\", num, num * num);        num　=　num　+　1;    &#125;    return　0;&#125;该程序打印数字1～20及其平方。接下来，我们再看一个更有趣的例子。\n指数增长读者可能听过这样一个故事，一位强大的统治者想奖励做出突出贡献的学者。他问这位学者想要什么，学者指着棋盘说，在第1个方格里放1粒小麦、第2个方格里放2粒小麦、第3个方格里放4粒小麦，第4个方格里放 8 粒小麦，以此类推。这位统治者不熟悉数学，很惊讶学者竟然提出如此谦虚的要求。因为他原本准备奖励给学者一大笔财产。如果程序清单5.5运行的结果正确，这显然是跟统治者开了一个玩笑。程序计算出每个方格应放多少小麦，并计算了总数。可能大多数人对小麦的产量不熟悉，该程序以谷粒数为单位，把计算的小麦总数与粗略估计的世界小麦年产量进行了比较。\n程序清单5.5 wheat.c程序\n12345678910111213141516171819202122232425/* wheat.c -- 指数增长 */#include　&lt;stdio.h&gt;#define SQUARES 64　　　　　　 // 棋盘中的方格数int　main(void)&#123;    const double CROP = 2E16;　// 世界小麦年产谷粒数    double current,total;    int count=1;    printf(\"square　grains　total \");    printf(\"fraction　of　\\n\");    printf(\"　　added　　grains　　 \");    printf(\"world　total\\n\");    total=current=1.0;　　 /* 从1颗谷粒开始　*/    printf(\"%4d　%13.2e　%12.2e　%12.2e\\n\",count,　current,total,total/CROP);    while(count&lt;SQUARES)    &#123;        count=count+1;        current=2.0*current;　 /* 下一个方格谷粒翻倍 */        total=total+current;　 /* 更新总数 */        printf(\"%4d　%13.2e　%12.2e　%12.2e\\n\",count,　current,total,total/CROP);    &#125;    printf(\"That's　all.\\n\");    return　0;&#125;程序的输出结果如下：\n1234567891011121314151617181920212223square　　　　　　grains　　　　　 total　　　　　　 fraction　ofadded　　　　　　 grains　　　　　 world　total1　　　　　　　 1.00e+00　　　　1.00e+00　　　　5.00e-172　　　　　　　 2.00e+00　　　　3.00e+00　　　　1.50e-163　　　　　　　 4.00e+00　　　　7.00e+00　　　　3.50e-164　　　　　　　 8.00e+00　　　　1.50e+01　　　　7.50e-165　　　　　　　 1.60e+01　　　　3.10e+01　　　　1.55e-156　　　　　　　 3.20e+01　　　　6.30e+01　　　　3.15e-157　　　　　　　 6.40e+01　　　　1.27e+02　　　　6.35e-158　　　　　　　 1.28e+02　　　　2.55e+02　　　　1.27e-149　　　　　　　 2.56e+02　　　　5.11e+02　　　　2.55e-1410　　　　　　　5.12e+02　　　　1.02e+03　　　　5.12e-1410个方格以后，该学者得到的小麦仅超过了1000粒。但是，看看55个方格的小麦数是多少：\n155　　　　　 1.80e+16　　　　3.60e+16　　　　1.80e+00总量已超过了世界年产量！不妨自己动手运行该程序，看看第64个方格有多少小麦。\n这个程序示例演示了指数增长的现象。世界人口增长和我们使用的能源都遵循相同的模式。\n除法运算符：/C使用符号/来表示除法。/左侧的值是被除数，右侧的值是除数。例如，下面four的值是4.0：\n1four = 12.0/3.0;整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。整数是没有小数部分的数。这使得5除以3很让人头痛，因为实际结果有小数部分。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断（truncation）。\n运行程序清单5.6中的程序，看看截断的情况，体会整数除法和浮点数除法的区别。\n程序清单5.6 divide.c程序\n12345678910111213/* divide.c -- 演示除法 */#include　&lt;stdio.h&gt;int　main(void)&#123;    printf(\"integer　division:　5/4　is　%d　\\n\",5/4);    printf(\"integer　division:　6/3　is　%d　\\n\",6/3);    printf(\"integer　division:　7/4　is　%d　\\n\",7/4);    printf(\"floating　division:　7./4. is　%1.2f　\\n\",7./4.);    printf(\"mixed　division:　7./4　is　%1.2f　\\n\",7./4);    return　0;&#125;程序清单5.6中包含一个“混合类型”的示例，即浮点值除以整型值。C相对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是要避免使用混合类型。该程序的输出如下：\n12345integer　division:　 5/4　　 is　1integer　division:　 6/3　　 is　2integer　division:　 7/4　　 is　1floating　division:　7./4.　is　1.75mixed　division:　　　7./4　 is　1.75注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。本例中，在进行除法运算前，整数会被转换成浮点数。\nC99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8 会怎样？该方法建议四舍五入为-4，因为-4 小于-3.8.但是，另一种舍入方法是直接丢弃小数部分。这种方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前，不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8转换成-3。\n运算符优先级考虑下面的代码：\n1butter=25.0+60.0*n/SCALE;这条语句中有加法、乘法和除法运算。先算哪一个？是25.0加上60.0，然后把计算的和85.0乘以n，再把结果除以SCALE？还是60.0乘以n，然后把计算的结果加上25.0，最后再把结果除以SCALE？还是其他运算顺序？假设n是6.0，SCALE是2.0，带入语句中计算会发现，第1种顺序得到的结果是255，第2种顺序得到的结果是192.5。C程序一定是采用了其他的运算顺序，因为程序运行该语句后，butter的值是205.0。\n显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过运算符优先级来解决操作顺序的问题。每个运算符都有自己的优先级。正如普通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法和除法。如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对象，则根据它们在语句中出现的顺序来执行。对大多数运算符而言，这种情况都是按从左到右的顺序进行（=运算符除外）。因此，语句：\n1butter=25.0+60.0*n/SCALE;的运算顺序是：\n12360.0*n　　　　　/*首先计算表达式中的*或/（假设n的值是6，所以60.0*n得360.0）*/360.0/SCALE　　 /*然后计算表达式中第2个*或*/25.0+180　　　　　/*最后计算表达式里第1个+或-，结果为205.0（假设SCALE的值是2.0）许多人喜欢用表达式树（expression tree）来表示求值的顺序，如图5.3所示。该图演示了如何从最初的表达式逐步简化为一个值。\n\n如何让加法运算在乘法运算之前执行？可以这样做：\n1flour=(25.0+60.0*n)/SCALE;最先执行圆括号中的部分。圆括号内部按正常的规则执行。该例中，先执行乘法运算，再执行加法运算。执行完圆括号内的表达式后，用运算结果除以SCALE。\n表5.1总结了到目前为止学过的运算符优先级。\n\n注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中用除号左侧的运算对象除以右侧的运算对象。\n优先级和求值顺序运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：\n1y=6*12+5*20;当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语句中，12是和+运算符的运算对象。根据运算符的优先级，乘法的优先级比加法高，所以先进行乘法运算。类似地，先对 5 进行乘法运算而不是加法运算。简而言之，先进行两个乘法运算6 * 12和5 * 20，再进行加法运算。但是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用哪种方案，表达式都会简化为 72 + 100，所以这并不影响最终的结果。但是，读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边的乘法。结合律只适用于共享同一运算对象运算符。例如，在表达式12 / 3 * 2中，/和运算符的优先级相同，共享运算对象3。因此，从左往右的结合律在这种情况起作用。表达式简化为4 * 2，即8（如果从右往左计算，会得到12/6，即2，这种情况下计算的先后顺序会影响最终的计算结果）。在该例中，两个*运算符并没有共享同一个运算对象，因此从左往右的结合律不适用于这种情况。\n学以致用\n接下来，我们在更复杂的示例中使用以上规则，请看程序清单5.7。\n1234567891011程序清单5.7 rules.c程序/* rules.c -- 优先级测试 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　top,　score;    top = score = -(2 + 5) * 6 + (4 + 3 * (2 + 3));    printf(\"top　=　%d,　score　=　%d\\n\",　top,　score);    return　0;&#125;该程序会打印什么值？先根据代码推测一下，再运行程序或阅读下面的分析来检查你的答案。\n首先，圆括号的优先级最高。先计算-(2 + 5) * 6中的圆括号部分，还是先计算(4 + 3 * (2 + 3))中的圆括号部分取决于具体的实现。圆括号的最高优先级意味着，在子表达式-(2 + 5) * 6中，先计算(2 + 5)的值，得7。然后，把一元负号应用在7上，得-7。现在，表达式是：\n1top = score = -7 * 6 + (4 + 3 * (2 + 3))下一步，计算2 + 3的值。表达式变成：\n1top = score = -7 * 6 + (4 + 3 * 5)接下来，因为圆括号中的*比+优先级高，所以表达式变成：\n1top = score = -7 * 6 + (4 + 15)然后，表达式为：\n1top = score = -7 * 6 + 19-7乘以6后，得到下面的表达式：\n1top = score = -42 + 19然后进行加法运算，得到：\n1top = score = -23现在，-23被赋值给score，最终top的值也是-23。记住，=运算符的结合律是从右往左。\n其他运算符C语言有大约40个运算符，有些运算符比其他运算符常用得多。前面讨论的是最常用的，本节再介绍4个比较有用的运算符。\nsizeof运算符和size_t类型读者在第3章就见过sizeof运算符。回顾一下，sizeof运算符以字节为单位返回运算对象的大小（在C中，1字节定义为char类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节）。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。程序清单5.8演示了这两种用法。\n1234567891011121314程序清单5.8 sizeof.c程序// sizeof.c -- 使用sizeof运算符// 使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu#include &lt;stdio.h&gt;int　main(void)&#123;    int　n=0;    size_t intsize;    intsize=sizeof(int);    printf(\"n=%d,　n　has　%zd　bytes;　all　ints　have　%zd　bytes.\\n\",n,sizeof　n,intsize);    return　0;&#125;C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，size_t是语言定义的标准类型。C有一个typedef机制（第14章再详细介绍），允许程序员为现有类型创建别名。例如，\n1typedef double real;这样，real就是double的别名。现在，可以声明一个real类型的变量：\n1real deal; // 使用typedef编译器查看real时会发现，在typedef声明中real已成为double的别名，于是把deal创建为double 类型的变量。类似地，C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或unsigned long的别名。这样，在使用size_t类型时，编译器会根据不同的系统替换标准类型。\nC99 做了进一步调整，新增了%zd 转换说明用于 printf()显示 size_t 类型的值。如果系统不支持%zd，可使用%u或%lu代替%zd。\n求模运算符：%求模运算符（modulus operator）用于整数运算。求模运算符给出其左侧整数除以右侧整数的余数（remainder）。例如，13 % 5（读作“13求模5”）得3，因为13比5的两倍多3，即13除以5的余数是3。求模运算符只能用于整数，不能用于浮点数。\n乍一看会认为求模运算符像是数学家使用的深奥符号，但是实际上它非常有用。求模运算符常用于控制程序流。例如，假设你正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用。这种情况可以在程序中对月份求模3（即，month % 3），并检查结果是否为0。如果为0，便加进额外的费用。等学到第7章的if语句后，读者会更明白。\n程序清单5.9演示了%运算符的另一种用途。同时，该程序也演示了while循环的另一种用法。\n1234567891011121314151617181920212223程序清单5.9 min_sec.c程序// min_sec.c -- 把秒数转换成分和秒#include　&lt;stdio.h&gt;#define SEC_PER_MIN 60　　　　　 // 1分钟60秒int　main(void)&#123;    int sec,min,left;    printf(\"Convert　seconds　to　minutes　and　seconds!\\n\");    printf(\"Enter　the　number　of　seconds　(&lt;=0　to　quit):\\n\");    scanf(\"%d\",&amp;sec);　　　　　 // 读取秒数    while(sec&gt;0)    &#123;        min=sec/SEC_PER_MIN;　　// 截断分钟数        left=sec%SEC_PER_MIN;　 // 剩下的秒数        printf(\"%d　seconds　is　%d　minutes,　%d　seconds.\\n\",sec,        min,left);        printf(\"Enter　next　value　(&lt;=0　to　quit):\\n\");        scanf(\"%d\",&amp;sec);    &#125;    printf(\"Done!\\n\");    return　0;&#125;该程序的输出如下：\n\n程序清单5.2使用一个计数器来控制while循环。当计数器超出给定的大小时，循环终止。而程序清单5.9则通过scanf()为变量sec获取一个新值。只要该值为正，循环就继续。当用户输入一个0或负值时，循环退出。这两种情况设计的要点是，每次循环都会修改被测试的变量值。\n负数求模如何进行？C99规定“趋零截断”之前，该问题的处理方法很多。但自从有了这条规则之后，如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数：\n123411/5\t得2，\t\t11 % 5\t\t得111/-5\t得-2，\t11 % -2\t\t得1-11/-5\t得2，\t\t-11 % -5\t得-1-11/5\t得-2，\t-11 % 5\t\t得-1如果当前系统不支持C99标准，会显示不同的结果。实际上，标准规定：无论何种情况，只要a和b都是整数值，便可通过a - (a/b)*b来计算a%b。例如，可以这样计算-11%5：\n1-11-(-11/5)*5=-11-(-2)*5=-11-(-10)=-1递增运算符：++递增运算符（increment operator）执行简单的任务，将其运算对象递增1。该运算符以两种方式出现。第1种方式，++出现在其作用的变量前面，这是前缀模式；第2种方式，++出现在其作用的变量后面，这是后缀模式。两种模式的区别在于递增行为发生的时间不同。我们先解释它们的相似之处，再分析它们不同之处。程序清单5.10中的程序示例演示了递增运算符是如何工作的。\n程序清单5.10 add_one.c程序\n1234567891011121314/* add_one.c -- 递增：前缀和后缀 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int ultra=0,super=0;    while(super&lt;5)    &#123;        super++;        ++ultra;        printf(\"super=%d,ultra=%d\\n\",super,ultra);    &#125;    return　0;&#125;运行该程序后，其输出如下：\n12345super　=　1,　ultra　=　1super　=　2,　ultra　=　2super　=　3,　ultra　=　3super　=　4,　ultra　=　4super　=　5,　ultra　=　5该程序两次同时计数到5。用下面两条语句分别代替程序中的两条递增语句，程序的输出相同：\n12super　=　super　+　1;ultra　=　ultra　+　1;这些都是很简单的语句，为何还要创建两个缩写形式？原因之一是，紧凑结构的代码让程序更为简洁，可读性更高。这些运算符让程序看起来很美观。例如，可重写程序清单5.2（shoes2.c）中的一部分代码：\n1234567shoe=3.0;while(shoe&lt;18.5)&#123;    foot=SCALE*size+ADJUST;    printf(\"%10.1f　%20.2f　inches\\n\",shoe,foot);    ++shoe;&#125;但是，这样做也没有充分利用递增运算符的优势。还可以这样缩短这段程序：\n123456shoe　=　2.0;while　(++shoe&lt;18.5)&#123;    foot = SCALE*shoe + ADJUST;    printf(\"%10.1f　%20.2f　inches\\n\",　shoe,　foot);&#125;如上代码所示，把变量的递增过程放入while循环的条件中。这种结构在C语言中很普遍，我们来仔细分析一下。\n首先，这样的while循环是如何工作的？很简单。shoe的值递增1，然后和18.5作比较。如果递增后的值小于18.5，则执行花括号内的语句一次。然后，shoe的值再递增1，重复刚才的步骤，直到shoe的值不小于18.5为止。注意，我们把shoe的初始值从3.0改为2.0，因为在对foot第1次求值之前， shoe已经递增了1（见图5.4）。\n\n其次，这样做有什么好处？它使得程序更加简洁。更重要的是，它把控制循环的两个过程集中在一个地方。该循环的主要过程是判断是否继续循环（本例中，要检查鞋子的尺码是否小于 18.5），次要过程是改变待测试的元素（本例中是递增鞋子的尺码）。\n如果忘记改变鞋子的尺码，shoe的值会一直小于18.5，循环不会停止。计算机将陷入无限循环（infinite loop）中，生成无数相同的行。最后，只能强行关闭这个程序。把循环测试和更新循环放在一处，就不会忘记更新循环。\n但是，把两个操作合并在一个表达式中，降低了代码的可读性，让代码难以理解。而且，还容易产生计数错误。\n递增运算符的另一个优点是，通常它生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越来越智能，这一优势可能会消失。一个智能的编译器可以把x = x + 1当作++x对待。\n最后，递增运算符还有一个在某些场合特别有用的特性。我们通过程序清单5.11来说明。\n1234567891011121314程序清单5.11 post_pre.c程序/* post_pre.c -- 前缀和后缀 */#include &lt;stdio.h&gt;int main(void)&#123;    int a=1,b=1;    int a_post,　pre_b;    a_post=a++;　// 后缀递增    pre_b=++b;　 // 前缀递增    printf(\"a　 a_post　　b　　pre_b　\\n\");    printf(\"%1d　%5d　%5d　%5d\\n\",　a,　a_post,　b,　pre_b);    return　0;&#125;如果你的编译器没问题，那么程序的输出应该是：\n12a\ta_post\tb\t\tpre_b2\t1\t\t2　　　　2a和b都递增了1，但是，a_post是a递增之前的值，而b_pre是b递增之后的值。这就是++的前缀形式和后缀形式的区别（见图5.5）。\n\n12a_post = a++;　　　// 后缀：使用a的值乊后，递增ab_pre= ++b;　　　　// 前缀：使用b的值乊前，递增b单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使用前缀或后缀的效果不同。例如，我们曾经建议用下面的代码：\n1while (++shoe &lt; 18.5)该测试条件相当于提供了一个鞋子尺码到18的表。如果使用shoe++而不是++shoes，尺码表会增至19。因为shoe会在与18.5进行比较之后才递增，而不是先递增再比较。\n当然，使用下面这种形式也没错：\n1shoe = shoe + 1;只不过，有人会怀疑你是否是真正的C程序员。\n在学习本书的过程中，应多留意使用递增运算符的例子。自己思考是否能互换使用前缀和后缀形式，或者当前环境是否只能使用某种形式。\n如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智的是不要那样使用它们。例如，不要使用下面的语句：\n1234b=++i; // 如果使用i++，会得到不同的结果应该使用下列语句：++i;　　　// 第1行b=i; // 如果第1行使用的是i++，幵不会影响b的值尽管如此，有时小心翼翼地使用会更有意思。所以，本书会根据实际情况，采用不同的写法。\n递减运算符：–每种形式的递增运算符都有一个递减运算符（decrement operator）与之对应，用–代替++即可：\n12--count; // 前缀形式的递减运算符count--; // 后缀形式的递减运算符程序清单5.12演示了计算机可以是位出色的填词家。\n程序清单5.12 bottles.c程序\n1234567891011121314#include　&lt;stdio.h&gt;#define　MAX　100int　main(void)&#123;    int　count　=　MAX　+　1;    while(--count&gt;0)　    &#123;        printf(\"%d　bottles　of　spring　water　on　the　wall,\"\"%d　bottles　of　spring　water!\\n\",　count,　count);        printf(\"Take　one　down　and　pass　it　around,\\n\");        printf(\"%d　bottles　of　spring　water!\\n\\n\",　count　-　1);    &#125;    return　0;&#125;该程序的输出如下（篇幅有限，省略了中间大部分输出）：\n12345678910100　bottles　of　spring　water　on　the　wall,　100　bottles　of　spring　water!Take　one　down　and　pass　it　around,99　bottles　of　spring　water!99　bottles　of　spring　water　on　the　wall,　99　bottles　of　spring　water!Take　one　down　and　pass　it　around,98　bottles　of　spring　water!...1 bottles of spring water on the wall, 1 bottles of spring water!Take one down and pass it around,0 bottles of spring water!显然，这位填词家在复数的表达上有点问题。在学完第7章中的条件运算符后，可以解决这个问题。\n顺带一提，&gt;运算符表示“大于”，&lt;运算符表示“小于”，它们都是关系运算符（relational operator）。我们将在第6章中详细介绍关系运算符。\n优先级递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x*y++表示的是(x)*(y++)，而不是(x*y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。\n不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句：\n123y=2;n=3;nextnum=(y+n++)*6;nextnum的值是多少？把y和n的值带入上面的第3条语句得：\n1nextnum = (2 + 3)*6 = 5*6 = 30n的值只有在被使用之后才会递增为4。根据优先级的规定，++只作用于n，不作用与y + n。除此之外，根据优先级可以判断何时使用n的值对表达式求值，而递增运算符的性质决定了何时递增n的值。\n如果n++是表达式的一部分，可将其视为“先使用n，再递增”；而++n则表示“先递增n，再使用”。\n不要自作聪明如果一次用太多递增运算符，自己都会糊涂。例如，利用递增运算符改进 squares.c 程序（程序清单5.4），用下面的while循环替换原程序中的while循环：\n1234while　(num&lt;21)&#123;    printf(\"%10d %10d\\n\", num, num*num++);&#125;这个想法看上去不错。打印num，然后计算num*num得到平方值，最后把num递增1。但事实上，修改后的程序只能在某些系统上能正常运行。该程序的问题是：当 printf()获取待打印的值时，可能先对最后一个参数（ ）求值，这样在获取其他参数的值之前就递增了num。所以，本应打印：\n15　　　　　　 25却打印成：\n16　　　　　　 25它甚至可能从右往左执行，对最右边的num（++作用的num）使用5，对第2个num和最左边的num使用6，结果打印出：\n16　　　　　　 30在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。\n类似这样的语句，也会导致一些麻烦：\n1ans = num/2 + 5*(1 + num++);同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能认为，先计算第1项（num/2），接着计算第2项（5*(1 + num++)）。但是，编译器可能先计算第2项，递增num，然后在num/2中使用num递增后的新值。因此，无法保证编译器到底先计算哪一项。\n还有一种情况，也不确定：\n12n=3;y=n++ + n++;可以肯定的是，执行完这两条语句后，n的值会比旧值大2。但是，y的值不确定。在对y求值时，编译器可以使用n的旧值（3）两次，然后把n递增1两次，这使得y的值为6，n的值为5。或者，编译器使用n的旧值（3）一次，立即递增n，再对表达式中的第2个n使用递增后的新值，然后再递增n，这使得 y 的值为 7，n 的值为 5。两种方案都可行。对于这种情况更精确地说，结果是未定义的，这意味着 C标准并未定义结果应该是什么。\n遵循以下规则，很容易避免类似的问题：\n如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；\n如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。\n另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面的“副作用和序列点”中学到序列点时再来讨论这部分内容。\n表达式和语句在前几章中，我们已经多次使用了术语表达式（expression）和语句（statement）。现在，我们来进一步学习它们。C的基本程序步骤由语句组成，而大多数语句都由表达式构成。因此，我们先学习表达式。\n表达式表达式（expression）由运算符和运算对象组成（前面介绍过，运算对象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。下面是一些表达式：\n12345674-64+21a*(b+c/d)/20q=5*2x=++q%3q&gt;3如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子表达式（subexpression）组成（子表达式即较小的表达式）。例如，c/d是上面例子中a*(b + c/d)/20的子表达式。\n每个表达式都有一个值\nC 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达式中，前几个都很清晰明了。但是，有赋值运算符（=）的表达式的值是什么？这些表达式的值与赋值运算符左侧变量的值相同。因此，表达式q = 5*2作为一个整体的值是10。那么，表达式q &gt; 3的值是多少？这种关系表达式的值不是0就是1，如果条件为真，表达式的值为1；如果条件为假，表达式的值为0。表5.2列出了一些表达式及其值：\n\n虽然最后一个表达式看上去很奇怪，但是在C中完全合法（但不建议使用），因为它是两个子表达式的和，每个子表达式都有一个值。\n语句语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。因此，\n1legs = 4只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码则是一条语句：\n1legs = 4;最简单的语句是空语句：\n1;　　 //空语句C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语句）。因此，像下面这样写也没问题：\n128;3 + 4;但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切地说，语句可以改变值或调用函数：\n123x = 25;++x;y = sqrt(x);虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，但并不是所有的指令都是语句。考虑下面的语句：\n1x = 6 + (y = 5);该语句中的子表达式y = 5是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，简单语句）。\n到目前为止，读者已经见过多种语句（不包括空语句）。程序清单5.13演示了一些常见的语句。\n1234567891011121314程序清单5.13 addemup.c程序/* addemup.c -- 几种常见的语句 */#include　&lt;stdio.h&gt;int main(void)　　　　　　　　 /* 计算前20个整数的和　 */&#123;    int count, sum;　　　　　/* 声明[[1\\]](part0010.xhtml#annot17)　　　　　　 */    count = 0;　　　　　　　　 /* 表达式语句　　　　　 */    sum = 0;　　　　　　　　　 /* 表达式语句　　　　　 */    while (count++ &lt; 20)　　　 /* 迭代语句　　　　　　*/    sum　=　sum　+　count;    printf(\"sum = %d\\n\", sum); /* 表达式语句[[2\\]](part0010.xhtml#annot18)　　　 */    return 0;　　　　　　　/* 跳转语句　　　　　　　　 */&#125;下面我们讨论程序清单 5.13。到目前为止，相信读者已经很熟悉声明了。尽管如此，我们还是要提醒读者：声明创建了名称和类型，并为其分配内存位置。注意，声明不是表达式语句。也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值：\n1int port /* 不是表达式，没有值 */赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾。注意，在while循环中有一个赋值表达式语句。赋值表达式语句是表达式语句的一个示例。\n函数表达式语句会引起函数调用。在该例中，调用printf()函数打印结果。while语句有3个不同的部分（见图5.6）。首先是关键字while；然后，圆括号中是待测试的条件；最后如果测试条件为真，则执行while循环体中的语句。该例的while循环中只有一条语句。可以是本例那样的一条语句，不需要用花括号括起来，也可以像其他例子中那样包含多条语句。多条语句需要用花括号括起来。这种语句是复合语句，稍后马上介绍。\n\nwhile语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂。在后面的章节里，我们会遇到许多这样的语句。\n副作用和序列点\n我们再讨论一个C语言的术语副作用（side effect）。副作用是对数据对象或文件的修改。例如，语句：\n1states = 50;它的副作用是将变量的值设置为50。副作用？这似乎更像是主要目的！但是从C语言的角度看，主要目的是对表达式求值。给出表达式4 + 6，C会对其求值得10；给出表达式states = 50，C会对其求值得50。对该表达式求值的副作用是把变量states的值改为50。跟赋值运算符一样，递增和递减运算符也有副作用，使用它们的主要目的就是使用其副作用。\n类似地，调用 printf()函数时，它显示的信息其实是副作用（printf()的返回值是待显示字符的个数）。\n序列点（sequence point）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符也有序列点。另外，任何一个完整表达式的结束也是一个序列点。\n什么是完整表达式？所谓完整表达式（full expression），就是指这个表达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和while循环中的作为测试条件的表达式，都是完整表达式。\n序列点有助于分析后缀递增何时发生。例如，考虑下面的代码：\n12while(guests++&lt;10)printf(\"%d　\\n\",guests);对于该例，C语言的初学者认为“先使用值，再递增它”的意思是，在printf()语句中先使用guests，再递增它。但是，表达式guests++ &lt; 10是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 printf()之前发生副作用（即，递增guests）。同时，使用后缀形式保证了guests在完成与10的比较后才进行递增。\n现在，考虑下面这条语句：\n1y=(4+x++)+(6+x++);表达式4+x++不是一个完整的表达式，所以C无法保证x在子表达式4+x++求值后立即递增x。这里，完整表达式是整个赋值表达式语句，分号标记了序列点。所以，C 保证程序在执行下一条语句之前递增x两次。C并未指明是在对子表达式求值以后递增x，还是对所有表达式求值后再递增x。因此，要尽量避免编写类似的语句。\n复合语句（块）复合语句（compound statement）是用花括号括起来的一条或多条语句，复合语句也称为块（block）。shoes2.c程序使用块让while语句包含多条语句。比较下面两个程序段：\n12345678910111213/* 程序段 1 */index　=　0;while(index++&lt;10)sam = 10 * index + 2;printf(\"sam　=　%d\\n\",　sam);/* 程序段 2 */index　=　0;while(index++&lt;10)&#123;    sam = 10 * index + 2;    printf(\"sam　=　%d\\n\",　sam);&#125;程序段1，while循环中只有一条赋值表达式语句。没有花括号，while语句从while这行运行至下一个分号。循环结束后，printf()函数只会被调用一次。\n程序段2，花括号确保两条语句都是while循环的一部分，每执行一次循环就调用一次printf()函数。根据while语句的结构，整个复合语句被视为一条语句（见图5.7）。\n\n提示 风格提示\n再看一下前面的两个while程序段，注意循环体中的缩进。缩进对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。\n程序段2中，块或复合语句放置花括号的位置是一种常见的风格。另一种常用的风格是：\n1234while(index++&lt;10)&#123;    sam = 10*index + 2;    printf(\"sam　=　%d　\\n\",　sam);&#125;这种风格突出了块附属于while循环，而前一种风格则强调语句形成一个块。对编译器而言，这两种风格完全相同。\n总而言之，使用缩进可以为读者指明程序的结构。\n总结 表达式和语句\n表达式：\n表达式由运算符和运算对象组成。最简单的表达式是不带运算符的一个常量或变量（如，22 或beebop）。更复杂的例子是55 + 22和vap = 2 * (vip + (vup = 4))。\n语句：\n到目前为止，读者接触到的语句可分为简单语句和复合语句。简单语句以一个分号结尾。如下所示：\n赋值表达式语句:　　　toes = 12;\n函数表达式语句:　　　printf(&quot;%d\\n&quot;, toes);\n空语句:　　　　　\n1　;　 /* 什么也不做 */复合语句（或块）由花括号括起来的一条或多条语句组成。如下面的while语句所示：\n123456while(years&lt;100)&#123;    wisdom=wisdom * 1.05;    printf(\"%d　%d\\n\",　years,　wisdom);    years=　years　+　1;&#125;类型转换通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 不会像 Pascal那样停在那里死掉，而是采用一套规则进行自动类型转换。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使用类型的情况下（许多UNIX系统都使用lint程序检查类型“冲突”。如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题）。最好先了解一些基本的类型转换规则。\n1.当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int，如有必要会被转换成unsigned int（如果short与int的大小相同，unsigned short就比int大。这种情况下，unsigned short会被转换成unsigned int）。在K&amp;R那时的C中，float会被自动转换成double（目前的C不是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为升级（promotion）。\n2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。\n3.类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。\n4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。\n5.当作为函数参数传递时，char和short被转换成int，float被转换成double。第9章将介绍，函数原型会覆盖自动升级。\n类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原因很简单：较低类型可能放不下整个数字。\n例如，一个8位的char类型变量储存整数101没问题，但是存不下22334。\n如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下。\n1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256。\n2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。\n3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。\n如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类型时，原来的浮点值会被截断。例如，23.12和23.99都会被截断为23，-23.5会被截断为-23。\n程序清单5.14演示了这些规则。\n程序清单5.14 convert.c程序\n1234567891011121314151617181920/* convert.c -- 自动类型转换 */#include　&lt;stdio.h&gt;int　main(void)&#123;    char ch;    int i;    float　fl;    fl=i=ch='C';　　　　　　　　　　　　　　　　　 /* 第9行　*/    printf(\"ch = %c, i = %d, fl = %2.2f\\n\", ch, i, fl);　/* 第10行 */    ch=ch+1;　　　　　　　　　　　　　　　　　　　　 /* 第11行 */    i=fl+2 * ch;　　　　　　　　　　　　　　　　　　 /* 第12行 */    fl=2.0 * ch + i;　　　　　　　　　　　　　　　　　 /* 第13行 */    printf(\"ch = %c, i = %d, fl = %2.2f\\n\", ch, i, fl);　/* 第14行 */    ch= 1107;　　　　　　　　　　　　　　　　　　　　　 /* 第15行 */    printf(\"Now ch = %c\\n\", ch);　　　　　　　　　　　　 /* 第16行 */    ch= 80.89;　　　　　　　　　　　　　　　　　　　　　/* 第17行 */    printf(\"Now ch = %c\\n\", ch);　　　　　　　　　　　　 /* 第18行 */    return　0;&#125;运行convert.c后输出如下：\n1234ch=C,　i=67,fl=67.00ch=D,　i=203,fl=339.00Now ch=SNow　ch=P在我们的系统中，char是8位，int是32位。程序的分析如下。\n第9行和第10行：字符&#39;C&#39;被作为1字节的ASCII值储存在ch中。整数变量i接受由&#39;C&#39;转换的整数，即按4字节储存67。最后，fl接受由67转换的浮点数67.00。\n第11行和第14行：字符变量&#39;C&#39;被转换成整数67，然后加1。计算结果是4字节整数68，被截断成1字节储存在ch中。根据%c转换说明打印时，68被解释成&#39;D&#39;的ASCII码。\n第12行和第14行：ch的值被转换成4字节的整数（68），然后2乘以ch。为了和fl相加，乘积整数（136）被转换成浮点数。计算结果（203.00f）被转换成int类型，并储存在i中。\n第13行和第14行：ch的值（’D’，或68）被转换成浮点数，然后2乘以ch。为了做加法，i的值（203）被转换为浮点类型。计算结果（339.00）被储存在fl中。\n第15行和第16行：演示了类型降级的示例。把ch设置为一个超出其类型范围的值，忽略额外的位后，最终ch的值是字符S的ASCII码。或者，更确切地说，ch的值是1107 % 256，即83。\n第17行和第18行：演示了另一个类型降级的示例。把ch设置为一个浮点数，发生截断后，ch的值是字符P的ASCII码。\n强制类型转换运算符通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是：\n1(type)用实际需要的类型（如，long）替换type即可。\n考虑下面两行代码，其中mice是int类型的变量。第2行包含两次int强制类型转换。\n12mice = 1.6 + 1.7;mice = (int)1.6 + (int)1.7;第1 行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配int 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。\n一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。\n总结 C的一些运算符\n下面是我们学过的一些运算符。\n赋值运算符：\n1=将其右侧的值赋给左侧的变量\n算术运算符：\n+　　　 将其左侧的值与右侧的值相加\n-　　　　将其左侧的值减去右侧的值\n-　　　　作为一元运算符，改变其右侧值的符号\n*　　　 将其左侧的值乘以右侧的值\n/　　　　将其左侧的值除以右侧的值，如果两数都是整数，计算结果将被截断\n%　　　　当其左侧的值除以右侧的值时，取其余数（只能应用于整数）\n++　　　 对其右侧的值加1（前缀模式），或对其左侧的值加1（后缀模式）\n--　　　 对其右侧的值减1（前缀模式），或对其左侧的值减1（后缀模式）\n其他运算符：\nsizeof　　　 获得其右侧运算对象的大小（以字节为单位），运算对象可以是一个被圆括号括起来的类型说明符，如sizeof(float)，或者是一个具体的变量名、数组名等，如sizeoffoo(类型名)\n强制类型转换运算符将其右侧的值转换成圆括号中指定的类型，如(float)9把整数9转换成浮点数9.0\n带参数的函数现在，相信读者已经熟悉了带参数的函数。要掌握函数，还要学习如何编写自己的函数（在此之前，读者可能要复习一下程序清单2.3中的butler()函数，该函数不带任何参数）。程序清单5.15中有一个pound()函数，打印指定数量的#号（该符号也叫作编号符号或井号）。该程序还演示了类型转换的应用。\n程序清单5.15 pound.c程序\n1234567891011121314151617181920/* pound.c -- 定义一个带一个参数的函数　*/#include　&lt;stdio.h&gt;void pound(int n);// ANSI函数原型声明int　main(void)&#123;    int times=5;    char ch='!';　　 // ASCII码是33    float　f=6.0f;    pound(times);　　　// int类型的参数    pound(ch);　　　　　// 和pound((int)ch);相同    pound(f);　　　　　 // 和pound((int)f);相同    return　0;&#125;void pound(int n)　　　// ANSI风格函数头&#123;　　　　　　　　　　　　 // 表明该函数接受一个int类型的参数    while(n--&gt;0)    printf(\"#\");    printf(\"\\n\");&#125;运行该程序后，输出如下：\n123############################################首先，看程序的函数头：\n1void pound(int n)如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的声明。参数名应遵循C语言的命名规则。\n声明参数就创建了被称为形式参数（formal argument或formal parameter，简称形参）的变量。该例中，形式参数是 int 类型的变量 n。像 pound(10)这样的函数调用会把 10 赋给 n。在该程序中，调用pound(times)就是把 times 的值（5）赋给 n。我们称函数调用传递的值为实际参数（actual argument或actual parameter），简称实参。所以，函数调用pound(10)把实际参数10传递给函数，然后该函数把10赋给形式参数（变量n）。也就是说，main()中的变量times的值被拷贝给pound()中的新变量n。\n注意 实参和形参\n形参为变量\n在英文中，argument和parameter经常可以互换使用，但是C99标准规定了：对于actual argument或actual parameter使用术语argument（译为实参）；对于formal argument或formal parameter使用术语parameter（译为形参）。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。因此，在程序清单5.15中，times是pound()的实参，n是pound()的形参。类似地，在函数调用pound(times + 4)中，表达式times + 4的值是该函数的实参。\n变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。如果在pound()中用times代替n，那么这个times与main()中的times不同。也就是说，程序中出现了两个同名的变量，但是程序可以区分它们。\n现在，我们来学习函数调用。第1 个函数调用是pound(times)，times的值5被赋给n。因此， printf()函数打印了5个井号和1个换行符。第2个函数调用是pound(ch)。这里，ch是char类型，被初始化为!字符，在ASCII中ch的数值是33。但是pound()函数的参数类型是int，与char不匹配。程序开头的函数原型在这里发挥了作用。原型（prototype）即是函数的声明，描述了函数的返回值和参数。pound()函数的原型说明了两点：\n该函数没有返回值（函数名前面有void关键字）；\n该函数有一个int类型的参数。\n该例中，函数原型告诉编译器pound()需要一个int类型的参数。相应地，当编译器执行到pound(ch)表达式时，会把参数ch自动转换成int类型。在我们的系统中，该参数从1字节的33变成4字节的33，所以现在33的类型满足函数的要求。与此类似，最后一次调用是pound(f)，使得float类型的变量被转换成合适的类型。\n在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指明了函数名和返回类型，没有指明参数类型。为了向下兼容，C现在仍然允许这样的形式：\n1void pound(); /* ANSI C乊前的函数声明 */如果用这条函数声明代替pound.c程序中的函数原型会怎样？第 1 次函数调用，pound(times)没问题，因为times是int类型。第2次函数调用，pound(ch)也没问题，因为即使缺少函数原型，C也会把char和short类型自动升级为int类型。第3次函数调用，pound(f)会失败，因为缺少函数原型，float 会被自动升级为 double，这没什么用。虽然程序仍然能运行，但是输出的内容不正确。在函数调用中显式使用强制类型转换，可以修复这个问题：\n1pound ((int)f); // 把f强制类型转换为正确的类型注意，如果f的值太大，超过了int类型表示的范围，这样做也不行。\n示例程序程序清单5.16演示了本章介绍的几个概念，这个程序对某些人很有用。程序看起来很长，但是所有的计算都在程序的后面几行中。我们尽量使用大量的注释，让程序看上去清晰明了。请通读该程序，稍后我们会分析几处要点。\n程序清单5.16 running.c程序\n1234567891011121314151617181920212223242526272829303132333435363738//　running.c　--　A　useful　program　for　runners#include　&lt;stdio.h&gt;const int S_PER_M=60;　　　　　　　 // 1分钟的秒数const int S_PER_H=3600;　　　　　　// 1小时的分钟数const double M_PER_K=0.62137;　　 // 1公里的英里数int　main(void)&#123;    double distk, distm;　 // 跑过的距离（分别以公里和英里为单位）    double rate;　　　　　　 // 平均速度（以英里/小时为单位）    int min, sec;　　　　　 // 跑步用时（以分钟和秒为单位）    int time;　　　　　　　　// 跑步用时（以秒为单位）    double mtime;　　　　　 // 跑1英里需要的时间，以秒为单位    int mmin, msec;　　　　 // 跑1英里需要的时间，以分钟和秒为单位    printf(\"This　program　converts　your　time　for　a　metric　race\\n\");    printf(\"to　a　time　for　running　a　mile　and　to　your　average\\n\");    printf(\"speed　in　miles　per　hour.\\n\");    printf(\"Please　enter,　in　kilometers,　the　distance　run.\\n\");    scanf(\"%lf\", &amp;distk);　　　　　　// %lf表示读取一个double类型的值    printf(\"Next　enter　the　time　in　minutes　and　seconds.\\n\");    printf(\"Begin　by　entering　the　minutes.\\n\");    scanf(\"%d\",　&amp;min);    printf(\"Now　enter　the　seconds.\\n\");    scanf(\"%d\",　&amp;sec);    time=S_PER_M * min+sec;　　 // 把时间转换成秒    distm=M_PER_K*distk;　　　　// 把公里转换成英里    rate=distm/time * S_PER_H;　// 英里/秒×秒/小时 = 英里/小时    mtime=(double)time / distm;　// 时间/距离 = 跑1英里所用的时间    mmin=(int)mtime / S_PER_M;　 // 求出分钟数    msec=(int)mtime % S_PER_M;　 // 求出剩余的秒数    printf(\"You　ran　%1.2f　km　(%1.2f　miles)　in　%d　min,　%d　sec.\\n\",    distk,　distm,　min,　sec);    printf(\"That　pace　corresponds　to　running　a　mile　in　%d　min,　\",    mmin);    printf(\"%d　sec.\\nYour　average　speed　was　%1.2f　mph.\\n\",　msec,    rate);    return　0;&#125;程序清单5.16使用了min_sec程序（程序清单5.9）中的方法把时间转换成分钟和秒，除此之外还使用了类型转换。为什么要进行类型转换？因为程序在秒转换成分钟的部分需要整型参数，但是在公里转换成英里的部分需要浮点运算。我们使用强制类型转换运算符进行了显式转换。\n实际上，我们曾经利用自动类型转换编写这个程序，即使用int类型的mtime来强制时间计算转换成整数形式。但是，在测试的11个系统中，这个版本的程序在1个系统上无法运行，这是由于编译器（版本比较老）没有遵循C规则。而使用强制类型转换就没有问题。对读者而言，强制类型转换强调了转换类型的意图，对编译器而言也是如此。\n下面是程序清单5.16的输出示例：\n12345678910111213This　program　converts　your　time　for　a　metric　raceto　a　time　for　running　a　mile　and　to　your　averagespeed　in　miles　per　hour.Please　enter,　in　kilometers,　the　distance　run.10.0Next　enter　the　time　in　minutes　and　seconds.Begin　by　entering　the　minutes.36Now　enter　the　seconds.23You　ran　10.00　km　(6.21　miles)　in　36　min,　23　sec.That　pace　corresponds　to　running　a　mile　in　5　min,　51　sec.Your average speed was 10.25 mph.关键概念C 通过运算符提供多种操作。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。每个 C表达式都有一个值。如果不了解运算符的优先级和结合律，写出的表达式可能不合法或者表达式的值与预期不符。这会影响你成为一名优秀的程序员。\n虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型。因此，C会进行自动类型转换。尽管如此，不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样，就不用担心出现不必要的自动类型转换。\n本章小结C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符。一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个运算对象的运算符（如负号和 sizeof）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符。\n表达式由运算符和运算对象组成。在C语言中，每个表达式都有一个值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺序。\n大部分语句都以分号结尾。最常用的语句是表达式语句。用花括号括起来的一条或多条语句构成了复合语句（或称为块）。while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句。\n在C语言中，许多类型转换都是自动进行的。当char和short类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为int类型；float类型在函数参数中时，会被升级为double类型。在K&amp;R C（不是ANSI C）下，表达式中的float也会被升级为double类型。当把一种类型的值赋给另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换成较小类型时（如，long转换成short，或 double 转换成 float），可能会丢失数据。根据本章介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型。\n定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。\n","plink":"https://dxsummer.gitee.io/posts/d0061c8b/"},{"title":"string.h中常用函数","date":"2020-05-30T07:08:03.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"updated":"2020-06-08T01:58:31.331Z","content":"strlen计算字符串长度\n1size_t strlen(const char *str)计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。\n函数实现：\n1234567int Strlen(const char *str)&#123;\tassert(str);\tint len = 0;\twhile ((*str++) != '\\0')len++;\treturn len;&#125;strcpy字符串复制\n1char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest。\n函数实现：\n1234567char *Strcpy(char *dst, const char *src)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile ((*dst++ = *src++) != '\\0');\treturn tmp;&#125;strncpy复制连续的n个字符\n1char *strncpy(char *dest, const char *src, size_t n)把 src 所指向的字符串复制到 dest，最多复制 n 个字符。\n函数实现：\n1234567891011121314151617181920char *Strncpy(char *dst, const char *src, int len)&#123;\tassert(dst&amp;&amp;src);\tchar *tmp = dst;\tint offset = 0;\tif (len &gt; strlen(src))\t&#123;\t\toffset = len - strlen(src);\t\tlen = strlen(src);\t&#125;\twhile (len--)\t&#123;\t\t*dst++ = *src++;\t&#125;\twhile (offset--)\t&#123;\t\t*dst++ = '\\0';\t&#125;\treturn tmp;&#125;strcat把一个字符串连接到另一个字符串后面\n1char *strcat(char *dest, const char *src)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。\n函数实现：\n123456789char *Strcat(char *dst, const char* src)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile (*dst++);\tdst--;\twhile (*dst++ = *src++);\treturn tmp;&#125;strncat把连续的n个字符连接到另一个字符串后面\n1char *strncat(char *dest, const char *src, size_t n)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。\n函数实现：\n12345678910111213char *Strncat(char *dst, const char* src, int len)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile (*dst++);\tdst--;\twhile (len--)\t&#123;\t\t*dst++ = *src++;\t&#125;\t*dst = '\\0';\treturn tmp;&#125;示例：\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123;    char str0[20] = \"Test:\";    char str1[20] = \"Welcome9999\";    char str2[20] = \" To \";    char str3[20] = \"0123Beijing55\";    char tmp[100];    strcpy(tmp, str0);    puts(tmp);      //Test:    strncpy(tmp, str1, 7);  //取st1前7个字符    puts(tmp);      //Welcome    strcat(tmp, str2);      //连接str2    puts(tmp);    strncat(tmp, str3 + 4, 7);  //取str3+4之后的7个字符    puts(tmp);    return 0;&#125;输出结果：\n\nstrchr查找某字符在字符串中首次出现的位置指针，如果不存在则返回NULL\n1char *strchr(const char *str, int c)在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。\n函数实现：\n12345678char* My_strchr(char *s, char c)&#123;    while(*s != '\\0' &amp;&amp; *s != c)    &#123;        ++s;    &#125;    return *s==c ? s : NULL;&#125;示例：\n1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;    char string[20] = \"This is a string\";    char *ptr1, *ptr2;    char c1 = 'r', c2 = 'b';    ptr1 = strchr(string, c1);    ptr2 = strchr(string, c2);    if(ptr1)        printf(\"字符1:%c 的位置是: %s \\n\",c1,ptr1);    else        printf(\"字符1:%c 未找到 \\n\", c1);    if(ptr2)        printf(\"字符2:%c 的位置是: %s \\n\",c2,ptr2);    else        printf(\"字符2:%c 未找到 \\n\", c2);    return 0;&#125;输出结果：\n\nstrcmp字符串比较\n1int strcmp(const char *str1, const char *str2)把 str1 所指向的字符串和 str2 所指向的字符串进行比较。\n设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。\n函数实现：\n123456789101112131415161718int Strcmp(char const *s1, char const *s2)&#123;\tassert(s1&amp;&amp;s2);\twhile (*s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\t&#123;\t\ts1++;\t\ts2++;\t&#125;\tif (*s1 == *s2)\t&#123;\t\treturn 0;\t&#125;\telse if (*s1 &gt; *s2)\t&#123;\t\treturn 1;\t&#125;\treturn -1;&#125;示例：\n123456789101112131415161718#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;    char str1[20] = \"abc\";    char str2[20] = \"abc\";    char str3[20] = \"bbc\";    int r1, r2, r3;    r1 = strcmp(str1, str2);    r2 = strcmp(str1, str3);    r3 = strcmp(str3, str1);    printf(\"r1 = %d, r2 = %d, r3 = %d \\n\", r1, r2, r3);    return 0;&#125;输出结果：\n\nstrstr字符串查找\n1char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。\n函数实现：\n12345678910111213141516171819char *Strstr(char const *s1, char const *s2)&#123;\tassert(s1&amp;&amp;s2);\tconst char *ps1, *ps2;\tps1 = s1;\tps2 = s2;\twhile (*ps1)\t&#123;\t\tconst char *tmp = ps1;\t\twhile (*tmp++ == *ps2++);\t\tif (*ps2 == '\\0')\t\t&#123;\t\t\treturn (char*)ps1;\t\t&#125;\t\tps2 = s2;\t\tps1++;\t&#125;\treturn NULL;&#125;strncmp1int strncmp(const char *str1, const char *str2, size_t n)把 str1 和 str2 进行比较，最多比较前 n 个字节。\n函数实现：\n12345678910int Strncmp(char const *s1, char const *s2, int len)&#123;\tassert(s1&amp;&amp;s2);\twhile (len-- &amp;&amp; *s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\t&#123;\t\ts1++;\t\ts2++;\t&#125;\treturn *s1 - *s2;&#125;memcpy内存复制\n1void *memcpy(void *dest, const void *src, size_t n)从 src 复制 n 个字符到 dest。\n函数实现\n1234567891011void *Memcpy(char *dst, char const *src, int len)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\tconst char *s = src;\twhile (len--)\t&#123;\t\t*dst++ = *src;\t&#125;\treturn tmp;&#125;","plink":"https://dxsummer.gitee.io/posts/52078792/"},{"title":"模拟电子技术基础笔记","date":"2020-05-28T10:29:09.000Z","date_formatted":{"ll":"2020年5月28日","L":"2020/05/28","MM-DD":"05-28"},"updated":"2020-06-08T01:55:42.762Z","content":"半导体二极管半导体的基本知识导体：自然界中很容易导电的物质称为导体，金属一般都是导体。\n\n绝缘体：有的物质几乎不导电，称为绝缘体，如橡皮、陶瓷、塑料和石英。\n\n半导体：另有一类物质的导电特性处于导体和绝缘体之间，称为半导体，如锗、硅、砷化镓和一些硫化物、氧化物等。\n当受外界热和光的作用时，它的导电能力明显变化。\n往纯净的半导体中掺入某些杂质，会使它的导电能力明显改变。\n\n本征半导体：完全纯净的、结构完整的半导体晶体。\n\n在常温下，由于热激发，使一些价电子获得足够的能量而脱离共价键的束缚，成为自由电子，同时共价键上留下一个空位，称为空穴。\n\n载流子可以运动的带电粒子\n\n\n本征半导体中电流\n自由电子移动产生的电流\n空穴移动产生的电流\n\n本征半导体的导电能力取决于载流子的浓度。温度越高，载流子的浓度越高。因此本征半导体的导电能力越强，温度是影响半导体性能的一个重要的外部因素，这是半导体的一大特点。\n\n杂质半导体N 型半导体：自由电子浓度大大增加的杂质半导体，也称为（电子半导体）。\n在硅或锗晶体中掺入少量的五价元素磷（或锑），晶体点阵中的某些半导体原子被杂质取代，磷原子的最外层有五个价电子，其中四个与相邻的半导体原子形成共价键，必定多出一个电子，这个电子几乎不受束缚，很容易被激发而成为自由电子，这样磷原子就成了不能移动的带正电的离子。每个磷原子给出一个电子，称为施主原子。\n由施主原子提供的电子，浓度与施主原子相同。\n本征半导体中成对产生的电子和空穴。\n掺杂浓度远大于本征半导体中载流子浓度，所以，自由电子浓度远大于空穴浓度。\n\n自由电子称为多数载流子（多子），空穴称为少数载流子（少子）\n\n\nP 型半导体：空穴浓度大大增加的杂质半导体，也称为（空穴半导体）。\n​    \nP 型半导体中空穴是多子，电子是少子\n\n杂质半导体的示意表示法PN结及半导体二极管PN 结的形成在同一片半导体基片上，分别制造P 型半导体和N 型半导体，经过载流子的扩散，在它们的交界面处就形成了PN 结。\n所以扩散和漂移这一对相反的运动最终达到平衡，相当于两个区之间没有电荷运动，空间电荷区的厚度固定不变。\n空间电荷区中没有载流子。\n空间电荷区中内电场阻碍P中的空穴、N区 中的电子（都是多子）向对方运动（扩散运动）。\nP 区中的电子和 N区中的空穴（都是少子），数量有限，因此由它们形成的电流很小。\nPN结的单向导电性PN 结加上正向电压、正向偏置的意思都是： P 区加正、N 区加负电压。\nPN 结加上反向电压、反向偏置的意思都是： P区加负、N 区加正电压。\n半导体二极管最大整流电流 IOM\n二极管长期使用时，允许流过二极管的最大正向平均电流。\n\n反向击穿电压UBR\n二极管反向击穿时的电压值。击穿时反向电流剧增，二极管的单向导电性被破坏，甚至过热而烧坏。手册上给出的最高反向工作电压UWRM一般是UBR的一半。\n\n反向电流 IR\n指二极管加反向峰值工作电压时的反向电流。反向电流大，说明管子的单向导电性差，因此反向电流越小越好。反向电流受温度的影响，温度越高反向电流越大。硅管的反向电流较小，锗管的反向电流要比硅管大几十到几百倍。\n\n","plink":"https://dxsummer.gitee.io/posts/dbbc2d17/"},{"title":"note和小tag标签","date":"2020-05-26T01:55:31.000Z","date_formatted":{"ll":"2020年5月26日","L":"2020/05/26","MM-DD":"05-26"},"updated":"2020-06-08T01:54:16.062Z","content":"/* note语法示例 */\n绿色\n红色\n黄色\n灰色\n蓝色12345&lt;p class&#x3D;&#39;div-border green&#39;&gt;绿色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border red&#39;&gt;红色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border yellow&#39;&gt;黄色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border grey&#39;&gt;灰色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border blue&#39;&gt;蓝色&lt;&#x2F;p&gt;/* 小tag标签语法示例 */\n红色小标签绿色小标签蓝色小标签黄色小标签灰色小标签\n12345&lt;span class&#x3D;&quot;inline-tag red&quot;&gt;红色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag green&quot;&gt;绿色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag blue&quot;&gt;蓝色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag yellow&quot;&gt;黄色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag grey&quot;&gt;灰色小标签&lt;&#x2F;span&gt;绿色1&lt;p class&#x3D;&#39;div-border green left right&#39;&gt;绿色&lt;&#x2F;p&gt;","plink":"https://dxsummer.gitee.io/posts/5d6d7b2d/"},{"title":"添加全局吸底APlayer","date":"2020-05-21T09:47:34.000Z","date_formatted":{"ll":"2020年5月21日","L":"2020/05/21","MM-DD":"05-21"},"updated":"2020-06-08T01:52:16.996Z","content":"如果你使用了butterfly做hexo主题可以向界面加入一些装饰,但butterfly使用了pug模板,所以与其他主题可能有些区别\n\nlive2d看板娘,能聊天,能玩耍,能换装等等这得感谢大神stevenjoezhang为原本只能显示一个模型的live2d插件添加了许多功能如果对位置什么的没有很大的要求的话,直接打开themes\\Butterfly\\layout\\includes\\head.pug结尾加入一行\n1script(src&#x3D;&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget&#x2F;autoload.js&#39;)就行了\n当然你会发现直接这样加的话,阅读Page时,打开TOC的话,看板娘会被遮住所以建议调整看板娘位置前往live2d-widget 下载\n解压后将autoload.js第二行的位置改成你挂载在服务器上的autoload.js所在文件夹的绝对路径比如autoload.js在科大ftp的/public_html/js/live2d-widget/目录下,这里就要改成http://home.ustc.edu.cn/~username/js/live2d-widget/ (科大ftp的根目录是/public_html/)然后修改waifu.css里面的 #waifu下的 left: 0;将这一行改成right: 70px;\n123456789#waifu &#123;\tbottom: -1000px;\tleft: 0;           &#x2F;&#x2F;这一行改成right: 70px;\tline-height: 0;\tposition: fixed;\ttransform: translateY(3px);\ttransition: transform .3s ease-in-out, bottom 3s ease-in-out;\tz-index: 1;&#125;将head.pug添加的src的autoload.js的路径改成你上传的路径就行了\n\n全局吸底APlayer打开themes\\Butterfly\\layout\\includes\\head.pug结尾加一句\n1include .&#x2F;third-party&#x2F;aplayer.pug然后在themes\\Butterfly\\layout\\includes\\third-party\\里面新建一个文件叫 aplayer.pug ,内容如下\n123456if theme.aplayer &amp;&amp; theme.aplayer.enable\t.aplayer(data-id&#x3D;theme.aplayer.id data-server&#x3D;theme.aplayer.server data-type&#x3D;theme.aplayer.type data-fixed&#x3D;theme.aplayer.fixed data-mini&#x3D;theme.aplayer.mini data-listFolded&#x3D;theme.aplayer.listFolded data-order&#x3D;theme.aplayer.order data-preload&#x3D;theme.aplayer.preload)\teach item in theme.aplayer.css\t\tlink(rel&#x3D;&#39;stylesheet&#39;, href&#x3D;item)\teach item in theme.aplayer.js\t\tscript(src&#x3D;item)然后打开butterfly.yml(如果你没有启用的话,就打开themes\\Butterfly_config.yml) 加入以下内容\n1234567891011121314aplayer:  enable: true  js:    - https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;aplayer&#x2F;1.10.1&#x2F;APlayer.min.js    - https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;meting@1.2.0&#x2F;dist&#x2F;Meting.min.js  css:    - https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;aplayer&#x2F;1.10.1&#x2F;APlayer.min.css  id: 2661264578  server: netease   type: playlist  fixed: &#39;true&#39;  order: random  preload: none  listFolded: &#39;false&#39;然后重新生成就可以看到 aplayer了,这里的id是我的网易云歌单号,可以修改成别的.但是浏览Page时会发现 aplayer会和 TOC(怎么又是它) 的切换按钮重合打开themes\\Butterfly\\source\\css\\_global\\index.styl修改第61行\n123456789#toggle-sidebar  position: fixed  bottom: $sidebar-icon-top           &#x2F;&#x2F;这里改成bottom: 70px  left: $sidebar-icon-left  z-index: 100  font-size: $sidebar-icon-size  &#x2F;&#x2F; opacity: 0  cursor: pointer  transition: all .2s\n","plink":"https://dxsummer.gitee.io/posts/ae7c64e9/"},{"title":"vscode下级文件夹与上级文件夹并列，文件夹折叠问题解决","date":"2020-05-19T10:16:02.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2020-06-08T01:56:37.672Z","content":"今天在创建文件夹的时候出现了创建的下级文件夹和上级文件夹并列，紧凑排列的情况，这里在最新版本的vs code中解决的途径如下：\n\n\n解决办法如下：\n\n点击上方文件，之后选择首选项，再进入设置；\n在用户中选择功能菜单栏下的资源管理器，在资源管理器中找到Compact Folders,将对号勾掉即可；\n\n\n这是改完后的效果，也是我们习惯的效果。\n\n\n","plink":"https://dxsummer.gitee.io/posts/98214d27/"},{"title":"GO语言环境搭建","date":"2020-05-19T07:18:47.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2020-06-08T01:53:48.832Z","content":"注意：\nGo语言1.14版本之后推荐使用`go modules`管理以来，也不再需要把代码写在GOPATH目录下了下载\n下载地址\n\nGo官网下载地址：https://golang.org/dl/\n\nGo官方镜像站（推荐）：https://golang.google.cn/dl/\n\n\n版本的选择\n\nWindows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。\n安装\nWindows安装\n\n此安装实例以 64位Win10系统安装 Go1.14.1可执行文件版本为例。将上一步选好的安装包下载到本地。\n\n双击下载好的文件，然后按照下图的步骤安装即可。\n\n\nLinux下安装\n\n如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。\n我们在版本选择页面选择并下载好go1.14.1.linux-amd64.tar.gz文件：\n1wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.14.1.linux-amd64.tar.gz将下载好的文件解压到/usr/local目录下：\n1tar -zxvf go1.14.1.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local  # 解压如果提示没有权限，加上sudo以root用户的身份再运行。执行完就可以在/usr/local/下看到go目录了。\n配置环境变量： Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。\n12export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goexport PATH&#x3D;$PATH:$GOROOT&#x2F;bin修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查：\n12~ go versiongo version go1.14.1 linux&#x2F;amd64\nMac下安装\n\n下载可执行文件版，直接点击下一步安装即可，默认会将go安装到/usr/local/go目录下。\n检查上一步安装过程执行完毕后，可以打开终端窗口，输入go version命令，查看安装的Go版本。\n\n配置GOROOT和GOPATHGOROOT和GOPATH都是环境变量，其中GOROOT是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为GOPATH设置一个默认目录，参见下表。\nGOPATH在不同操作系统平台上的默认值\n\n平台GOPATH默认值举例\n\nWindows%USERPROFILE%/goC:\\Users\\用户名\\go\n\nUnix$HOME/go/home/用户名/go\n可以通过以下方法查看默认的GOPATH目录：\n\n我们只需要记住默认的GOPATH路径在哪里就可以了，并且默认情况下 GOROOT下的bin目录及GOPATH下的bin目录都已经添加到环境变量中了，我们也不需要额外配置了。\n\nGOPROXY\n\nGo1.14版本之后，都推荐使用go mod模式来管理依赖环境了，也不再强制我们把代码必须写在GOPATH下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）\n设置GOPATH路径（GOPATH路径是我们的工作区）\n1go env -w GOPATH&#x3D;我们自己的工作区路径例如我的就设为 /Users/naonao/go\n什么都别管，先打开GoMOD，再配置代理\n在这里感谢「七牛云」为我们中国区的Golang开发者提供的代理服务\n12$ go env -w GO111MODULE&#x3D;on$ go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct做到这2点后，我们现在就可以打开我们的VsCode（再次感谢七牛云，从此以后我们再也不用到Github以及Golang.org上clone到本地进行install了）\n查看GO相关的环境变量1go envGo项目结构在进行Go语言开发的时候，我们的代码总是会保存在$GOPATH/src目录下。在工程经过go build、go install或go get等指令后，会将下载的第三方包源代码文件放在$GOPATH/src目录下， 产生的二进制可执行文件放在 $GOPATH/bin目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。\n如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需版本控制。\n适合个人开发者我们知道源代码都是存放在GOPATH的src目录下，那我们可以按照下图来组织我们的代码。\n\n目前流行的项目结构Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用顶级域名来作为包名的前缀，这样就不担心项目名冲突的问题了。\n因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。\n\n举个例子：张三和李四都有一个名叫studygo的项目，那么这两个包的路径就会是：\n1import &quot;github.com&#x2F;zhangsan&#x2F;studygo&quot;和\n1import &quot;github.com&#x2F;lisi&#x2F;studygo&quot;以后我们从github上下载别人包的时候，如：\n1go get github.com&#x2F;jmoiron&#x2F;sqlx那么，这个包会下载到我们本地GOPATH目录下的src/github.com/jmoiron/sqlx。\n适合企业开发场景\nGo开发编辑器Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用VS Code和Goland。 VS Code是微软开源的编辑器，而Goland是jetbrains出品的付费IDE。\n我们这里使用VS Code 加插件做为go语言的开发工具。\nVS Code介绍VS Code全称Visual Studio Code，是微软公司开源的一款免费现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。\n虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。\n下载与安装VS Code官方下载地址：https://code.visualstudio.com/Download\n三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。\n\n双击下载好的安装文件，双击安装即可。\n配置安装中文简体插件点击左侧菜单栏最后一项管理扩展，在搜索框中输入chinese ，选中结果列表第一项，点击install安装。\n安装完毕后右下角会提示重启VS Code，重启之后你的VS Code就显示中文啦！\n\nVSCode主界面介绍：\n\n安装go扩展现在我们要为我们的VS Code编辑器安装Go扩展插件，让它支持Go语言开发。\n\n变更编辑器主题依次点击设置-&gt;颜色主题，\n\n会弹出如下窗口：\n\n可以根据自己的喜好选择相应的主题。\n安装Go语言开发工具包在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。\n在此之前请先设置GOPROXY，打开终端执行以下命令：\n1go env -w GOPROXY=https://goproxy.cn,directWindows平台按下Ctrl+Shift+P，Mac平台按Command+Shift+P，这个时候VS Code界面会弹出一个输入框，如下图：\n\n我们在这个输入框中输入&gt;go:install，下面会自动搜索相关命令，我们选择Go:Install/Update Tools这个命令，按下图选中并会回车执行该命令（或者使用鼠标点击该命令）\n\n在弹出的窗口选中所有，并点击“确定”按钮，进行安装。\n\n然后会弹出如下窗口，开始安装工具：\n\n喝口水，等待所有工具都安装成功，如下图所示:\n\n配置VSCode开启自动保存按下图依次点击 文件-&gt;首选项-&gt;设置，\n打开设置页面就能看到自动保存相关配置如下图，可以根据自己的喜好选择自动保存的方式：\n配置代码片段快捷键还是按Ctrl/Command+Shift+P,按下图输入&gt;snippets，选择命令并执行：\n然后在弹出的窗口点击选择go选项：\n然后弹出如下页面：\n大家可以简单看下上面的注释，介绍了主要用法：\n12345“这里放个名字”:&#123;    &quot;prefix&quot;: &quot;这个是快捷键&quot;,    &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,    &quot;description&quot;: &quot;这里放提示信息的描述&quot;&#125;其中$0表示最终光标提留的位置。 举个例子，我这里创建了两个快捷方式，一个是输入pln就会在编辑器中插入fmt.Println()代码；输入plf，就会插入fmt.Printf(&quot;&quot;)代码。\n123456789101112&#123;\t&quot;println&quot;:&#123;\t\t&quot;prefix&quot;: &quot;pln&quot;,\t\t&quot;body&quot;:&quot;fmt.Println($0)&quot;,\t\t&quot;description&quot;: &quot;println&quot;\t&#125;,\t&quot;printf&quot;:&#123;\t\t&quot;prefix&quot;: &quot;plf&quot;,\t\t&quot;body&quot;: &quot;fmt.Printf(\\&quot;$0\\&quot;)&quot;,\t\t&quot;description&quot;: &quot;printf&quot;\t&#125;&#125;把上面的代码，按下图方式粘贴到配置文件中，保存并关闭配置文件即可。\n添加如上配置后，保存。 我们打开一个go文件，测试一下效果：\n文章源于[Q1mi](https://www.liwenzhou.com/posts/Go/00_go_in_vscode/)","plink":"https://dxsummer.gitee.io/posts/c876fc85/"},{"title":"GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床","date":"2020-05-12T08:29:03.000Z","date_formatted":{"ll":"2020年5月12日","L":"2020/05/12","MM-DD":"05-12"},"updated":"2020-06-08T01:53:13.707Z","content":"GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床前言\n为什么要使用图床呢？\n\n因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 Ctrl + C 的方式一键搞定，为了解决这个问题，使用 MarkDown + 图床 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。所谓图床，就是将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。MarkDown 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。作为程序员，你会发现，现在很多论坛和社区都开始支持使用 MarkDown，如果你没使用图床的情况下，你分享同一篇文章，你要在不同的平台，各自重新编辑排版一遍和上传图片一次。有了图床，情况就不一样了，Ctrl+C 的方式就搞定了，根本不用再 Check 文章内容一遍。\n\n图床的选择？\n\n微博图床：以前用的人比较多，从 2019 年 4 月开始开启了防盗链，凉凉\nSM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧\n其他小众图床：随时有挂掉的风险\nImgur 等国外图床：国内访问速度太慢，随时有被墙的风险\n大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）\nGitHub 图床：免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了）\n使用流程新建 GitHub 仓库\n生成一个 Token\n配置 PicGo 并使用 jsdelivr 作为 CDN 加速\n使用 Imagine 进行图片压缩\n上传图片到 PicGo 并使用图床\n新建 GitHub 仓库登录/注册 GitHub\n新建一个仓库，填写好仓库名\n仓库描述\n将权限设置成 public\n根据需求选择是否为仓库初始化一个 README.md 描述文件\n\n新建 GitHub 仓库\n生成一个 Token点击用户头像 -&gt; 选择 Settings\n\nSettings\n点击 Developer settings\n\nDeveloper settings\n点击 Personal access tokens\n\nPersonal access tokens\n点击 Generate new token\n\nGenerate new token\n填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token\n\n填写 Token 描述\n获取 Token 密钥\n\n注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页\n\n\n获取 Token 密钥\n配置 PicGo 并使用 jsdelivr 作为 CDN 加速前往下载 PicGo（点击下载），安装好后开始配置图床\n设定仓库名：按照 用户名/图床仓库名 的格式填写\n设定分支名：master\n设定 Token：粘贴之前生成的 Token\n指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中\n设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名\n\n配置 PicGo\nText\n123Q：什么是 jsdelivr ?A：jsDelivr 为开发者提供免费公共 CDN 加速服务使用 Imagine 进行图片压缩通常情况下，图片大小都是超过 200KB 的，所以网页加载的时候会特别慢，一般我们会对图片进行压缩，这里我推荐 Imagine（点击下载） 支持全平台。\n\n使用 Imagine 进行图片压缩\n\nImagine 采用的是有损压缩，介意的可以忽略这一步\n\n顺便推荐一个无损压缩的网站：https://tinypng.com/\n上传图片到 PicGo 并使用图床配置好 PicGo 后，我们就可以进行高效创作了，将压缩后的图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的\n\n上传图片到 PicGo 并使用图床\n此外 PicGo 还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo 还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！\n文章源于\n[Sitoi](https://sitoi.cn/posts/39161.html)","plink":"https://dxsummer.gitee.io/posts/b6c34a37/"},{"title":"Step 2 了解英语中关键的关键—单词","date":"2020-05-11T09:36:38.000Z","date_formatted":{"ll":"2020年5月11日","L":"2020/05/11","MM-DD":"05-11"},"updated":"2020-06-28T03:26:38.959Z","content":"Day03形容词（含比较级&amp;最高级）形容词的用法\n形容词主要用来修饰名词或不定代词（some，no，every，all，each，both，much，many，（a）little，（a）few，other（s），another），表示人或事物的性质、状态和特征的词。形容词在句中作定语、补语及修饰从句等。例如：\nShe is a pretty girl.（她是一个漂亮的女孩。）He looks very happy.（他看起来很开心。）\n使用时机及用法定语：一般放在所修饰词的前面。\n\n动词补语：放在系动词后面。\n\n宾语补语：修饰句中宾语。\n\n副词从句：成为形容词短语从句，修饰主句。\n\n使用规则及要点修饰不定代词时置于其后：当形容词修饰由some-, any-, no-, every-这些字首所构成的不定代词时，形容词要放在这些不定代词之后。例如：\n\n There must be something wrong with my computer.（我的电脑出了点问题。）\n两个以上的形容词的顺序：\n当一个句子中，有两个以上的形容词用来修饰同一个名词时，其先后顺序为：（冠词＋数量＋性质＋大小＋形状＋新旧＋颜色＋国籍）＋名词。可背诵以下的例句辅助记忆：\n I have a beautiful little new white Chinese wooden table.（我有一张新的白色中式木桌，漂亮且小巧。）\n\n“The＋形容词”用来表示特定的人／物：\n用“The＋形容词”可用来表示特定的人或物，例如：the rich富人、the young年轻人、the old老人等。后面须接复数动词。\nWe should look after the old and love the young.（我们应该尊老爱幼。）\n\n\n两个以上形容词当定语置于最后：\n用and或or连接起来的两个形容词做定语时，一般把它们放在被修饰的名词后面，以进一步产生修饰作用。\nYou can take any dress, pink or blue.（你可以拿这两件裙子中的任何一条，粉红色或蓝色的都行。）\n\n\n修饰长宽高深及年龄置于名词之后：\n表示长、宽、高、深及年龄的形容词，应放在相应的名词之后。\nThe river is about two hundred meters long.（这条河大约两百米长。）\n\n\n形容词的比较级、最高级\n规则变化单音节词在字尾加-er / -est：单音节形容词在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：clean→cleaner→cleanest。\n\n单音节词以–e结尾在字尾加-r / -st：以–e结尾的单音节形容词，转变为比较级和最高级时，规则是在字尾加–r和–st。例如：wide→wider→widest。\n\n双音节（音节中含有两个元音音素，称为双音节单词；如：hello,alone,etc）词以-y, -er, -ow, -ble结尾在字尾加-er / -est：少数以-y, -er, -ow, -ble结尾的双音节形容词，在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：slow→slower→slowest。\n\n以-y结尾的形容词，去掉字尾-y加-ier / -iest：以–y结尾，但–y前是辅音字母的形容词的比较级和最高级是把-y去掉，加上–ier和-iest。例如：lonely→lonelier→loneliest。\n\n形容词字尾“辅元辅”重复字尾再加–er：当形容词或其字尾出现“辅音＋元音＋辅音”现象，也就是最后三个字母和音标的排列是“辅元辅”，在转变为比较级和最高级时，规则是要重复字尾，再加-er。例如：big→bigger→biggest。\n\n三音节词和多音节词，以more / most修饰：三个音节以上的形容词，则在其前加more / most，以形成比较级及最高级。另外注意，more / most后的形容词必须是原级。例如：beautiful→more beautiful→most beautiful。\n\n不规则变化\n比较级与最高级用法两个人或两种事物比较时，用比较级。\n 句型为“比较级＋than…”例如： Bob is taller than Jack.（鲍勃比杰克高。）\n\n三个或三个以上的人或事物比较，其中有一个在某一方面超过其他几个时，用最高级。\n 句型为“the＋最高级＋…in / of…”。例如： Bob is the tallest in his class.（鲍勃是他班上最高的。）\n\n表示双方程度相等时，用“…as＋形容词原级＋as…”句型，可译为“…和…一样”；表示双方程度不相等时，用“…not so / as＋形容词原级＋as…”句型，可译为“…和…不一样”或“…不如…”，例如：\n This box is as big as mine.（这个盒子和我的一样大。） He runs not so fast as me.（他跑得没我快。）\n\n表示“越来越……”可用“The＋形容词比较级……, the＋形容词比较级”。\n 例如：The more you study, the more you know.（你学习的越多，你就知道的越多。）\n\n表示程度越来越强，用“比较级＋and＋比较级”句型，可译为“越来越……”。例如：\n It is getting hotter and hotter.（天气变得越来越热。）\n\nmost同形容词连用，前面不加the，可表示极……，很……，非常……，十分……。例如：\n It’s most dangerous to be here.（在这儿实在很危险。）\n\n比较级前可以加副词修饰，以加强程度。例如：much, far, still, even, a lot, a little, a bit等等。例如：\n The rope is much longer than that one.（这条绳比那条绳长很多。）\n\n两者之间选择“哪一个更……”时，用句型“Which / Who＋is＋比较级，…or…?”，例如：\n Which is bigger, the sun or the moon?（太阳和月亮，哪一个更大？）\n\n表示“最……之一”时，用“one of＋the＋最高级”。例如：\n The light bulb is one of the most helpful inventions.（电灯泡是最有用的发明之一。）\n\n语法观念例句示范01．The sunset was a beautiful sight.日落是一种美丽的景象。\n02．He is the happiest man on earth.他是地球上最快乐的人。\n03．The film is boring.那个电影很枯燥。\n04．It’s an utter mystery.这完全是个迷。\n05．She looked embarrassed.她好像很尴尬。\n06．He is one of the greatest composers in the word.他是世界上最伟大的作曲家之一。\n07．It’s foolish of her to go alone.她单独出去太傻了。\n08．The black one is the more expensive of the two boxes.黑色的是这两个盒子当中最贵的。\n09．The more careful you are, the fewer mistakes you will make.你越仔细，犯的错误越少。\n10．Mountain climbing is one of the most dangerous sports.爬山是最危险的运动之一。\n语法观念辨析练习请选出正确的选项。\n01．The writer died before finishing his________book.\nA lateB laterC lastD latest.\n02．She got________that she couldn’t dance anymore.\nA very angrilyB too angrilyC too angryD so angry\n03．The sweater is very beautiful, but it’s________small.\nA too muchB much tooC manyD more\n04．She looks very________. I think she needs rest.\nA tiredB hardC wellD hardly.\n05．Lots of visitors come to visit Hamburg because she’s________city.\nA very a beautifulB quite a beautifulC so a beautifulD a quite beautiful\n06．- Which is________, the sun, the moon or the earth? —— Of course the moon.\nA smallB smallerC smallestD the smallest\n07．She isn’t so________at math as you are.\nA wellB goodC betterD best\n08．I have________to do today.\nA anything importantB something importantC important nothingD important something\n09．Mary writes________of the three.\nA betterB bestC goodD well\n10．My________brother is________than I.\nA elder, three years olderB older, olderC older, three years elderD elder, elder\n正确答案及题目译文：\n副词（含比较级&amp;最高级）副词主要用来修饰动词、形容词、其他副词或全句，用来说明时间、地点、程度、方式等概念的词。副词在句中主要作状语。副词可以分为时间副词、地点副词、方式副词、程度副词、频率副词等。\nShe speaks English quite well.（她英语说得相当好。）\n\nThey live frugally.（她们生活很节俭。）\n\n使用时机及用法\n使用时机及用法置于形容词前方，修饰形容词用。例如：\n\n置于动词前方，修饰动词用。例如：\n\n置于副词前方，修饰副词用。例如：\n\n置于介词短语前方，修饰介词短语用。例如：\n\n使用enough修饰形容词或其他副词时，置于被修饰词后方。例如：\n\n频率副词，例如：usually, always, often, never等，一般放在行为动词前，或是使役动词、助动词或be动词之后。例如：\n\n句中同时出现时间、地点的副词时，先地点再时间。\n\n某些副词形式相似，但要注意，两种形式的字义不同。例如：\n\nclose接近地←→closely仔细地，密切地\nwide广阔地，充分地←→widely广泛地\n副词的比较级、最高级副词和形容词一样有比较级和最高级。\n同级副词的比较→as＋原级＋as：\n\n比较级副词的比较→副词比较级＋than：\n\n最高级副词的比较→同形容词用法但不加the：\n\n副词的比较级与最高级规则变化：\n 同形容词，单音节词在字尾加-er / -est、以–y结尾的去掉字尾-y加-ier / -iest等。\n （速度）快地：fast→faster→fastest （时间）快地：soon→sooner→soonest （声音）大地：loud→louder→loudest\n\n副词的比较级与最高级常见之不规则变化：\n （程度）良好地：well→better→best （程度）不好地：badly→worse→worst （距离）远地：far→farther→farthest （时间）迟地：late→later→last （数量、程度）多地：much→more→most （数量、程度）少地：little→less→least （程度）糟糕地：poorly→worse→worst （程度）邪恶地：ill→worse→worst\n\n语法观念例句示范01．He knew London very well.他对伦敦很熟悉。\n02．You need to form the habit of reading carefully.你需要养成仔细阅读的习惯。\n03．Please listen to me carefully.请认真听我说。\n04．Her pronunciation is very good.她的发音很棒。\n05．He didn’t study hard enough.他学习不够刻苦。\n06．Tom looked at me suspiciously.汤姆怀疑地看着我。\n07．I sometimes stay up all night.我有时会熬夜。\n语法观念辨析练习请填入正确时态的副词。\n01．My purse was stolen on the bus yesterday.____(Fortunate), there was no money in it.\n02．He put on his coat and went out________(quick).\n03．It’s snowing hard. You must drive________(careful).\n04．I used to smoke________(heavy) but I give it up three years ago.\n05．What have you been doing________(late)?\n06．He thinks________(high) of my opinion.\n07．He is________(strong) enough to carry the heavy box.\n08．These oranges taste________(good).\n正确答案及题目译文：\n动词短语（不可分离vs．可分离）\n所谓的动词短语，是指由动词加上介词／副词所组成的短语。其短语意义有时与原先单独动词的字义不同，并且有多种字义。英语中的动词短语依照结构分为两种：不可分离的动词短语（动词＋介词），及可分离的动词短语（动词＋副词）。\n不可分离动词短语句型结构：（不及物）动词＋介词＋宾语\n不可分离动词短语中，常常是不及物动词连接介词，宾语必须接在后面。\n\n常见的此类动词短语有look after, look for, ask for, care about, laugh at, hear of等，所组成的动词短语字义通常不变。\nDon’t laugh at others.（不要嘲笑别人。）\nThey didn’t look after the children properly.（她们没有正确地照顾孩子们。）\n\n可分离动词短语句型结构：\n（及物）动词＋宾语＋副词\n\n（及物）动词＋副词＋宾语\n可分离动词短语是及物动词与副词可以被分开，并可以在中间加入宾语，也可以把宾语放在副词后面。\n\n\n副词改变原动词字义：\n可分离动词短语中的副词可置于动词后修饰动词，使得动词改变原本的意思，而产生新的字义。\n\n此类常见的动词短语有：give up, find out, think over, pick up, point out, hand in等。\n\n名词放在副词之前或之后：可分离动词短语中，如果宾语是名词，既可放在副词前面，又可放在副词后面。\n\n人称代名词、反身代词放介副词之前：可分离动词短语中，如果宾语是人称代名词或反身代词，则放在副词前面。\n\n语法观念例句示范01．The police are looking into the case.\n警察们在调查那件案子。\n02．They turned down my offer.\n他们拒绝了我的提议。\n03．Something unexpected has turned up.\n出现了令人意外的情况。\n04．This paper comes out once a week.\n这份报纸每星期出版一次。\n05．The meeting has been called off.\n会议被取消了。\n06．I filled in an application form.\n我填写了申请表。\n07．Mr. Ericsson, please put it down.\n艾瑞克森先生，请把东西放下来。\n08．Please don’t forget to hand it in.\n请不要忘了把它交上来。\n09．I can’t figure out why you said that.\n我不能理解你为什么那么说。\n10．I won’t let him down in any way.\n无论如何我是不会让他失望的。\n语法观念辨析练习01．没有人能够解释他的怪异行为。（account for）\n\n02．火车被大雾阻挡而晚点了。（hold up）\n\n03．我在公园等了她很长时间，但是她没有出现。（turn up）\n\n04．请勿践踏草坪！（keep off）\n\n05．如果我这次饶恕了你，你就能保证下次不会这么做了吗？（let off）\n\n06．不要把今天的事情拖到明天做。（pull off）\n\n07．别受骗上当。（take in）\n\n08．请关门。（shut off）\n\n09．你昨天买的这条裙子很漂亮，快穿上吧。（put on）\n\n10．明天早上记得叫我起床。（wake up）\n\n正确答案及题目译文：\n\nDay04系动词vs．感官动词\n系动词是用来补充描述和指明事物的，常用形容词来补充说明主语的不足，使得整句意思更完整，常用的系动词有seem, appear, look, feel, sound, taste, become, get, turn, smell, grow等；感官动词是表示人的感觉的动词，常见的感官动词有feel, hear, sound, see, taste, smell, look at等。\n系动词本质\n系动词是在主语和补语之间起连接功能的动词\n\n补语特性及句型结构\n系动词＋形容词\n\n系动词＋like＋名词\n\n系动词所连接的表语一般为形容词。若要连接名词时可以在系动词后加“like”，例如：\nThe story sounds interesting.（这个故事听起来很有趣。）\nIt sounds like an interesting story.（听起来是个有趣的故事。）\n\n状态的改变\n状态的改变：become, get, grow\nbecome, get, grow等系动词可用来表示“从一种状态变为另一种状态”，并且可以搭配使用进行时，表示（越来越……）。\nI am getting more and more tired.（我变得越来越累。）\n\n感官动词\n本质\n表达人类感受的动词。\n感官动词是表示人类感觉、感受的动词，故称为感官动词。可作完全及物动词或不完全及物动词，例如：listen to, hear, watch, see, feel等。\n   I feel sick today.（我今天觉得不舒服。）\n\n句型结构及特性\n不完全及物动词＋宾语＋动词原形→表示全部过程\n\n不完全及物动词＋宾语＋现在分词→表示正在进行的动作\n I saw the old lady cross the road.（我看到老太太过马路。）\n I saw the old lady crossing the road.（我看见老太太正在过马路。）\n\n\n被动语态\n   感官动词用于被动语态，“V原形”改为“to+V”：\n   感官动词用于被动语态，后面原有动词原形要改为带to的不定式，例如：\n   I hear the boy sing every day.\nThe boy is heard to sing every day.\n（我每天都听到那个男孩唱歌。）\n\n语法观念例句示范01．His suggestion sounds ridiculous.\n他的建议听起来很可笑。\n\n02．The soup tastes good.\n这汤的味道尝起来不错。\n\n03．He becomes lazy.\n他变懒了。\n\n04．She feels nervous before the exam.\n考试前她很紧张。\n\n05．It sounds like a good idea.\n听起来是个不错的主意。\n\n06．The weather usually turns cold in the end of August.\n天气通常在八月底开始变冷。\n\n07．You get fat again.\n你又变胖了。\n\n08．The weather is getting hotter every day.\n天气一天天越来越热了。\n语法观念辨析练习请将以下句子翻译为英语。\n01．我听到有人在唱歌。\n\n02．我昨天晚上觉得牙齿很痛。\n\n03．我看他进房间了。\n\n04．她长得像她妈妈。\n\n05．那时候他很开心。\n\n06．这款布料很柔顺。\n\n07．比赛越来越精彩了。\n\n正确答案及题目译文：\n\n动名词与不定式\n当一个句子中出现两个动词时，通常会用两种形式呈现。\n\n动名词：动词＋ing→具有动词及名词的特性，在句子中作为名词使用。\n\n\n不定式：to＋动词原形→具有名词、形容词和副词的特性，在句子中作为主语、补语及副词使用。\n\n动名词使用时机作为主语使用→置于句首：\n当动名词作为主语时，通常位于句首，例如：\nSeeing is believing.（眼见为实。）\n\n主语为动作→使用动名词：\n在英语语法中，若句子的主语为动作时，通常必须转化为动名词形式。例如：\nWalking to office is a best way to lose weight.（走路上班是减肥的最好方法。）\n\n动名词作补语使用，句子的主语通常为→\n无生命的名词，例如：\nMy favorite sport is playing tennis.（我最喜欢是运动是打网球。）\n以what引导的名词从句，例如：\nWhat I want is having a rest.（我想要的是好好休息一下。）\n\n作为宾语使用→可当动词宾语或介词的宾语：\n\n动词宾语：  英语中有些动词后面只能使用动名词作为宾语。这类动词常见的有：admit, advice, anticipate, appreciate, avoid, consider, delay, deny, dislike, enjoy, escape, excuse, fancy, favor, finish, imagine, include, keep, mind, miss, postpone, practice, prevent, propose, resist, risk, suggest等。例如：\nPlease pardon my disturbing you.（请原谅我打扰您了。）\nI suggest doing it in a different way.（我建议用不同的方法做。）\n\nTIPS!\n\n  连接在need, require, want之后的动词以动名词呈现时，表示被动意义。例如：\n  The car needs repairing.（这辆车需要修理。）\n\n介词的宾语：\n英语中有些连接在介词后面的动词需要以动名词的形式呈现。例如：\nShe is worring about discussing the new proposal with sales manager tomorrow very much.（她现在非常担心明天要跟业务经理讨论新方案。）\n\nTIPS!\n\n\n这类介词后面连接动名词的状况常常出现在特定介词短语中，例如：be afraid of, be careful of, talk about, worry about。\n5 .  作形容词使用→置于名词之前：\n动名词放在名词之前可作为修饰用形容词使用，例如：\n\n时态陈述句动名词→所表时间与主要动词时间一致或未来：\n陈述句动名词所表示的时间，与句中动词所表示的时间“一致或是表示未来”。例如：\nI am sure of his quitting.＝I am sure he will quit.\n（我很肯定他会辞职。）\n\n完成时动名词→所表示的时间比主要动词时间更早：\n完成时动名词所表示的时间，比句中动词所表示的时间“更早发生”。例如：\nI am sure of his having done so.＝I am sure that he has done so.\n（我很肯定他曾经这样做过。）\n\n不定式\n使用时机作为主语使用→置于句首：\n不定式做为主语使用时，一般表示具体的动作，常置于句首。例如：\nTo save time is to lengthen life.（节约时间就等于延长了人的生命。）\n\n作为补语使用→表示将来的动作：\n不定式作补语使用时，常表示将来的动作。而句中主语常常是表示意向、打算、计划的词，例如wish, idea, task, purpose, duty, job等。\nMy work is to clean the classroom every day.（我的工作是每天打扫教室。）\n\n置于系动词后→表示状态：\n不定式置于seem, appear, prove等系动词后面时，表示状态，例如：\nThis plan seems to be possible.（这个计划似乎是可行的。）\n\n作为宾语使用→可当动词宾语或限定介词的宾语：\n\n动词宾语：\n不定式常在下列动词后做宾语，例如afford, agree, apply, arrange, ask, attempt, beg, begin, care, choose, claim, consent, demand, decide, desire, determine, expect, fail, hope, hesitate, hate, intend, learn, like, manage, mean, neglect, offer, plan, prepare, pretend, promise, refuse, resolve, seek, tend, threaten, want等。\nHe promises to keep my secret.（他答应替我保守秘密。）\n\n限定介词之宾语：\n不定式通常不做介词的宾语。但是遇到but, except, besides, than, instead of, about这几个特殊介词，不定式可连接在后面作为宾语。例如：\nWe can do nothing but to wait.（除了等我们什么也做不了。）\n\n作为动词之后的宾语补语\n不定式常跟在下列动词之后做宾语补语：ask, advise, allow, beg, cause, compel, command, enable, encourage, expect, feel, force, find, hear, have, inform, invite, let, make, mean, notice, order, permit, persuade, remind, require, request, teach, tell, urge, watch, warn, watch等。\nThe teacher asked her to answer the question.（老师叫她回答问题。）\n\n\nTIPS!\n\n不定式在下列动词的后面做宾语补语时，需要省略to，例如feel, hear, listen to, let, have, make, look at, see, watch, notice, observe, help等，但是变成被动语态时，省略的to必须再补上。\nWhenever something is wrong with you, please do let me know.（无论什么时候你出问题了，请告诉我。）\n6．作副词使用\n修饰动词→表目的：\n不定式做副词修饰动词时，通常表示特定目的，或是表示出乎意料的结果。\nHe woke up to find everybody gone.\n（他起来后发现所有人都不见了。）→不定式表结果\n\n修饰形容词→表原因：\n不定式做副词修饰形容词时，通常表示原因，并且通常与以下表示感情的形容词连用：glad, sorry, proud, angry, ashamed, excited, disappointed, interested…\nI am sorry to hear this information.（我很遗憾听到这个消息。）→不定式表原因\n\n时态陈述句不定式→所表示的时间与主要动词一致\nI like to read newspaper.（我喜欢看报纸。）\n\n进行时不定式→所表示的时间与主要动词同时\nI am very glad to be work with you.（我很高兴能与你一同工作。）\n\n完成时不定式→所表示的时间比主要动词更早\nI am sorry to have kept you waiting so long.（很抱歉让你等这么久。）\n\n语态主动语态→主语是执行者\n句中不定式使用主动语态时，通常代表主语是该动作的执行者。例如：\nI am glad to attend your marriage.（我很高兴能出席你的婚礼。）\n\n被动语态→主语是承受者\n句中不定式使用被动语态时，通常代表主语是该动作的承受者。例如：\nHe didn’t like to be laughed at.（他不喜欢被人嘲笑。）\n\n延伸用法，事半功倍！动名词和不定式都可以做主语。不定式做主语表示具体的动作，动名词做主语则可以表示抽象或一般性的动作或情况。例如：\nTo play with fire will be dangerous.（玩火是非常危险的。）\n→ 指特定的人的具体动作\nPlaying with fire is dangerous.（玩火是非常危险的。）\n→ 泛指玩火\n\n在allow, advise, forbid, permit等动词后，以另一个动词作宾语时，要用动名词形式。但如果后面有名词、代名词作宾语时，需连接不定式。例如：\nYou don’t allow smoking here.（你不允许在这里抽烟。）\nI don’t allow you to smoke here.（我不允许你在这里抽烟。）\n\n语法观念例句示范01．Smoking may cause cancer.\n吸烟会致癌。\n\n02．It’s useless arguing about it.\n争论这件事没有意义。\n\n03．Her hobby is painting.\n她的爱好是绘画。\n\n04．Remember to tell him the news.\n记得告诉他这个消息。\n\n05．I don’t feel like going to the movie.\n我不想去看电影。\n\n06．To master a foreign language is really important nowadays.\n如今，掌握一门外语真的很重要。\n\n07．It’s kind of you to think so much of us.\n你为我们考虑这么多真是太好了。\n\n08．To see is to believe.\n眼见为实。\n\n09．You must learn to look after yourself.\n你必须自己学会照顾自己。\n\n10．I don’t know what to do next.\n我不知道接下来该怎么做。\n语法观念辨析练习请选出正确的选项。\n01．She can’t help________the house because her guests is about to come.\nA to clean\nB cleaning\nC cleaned\nD being cleaned\n\n02．It is difficult to get used________on the sofa.\nA sleep\nB to sleeping\nC slept\nD to sleep\n\n03．Though________money, his parents managed to send him to university.\nA lacked\nB lacking of\nC lacking\nD lacked in\n\n04．She pretended________me when I passed by.\nA not to see\nB not seeing\nC to not see\nD have not seen\n\n05．It’s no use________to get a bargain in the department store.\nA to except\nB excepting\nC wanting\nD you excepting\n\n06．After________for the job, you will be required to take a language test.\nA being interviewed\nB interviewed\nC interviewing\nD having interviewed\n\n07．It was unbelievable that the fans waited outside the gym for three hours just________a look at the sports stars.\nA had\nB having\nC to have\nD have\n\n08．I saw him________out of the room.\nA go\nB had gone\nC has gone\nD goes\n\n09．No one can avoid________by advertisements.\nA to be influenced\nB being influenced\nC influencing\nD having influence\n\n10．It was impolite of him________without________good-bye.\nA to leave, saying\nB leaving, to say\nC to leave, to say\nD leaving, saying\n\n正确答案及题目译文：\n\n连词\n功能连接单词\nlove and hate（爱和恨）\na difficult but worthy life（艰难却有价值的人生）\nneither the teacher nor his student（不是那位老师也不是他的学生）\n\n连接短语\nready to start and easy to finish（准备出发和容易完成）\n\n连接从句\nJohnny has not smoked since his daughter was born.（自从强尼的女儿出生后，他就没有抽过烟了。）\n\n使用分类并列连词\n此类连词有and, but, so, yet, still, either, or, neither, nor, than, either…or, neither...nor, not only...but also, as well as等。例如：\nI will do it right away and do it well.（我现在就做，而且我会把这件事做好。）\nShe agreed with Martin’s proposal, but she didn’t want to join his team.（她同意马丁的提案，但是她不想加入马丁的团队。）\n\n从属连词\n\n名词从属连词及从句\n可用来当主语和宾语，此类连词有whoever, whatever, who, whom, which, that, when, where, how, what, why, whether等。\nWhen mother finished the cake was a surprise.（妈妈完成蛋糕的时间是个惊喜。）\n→ 名词从句当主语\nMicheal joined the team which is leaded by his father.（迈克加入了由他爸爸领军的团队。）\n→ 名词从句当宾语\n\n形容词从属连词及从句\n可用来当主语补语和形容词，此类连词有who, whom, whose, which, that, when, where等。\nThe point is who did this.（重点是谁完成了这件事。）\n→ 形容词从句当主语补语\nThe old lady who has 5 dogs is my mother-in-law.（有五只狗的老太太是我的岳母。）\n→ 形容词从句当形容词\n\n副词从属连词及从句\n可以当副词使用或是引出副词从句，此类连词有after, as, although, because, before, if, since, though, until, when, whenever, while, wherever等。\nShe woke up after I left home.（我一出家门她就醒了。）\n→ 连词带出副词从句\n\n语法观念例句示范01．Air and water are indispensible for human beings.\n空气和水对人类来说必不可少。\n\n02．You may go, only come back early.\n你可以去，只是要早点回来。\n\n03．We should strike while the iron is hot.\n我们要趁热打铁。\n\n04．Where there is a will, there is a way.\n有志者，事竟成。\n\n05．We wouldn’t lose heart even if we should fail ten times.\n我们就是失败十次也不灰心。\n\n06．Now that you are all back, we’d better start the work right now.\n你们既然都回来了，我们最好马上就开始工作。\n\n07．Wherever you are, I will be with you.\n不管你到哪，我都会在你身边。\n语法观念辨析练习01　I was reading a newspaper________he came in.\nA as soon as\nB since\nC while\nD when\n\n02．Hurry up, ____you’ll be late for school.\nA and\nB but\nC so\nD or\n\n03．Excuse me for breaking in, ____I have some news for you.\nA so\nB and\nC but\nD yet\n\n04．____you’ve got a chance, you might as well make full use of it.\nA Now that\nB After\nC Although\nD As soon as\n\n05．The old man________lives in that old house is my uncle.\nA who\nB which\nC where\nD how\n\n06．One can’t learn a foreign language well________he studies hard.\nA because\nB though\nC unless\nD if\n\n07________you decide to take this job, you should try to make it a success.\nA Whatever\nB Unless\nC Whenever\nD If only\n\n08．I’ll accept any job________I don’t have to get up early.\nA lest\nB as long as\nC in case\nD though\n\n正确答案及题目译文：\n\nDay05介词介词。是用来表明单词与单词之间的各种关系，主要是用来引出具有名词作用的单词，例如名词、动名词、代名词及名词从句。\n\n种类简单介词→只有一个单词：\n简单介词是指只有一个单词的介词。例如：at, before, for, from, in, next, of, over, since, to, under, with等。\n\n合成介词→两个以上单词组成：\n合成介词是指由两个单词所合成的介词。例如：inside, into, out of, outside, upon, within, without等。\n\n双重介词→由两个介词组成：\n双重介词是指由两个介词所组成的介词。例如：according to（根据）、from behind（从……后面）、along with（与……一起）等。\n\n介词短语→由两个或以上的单词组成：\n介词短语是指由两个或以上的单词组成的短语。例如：at the end of（在……最后）、because of（由于）、by means of（以……为手段）、in case of（万一）、in need of（需要）、in front of（在……之前）、in spite of（尽管……还是）、instead of（代替）、owing to（由于）。\n\n使用时机表示时间→at, on, in, by, for, during, from, after\nat：用来表示特定的时间、节日、年龄等。例如：\nat night（在晚上）、at 5 p.m.（在下午五点）。\nI will meet you at 10 a.m. tomorrow morning.（明天早上10点见。）\n\non：用来表示某一天或星期几，指明具体的时间。例如：\non Friday（在礼拜五）、on the date you born（在你出生的那天）\nSarah’s birthday this year is on Saturday.（莎拉今年的生日是星期六。）\n\nin：用来表示一天中某段时间，指天、月、年、季节、周次等。\n例如：in the morning（在早上）、in Summer（在夏天）、in 1991（在1991年）\nI always like to go the beach in Summers.（每年夏天我都喜欢去海边。）\n\nby：表示“……的时候、到……、等到……，已经……”，用在日期、时间的“前面”，例如：by 5 o&#39;clock（到五点的时候）。\nPlease wait for my information. I will come back by 7 p.m.（请等待我的消息，我会在七点的时候回来。）\n\nfor：表示一段不明确的时间，指时间的长度，动作是断断续续的。例如：\nI have been living here for ten years.（我已经住在这里10年了。）\n\nsince：表示从过去某一时间点开始，到现在的一个时间点。例如：\nI have been living here since 2000.（我从2000年开始就住在这里了。）\n\nduring：在……期间。表示一段从开始到结束相当分明的时间片段。动作是规律性的持续，例如：\nHe swims every day during this summer.（在今年夏天，他每天都会游泳。）\n\nfrom：自从……。仅说明从什么时候开始，不说明某动作或情况持续多久，例如：\nI began to work from this morning.（我从今天早上就开始工作了。）\n\nafter：表示在……之后。如果后面接一段不明确的时间，就表示从过去某一段时间以后；如果后面接一个精确的时间点，表示从“某一时刻以后”。例如：\nMy mother was exhausted after 3 hour’s housework.（妈妈在做完三个小时的家务事之后十分疲惫。）\nWe’ll go out for a walk after dinner.（我们晚餐之后会出去散步。）\n\n\n表示地点→at, in, on\nat：在一个精确的点（point），表示地点、地方、位置，指范围较小的地方，或是特定的地点。例如：\nat the school’s front gate（在学校的前门）。\nat the same restaurant（在同一间餐厅）。\nTommy was waiting for you at the bus stop for almost 3 hours!\n（汤米已经在公车站等你等了快三个小时了！）\n\nin：表示在某个特定、有明显区域范围的空间之内（enclosed space），例如：in London（在伦敦）、in the garden（在花园里面）、in my bag（在我的包里）。\nIris has an important meeting at the World Trade Center in Bangkok.\n艾瑞斯在曼谷的世界贸易中心有一个重要的会议。\n\non：表示在一个位置或地点的上方（surface），例如：\non the wall（在墙上）、on the floor（在地板上）、on a page of the book（在这本书的一页上）。\nI live on the 8th floor at Wall Street in New York.（我住在纽约华尔街的八楼。）\n\n\n表示方位→above, over, below, under, in front of, in the front of\nabove：指“在……上方”，不强调是否垂直，与below相对，例如：\nThe bird is flying above my head.（这只鸟飞过了我的头上。）\n\nover：指“垂直”的上方，与under相对，但通常是指上面的物体从一边移动到另一边的情况。例如：\nThere is a bridge over the river.（有一条桥横越那条河。）\n\nbelow, under：都表示“在……下面”，但under在正下方，below不一定在正下方。\nThere is a ball under the chair.（有颗球在椅子下面。）\nMy new skirt came below my ankles.（我的新裙子到我的脚踝以下。）\n\nin front of / in the front of：都表示在……前面，但in front of指甲物在乙物之前，两个物体为各自独立的物体，反义词是behind（在……后面）；in the front of指甲物在乙物的“内部”，也就是乙物包含了甲物在内，反义词为at the back of（在……范围内的后面）。\nThere is a river in front of my house.\n（我家门前有一条小河。）→我家与小河各自独立，没有接触\nOur teacher stands in the front of the classroom.\n（我们老师站在教室的前面。）→老师在教室里面，但是站在教室的前面\n\n\n表示运动方向→along, across, through\nalong：表示“沿着……”，例如：along the river（沿着这条河）。\nJust walk along the street and you will find the bus stop.（只要沿着这条街一直走，你就会看到公共汽车站了。）\n\nacross：表示“横过……”，通常与“道路、河川、平原”等地点连用，例如：across the road（横越马路）。\nThe Wang’s just live across the street.（王氏一家人就住在这条街的对面。）\n\nthrough：表示“穿过……、穿越……”，指从物体内部穿过，例如：through the door（穿过门）。\nI saw Sandy through the window.（我透过玻璃窗看到了珊蒂。）\n\n\n表示在……之间→between, among\nbetween：指在两个人或事物之间，例如：\nbetween you and me（在你跟我之间）。\nMy boss divided all the profit between John and him.（老板把所有的利润分给了他和约翰。）\n\namong：指在三个或以上的人或物之间，例如：among all of us.\nMy boss divided all the profit among all of us.\n（我老板把所有的利润分给了我们所有人。）\n\n\n表示方法、手段、工具→by, with, in\nby：表示以……方法、手段或泛指某种交通工具。例如：\nI go to school by bus every day.（我每天都坐公共汽车上学。）\n\nwith：表示用……工具、手段，一般接具体的工具和手段，如：\nI cut the apple with knife.（我用刀子切开苹果。）\n\nin：表示用……方式，用～语言（语调、笔墨、颜色）等，例如：\nHe talks with me in English for 15 minutes every day.（他每天都用英语跟我说话15分钟。）\n\n\n表示原因→because, as, for\nbecause：表示直接的、明确的原因，用来回答why的问句。例如：\nHe was late for school, because he didn’t catch the bus.\n（他上学迟到了，因为他没有赶上公共汽车。）\n\nas：表示由于……，鉴于……，指一种显而易见、谈话双方已知的理由。如：She stayed at home as she was ill.（她待在家，因为她生病了。）\n\nfor：表示由于、因为，指一种间接原因，甚至只是一种附带的说明。例如：\nIt must have rained last night, for the road is wet.（昨天晚上一定下雨了，因为路是湿的。）\n\n\n语法观念例句示范01．He is intent on winning.\n他一心只想着赢。\n\n02．Joe was very disappointed at not finding her at home.\n乔伊发现她不在家很失望。\n\n03．I shall prevail on him to make the attempt.\n我将说服他试一试。\n\n04．We concentrated on doing one job at a time.\n我们集中精力一次做一份工作。\n\n05．I don’t wish to break in on your thoughts.\n我不是有意打断你的思绪的。\n\n06．He achieved his aim by force of sheer determination.\n他完全凭决心达到了他的目标。\n\n07．Such irresponsible conduct can only work to the prejudice of our cause.\n这种不负责任的行为只会有损于我们的事业。\n\n08．He is working hard now with an eye to the future.\n他为了前途而现在努力工作。\n\n09．In the event of an accident, the police must be called at once.\n如果出了事故，应该立刻叫警察。\n\n10．She was cheated out of 1,000 dollars by the young man.\n她被一个年轻男人骗走了1000美元。\n语法观念辨析练习请填入适合题目句中底线的介词。\n01．Please don’t get mad________me. I was only trying to help.\n02．Fruit is rich________vitamins.\n03．John was impatient________his daughter.\n04．Cathy was particular________the jewelry she wore.\n05．The jury decided that Susan was guilty________murder.\n06．The word derives________Latin.\n07．Everyone blamed you________a certain mistake, you need to say something.\n08．This water taste________salt.\n09．It’s rude to point________someone.\n10．I’ll find someone to fill in this formula________you.\n正确答案及题目译文：\n\n短语短语是指由两个或两个以上的英语单词所组合的词语，其中不包含主语和动词，连在一起具有类似一种词类作用的字群。\n\n名词短语名词短语如同名词，可做句子中的：\n主语 \n（让我失望是你做过的最糟糕的事情。）\n\n及物动词的宾语\n \n\n介词的宾语\n \n\n形容词短语形容词短语如同形容词，用以修饰句中的名词，置于所修饰的名词之后由于形容词能修饰名词，而名词又能做句子的主语、宾语、表语等，所以形容词短语具有修饰主语、宾语、表语的功能。\n修饰主语\n\n  （坐在你身后的女孩是我最好的朋友。）\n修饰宾语\n \n （公司把工作交给最有经验的人。）\n\n修饰主语补语\n \n （这是一本有许多趣味故事的书。）\n\n副词短语副词短语如同副词，用来修饰句中的动词、形容词、副词和整句。\n修饰动词\n \n\n修饰形容词\n \n （很抱歉要你等这么久的时间。）\n\n修饰副词\n \n\n动词短语动词短语是由动词加上副词所形成，这些副词常见的有up, down, in, out, on, off…。\n宾语为名词时→放在短语之后或是中间，例如：\ntake off the coat或take the coat off。\n\n宾语为代名词时→放在短语中间，例如：put it up。\n\n介词短语介词短语就是介词和宾语连在一起，当形容词或副词用。\n当形容词用，修饰主语：\n \n （棕色头发的男孩正在那儿踢足球。）\n\n当副词用，修饰动词：\n \n\n语法观念例句示范01．I will call on you next Sunday.\n我下个星期天会去拜访你。\n\n02．I want to run some errands.\n我要去办点杂事。\n\n03．There is a bunch of books in my living room.\n我的客厅里有一堆书。\n\n04．He pulled an all-nighter last night.\n他昨晚熬夜了。\n\n05．They hang out a lot.\n他们常在一起。\n\n06．Above all, we must finish the work at hand.\n最重要的是，我们必须把手上的工作完成。\n\n07．As a matter of fact, I’m a very efficient worker.\n事实上，我是个做事非常有效率的员工。\n\n08．I will go with the chicken noodle soup.\n我会选择鸡肉汤面。\n\n09．Take a little more money with you, just in case.\n多带一点钱在身上，以备不时之需。\n\n10．You’ve said a lot, but nothing was to the point.\n你说了很多，但都没有说到重点。\n语法观念辨析练习请将题目句翻译成英语。\n01．我们为何不停车，下车一会儿呢？\n\n02．在你出门前把帽子带上。\n\n03．请打开灯，这里太暗了。\n\n04．我只能一天一天的等待奇迹的发生。\n\n05．关于那份新的工作，你接到公司的通知了吗？\n\n06．我相信这个产品会非常畅销。\n\n07．你必须准时赶到约定的地方。\n\n08．请千万小心，别让小孩靠近马路。\n\n09．警察正在调查电脑失窃的案件。\n\n10．没有证据可以证明我是被陷害的。\n\n正确答案及题目译文：\n\n","plink":"https://dxsummer.gitee.io/posts/2f6cae91/"},{"title":"Butterfly主题更新总结","date":"2020-05-08T06:33:23.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:49:56.372Z","content":"本文仅记录一些看似无意义的小改动，你可以在本文 get：\n1. 各种自定义样式的`路径`\n2. 如何自定义字体和文字色块\n3. 如何增加评分的小星星\n4. 插件的总结等…\n对于没学过任何 CSS 的我能改成这样实属不易，还望各位大佬指出我的错误~~并五星好评~~。修改主题，先装依赖出现报错，未安装渲染依赖！\n执行以下命令\n1npm install hexo-renderer-pug hexo-renderer-stylus --save菜单栏设置新版本默认是中文，但是修改根目录配置文件的 language 为 zh-CN 之后，菜单栏会变回英文。直接修改主题配置文件 menu 为中文即可\n123456menu:  首页: &#x2F; || fa fa-home  归档: &#x2F;archives&#x2F; || fa fa-archive  标签: &#x2F;tags&#x2F; || fa fa-tags  分类: &#x2F;categories&#x2F; || fa fa-list-ul  友链: &#x2F;link&#x2F; || fa fa-cogs\n首页留空表示跳转起始页，若加上 /home/ 则为新页面，类似分类标签页\n\n菜单栏跳转外链，去掉 / 直接写链接即可\n\n1云盘 || http:&#x2F;&#x2F;kd.xiabor.com || fa fa-mixcloud文章主页描述关闭自动节选，才能在 Page Front-matter 中添加 description\n1234# 自動節選auto_excerpt:  enable: false  length: 150代码高亮及自动换行代码高亮试了其他的插件，Mac Pannel 样式等，调来调去还不如默认的，索性不改了\n\n打开自动换行code_word_wrap: true，根目录下配置文件_config.yml，將 line_number 改成 false:\n12345highlight:  enable: true  line_number: false  auto_detect: false  tab_replace:事实证明，代码换行在移动端很不舒服，还是关掉吧。\n\n主题美化取消主题配置文件 theme_color 的注释\n自定义主色调为浅绿，设置 footer 显示图片背景与 top_img 一致。\n推荐文章设置 limit: 3\n打开图片文字描述 photofigcaption: true\n设置评论区打字冒光和抖动效果，activate_power_mode: true\n鼠标点击出现爱心 click_heart: true\n美化页面展示，修改标题前图标为闪电 title-prefix-icon:&#39;\\f0e7&#39;，颜色为黄色 title-prefix-icon-color: &quot;#ffb821&quot;\n主页调用金山词霸的每日一句打字效果，需注意的是：自定义副标题 sub 的时候，符号必须用 ASCII 码表示，常用的逗号为 , 句号为 . 双引号为 &quot; 英文缩写符号为 &#39;\n打开 snackbar 弹窗并设置底部居中 position: bottom-center\n打开中英文之间添加空格 pangu: true\n至此主题配置文件在不装插件前提下算是修改完毕了，明天继续折腾插件和 css 样式。眼睛疼，睡了自定义样式修改菜单字体大小为 18，修改鼠标悬停时颜色为主色调浅绿。\n在路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\head.styl 下查找.site-page，设置 font-size 为.7rem\n在此目录下 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl 新增自定义颜色值 $laurel-green = #9fefaf，在路径下修改 &amp;:hover: $laurel-greenhexo clean &amp;&amp; hexo s 查看效果\n\n由于菜单打开子菜单是悬停后选中，鼠标移开子菜单便关闭。导致鼠标如果不是从主菜单近乎垂直往下滑就无法点击子菜单。（改动意义似乎不大）自定义修改参考旧版本如下：路径 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl\n1234567891011121314151617181920212223.menus_item_child        position: absolute        right: 0        display: none        margin-top: 8px        padding: 0        border-radius: 5px        width: max-content        background-color: alpha($white, .8)        box-shadow: 0 5px 20px -4px rgba($dark-black, .5)        animation: sub_menus .3s .1s ease both        &amp;:before          position: absolute          top: -55px          left: 50%          width: 0          height: 21px          content: &#39;&#39;          margin-left: -18px          border-width: 18px          border-style: solid          border-color: transparent transparent rgba($white 0.8)\n主页文章区域，路径均为 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\pagination.styl\n外圆角修改为 5px，且图片与描述圆角为 3px\n\n主页文章描述修改，增加描述区域高度，标题距离描述适当增加，字体由 1.2 调整至 1rem\n123456789101112131415161718&amp; &gt;.recent-post-info  display: inline-block  overflow: hidden  padding: 50px 40px  width: 55%  &amp; &gt; .article-title    display: -webkit-box    overflow: hidden    margin-bottom: 1.2rem    color: $font-black    text-overflow: ellipsis    word-wrap: break-word    font-size: 1.2rem    line-height: 1.5    transition: all .2s ease-in-out    -webkit-box-orient: vertical    -webkit-line-clamp: 2\n描述文字可能较多，因此调整溢出方式为 scroll\n1234567display: -webkit-boxoverflow: scrollmargin-top: .2remheight: 97pxword-break: break-word-webkit-line-clamp: 3-webkit-box-orient: vertical\n并适当降低侧栏滚动条宽度，-webkit-scrollbar 路径为 D:\\blog\\themes\\Butterfly\\source\\css\\_global\\index.styl\n\n调整分类和发表时间字体大小为 80%，路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\page.styl\n12&amp; &gt; .article-meta-wrap      font-size: 80%\n\n\n调整移动端主页文章区域边距 5px 为 0.75rem，调整移动端描述字体大小为 0.6rem\n1234567@media screen and (max-width: $sm)    .layout_page      padding: 1rem 0.75rem !important      .content        height: auto        font-size: 0.6rem\n既然要圆润，那就全部都要圆润。调整页码圆角，算了，直接改成圆形。路径为 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\pagination.styl\n1234567891011121314.page-number  display: inline-block  margin: 0 .2rem  min-width: w &#x3D; 1.5rem  height: w  text-align: center  line-height: w  cursor: pointer&amp;.current  background: $theme-color  color: $button-color  cursor: default  border-radius: 20px\n调整页脚高度，去除驱动和主题描述，，修改 By 字母为红色爱心。\n在路径D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug下，将 By 替换为以下内容\n1&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;\n同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n12345678.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly\n利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n\n\n修改侧栏设置及返回顶部按钮\n在路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\rightside.styl下加大按钮高宽度并设置圆角，调整间距，使设置按钮的子菜单不打开状态隐藏到最右侧不可见。\n1234567891011121314151617181920212223242526#rightside  position: fixed  right: -38px  bottom: 10px  opacity: 0  transition: all .3s  #rightside-config-hide    transform: translate(40px, 0)&amp; &gt; div  &amp; &gt; i,  &amp; &gt; a,  &amp; &gt; div    display: block    margin-bottom: 2px    width: 36px    height: 36px    background-color: $light-blue    color: $button-color    text-align: center    font-size: 16px    line-height: 35px    margin-bottom: 4px    margin-right: 4px    cursor: pointer    border-radius: 3px\n\n文章目录美化\n调整左侧边距 0.5rem 为 2rem\n\n选择某一目录时，背景框宽度为最大且为方形，修改选中时边框为圆润且适应标题长度，路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\sidebar.styl下修改或增加以下内容\n12345678910.toc-link  &amp;.active    border-right-color: darken($theme-toc-color, 20%)    background: $theme-toc-color    color: $sidebar-active-color    border-radius: 5px    width: max-content    padding-right: 5px    padding-left: 5px\n\n打赏按钮美化，设置圆角并修改颜色，调整赞赏码大小确保能扫描成功\n路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\reward.styl 下修改赞赏码大小，默认 130，扫描可能无法识别，建议 200。\n\n修改底部标签边框和字体为黑色，调整大小。底部版权声明增加 1px 边框\n路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下修改以下内容\n12345678910111213141516171819202122232425&amp;__tags   display: inline-block   margin: .4rem .4rem .4rem 0   padding: 0 .6rem   width: fit-content   border: 2px solid $font-black   border-radius: .2rem   color: $font-black   font-size: 14px   text-decoration: overline   cursor: pointer   transition: all .2s ease-in-out  .post-copyright   position: relative   margin: 2rem 0 .5rem   padding: .5rem .8rem   border: 1px solid $dark-white   transition: box-shadow .3s ease-in-out   border-radius: 5px   .post-copyright     &amp;-meta       color: $grey       font-weight: bold\n提到版权申明，修改默认的灰色链接的颜色为蓝色。可以先在 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl 里添加自定义颜色，再去 post.styl 里修改，或者直接修改链接颜色为蓝色。修改其他自定义颜色的方法亦是如此。\n1$a-link-color &#x3D; #638fff版权声明\n\n文章作者: xx\n文章链接: https://xxx\n版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。\n\n点击这部分的文章作者出现 mailto:undefined，查看 copyright.pug 文件发现 email 需要在根目录 config.yml 下自定义\n因此在根目录 config.yml 下添加即可\n1email: xxxx@xxx.com\nRating 评分评价文章打字麻烦？那就用小星星吧，直接给文章打分。效果如下：\n配置教程：参考学姐的添加 Rating 投票功能\n官网传送门：widgetpack.com\n由于 butterfly 主题和 next、Sakura 等主题文件结构不同，所以详细记录本主题的配置：\n注册完 Widgetpack 选择 Rating 可以拿到一段代码如下：\n123456789101112131415&lt;div id&#x3D;&quot;wpac-rating&quot;&gt;&lt;&#x2F;div&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  wpac_init &#x3D; window.wpac_init || [];  wpac_init.push(&#123;widget: &#39;Rating&#39;, id: 你的IDxxx&#125;);  (function() &#123;      if (&#39;WIDGETPACK_LOADED&#39; in window) return;      WIDGETPACK_LOADED &#x3D; true;      var mc &#x3D; document.createElement(&#39;script&#39;);      mc.type &#x3D; &#39;text&#x2F;javascript&#39;;      mc.async &#x3D; true;      mc.src &#x3D; &#39;https:&#x2F;&#x2F;embed.widgetpack.com&#x2F;widget.js&#39;;      var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(mc, s.nextSibling);  &#125;)();  &lt;&#x2F;script&gt;  &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;widgetpack.com&quot; class&#x3D;&quot;wpac-cr&quot;&gt;Star Rating WIDGET PACK&lt;&#x2F;a&gt;利用在线转化将其转为.pug 格式，并增加点小改动，使其居中。创建并放入目录 D:\\blog\\themes\\Butterfly\\layout\\includes\\addons\\rating.pub 中\n1234567891011121314151617htmlbody  #wpac-rating(align&#x3D;&quot;center&quot;)  script(type&#x3D;&quot;text&#x2F;javascript&quot;).    wpac_init &#x3D; window.wpac_init || [];    wpac_init.push(&#123;widget: &#39;Rating&#39;, id: 你的ID&#125;);     (function() &#123;    if (&#39;WIDGETPACK_LOADED&#39; in window) return;    WIDGETPACK_LOADED &#x3D; true;    var mc &#x3D; document.createElement(&#39;script&#39;);    mc.type &#x3D; &#39;text&#x2F;javascript&#39;;    mc.async &#x3D; true;    mc.src &#x3D; &#39;https:&#x2F;&#x2F;embed.widgetpack.com&#x2F;widget.js&#39;;    var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(mc, s.nextSibling);    &#125;)();  #copy(align&#x3D;&quot;center&quot;)    | ღ喜欢记得五星好评哦~\n在合适位置引入评分，例如我的：（置于赞赏的上面）\n12345if theme.rating.enable  include includes&#x2F;addons&#x2F;rating.pug&#x2F;&#x2F;-加入以上代码，下面为赞赏    if theme.reward.enable  !&#x3D;partial(&#39;includes&#x2F;post&#x2F;reward&#39;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)\n最后，在主题配置文件设置是否打开该功能，星星颜色在 widgetpack.com 修改\n1234# Star rating support to each article.# To get your ID visit https:&#x2F;&#x2F;widgetpack.comrating:   enable: true\n\n特别提示：设置投票记录方式，有三种可选，国内最好选择 IP Address 记录。另外，widgetpack.com 只能绑定一个域名，但可以随时更换\n\n\n特别鸣谢 @GamerNoTitle，一提需求，立马奋笔疾书教我配置小星星。还回来看我文章并指出错误，佩服大佬的细心与热心。\n\n自动切换夜间模式时间修改夜间模式自动切换时间为晚上 21 点至早晨 7 点，路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\head，修改时注意格式不变\n移动端优化PC 端分类归档标签等是显示在右侧，移动端则在底部，与侧栏重复，因此去除分类标签归档个人信息，只保留网站统计。将以下代码添加进任意.styl文件里即可。效果如图（补充：调整移动端底部网站资讯字体大小为 13px）\n12345@media screen and (max-width: $sm)  #aside_content    div:not(:last-child)      display: none      font-size: 13px\n\n手机端侧栏美化，缩小头像及菜单间距。路径 D:\\blog\\themes\\Butterfly\\source\\css\\mobile-sidebar.styl 下自行调整\n在路径 post.styl 下调整移动端.post_cover 圆角为 5px\n调整移动端文章字体大小在D:\\blog\\themes\\Butterfly\\source\\css\\var.styl下自定义一个字体大小值，例如：$font-media-size = 13px，然后在D:\\anewblog\\themes\\Butterfly\\source\\css\\_global\\index.styl增加以下内容\n123@media screen and (max-width: $sm)body    font-size: $font-media-size &#x3D; 13px\n侧栏自定义加入书签按钮设置圆角aside.styl\n123456789#bookmark-it  position: relative  z-index: 1  display: block  background-color: $light-blue  color: $button-color  text-transform: uppercase  line-height: 1.6rem  border-radius: 5px\n顺便设置选中时的圆角D:\\blog\\themes\\Butterfly\\source\\css\\_global\\index.styl\n123456789101112.button--animated  transition-duration: 1s  transition-property: color  &amp;:before    position: absolute    top: 0    right: 0    bottom: 0    left: 0    z-index: -1    border-radius: 5px\n修改某些名称，例如网站资讯的名称在 D:\\blog\\themes\\Butterfly\\languages\\zh-CN 下修改即可\n\n自定义字体，图标引用外部字体和鼠标样式引用格式\n123@font-face &#123; font-family:MyFont;src: url(https:xxx)&#125;body&#123;font-family:MyFont!important;&#125;\n引用方法：将引用代码添加到 D:\\blog\\themes\\Butterfly\\source\\css\\_third-party\\normalize.min.css 末尾即可，鼠标样式亦是如此。\n\n鼠标样式引用格式\n12body &#123; cursor: url(https:&#x2F;&#x2F;xxx.png),default;&#125;a:hover &#123; cursor: url(https:&#x2F;&#x2F;xxx.png),pointer;&#125;\n修改图标可直接使用 Font Awesome 的图标。地址：Font Awesome\n\n在路径 D:\\anewblog\\themes\\Butterfly\\layout\\includes\\mixins\\UI.pug不对等我找找。第二天找到了正确的路径为 D:\\anewblog\\themes\\Butterfly\\layout\\includes\\header 可修改文章内头部（发表、更新、分类等）图标。\n12345678910111213141516#post-meta  .meta-firstline    if (theme.post_meta.post.date_type)      if (theme.post_meta.post.date_type &#x3D;&#x3D;&#x3D; &#39;both&#39;)        time.post-meta__date          span.post-meta__date-created(title&#x3D; _p(&#39;post.created&#39;)+&#39; &#39;+full_date(page.date))            i.fa.fa-pencil(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;&#39; &#39;+_p(&#39;post.created&#39;)+&#39; &#39;+date(page.date, config.date_format)          span.post-meta__separator |          span.post-meta__date-updated(title&#x3D; _p(&#39;post.updated&#39;)+&#39; &#39;+full_date(page.updated))            i.fa.fa-wrench(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;&#39; &#39;+_p(&#39;post.updated&#39;)+&#39; &#39;+date(page.updated, config.date_format)      else        - var data_type_update &#x3D; theme.post_meta.post.date_type &#x3D;&#x3D;&#x3D; &#39;updated&#39;        - var date_type &#x3D; data_type_update ? &#39;updated&#39; : &#39;date&#39;        - var date_icon &#x3D; data_type_update ? &#39;fa-wrench&#39; :&#39;fa-pencil&#39;\n修改主页文章的分类和发表时间图标，在路径 D:\\anewblog\\themes\\Butterfly\\layout\\includes 下修改即可\n12345678910111213141516if (theme.post_meta.page.date_type)      if (theme.post_meta.page.date_type &#x3D;&#x3D;&#x3D; &#39;both&#39;)        time.post-meta__date          span.post-meta__date-created(title&#x3D;_p(&#39;post.created&#39;) + &#39; &#39; + full_date(article.date))            i.fa.fa-pencil(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;date(article.date, config.date_format)          span.article-meta__separator |          span.post-meta__date-updated(title&#x3D;_p(&#39;post.updated&#39;) + &#39; &#39; + full_date(article.updated))            i.fa.fa-wrench(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;date(article.updated, config.date_format)      else        - var data_type_updated &#x3D; theme.post_meta.page.date_type &#x3D;&#x3D;&#x3D; &#39;updated&#39;        - var date_type &#x3D; data_type_updated ? &#39;updated&#39; : &#39;date&#39;        - var date_icon &#x3D; data_type_updated ? &#39;fa-wrench&#39; :&#39;fa-pencil&#39;        - var date_title &#x3D; data_type_updated ? _p(&#39;post.updated&#39;) : _p(&#39;post.created&#39;)        time.post-meta__date(title&#x3D;date_title + &#39; &#39; + full_date(article[date_type]))\n例如修改主页底部向下箭头为双箭头，先去 Font Awesome 找到合适的图标，新版在路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\header\\index.pug 的末尾修改\n12.scroll-down  i.fa.fa-angle-double-down.scroll-down-effects旧版在路径 H:\\blog\\themes\\Butterfly\\layout\\includes\\nav.pug 下修改\n\n文章内引用图标，格式如下\n1&lt;i class&#x3D;&quot;fa fa-plane&quot;&gt;&lt;&#x2F;i&gt;\n插件总结搜索插件采用本地搜索，安装插件 hexo-generator-search\n1npm install hexo-generator-search --save\n根目录配置文件添加以下内容，打开主题配置文件 local_search 即可\n1234search:  path: search.xml  field: post  content: true字数统计安装统计插件，主题配置文件打开 wordcount 即可\n1npm install hexo-wordcount --save音乐电影豆瓣插件\n安装 hexo-douban 插件\n1npm install hexo-douban --save\n并将以下内容加入根目录配置文件，hexo douban 命令进行初始化\n12345678910111213douban:  user: mythsman  builtin: false  book:    title: &#39;This is my book title&#39;    quote: &#39;This is my book quote&#39;  movie:    title: &#39;This is my movie title&#39;    quote: &#39;This is my movie quote&#39;  game:    title: &#39;This is my game title&#39;    quote: &#39;This is my game quote&#39;  timeout: 10000\n\n播放器插件在 Hexo 页面中嵌入APlayer 播放器\n1npm install --save hexo-tag-aplayer\n用法：参数选项详见 APlayer\n1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;\n部署插件安装安装 hexo-deployer-git, 填写仓库就可以部署至网络世界啦\n1npm install hexo-deployer-git --save\n置顶插件\n文章置顶\n\n要为文章置顶，你需要安装插件(hexo-generator-index-pin-top 或者 hexo-generator-indexed)，记得先卸载掉hexo-generator-index\n如果使用hexo-generator-index-pin-top, 在文章的front-matter区域里添加top: true属性来把这篇文章置顶\n如果使用hexo-generator-indexed, 在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大\n方法1\n- 卸载替换置顶插件\n  12npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save\n在文章的 front-matter 添加 top: true或数值将篇文章置顶方法2\n如果使用`hexo-generator-indexed`, 在文章的`front-matter`区域里添加`sticky: 1`属性来把这篇文章置顶。数值越大，置顶的优先级越大脚注插件这个插件是最容易忘记的，还好看到文章里有注脚脚注，执行以下命令安装注脚插件：\n1npm install hexo-reference --savenew page\nhexo new page xxx\n\n版本更新后建议页面重新建立，再复制 md 内容进去，否则容易报错。出现报错的页面有 music、photo，为什么新建页面一模一样的 md 复制进去就不报错了呢？\n设置页面顶部图photo、music、link 页面均在相应 md 文件内增加 top_img，设置顶部图。其余在主题配置文件设置即可。\n不常见问题侧栏目录消失卸载原有的渲染插件，安装新的插件\n123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save\n菜单栏消失更新产生的问题，将_data 的 butterfly.yml 移动到其他地方，重新 hexo clean&amp;&amp;hexo s，在将主题配置文件拷贝替换 butterfl.yml 即可。\n底部去除驱动和主题描述，，修改 By 字母为红色爱心在路径D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug下，将 By 替换为以下内容\n1&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;\n同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n12345678.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly\n利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n\n","plink":"https://dxsummer.gitee.io/posts/d1a5291c/"},{"title":"hexo博客添加live2d看板娘","date":"2020-05-08T05:12:15.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:51:40.886Z","content":"下载安装检测npm版本是否最新\n1npm -v\nnpm更新方法:\n\n1nmp install npm@latest -g安装hexo-helper-live2d进入hexo目录下\n1npm install –save hexo-helper-lived打开hexo目录下的_config.yml的配置文件\n配置\n将以下代码添加到站点配置文件末尾\n\n123456789101112131415161718192021222324252627282930313233  # Live2D## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2dlive2d:  enable: true  # scriptFrom: jsdelivr # jsdelivr CDN  # scriptFrom: unpkg # unpkg CDN  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url  # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名  # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径  # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url  # enable: false  scriptFrom: local # 默认  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径  model:    use: live2d-widget-model-ni-j # npm-module package name    scale: 1    hHeadPos: 0.5    vHeadPos: 0.618  display:    superSample: 2    width: 150    height: 300    position: left    hOffset: 0    vOffset: -50  mobile:    show: true    scale: 0.5  react:    opacityDefault: 0.7    opacityOnHover: 0.2下载模型动画后宫预览点这里选择你的后宫看好了默默记下小姐姐的名字,初音的模型名字:ni-j博客中都是按照ni-j操作\n1npm install –save live2d-widget-model-ni-j\n此时初音模型已经下载完毕\n\n12model:   use: live2d-widget-model-ni-j # 将&#96;ni-j&#96;替换成其他包名,即可替换不同模型人物.资源1[github源码和中文操作指南][3]重新加载博客\nhexo cleanhexo g打开浏览器看看你的初音吧\n\n","plink":"https://dxsummer.gitee.io/posts/2805db8d/"},{"title":"hexo博客开启pwa","date":"2020-05-08T04:41:25.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:53:02.940Z","content":"前言Progressive Web App, 简称PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\nPWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。\nPWA 的主要特点包括下面三点：\n可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现\n体验 - 快速响应，并且有平滑的动画响应用户的操作\n粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面\nPWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。\n Warning Header\n开始pwa之前，全站必须支持HTTPS\n开始pwa之前，全站必须支持HTTPS\n开始pwa之前，全站必须支持HTTPS安装pwahexo@4.2.0 目前赞不兼容 hexo-pwa,使用 hexo@4.2.0 版本的用户推荐降级到 hexo@4.1.1\n使用sudo hexo -version 查看版本\n安装指定版本 sudo npm install hexo@4.1.1 --save\n安装hexo-pwa\n1sudo npm install hexo-pwa --save配置添加manifest.json在manifest.json生成网站生成manifest.json首先你需要准备一个你喜欢的图标，填写香相关选项，并上传图标，将生成的manifest.json文件，放到 博客根目录下\n我生成的如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123;  &quot;name&quot;: &quot;YH&#39;s Blog&quot;,  &quot;short_name&quot;: &quot;YH&#39;s Blog&quot;,  &quot;theme_color&quot;: &quot;#2196f3&quot;,  &quot;background_color&quot;: &quot;#2196f3&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;Scope&quot;: &quot;&#x2F;&quot;,  &quot;start_url&quot;: &quot;&#x2F;&quot;,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-72x72.png&quot;,      &quot;sizes&quot;: &quot;72x72&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-96x96.png&quot;,      &quot;sizes&quot;: &quot;96x96&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-128x128.png&quot;,      &quot;sizes&quot;: &quot;128x128&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-144x144.png&quot;,      &quot;sizes&quot;: &quot;144x144&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-152x152.png&quot;,      &quot;sizes&quot;: &quot;152x152&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-192x192.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-384x384.png&quot;,      &quot;sizes&quot;: &quot;384x384&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-512x512.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;  ],  &quot;splash_pages&quot;: null&#125;参数解释\nname: {string} 应用名称，用于安装横幅、启动画面显示\nshort_name: {string} 应用短名称，用于主屏幕显示\ntheme_color: {Color} css色值theme_color 属性可以指定 PWA 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如 PWA 启动画面上状态栏、内容页中状态栏、地址栏的颜色，会被 theme_color 所影响。\nbackground_color: {Color} css色值 可以指定启动画面的背景颜色。\ndisplay: {string} 显示类型\nfullscreen 应用的显示界面将占满整个屏幕\nstandalone 浏览器相关UI（如导航栏、工具栏等）将会被隐藏\nminimal-ui 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\nbrowser 浏览器模式，与普通网页在浏览器中打开的显示一致\nscope: {string} 作用域\n\nscope 应遵循如下规则：如果没有在 manifest 中设置 scope，则默认的作用域为 manifest.json 所在文件夹；scope 可以设置为 …/ 或者更高层级的路径来扩大PWA的作用域；\n\nstart_url 必须在作用域范围内；\n\n如果 start_url 为相对地址，其根路径受 scope 所影响；如果 start_url 为绝对地址（以 / 开头），则该地址将永远以 / 作为根地址；\n\nstart_url: {string} 应用启动地址\nicons: {Array.} 应用图标列表\nsrc: {string} 图标 url\n\nsizes {string} 图标尺寸，格式为widthxheight，宽高数值以 css 的 px 为单位。如果需要填写多个尺寸，则使用空格进行间隔，如”48x48 96x96 128x128”type {string} 图标的 mime 类型，非必填项，该字段可让浏览器快速忽略掉不支持的图标类型\n\n添加sw.js新建一个名为sw.js的文件，放在站点根目录下，在文件里填入一下内容\n1234567891011121314importScripts(&#39;https:&#x2F;&#x2F;g.alicdn.com&#x2F;kg&#x2F;workbox&#x2F;3.3.0&#x2F;workbox-sw.js&#39;);​if (workbox) &#123;    workbox.setConfig(&#123; modulePathPrefix: &#39;https:&#x2F;&#x2F;g.alicdn.com&#x2F;kg&#x2F;workbox&#x2F;3.3.0&#x2F;&#39; &#125;);​    workbox.precaching.precache([&#39;&#x2F;&#39;, &#39;&#x2F;index.html&#39;]);​    workbox.routing.registerRoute(new RegExp(&#39;^https?:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;?$&#39;), workbox.strategies.networkFirst());​    workbox.routing.registerRoute(new RegExp(&#39;.*.html&#39;), workbox.strategies.networkFirst());​    workbox.routing.registerRoute(new RegExp(&#39;.*.(?:js|css|jpg|png|gif)&#39;), workbox.strategies.staleWhileRevalidate());​&#125;\n将其中域名改为你自己主页的域名：https?://dxsummer.gitee.io/ 改为你的域名，格式要和我的一样。\n\n配置站点配置文件首先将生成的images文件复制到 /source 文件夹下将下面的配置代码复制到你的站点根目录配置文件 _config.yml中\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# https:&#x2F;&#x2F;github.com&#x2F;lavas-project&#x2F;hexo-pwapwa:  manifest:    path: &#x2F;manifest.json    body:      name: YH&#39;s Blog      short_name: YH&#39;s Blog      theme_color: #2196f3      background_color: #2196f3      display: standalone      orientation: portrait      scope: &#x2F;      start_url: &#x2F;      icons:        - src: &#x2F;images&#x2F;icons&#x2F;icon-72x72.png          type: image&#x2F;png          sizes: 72x72        - src: &#x2F;images&#x2F;icons&#x2F;icon-96x96.png          type: image&#x2F;png          sizes: 96x96        - src: &#x2F;images&#x2F;icons&#x2F;icon-128x128.png          type: image&#x2F;png          sizes: 128x128        - src: &#x2F;images&#x2F;icons&#x2F;icon-144x144.png          type: image&#x2F;png          sizes: 144x144        - src: &#x2F;images&#x2F;icons&#x2F;icon-152x152.png          type: image&#x2F;png          sizes: 152x152        - src: &#x2F;images&#x2F;icons&#x2F;icon-192x192.png          type: image&#x2F;png          sizes: 192x192        - src: &#x2F;images&#x2F;icons&#x2F;icon-384x384.png          type: image&#x2F;png          sizes: 384x384        - src: &#x2F;images&#x2F;icons&#x2F;icon-512x512.png          type: image&#x2F;png          sizes: 512x512  serviceWorker:    path: &#x2F;sw.js    preload:      urls:        - &#x2F;      posts: 12    opts:      networkTimeoutSeconds: 30    routes:      - pattern: !!js&#x2F;regexp &#x2F;hm.baidu.com&#x2F;        strategy: networkOnly      - pattern: !!js&#x2F;regexp &#x2F;www.google-analytics.com&#x2F;        strategy: networkOnly      - pattern: !!js&#x2F;regexp &#x2F;.*\\.(js|css|jpg|jpeg|png|gif)$&#x2F;        strategy: cacheFirst      - pattern: !!js&#x2F;regexp &#x2F;\\&#x2F;&#x2F;        strategy: networkFirst  priority: 5检查pwa部署是否成功执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n然后在浏览器输入localhost:4000，查看效果。\n按F12，然后选择Application—&gt;Service Workers，查看是否成功？\n\n成功状态提示：Status #xxx activated and is running\n\n谷歌浏览器安装PWA\n前面的步骤操作没错，配置也没问题，则在本地运行试，浏览器地址栏中会出现一个类似 ➕ 加号的图标，点击它会出现一个弹出框，就说明配置成功，当然你可以选择安装，安装过后桌面会出现一个图标，点击就可以访问，但是如果你本地服务关闭的话，再点击这个图标，有些页面可以访问，但有些页面访问不了。如果需要它都能够全部访问的话，你需要开启本地服务，也就是hexo s\n如果你的地址栏没有出现这个加号，首先在新的标签页上的地址栏输入Chrome://flags，然后再搜索栏输入PWAS进行查找，会出现两个选项一个为Desktop PWAs local updating，另一个为Desktop PWAs installable from the omnibox，将其设为Enabled，然后点击Relaunch，进行浏览器的重启，再查看localhost:4000，就会出现加号了。\n部署到github和coding123sudo hexo cleansudo hexo gsudo hexo d参考资料引用郭元洪\nHexo添加PWA支持\n","plink":"https://dxsummer.gitee.io/posts/805d5d89/"},{"title":"高数例题","date":"2020-05-06T11:11:13.000Z","date_formatted":{"ll":"2020年5月6日","L":"2020/05/06","MM-DD":"05-06"},"updated":"2020-09-19T09:28:57.545Z","content":"9.7方向导数与梯度1\n2\n设f(x,y,z)=x2+y2+z2,求gradf(1,-1,2)及其模\n\n\n9.8多元函数的极值及其求法1\n2\n![](https://i.loli.net/2020/05/08/SE3YZ9O2FiyweGU.png \"|block\")第九章测试1\n2\n3\n10.1二重积分的概念与性质1\n2\n3\n4 √\n10.2二重积分的计算1\n2\n3\n4\n5 √\n11.3格林公式及其应用\n11.4对面积的曲面积分\n11.5对坐标的曲面积分\n","plink":"https://dxsummer.gitee.io/posts/7c5cf7ba/"},{"title":"C语言程序算法","date":"2020-05-04T12:05:29.000Z","date_formatted":{"ll":"2020年5月4日","L":"2020/05/04","MM-DD":"05-04"},"updated":"2020-06-11T15:07:16.162Z","content":"三角形12345678910111213#include &lt;stdio.h&gt;main()&#123;    int a,b,c;    for(a=1;a&lt;6;a++)    &#123;\t        for(b=5;b&gt;=a*2-a;b--)            printf(\" \");        for(b=1;b&lt;=a*2-1;b++)            printf(\"*\");        printf(\"\\n\");    &#125;&#125;输出结果：\n12345    *   ***  ***** ****************对用户输入的任意一组数字，如{2,3,4,3,5,2,7,8,3,4}输出其中出现次数最多的数及次数1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123;    int i,j,n,max,a[1010],b[1010]=&#123;&#125;;    printf(\"要输入多少个数？\");    scanf(\"%d\",&amp;n);    printf(\"请输入\");    for(i=0;i&lt;n;i++)        scanf(\"%d\",&amp;a[i]);    for(i=0;i&lt;n;i++)        for(j=0;j&lt;n;j++)            if(a[i]==a[j])                b[i]++;    max=b[0],j=0;    for(i=0;i&lt;n;i++)        if(b[i]&gt;max)        &#123;            max=b[i];            j=i;        &#125;    printf(\"重复值%d 数量%d\\n\",a[j],max);    return 0;&#125;字符串多组输入，直到遇到回车结束输入\n论他大神给出的解决办法\n\n12string s;while(getline(std::cin,s)&amp;&amp;!s.empty())&#123;&#125;12char s[maxn];while(gets(s)&amp;&amp;strcmp(s,\"\")!=0)&#123;&#125;比较大小12345678910111213141516#include &lt;stdio.h&gt;int main()&#123;\tint a[5]=&#123;5,2,1,8&#125;,i,k,z;\tscanf(\"%d\",a[4]);\tfor(i=0;i&lt;5;i++)\t\tfor(k=i+1;k&lt;5;k++)\t\t\tif(a[i]&gt;a[k])\t\t\t&#123;\t\t\t\tz=a[i];\t\t\t\ta[i]=a[k];\t\t\t\ta[k]=z;\t\t\t&#125;\tfor(k=0;k&lt;5;k++)\tprintf(\"%d\\n\",a[k]);&#125;🍓以二进制形式打印制整数123456789101112131415161718192021222324252627/* binary.c -- 以二进制形式打印制整数 */#include　&lt;stdio.h&gt;void to_binary(unsigned long n);int main(void)&#123;    unsigned long number;    printf(\"Enter　an　integer　(q　to　quit):\\n\");    while(scanf(\"%lu\",&amp;number)　==　1)    &#123;        printf(\"Binary　equivalent:　\");        to_binary(number);        putchar('\\n');        printf(\"Enter　an　integer　(q　to　quit):\\n\");    &#125;    printf(\"Done.\\n\");    return　0;&#125;void to_binary(unsigned long n)　/* 递归函数 */&#123;    int r;    r=n%2;    if(n&gt;=2)    \tto_binary(n/2);    putchar(r==0?'0':'1');    return;&#125;","plink":"https://dxsummer.gitee.io/posts/13623648/"},{"title":"Step2 字符串和格式化输入/输出","date":"2020-04-29T09:02:38.000Z","date_formatted":{"ll":"2020年4月29日","L":"2020/04/29","MM-DD":"04-29"},"updated":"2020-06-08T01:44:53.958Z","content":"本章介绍以下内容：\n  函数：strlen()  关键字：const  字符串  如何创建、存储字符串  如何使用strlen()函数获取字符串的长度  用C预处理器指令#define和ANSIC的const修饰符创建符号常量  \n\n\n本章重点介绍输入和输出。与程序交互和使用字符串可以编写个性化的程序，本章将详细介绍C语言的两个输入/输出函数：printf()和scanf()。学会使用这两个函数，不仅能与用户交互，还可根据个人喜好和任务要求格式化输出。最后，简要介绍一个重要的工具——C预处理器指令，并学习如何定义、使用符号常量。\n\n程序清单4.1 talkback.c程序\n123456789101112131415161718192021// talkback.c -- 演示与用户交互#include &lt;stdio.h&gt;#include &lt;string.h&gt;　　 // 提供strlen()函数的原型#define DENSITY 62.4　　// 人体密度（单位：磅/立方英尺）int main()&#123;    float weight, volume;    int size, letters;    char name[40];　　　 // name是一个可容纳40个字符的数组    printf(\"Hi! What's your first name?\\n\");    scanf(\"%s\", name);    printf(\"%s, what's your weight in pounds?\\n\", name);    scanf(\"%f\", &amp;weight);    size = sizeof name;    letters = strlen(name);    volume = weight / DENSITY;    printf(\"Well, %s, your volume is %2.2f cubic feet.\\n\", name, volume);    printf(\"Also, your first name has %d letters,\\n\", letters);    printf(\"and we have %d bytes to store it.\\n\", size);    return 0;&#125;运行talkback.c程序，输入结果如下：\n1234567Hi! What's your first name?ChristineChristine, what's your weight in pounds?154Well, Christine, your volume is 2.47 cubic feet.Also, your first name has 9 letters,and we have 40 bytes to store it.该程序包含以下新特性。\n用数组（array）储存字符串（character string）。在该程序中，用户输入的名被储存在数组中，该数组占用内存中40个连续的字节，每个字节储存一个字符值。\n使用%s转换说明来处理字符串的输入和输出。注意，在scanf()中，name没有&amp;前缀，而weight有（稍后解释，&amp;weight和name都是地址）。\n用C预处理器把字符常量DENSITY定义为62.4。\n用C函数strlen()获取字符串的长度。\n对于BASIC的输入/输出而言，C的输入/输出看上去有些复杂。不过，复杂换来的是程序的高效和方便控制输入/输出。而且，一旦熟悉用法后，会发现它很简单。\n字符串简介字符串（character string）是一个或多个字符的序列，如下所示：\n1\"Zing went the strings of my heart!\"双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。\nchar类型数组和null字符C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符（见图4.1）。\n注意图4.1中数组末尾位置的字符\\0。这是空字符（null character），C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。因此，程序清单4.1中有40个存储单元的字符串，只能储存39个字符，剩下一个字节留给空字符。\n那么，什么是数组？可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是同类型数据元素的有序序列。程序清单4.1通过以下声明创建了一个包含40个存储单元（或元素）的数组，每个单元储存一个char类型的值：\n1char name[40];name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量。char表明每个元素的类型（见图4.2）。\n字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个放入数组，还要记得在末尾加上一个\\0。还好，计算机可以自己处理这些细节。\n使用字符串试着运行程序清单4.2，使用字符串其实很简单。\n程序清单4.2 praise1.c程序\n1234567891011/* praise1.c -- 使用不同类型的字符串 */#include &lt;stdio.h&gt;#define PRAISE \"You are an extraordinary being.\"int main(void)&#123;    char name[40];    printf(\"What's your name? \");    scanf(\"%s\", name);    printf(\"Hello, %s.%s\\n\", name, PRAISE);    return 0;&#125;%s告诉printf()打印一个字符串。%s出现了两次，因为程序要打印两个字符串：一个储存在name数组中；一个由PRAISE来表示。运行praise1.c，其输出如下所示：\n12What's your name? Angela PlainsHello, Angela.You are an extraordinary being.你不用亲自把空字符放入字符串末尾，scanf()在读取输入时就已完成这项工作。也不用在字符串常量PRAISE末尾添加空字符。稍后我们会解释#define指令，现在先理解PRAISE后面用双引号括起来的文本是一个字符串。编译器会在末尾加上空字符。\n注意（这很重要），scanf()只读取了Angela Plains中的Angela，它在遇到第1个空白（空格、制表符或换行符）时就不再读取输入。因此，scanf()在读到Angela和Plains之间的空格时就停止了。一般而言，根据%s转换说明，scanf()只会读取字符串中的一个单词，而不是一整句。C语言还有其他的输入函数（如，fgets()），用于读取一般字符串。后面章节将详细介绍这些函数。\n字符串和字符字符串常量&quot;x&quot;和字符常量&#39;x&#39;不同。区别之一在于&#39;x&#39;是基本类型（char），而&quot;x&quot;是派生类型（char数组）；区别之二是&quot;x&quot;实际上由两个字符组成：&#39;x&#39;和空字符\\0（见图4.3）。\nstrlen()函数上一章提到了 sizeof 运算符，它以字节为单位给出对象的大小。strlen()函数给出字符串中的字符长度。因为 1 字节储存一个字符，读者可能认为把两种方法应用于字符串得到的结果相同，但事实并非如此。请根据程序清单4.3，在程序清单4.2中添加几行代码，看看为什么会这样。\n程序清单4.3 praise2.c程序\n123456789101112131415161718/* praise2.c */// 如果编译器不识别%zd，尝试换成%u或%lu。#include &lt;stdio.h&gt;#include &lt;string.h&gt;　　/* 提供strlen()函数的原型 */#define PRAISE \"You are an extraordinary being.\"int main(void)&#123;    char name[40];    printf(\"What's your name? \");    scanf(\"%s\", name);    printf(\"Hello, %s.%s\\n\", name, PRAISE);    printf(\"Your name of %zd letters occupies %zd memory cells.\\n\",    strlen(name), sizeof name);    printf(\"The phrase of praise has %zd letters \",    strlen(PRAISE));    printf(\"and occupies %zd memory cells.\\n\", sizeof PRAISE);    return 0;&#125;如果使用ANSI C之前的编译器，必须移除这一行：\n1#include &lt;string.h&gt;string.h头文件包含多个与字符串相关的函数原型，包括strlen()。第11章将详细介绍该头文件（顺带一提，一些ANSI之前的UNIX系统用strings.h代替string.h，其中也包含了一些字符串函数的声明）。\n一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供一个头文件。例如，printf()和scanf()都隶属标准输入和输出函数，使用stdio.h头文件。string.h头文件中包含了strlen()函数和其他一些与字符串相关的函数（如拷贝字符串的函数和字符串查找函数）。\n注意，程序清单4.3使用了两种方法处理很长的printf()语句。第1种方法是将printf()语句分为两行（可以在参数之间断为两行，但是不要在双引号中的字符串中间断开）；第 2 种方法是使用两个printf()语句打印一行内容，只在第2条printf()语句中使用换行符（\\n）。运行该程序，其交互输出如下：\n1234What's your name? Serendipity ChanceHello, Serendipity.You are an extraordinary being.Your name of 11 letters occupies 40 memory cells.The phrase of praise has 31 letters and occupies 32 memory cells.sizeof运算符报告，name数组有40个存储单元。但是，只有前11个单元用来储存Serendipity，所以strlen()得出的结果是11。name数组的第12个单元储存空字符，strlen()并未将其计入。图4.4演示了这个概念。\n对于 PRAISE，用 strlen()得出的也是字符串中的字符数（包括空格和标点符号）。然而，sizeof运算符给出的数更大，因为它把字符串末尾不可见的空字符也计算在内。该程序并未明确告诉计算机要给字符串预留多少空间，所以它必须计算双引号内的字符数。\n第 3 章提到过，C99 和 C11 标准专门为 sizeof 运算符的返回类型添加了%zd 转换说明，这对于strlen()同样适用。对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）。\n另外，还要注意一点：上一章的 sizeof 使用了圆括号，但本例没有。圆括号的使用时机否取决于运算对象是类型还是特定量？运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。尽管如此，还是建议所有情况下都使用圆括号，如sizeof(6.28)。\n程序清单4.3中使用strlen()和sizeof，完全是为了满足读者的好奇心。在实际应用中，strlen()和 sizeof 是非常重要的编程工具。例如，在各种要处理字符串的程序中，strlen()很有用。详见第11章。\n下面我们来学习#define指令。\n常量和C预处理器有时，在程序中要使用常量。例如，可以这样计算圆的周长：\n1circumference &#x3D; 3.14159 * diameter;这里，常量3.14159代表著名的常量pi（π）。在该例中，输入实际值便可使用这个常量。然而，这种情况使用符号常量（symbolic constant）会更好。也就是说，使用下面的语句，计算机稍后会用实际值完成替换：\n1circumference &#x3D; pi * diameter;为什么使用符号常量更好？首先，常量名比数字表达的信息更多。请比较以下两条语句：\n12owed &#x3D; 0.015 * housevalue;owed &#x3D; taxrate * housevalue;如果阅读一个很长的程序，第2条语句所表达的含义更清楚。\n另外，假设程序中的多处使用一个常量，有时需要改变它的值。毕竟，税率通常是浮动的。如果程序使用符号常量，则只需更改符号常量的定义，不用在程序中查找使用常量的地方，然后逐一修改。\n那么，如何创建符号常量？方法之一是声明一个变量，然后将该变量设置为所需的常量。可以这样写：\n123float taxrate;taxrate &#x3D; 0.015;这样做提供了一个符号名，但是taxrate是一个变量，程序可能会无意间改变它的值。C语言还提供了一个更好的方案——C预处理器。第2 章中介绍了预处理器如何使用#include包含其他文件的信息。预处理器也可用来定义常量。只需在程序顶部添加下面一行：\n1#define TAXRATE 0.015编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的替换均已完成（见图 4.5）。通常，这样定义的常量也称为明示常量（manifest constant）[1]。\n请注意格式，首先是#define，接着是符号常量名（TAXRATE），然后是符号常量的值（0.015）（注意，其中并没有=符号）。所以，其通用格式如下：\n1#define NAME value实际应用时，用选定的符号常量名和合适的值来替换NAME和value。注意，末尾不用加分号，因为这是一种由预处理器处理的替换机制。为什么 TAXRATE 要用大写？用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。大写常量只是为了提高程序的可读性，即使全用小写来表示符号常量，程序也能照常运行。尽管如此，初学者还是应该养成大写常量的好习惯。\n另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量（如，c_level或k_line）。\n符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线字符，首字符不能为数字。程序清单4.4演示了一个简单的示例。\n程序清单4.4 pizza.c程序\n1234567891011121314/* pizza.c -- 在比萨饼程序中使用已定义的常量 */#include &lt;stdio.h&gt;#define PI 3.14159int main(void)&#123;    float area, circum, radius;    printf(\"What is the radius of your pizza?\\n\");    scanf(\"%f\", &amp;radius);    area = PI * radius * radius;    circum = 2.0 * PI *radius;    printf(\"Your basic pizza parameters are as follows:\\n\");    printf(\"circumference = %1.2f, area = %1.2f\\n\", circum,area);    return 0;&#125;printf()语句中的%1.2f表明，结果被四舍五入为两位小数输出。下面是一个输出示例：\n1234What is the radius of your pizza?6.0Your basic pizza parameters are as follows:circumference = 37.70, area = 113.10#define指令还可定义字符和字符串常量。前者使用单引号，后者使用双引号。如下所示：\n1234#define BEEP '\\a'#define TEE 'T'#define ESC '\\033'#define OOPS \"Now you have done it!\"记住，符号常量名后面的内容被用来替换符号常量。不要犯这样的常见错误：\n12/* 错误的格式 */#define TOES = 20如果这样做，替换TOES的是= 20，而不是20。这种情况下，下面的语句：\n1digits = fingers + TOES;将被转换成错误的语句：\n1digits = fingers + = 20;const限定符C90标准新增了const关键字，用于限定一个变量为只读（注意，在C语言中，用const类型限定符声明的是变量，不是常量。）\n1const int MONTHS = 12; // MONTHS在程序中不可更改，值为12这使得MONTHS成为一个只读值。也就是说，可以在计算中使用MONTHS，可以打印MONTHS，但是不能更改MONTHS的值。const用起来比#define更灵活，第12章将讨论与const相关的内容。\n明示常量C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息。每个头文件都定义了一系列供实现使用的明示常量 [再次提醒读者注意，本书作者认为“明示常量”相当于“符号常量”，经常在书中混用这两个术语。]。例如，limits.h头文件包含以下类似的代码：\n12#define INT_MAX +32767#define INT_MIN -32768这些明示常量代表int类型可表示的最大值和最小值。如果系统使用32 位的int，该头文件会为这些明示常量提供不同的值。如果在程序中包含limits.h头文件，就可编写下面的代码：\n1printf(\"Maximum int value on this system = %d\\n\", INT_MAX);如果系统使用4字节的int，limits.h头文件会提供符合4字节int的INT_MAX和INT_MIN。表4.1列出了limits.h中能找到的一些明示常量。\n类似地，float.h头文件中也定义一些明示常量，如FLT_DIG和DBL_DIG，分别表示float类型和double类型的有效数字位数。表4.2列出了float.h中的一些明示常量（可以使用文本编辑器打开并查看系统使用的float.h头文件）。表中所列都与float类型相关。把明示常量名中的FLT分别替换成DBL和LDBL，即可分别表示double和long double类型对应的明示常量（表中假设系统使用2的幂来表示浮点数）。\n程序清单4.5演示了如何使用float.h和limits.h中的数据（注意，编译器要完全支持C99标准才能识别LLONG_MIN标识符）。\n程序清单4.5 defines.c程序\n12345678910111213141516// defines.c -- 使用limit.h和float头文件中定义的明示常量#include &lt;stdio.h&gt;#include &lt;limits.h&gt;　 // 整型限制#include &lt;float.h&gt;　　// 浮点型限制int main(void)&#123;    printf(\"Some number limits for this system:\\n\");    printf(\"Biggest int: %d\\n\", INT_MAX);    printf(\"Smallest long long: %lld\\n\", LLONG_MIN);    printf(\"One byte = %d bits on this system.\\n\", CHAR_BIT);    printf(\"Largest double: %e\\n\", DBL_MAX);    printf(\"Smallest normal float: %e\\n\", FLT_MIN);    printf(\"float precision = %d digits\\n\", FLT_DIG);    printf(\"float epsilon = %e\\n\", FLT_EPSILON);    return 0;&#125;该程序的输出示例如下：\n12345678Some number limits for this system:Biggest int: 2147483647Smallest long long: -9223372036854775808One byte = 8 bits on this system.Largest double: 1.797693e+308Smallest normal float: 1.175494e-38float precision = 6 digitsfloat epsilon = 1.192093e-07C预处理器是非常有用的工具，要好好利用它。本书的后面章节中会介绍更多相关应用。\nprintf()和scanf()printf()函数和scanf()函数能让用户可以与程序交流，它们是输入/输出函数，或简称为I/O函数。它们不仅是C语言中的I/O函数，而且是最多才多艺的函数。过去，这些函数和C库的一些其他函数一样，并不是C语言定义的一部分。最初，C把输入/输出的实现留给了编译器的作者，这样可以针对特殊的机器更好地匹配输入/输出。后来，考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()。尽管如此，各版本之间偶尔有一些差异。C90 和C99 标准规定了这些函数的标准版本，本书亦遵循这一标准。\n虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同。两个函数都使用格式字符串和参数列表。我们先介绍printf()，再介绍scanf()。\nprintf()函数请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时使用%d，打印字符时使用%c。这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可显示的形式。我们先列出ANSI C标准为printf()提供的转换说明，然后再示范如何使用一些较常见的转换说明。表4.3列出了一些转换说明和各自对应的输出类型。\n\n使用printf()程序清单4.6的程序中使用了一些转换说明。\n程序清单4.6 printout.c程序\n1234567891011121314/* printout.c -- 使用转换说明 */#include &lt;stdio.h&gt;#define PI 3.141593int main(void)&#123;    int number = 7;    float pies = 12.75;    int cost = 7800;    printf(\"The %d contestants ate %f berry pies.\\n\", number,pies);    printf(\"The value of pi is %f.\\n\", PI);    printf(\"Farewell! thou art too dear for my possessing,\\n\");    printf(\"%c%d\\n\", '$', 2 * cost);    return 0;&#125;该程序的输出如下：\n1234The 7 contestants ate 12.750000 berry pies.The value of pi is 3.141593.Farewell! thou art too dear for my possessing,$15600这是printf()函数的格式：\n1printf( 格式字符串, 待打印项1, 待打印项2,...);待打印项1、待打印项2等都是要打印的项。它们可以是变量、常量，甚至是在打印之前先要计算的表达式。第3章提到过，格式字符串应包含每个待打印项对应的转换说明。例如，考虑下面的语句：\n1printf(\"The %d contestants ate %f berry pies.\\n\", number,pies);格式字符串是双引号括起来的内容。上面语句的格式字符串包含了两个待打印项number和poes对应的两个转换说明。图4.6演示了printf()语句的另一个例子。\n下面是程序清单4.6中的另一行：\n1printf(\"The value of pi is %f.\\n\", PI);该语句中，待打印项列表只有一个项——符号常量PI。\n如图4.7所示，格式字符串包含两种形式不同的信息：实际要打印的字符；转换说明。\n警告\n格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。千万别写成下面这样：\n1printf(\"The score was Squids %d, Slugs %d.\\n\", score1);这里，第2个%d没有对应任何项。系统不同，导致的结果也不同。不过，出现这种问题最好的状况是得到无意义的值。\n如果只打印短语或句子，就不需要使用任何转换说明。如果只打印数据，也不用加入说明文字。程序清单4.6中的最后两个printf()语句都没问题：\n12printf(\"Farewell! thou art too dear for my possessing,\\n\");printf(\"%c%d\\n\", '$', 2 * cost);注意第2条语句，待打印列表的第1个项是一个字符常量，不是变量；第2个项是一个乘法表达式。这说明printf()使用的是值，无论是变量、常量还是表达式的值。\n由于 printf()函数使用%符号来标识转换说明，因此打印%符号就成了个问题。如果单独使用一个%符号，编译器会认为漏掉了一个转换字符。解决方法很简单，使用两个%符号就行了：\n12pc = 2*6;printf(\"Only %d%% of Sally's gribbles were edible.\\n\", pc);下面是输出结果：\n1Only 12% of Sally's gribbles were edible.printf()的转换说明修饰符在%和转换字符之间插入修饰符可修饰基本的转换说明。表4.4和表4.5列出可作为修饰符的合法字符。如果要插入多个字符，其书写顺序应该与表4.4中列出的顺序相同。不是所有的组合都可行。表中有些字符是C99新增的，如果编译器不支持C99，则可能不支持表中的所有项。\n\n注意 类型可移植性\nsizeof 运算符以字节为单位返回类型或值的大小。这应该是某种形式的整数，但是标准只规定了该值是无符号整数。在不同的实现中，它可以是unsigned int、unsigned long甚至是unsigned long long。因此，如果要用printf()函数显示sizeof表达式，根据不同系统，可能使用%u、%lu或%llu。这意味着要查找你当前系统的用法，如果把程序移植到不同的系统还要进行修改。鉴于此， C提供了可移植性更好的类型。首先，stddef.h头文件（在包含stdio.h头文件时已包含其中）把size_t定义成系统使用sizeof返回的类型，这被称为底层类型（underlying type）。其次，printf()使用z修饰符表示打印相应的类型。同样，C还定义了ptrdiff_t类型和t修饰符来表示系统使用的两个地址差值的底层有符号整数类型。\n注意 float参数的转换对于浮点类型，有用于double和long double类型的转换说明，却没有float类型的。这是因为在K&amp;R C中，表达式或参数中的float类型值会被自动转换成double类型。一般而言，ANSI C不会把float自动转换成double。然而，为保护大量假设float类型的参数被自动转换成double的现有程序，printf()函数中所有float类型的参数（对未使用显式原型的所有C函数都有效）仍自动转换成double类型。因此，无论是K&amp;R C还是ANSI C，都没有显示float类型值专用的转换说明。\n\n使用修饰符和标记的示例接下来，用程序示例演示如何使用这些修饰符和标记。先来看看字段宽度在打印整数时的效果。考虑程序清单4.7中的程序。\n程序清单4.7 width.c程序\n1234567891011/* width.c -- 字段宽度 */#include &lt;stdio.h&gt;#define PAGES 959int main(void)&#123;    printf(\"*%d*\\n\", PAGES);    printf(\"*%2d*\\n\", PAGES);    printf(\"*%10d*\\n\", PAGES);    printf(\"*%-10d*\\n\", PAGES);    return 0;&#125;程序清单4.7通过4种不同的转换说明把相同的值打印了4次。程序中使用星号（*）标出每个字段的开始和结束。其输出结果如下所示：\n1234*959**959**　　 959**959　　 *第1个转换说明%d不带任何修饰符，其对应的输出结果与带整数字段宽度的转换说明的输出结果相同。在默认情况下，没有任何修饰符的转换说明，就是这样的打印结果。\n第2个转换说明是%2d，其对应的输出结果应该是 2 字段宽度。因为待打印的整数有 3 位数字，所以字段宽度自动扩大以符合整数的长度。\n第 3个转换说明是%10d，其对应的输出结果有10个空格宽度，实际上在两个星号之间有7个空格和3位数字，并且数字位于字段的右侧。\n最后一个转换说明是%-10d，其对应的输出结果同样是 10 个空格宽度，-标记说明打印的数字位于字段的左侧。熟悉它们的用法后，能很好地控制输出格式。试着改变PAGES的值，看看编译器如何打印不同位数的数字。\n\n接下来看看浮点型格式。请输入、编译并运行程序清单4.8中的程序。\n\n程序清单4.8 floats.c程序\n123456789101112131415// floats.c -- 一些浮点型修饰符的组合#include &lt;stdio.h&gt;int main(void)&#123;    const double RENT = 3852.99;　// const变量    printf(\"*%f*\\n\", RENT);    printf(\"*%e*\\n\", RENT);    printf(\"*%4.2f*\\n\", RENT);    printf(\"*%3.1f*\\n\", RENT);    printf(\"*%10.3f*\\n\", RENT);    printf(\"*%10.3E*\\n\", RENT);    printf(\"*%+4.2f*\\n\", RENT);    printf(\"*%010.2f*\\n\", RENT);    return 0;&#125;该程序中使用了const关键字，限定变量为只读。该程序的输出如下：\n12345678*3852.990000**3.852990e+03**3852.99**3853.0**　3852.990** 3.853E+03**+3852.99**0003852.99*本例的第1个转换说明是%f。在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，即字段宽度是容纳带打印数字所需的位数和小数点后打印6位数字。\n第2个转换说明是%e。默认情况下，编译器在小数点的左侧打印1个数字，在小数点的右侧打印6个数字。这样打印的数字太多！解决方案是指定小数点右侧显示的位数，程序中接下来的 4 个例子就是这样做的。请注意，第4个和第6个例子对输出结果进行了四舍五入。另外，第6个例子用E代替了e。\n第7个转换说明中包含了+标记，这使得打印的值前面多了一个代数符号（+）。0标记使得打印的值前面以0填充以满足字段要求。注意，转换说明%010.2f的第1个0是标记，句点（.）之前、标记之后的数字（本例为10）是指定的字段宽度。尝试修改RENT的值，看看编译器如何打印不同大小的值。程序清单4.9演示了其他组合。\n程序清单4.9 flags.c程序\n123456789/* flags.c -- 演示一些格式标记 */#include &lt;stdio.h&gt;int main(void)&#123;    printf(\"%x %X %#x\\n\", 31, 31, 31);    printf(\"**%d**% d**% d**\\n\", 42, 42, -42);    printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\", 6, 6, 6, 6);    return 0;&#125;该程序的输出如下：\n1231f 1F 0x1f**42** 42**-42****　 6** 006**00006** 006**第1行输出中，1f是十六进制数，等于十进制数31。第1行printf()语句中，根据%x打印出1f，%F打印出1F，%#x打印出0x1f。\n第 2 行输出演示了如何在转换说明中用空格在输出的正值前面生成前导空格，负值前面不产生前导空格。这样的输出结果比较美观，因为打印出来的正值和负值在相同字段宽度下的有效数字位数相同。\n第3行输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被忽略。\n\n下面来看看字符串格式的示例。考虑程序清单4.10中的程序。\n\n程序清单4.10 stringf.c程序\n1234567891011/* stringf.c -- 字符串格式 */#include &lt;stdio.h&gt;#define BLURB \"Authentic imitation!\"int main(void)&#123;    printf(\"[%2s]\\n\", BLURB);    printf(\"[%24s]\\n\", BLURB);    printf(\"[%24.5s]\\n\", BLURB);    printf(\"[%-24.5s]\\n\", BLURB);    return 0;&#125;该程序的输出如下：\n1234[Authentic imitation!][　　Authentic imitation!][　　　　　　　　　　Authe][Authe　　　　　　　　　　]注意，虽然第1个转换说明是%2s，但是字段被扩大为可容纳字符串中的所有字符。还需注意，精度限制了待打印字符的个数。.5告诉printf()只打印5个字符。另外，-标记使得文本左对齐输出。\n学以致用学习完以上几个示例，试试如何用一个语句打印以下格式的内容：\n1The NAME family just may be $XXX.XX dollars richer!这里，NAME和XXX.XX代表程序中变量（如name[40]和cash）的值。可参考以下代码：\n1printf(\"The %s family just may be $%.2f richer!\\n\",name,cash);转换说明的意义下面深入探讨一下转换说明的意义。转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。%d转换说明将其转换成字符7和6，并显示为76；%x转换说明把相同的值（01001100）转换成十六进制记数法4c；%c转换说明把01001100转换成字符L。\n转换（conversion）可能会误导读者认为原始值被转替换成转换后的值。实际上，转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来”。\n转换不匹配\n前面强调过，转换说明应该与待打印值的类型相匹配。通常都有多种选择。例如，如果要打印一个int类型的值，可以使用%d、%x或%o。这些转换说明都可用于打印int类型的值，其区别在于它们分别表示一个值的形式不同。类似地，打印double类型的值时，可使用%f、%e或%g。\n转换说明与待打印值的类型不匹配会怎样？上一章中介绍过不匹配导致的一些问题。匹配非常重要，一定要牢记于心。程序清单4.11演示了一些不匹配的整型转换示例。\n程序清单4.11 intconv.c程序\n1234567891011121314/* intconv.c -- 一些不匹配的整型转换 */#include &lt;stdio.h&gt;#define PAGES 336#define WORDS 65618int main(void)&#123;    short num = PAGES;    short mnum = -PAGES;    printf(\"num as short and unsigned short:　%hd %hu\\n\", num,num);    printf(\"-num as short and unsigned short: %hd %hu\\n\", mnum,mnum);    printf(\"num as int and char: %d %c\\n\", num, num);    printf(\"WORDS as int, short, and char: %d %hd %c\\n\",WORDS,WORDS, WORDS);    return 0;&#125;在我们的系统中，该程序的输出如下：\n1234num as short and unsigned short: 336 336-num as short and unsigned short: -336 65200num as int and char: 336 PWORDS as int, short, and char: 65618 82 R请看输出的第1行，num变量对应的转换说明%hd和%hu输出的结果都是336。这没有任何问题。\n然而，第2行mnum变量对应的转换说明%u（无符号）输出的结果却为65200，并非期望的336。这是由于有符号short int类型的值在我们的参考系统中的表示方式所致。首先，short int的大小是2字节；其次，系统使用二进制补码来表示有符号整数。这种方法，数字0～32767代表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534表示-2，以此类推。因此，-336表示为65200（即， 65536-336）。所以被解释成有符号int时，65200代表-336；而被解释成无符号int时，65200则代表65200。一定要谨慎！一个数字可以被解释成两个不同的值。尽管并非所有的系统都使用这种方法来表示负整数，但要注意一点：别期望用%u转换说明能把数字和符号分开。\n第3行演示了如果把一个大于255的值转换成字符会发生什么情况。在我们的系统中，short int是2字节，char是1字节。当printf()使用%c打印336时，它只会查看储存336的2字节中的后1字节。这种截断（见图4.8）相当于用一个整数除以256，只保留其余数。在这种情况下，余数是80，对应的ASCII值是字符P。用专业术语来说，该数字被解释成“以256为模”（modulo 256），即该数字除以256后取其余数。\n最后，我们在该系统中打印比short int类型最大整数（32767）更大的整数（65618）。这次，计算机也进行了求模运算。在本系统中，应把数字65618储存为4字节的int类型值。用%hd转换说明打印时， printf()只使用最后2个字节。这相当于65618除以65536的余数。这里，余数是82。鉴于负数的储存方法，如果余数在32767～65536范围内会被打印成负数。对于整数大小不同的系统，相应的处理行为类似，但是产生的值可能不同。\n总结\n当遇到溢出问题，为：**该数字模除256后取其余数**混淆整型和浮点型，结果更奇怪。考虑程序清单4.12。\n程序清单4.12 floatcnv.c程序\n12345678910111213/* floatcnv.c -- 不匹配的浮点型转换 */#include &lt;stdio.h&gt;int main(void)&#123;    float n1 = 3.0;    double n2 = 3.0;    long n3 = 2000000000;    long n4 = 1234567890;    printf(\"%.1e %.1e %.1e %.1e\\n\", n1, n2, n3, n4);    printf(\"%ld %ld\\n\", n3, n4);    printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);    return 0;&#125;在我们的系统中，该程序的输出如下：\n1233.0e+00 3.0e+00 3.1e+46 1.7e+2662000000000 12345678900 1074266112 0 1074266112第1行输出显示，%e转换说明没有把整数转换成浮点数。\n考虑一下，如果使用%e转换说明打印n3（long类型）会发生什么情况。首先，%e转换说明让printf()函数认为待打印的值是double类型（本系统中double为8字节）。当printf()查看n3（本系统中是4字节的值）时，除了查看n3的4字节外，还会查看查看n3相邻的4字节，共8字节单元。接着，它将8字节单元中的位组合解释成浮点数（如，把一部分位组合解释成指数）。因此，即使n3的位数正确，根据%e转换说明和%ld转换说明解释出来的值也不同。最终得到的结果是无意义的值。\n第1行也说明了前面提到的内容：float类型的值作为printf()参数时会被转换成double类型。在本系统中，float是4字节，但是为了printf()能正确地显示该值，n1被扩成8字节。\n第2行输出显示，只要使用正确的转换说明，printf()就可以打印n3和n4。\n第3行输出显示，如果printf()语句有其他不匹配的地方，即使用对了转换说明也会生成虚假的结果。用%ld转换说明打印浮点数会失败，但是在这里，用%ld打印long类型的数竟然也失败了！问题出在C如何把信息传递给函数。具体情况因编译器实现而异。“参数传递”框中针对一个有代表性的系统进行了讨论。\n\n参数传递\n\n参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原理。函数调用如下：\n1printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);该调用告诉计算机把变量n1、n2、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。\n12345float n1; /* 作为double类型传递 */double n2;long n3, n4;...printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);printf()的返回值第2章提到过，大部分C函数都有一个返回值，这是函数计算并返回给主调程序（calling program）的值。例如，C库包含一个sqrt()函数，接受一个数作为参数，并返回该数的平方根。可以把返回值赋给变量，也可以用于计算，还可以作为参数传递。总之，可以把返回值像其他值一样使用。printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值（printf()的旧版本会返回不同的值）。\nprintf()的返回值是其打印输出功能的附带用途，通常很少用到，但在检查输出错误时可能会用到（如，在写入文件时很常用）。如果一张已满的CD或DVD拒绝写入时，程序应该采取相应的行动，例如终端蜂鸣30秒。不过，要实现这种情况必须先了解if语句。程序清单4.13演示了如何确定函数的返回值。\n程序清单4.13 prntval.c程序\n12345678910/* prntval.c -- printf()的返回值 */#include &lt;stdio.h&gt;int main(void)&#123;    int bph2o = 212;    int rv;    rv = printf(\"%d F is water's boiling point.\\n\", bph2o);    printf(\"The printf() function printed %d characters.\\n\",rv);    return 0;&#125;该程序的输出如下：\n12212 F is water's boiling point.The printf() function printed 32 characters.首先，程序用rv = printf(...);的形式把printf()的返回值赋给rv。因此，该语句执行了两项任务：打印信息和给变量赋值。其次，注意计算针对所有字符数，包括空格和不可见的换行符（\\n）。\n打印较长的字符串有时，printf()语句太长，在屏幕上不方便阅读。如果空白（空格、制表符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。例如，程序清单4.13中的一条printf()语句：\n12printf(\"The printf() function printed %d characters.\\n\",rv);该语句在逗号和 rv之间断行。为了让读者知道该行未完，示例缩进了 rv。C编译器会忽略多余的空白。\n但是，不能在双引号括起来的字符串中间断行。如果这样写：\n12printf(\"The printf() function printed %dcharacters.\\n\", rv);C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\\n来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行符。\n给字符串断行有3种方法，如程序清单4.14所示。\n12345678910111213141516程序清单4.14 longstrg.c程序/* longstrg.c ––打印较长的字符串 */\\#include &lt;stdio.h&gt;int main(void)&#123;    printf(\"Here's one way to print a \");\t//方法1    printf(\"long string.\\n\");        printf(\"Here's another way to print a \\long string.\\n\");\t//方法2        printf(\"Here's the newest way to print a \"\"long string.\\n\");　　/* ANSI C */    return 0;&#125;该程序的输出如下：\n123Here's one way to print a long string.Here's another way to print a long string.Here's the newest way to print a long string.方法1：使用多个printf()语句。因为第1个字符串没有以\\n字符结束，所以第2个字符串紧跟第1个字符串末尾输出。\n方法2：用反斜杠（\\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。\n方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。因此，以下3种形式是等效的：\n123456printf(\"Hello, young lovers, wherever you are.\");printf(\"Hello, young \"　　 \"lovers\" \", wherever you are.\");printf(\"Hello, young lovers\"\", wherever you are.\");上述方法中，要记得在字符串中包含所需的空格。如，&quot;young&quot;&quot;lovers&quot;会成为&quot;younglovers&quot;，而&quot;young &quot; &quot;lovers&quot;才是&quot;young lovers&quot;。\n使用scanf()刚学完输出，接下来我们转至输入——学习scanf()函数。C库包含了多个输入函数，scanf()是最通用的一个，因为它可以读取不同格式的数据。当然，从键盘输入的都是文本，因为键盘只能生成文本字符：字母、数字和标点符号。如果要输入整数 2014，就要键入字符 2、0、1、4。如果要将其储存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的。scanf()把输入的字符串转换成整数、浮点数、字符或字符串，而 printf()正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。\nscanf()和 printf()类似，也使用格式字符串和参数列表。scanf()中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。printf()函数使用变量、常量和表达式，而scanf()函数使用指向变量的指针。\n这里，读者不必了解如何使用指针，只需记住以下两条简单的规则：\n如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;；\n如果用scanf()把字符串读入字符数组中，不要使用&amp;。\n程序清单4.15中的小程序演示了这两条规则。\n12345678910111213141516程序清单4.15 input.c程序// input.c -- 何时使用&amp;\\#include &lt;stdio.h&gt;int main(void)&#123;    int age;　　　　　 // 变量    float assets;　　　// 变量    char pet[30];　　　// 字符数组，用于储存字符串    printf(\"Enter your age, assets, and favorite pet.\\n\");    scanf(\"%d %f\", &amp;age, &amp;assets); // 这里要使用&amp;    scanf(\"%s\", pet);　　　　　　　 // 字符数组不使用&amp;    printf(\"%d $%.2f %s\\n\", age, assets, pet);    return 0;&#125;下面是该程序与用户交互的示例：\n1234Enter your age, assets, and favorite pet.3892360.88 llama38 $92360.88 llamascanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。注意，上面示例的输入项（粗体部分是用户的输入）分成了两行。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入：\n12345Enter your age, assets, and favorite pet.422121.45guppy42 $2121.45 guppy唯一例外的是%c转换说明。根据%c，scanf()会读取每个字符，包括空白。我们稍后详述这部分。\nscanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。表4.6列出了C99标准中常用的转换说明。\n表4.6 ANSI C中scanf()的转换说明\n可以在表4.6所列的转换说明中（百分号和转换字符之间）使用修饰符。如果要使用多个修饰符，必须按表4.7所列的顺序书写。\n表4.7 scanf()转换说明中的修饰符\n\n如你所见，使用转换说明比较复杂，而且这些表中还省略了一些特性。省略的主要特性是，从高度格式化源中读取选定数据，如穿孔卡或其他数据记录。因为在本书中，scanf()主要作为与程序交互的便利工具，所以我们不在书中讨论更复杂的特性。\n1.从scanf()角度看输入\n接下来，我们更详细地研究scanf()怎样读取输入。假设scanf()根据一个%d转换说明读取一个整数。scanf()函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取整数，所以 scanf()希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf()不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后，scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。\n如果使用字段宽度，scanf()会在字段结尾或第1个空白字符处停止读取（满足两个条件之一便停止）。\n如果第1个非空白字符是A而不是数字，会发生什么情况？scanf()将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明， scanf()就一直无法越过A读下一个字符。另外，如果使用带多个转换说明的scanf()，C规定在第1个出错处停止读取输入。\n用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于 scanf()会把更多字符识别成数字的一部分。例如，%x转换说明要求scanf()识别十六进制数a～f和A～F。浮点转换说明要求scanf()识别小数点、e记数法（指数记数法）和新增的p记数法（十六进制指数记数法）。\n如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串。如果使用字段宽度，scanf()在字段末尾或第1个空白字符处停止读取。无法利用字段宽度让只有一个%s的scanf()读取多个单词。最后要注意一点：当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上&#39;\\0&#39;，让数组中的内容成为一个C字符串。\n实际上，在C语言中scanf()并不是最常用的输入函数。这里重点介绍它是因为它能读取不同类型的数据。C 语言还有其他的输入函数，如 getchar()和 fgets()。这两个函数更适合处理一些特殊情况，如读取单个字符或包含空格的字符串。我们将在第7章、第11章、第13章中讨论这些函数。目前，无论程序中需要读取整数、小数、字符还是字符串，都可以使用scanf()函数。\n格式字符串中的普通字符scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号：\n1scanf(\"%d,%d\", &amp;n, &amp;m);scanf()函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数：\n188,121由于格式字符串中，%d后面紧跟逗号，所以必须在输入88后再输入一个逗号。但是，由于scanf()会跳过整数前面的空白，所以下面两种输入方式都可以：\n188, 121和\n1288,121格式字符串中的空白意味着跳过下一个输入项前面的所有空白。例如，对于下面的语句：\n1scanf(\"%d ,%d\", &amp;n, &amp;m);以下的输入格式都没问题：\n12388,12188 ,12188 , 121请注意，“所有空白”的概念包括没有空格的特殊情况。\n除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。因此，scanf(&quot;%d%d&quot;, &amp;n, &amp;m)与scanf(&quot;%d %d&quot;, &amp;n, &amp;m)的行为相同。对于%c，在格式字符串中添加一个空格字符会有所不同。例如，如果把%c放在格式字符串中的空格前面，scanf()便会跳过空格，从第1个非空白字符开始读取。也就是说，\n🍖scanf(&quot;%c&quot;, &amp;ch)从输入中的第1个字符开始读取，而scanf(&quot; %c&quot;, &amp;ch)则从第1个非空白字符开始读取。\nscanf()的返回值scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。我们将在第6章中讨论文件结尾的相关内容以及如何利用scanf()的返回值。在读者学会if语句和while语句后，便可使用scanf()的返回值来检测和处理不匹配的输入。\nprintf()和scanf()的*修饰符printf()和scanf()都可以使用*修饰符来修改转换说明的含义。但是，它们的用法不太一样。首先，我们来看printf()的*修饰符。\n如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这个技巧也可用于浮点值指定精度和字段宽度。程序清单4.16演示了相关用法。\n123456789101112131415161718程序清单4.16 varwid.c程序/* varwid.c -- 使用变宽输出字段 */\\#include &lt;stdio.h&gt;int main(void)&#123;    unsigned width, precision;    int number = 256;    double weight = 242.5;    printf(\"Enter a field width:\\n\");    scanf(\"%d\", &amp;width);    printf(\"The number is :%*d:\\n\", width, number);    printf(\"Now enter a width and a precision:\\n\");    scanf(\"%d %d\", &amp;width, &amp;precision);    printf(\"Weight = %*.*f\\n\", width, precision, weight);    printf(\"Done!\\n\");    return 0;&#125;变量width提供字段宽度，number是待打印的数字。因为转换说明中*在d的前面，所以在printf()的参数列表中，width在number的前面。同样，width和precision提供打印weight的格式化信息。下面是一个运行示例：\n1234567Enter a field width:6The number is : 256:Now enter a width and a precision:8 3Weight = 242.500Done!这里，用户首先输入6，因此6是程序使用的字段宽度。类似地，接下来用户输入8和3，说明字段宽度是8，小数点后面显示3位数字。一般而言，程序应根据weight的值来决定这些变量的值。\nscanf()中*的用法与此不同。把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项。程序清单4.17就是一个例子。\n程序清单4.17 skip2.c程序\n1234567891011/* skiptwo.c -- 跳过输入中的前两个整数 */\\#include &lt;stdio.h&gt;int main(void)&#123;    int n;    printf(\"Please enter three integers:\\n\");    scanf(\"%*d %*d %d\", &amp;n);    printf(\"The last integer was %d\\n\", n);    return 0;&#125;程序清单4.17中的scanf()指示：跳过两个整数，把第3个整数拷贝给n。下面是一个运行示例：\n123Please enter three integers:2013 2014 2015The last integer was 2015在程序需要读取文件中特定列的内容时，这项跳过功能很有用。\nprintf()的用法提示想把数据打印成列，指定固定字段宽度很有用。因为默认的字段宽度是待打印数字的宽度，如果同一列中打印的数字位数不同，那么下面的语句：\n1printf(\"%d %d %d\\n\", val1, val2, val3);打印出来的数字可能参差不齐。例如，假设执行3次printf()语句，用户输入不同的变量，其输出可能是这样：\n12312 234 12224 5 2322334 2322 10001使用足够大的固定字段宽度可以让输出整齐美观。例如，若使用下面的语句：\n1printf(\"%9d %9d %9d\\n\", val1, val2, val3);上面的输出将变成：\n123   12　　 　234　　　1222    4　　　 　5　　 　2322334　　  2322　　 10001在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟该数字一起输出（这样两个数字看起来像是一个数字）。这是因为格式字符串中的普通字符（包括空格）会被打印出来。\n另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适，没有不必要的空白。例如，下面的语句：\n1printf(\"Count Beppo ran %.2f miles in 3 hours.\\n\", distance);其输出如下：\n1Count Beppo ran 10.22 miles in 3 hours.如果把转换说明改为%10.2f，则输出如下：\n1Count Beppo ran　　 10.22 miles in 3 hours.本地化设置\n美国和世界上的许多地区都使用一个点来分隔十进制值的整数部分和小数部分，如3.14159。然而，许多其他地区用逗号来分隔，如 3,14159。读者可能注意到了，printf()和 scanf()都没有提供逗号的转换说明。C语言考虑了这种情况。本书附录B的参考资料V中介绍了C支持的本地化概念，因此C程序可以选择特定的本地化设置。例如，如果指定了荷兰语言环境，printf()和scanf()在显示和读取浮点值时会使用本地惯例（在这种情况下，用逗号代替点分隔浮点值的整数部分和小数部分）。另外，一旦指定了环境，便可在代码的数字中使用逗号：\n1double pi &#x3D; 3,14159; &#x2F;&#x2F; 荷兰本地化设置C标准有两个本地化设置：”C“和” “（空字符串）。默认情况下，程序使用”C”本地化设置，基本上符合美国的用法习惯。而””本地化设置可以替换当前系统中使用的本地语言环境。原则上，这与”C”本地化设置相同。事实上，大部分操作系统（如UNIX、Linux和Windows）都提供本地化设置选项列表，只不过它们提供的列表可能不同。\n关键概念C语言用char类型表示单个字符，用字符串表示字符序列。字符常量是一种字符串形式，即用双引号把字符括起来：”Good luck, my friend”。可以把字符串储存在字符数组（由内存中相邻的字节组成）中。字符串，无论是表示成字符常量还是储存在字符数组中，都以一个叫做空字符的隐藏字符结尾。\n在程序中，最好用#define 定义数值常量，用 const 关键字声明的变量为只读变量。在程序中使用符号常量（明示常量），提高了程序的可读性和可维护性。\nC 语言的标准输入函数（scanf()）和标准输出函数（printf()）都使用一种系统。在该系统中，第1个参数中的转换说明必须与后续参数中的值相匹配。例如，int转换说明%d与一个浮点值匹配会产生奇怪的结果。必须格外小心，确保转换说明的数量和类型与函数的其余参数相匹配。对于scanf()，一定要记得在变量名前加上地址运算符（&amp;）。\n空白字符（制表符、空格和换行符）在 scanf()处理输入时起着至关重要的作用。除了%c 模式（读取下一个字符），scanf()在读取输入时会跳过非空白字符前的所有空白字符，然后一直读取字符，直至遇到空白字符或与正在读取字符不匹配的字符。考虑一下，如果scanf()根据不同的转换说明读取相同的输入行，会发生什么情况。假设有如下输入行：\n1-13.45e12# 0\t//`-`前面有空格如果其对应的转换说明是%d，scanf()会读取3个字符（-13）并停在小数点处，小数点将被留在输入中作为下一次输入的首字符。如果其对应的转换说明是%f，scanf()会读取-13.45e12，并停在#符号处，而#将被留在输入中作为下一次输入的首字符；然后，scanf()把读取的字符序列-13.45e12转换成相应的浮点值，并储存在float类型的目标变量中。如果其对应的转换说明是%s，scanf()会读取-13.45e12#，并停在空格处，空格将被留在输入中作为下一次输入的首字符；然后，scanf()把这 10个字符的字符码储存在目标字符数组中，并在末尾加上一个空字符。如果其对应的转换说明是%c，scanf()只会读取并储存第1个字符，该例中是一个空格 \n本章小结字符串是一系列被视为一个处理单元的字符。在C语言中，字符串是以空字符（ASCII码是0）结尾的一系列字符。可以把字符串储存在字符数组中。数组是一系列同类型的项或元素。下面声明了一个名为name、有30个char类型元素的数组：\n1char name[30];要确保有足够多的元素来储存整个字符串（包括空字符）。\n字符串常量是用双引号括起来的字符序列，如：&quot;This is an example of a string&quot;。\nscanf()函数（声明在string.h头文件中）可用于获得字符串的长度（末尾的空字符不计算在内）。scanf()函数中的转换说明是%s时，可读取一个单词。\nC预处理器为预处理器指令（以#符号开始）查找源代码程序，并在开始编译程序之前处理它们。处理器根据#include指令把另一个文件中的内容添加到该指令所在的位置。#define指令可以创建明示常量（符号常量），即代表常量的符号。limits.h和float.h头文件用#define定义了一组表示整型和浮点型不同属性的符号常量。另外，还可以使用const限定符创建定义后就不能修改的变量。\nprintf()和scanf()函数对输入和输出提供多种支持。两个函数都使用格式字符串，其中包含的转换说明表明待读取或待打印数据项的数量和类型。另外，可以使用转换说明控制输出的外观：字段宽度、小数位和字段内的布局。\n","plink":"https://dxsummer.gitee.io/posts/2a5471de/"},{"title":"英语笔记","date":"2020-04-26T01:22:05.000Z","date_formatted":{"ll":"2020年4月26日","L":"2020/04/26","MM-DD":"04-26"},"updated":"2020-07-23T10:16:06.016Z","content":"及物动词、不及物动词英语是以【动词】为核心的语言。探索语法的起步阶段，必须不厌其烦地分析动词。\n按各种不同的标准来分类动词，会带给我们清晰的视野。\n及物动词与不及物动词，来源于这样的分类标准：\n有些动词自身词义完整，比如：游泳swim， 睡觉sleep。\nI swim. 我游泳。 swim 没有【受者】\nHe sleeps. 他睡觉。 sleep 没有【受者】\n这类的动词， 不需要 【受者】。\n\n有些动词必须要有【受者】，比如：喜欢like， 想要want。\nI like him. 我喜欢。 如果like没有【受者】，句子不完整。\nHe wants some money. 他想要一些钱。 如果want没有【受着】，句子不完整。\n这类动词，必须要【 受者】。\n\n不需要【受者】的动词，叫做 不及物动词（vi.)\n需要【受者】的动词，叫做 及物动词(vt.)\n\n分类的意义何在？写正确的句子。\n有些动词，只具备及物动词词性\n这意味着，句子没有出现【受者】，句子错误。\n错误的句子：I like.\n正确的句子：I like it. 及物动词后一定要出现【受者】\n\n有些动词，只具备不及物动词词性\n这意味着，句子出现了【受者】，句子错误。\n错误的句子：I wait you. 正确的句子：I wait.\n那，这时候根据句子要表达的含义，不及物动词后要接【受者】，解决这个问题，虚词———介词登场了。\n 不及物动词+介词 = 及物动词 介词有词义，同一个不及物动词 + 不同的介词 ，表达的是不一样的含义呢，这个另起一篇文章讲吧。\n 我等你，正确的句子是：I wait for you.\n 这样的句子中，介词没有，错！\n wait 后用的不是for，而是别的介词，还是错！\n （题外话再说一句—– 业界也有称英文是以介词为核心的语言。不及物动词这样的用法是原因之一，其它的原因，再看我写的关于介词的文章吧，关注此专栏，敬请期待，不会让你失望。）\n\n有些动词，既具备不及物动词词性，又具备及物动词词性，两种词性下，词义相同。 （这样的用法，我们太喜欢啦）\nI am reading now. “read” 没有【受者】 不及物动词 词义”阅读”\nI am reading a newspaper now. “read” 有【受者】 及物动词 词义还是”阅读”\n\n最复杂，最烦人的这类动词来了，偏偏这一类动词很多呀这一类动词，既具备不及物动词词性， 又具备及物动词词性，两种词性下，词义非常的不同 （这就是词法啦，量的积累要靠时间支持）\n\n\n\nI got a book.get 及物动词 词义”得到”\n\nI got to the zoo.get 不及物动词 词义”到达”\n\nThey are moving the bookcase.move 及物动词 词义”移动””挪动”\n\nThey moved.move 不及物动词 词义”搬家”\n\nThey moved into the new house.move不及物动词 词义”搬家”\n\nThey are playing the piano.play 及物动词 词义”弹，玩”\n\nThey are playing.play 不及物动词 词义”玩耍”\n\nThey played with the children.play 不及物动词 词义”玩耍”\n\n情态动词+动词原型\n英语中有3个基本助动词: \n\n基本助动词\n\n1be\n\n2do\n\n3have be+doing表进行;be+done 表被动;have+done    表完成等。\n\nbe+to do表既定计划;do+do 表强调;\nbe动词作助动词由连系动词am，is， are构成的句子:变一般疑问句时把am，is， are提到句子的前面，句尾用问号即可。变否定句时直接在am，is, are后面加not即可。肯定句:     He is a student.一般疑问句:     Is he a student?否定句:     He is not a student.\n\nwas是am，is的过 去式，were是are的过去式，若句子中有以上两词时，变疑问句及否定句方法与1相同。\n\n情态动词作助动词由情态动词can，may， will， shall等 构成的句子:变一般疑问句时把can，may,will，shall提到句子的前面，句尾用问号即可。变否定句时直接在can，may， 后面加not即可。肯定句: She can swim.一般疑问句: Can she swim?否定句: She can not swim.\n\ncould，might， would， should是can， may，will， sha11的过去式，若句子中有以上两词时，变疑问句及否定句方法与1相同。\n\ndo作为助动词由行为动词构成的句子: 需要加助词do或does。变一般疑问句时把do/ does放在句子前面，变否定句时把 don’t / doesn’ t 放在动词的前面。要注意观察动词的形式并对号入座。一般疑问句和否定句的动词三单式都要变回原型。\n\nplay——doplays——does\n\n\nhave/has作为助动词由have，has构成的现在完成时句子，变一般疑问句时把have，has提到句子的前面，句尾用问号即可。变否定句时直接在have，has后面加not即可。肯定句: He has read today’ s newspaper.一般疑问句: Has he read today’ s newspaper?否定句: He has not read today’ s newspape.\n\nhad是have和has的过去式，在构成的过去完成时句子中，一般疑问句时把had提到到句子的前面，句尾用问号即可。变否定句时直接在had后面加not即可。\n\n若have，has，had没有出现在完成时的句子中，则当实义动词对待，请参考实义动词的用法。.\n\n情态动词\n英语中有所谓的助动词。英语中有很多助动词，除了do外，can, may, might, would, will, must也是助动词。\n\n情态动词+动词原型\n\nxYou must practiced your English every day.（你必须每天练习英语。）\n\noYou must practice your English every day.\nto的三种用法\n在英语中to的用法是比较重要的，一般来说to有三种基本用法: \n做介词，表示“到，向，往”，如go to，fly to，后面跟名词作定语，构成介宾结构。\n\n动词不定式的标志，很常见的，如: want to do， be happy to do。 注意有一些看似不定式但实为介词的结构，如look forward to, pay attention to，他们后面跟动词的ing形式作宾语，千万不能跟原形。\n\n其他的如to+do作定语等等基本都是以上两种用法的延伸。\n\nto doing用法当to用作介词的时候，后bai面跟du表示动作的动词时，要把这个动词通过zhi加ing变成“动dao名词(动词加ing,用作名词时，叫动名词)”。\n例如:\nHe is used to getting up early.他习惯早起了。\n这里的to是介词。\nHe preferred staying at home to going out.\n他更喜欢呆在家，而不愿意外出。\n这里的to也是介词。\n\n\n扩展资料动词+宾语+介词to+动名词\n\napply oneself to doing sth 专心致力于做某事\ndevote sth to doing sth 把……献给做某事\ndevote oneself to doing sth 献身于做某事\nlimit sth to doing sth 把…限制在做某事的范围内\nreduce sb to doing sth 使某人沦为做某事\ngive one’s life to doing sth 献身于做某事\ngive one’s mind to doing sth 专心做某事\nhave a dislike to doing sth 厌恶做某事\nhave an eye to doing sth 注意做某事\nhave an objection to doing sth 反对(反感)做某事\npay attention to doing sth 注意做某事\nset one’s mind to doing sth 决心做某事\n不及物动词+to+名词若是要表示过去的“习惯性”动作，可用would, used to来表达，例如：He used to go to school by bus.（他过去经常坐公共汽车去上课。）\ngo是不及物动词，后面跟名词则+to不及物动词+to+名词home是副词，所以不用+to\narrive+at/in+名词I often go to school by bike.I go home at 5 o’clock.I arrived in London yesterday.I arrived here just now.\nwill be用法will表示将要做什么，后面加动词原型。am/is/are的 原型是be，所以will be就是表示“将要成为”，“将 要…..”. ; will be后面加形容词。\n\nwill be用 于将来时，be和后面的名词、形容词等可以构成系表结构，表示主语的身份或者所处的状态等。\nwill be用法用于一般将来时。will后面可以加实意动词的原形，比如will go， will run等， 表示实际的动作。will be，be和后面的名词、形容词等可以构成系表结构，表示主语的身份或者所处的状态等，比如: \nWe will be pleased to answer any questions you may have.我们将很乐意回答你们可能想问的任何问题。\nwill be例句\nI’ m afraid the meeting will be postponed.会议怕要延期了。\n\nI hope what I have written will be of benefit to someone else who may feel the same way.我希望我所写的内容能对其他和我有同感的人有所裨益。\n\nThere will be no moon.月亮不会出来了。\n\nIf they arrive before I leave，well and good. If not, the responsibility will be mine.如果他们在我离开之前到达，那自然很好。但如果不是的话，那责任就是我的了。\n\nwill be与would be的区别意思：will be与would be意思相同，都为“将；将会”，但would be比will be多了一层委婉的意思。\n\n时态：will be 与would be都用于将来时态的句子，但will be 用于将来时而would be用于过去将来时。\n\n具体介绍：\nwill be的意思：将会;该怎样就怎样;我将会。\nwill be用于将来时态句子，比如将来进行时（will be doing）。\n例句：I’m afraid the meeting will be postponed. \n翻译：会议怕要延期了。\nbe原形一个完整的句子里面一定要有个动词.(如果遇到第二个动词则前面加”to“)\nwill,would,shall,must,等助动词后面必须用原形动词；\n形容词前面一定要用 be 动词（is,are,was,were,be）“be+adj.”这种组合是固定的.\nbe + p.p（过去分词）－－该过去分词就当做形容词用.例如：be relaxed（放轻松）；be boxed（用纸箱包装的）\n用be to/be about to＋动词原形 表示将来表示按计划、安排要做的事，具有“必要”的强制性意义。 The meeting is to take place tonight.（今晚召开会议。）\n\n表示约定、责任、命令或注定要发生的动作。Our plan is to be a failure.（我们的计划注定会失败。）  \n\n官方计划或决定（常见于报纸或广播）。The President is to visit USA next week.（总统将于下个星期出访美国。）\n\n用“be about to＋动词原形”表示将来。表示（按计划）即将发生的动作或情况。My grandpa is about to retire.（我祖父就要退休了。）She was about to go out when I arrived.（我来的时候她正准备出门。）\n\n\nHad you ever been to a blind date before you married?（你结婚以前曾经参加相亲吗？）\n\n解析：    在你结婚前，你有过一次相亲    Had you ever been to a blind date before you married，结婚之前你相亲过吗？    have gone to 不能代替这个意思    have been to 表示去过某地，经常和表示次数的次连用    have gone to 表示去了某地，还没有回来\nis being“be”动词用于现在进行时表示说话者认为是短暂的、和平常不一样的、甚至是伪装的。He is being foolish. 他在装傻。He is being honest. 他表现得特别老实。She is being rude. 她故意表现粗鲁。I can’t understand why he is being so selfish.我不明白此时他为何如此自私。适合于此种用法的有：foolish愚蠢的，nice好的，kind好心的，careful细心的，patient耐心的，lazy懒惰的，silly傻的，rude粗鲁的，polite礼貌的，impolite无礼的等表示人的特性、性格的形容词。(“be”动词用于现在进行时表示人的行为，纯粹表示心理或生理的状态而不带有行动时或主语不是人时，“be”动词不能用于现在进行时)如： \nI am happy.(表语是纯粹的心理状态，不可用am being) 我很快乐。He’s tired.(表语是纯粹的生理状态，不可用is being) 他很疲倦。It’s hot today.(主语不是人，不可用is being) 今天很热。\n形容词修饰不定代词时置于其后：当形容词修饰由some-, any-, no-, every-这些字首所构成的不定代词时，形容词要放在这些不定代词之后。例如：\nThere must be something wrong with my computer.（我的电脑出了点问题。）\nthe用法\n表示特指的人或物The boy in red is her brother.穿黑衣服的那个男孩是她哥哥。I like the music of the film.我喜欢这部电影的音乐。\n和单数名词、形容词或者分词连用，表示一类人或事物。the tiger老虎 the old老年人 the living生者 .\n指世界上独一无二的事物The sun is shining. 阳光普照。\n特指再次出现的人或事物。He told us a story , but I was not interested in the story.他给我们讲了一一个故事,但是我对这个故事不感兴趣。\n指谈话双方都知道或心中明白的人或物We went the station to see the friend off.我们去车站送朋友。\n表示某一国家的人时,其前用the。Yesterday the Singaporean came to visit our school.昨天有新加坡人来我校参观。\n用于表示方位的名词前There is a beautiful park in the east of our city.在我们的城市东面有-一个美丽的公园。\n用在江河、海洋、湖泊、群岛、山脉的名称前the Great Wall 长城\n用在乐器名词前play the guitar 弹吉他\n用在序数词、形容词最高级前\n形容词的比较级、最高级单音节词在字尾加-er / -est：单音节形容词在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：clean→cleaner→cleanest。\n\n单音节词以–e结尾在字尾加-r / -st：以–e结尾的单音节形容词，转变为比较级和最高级时，规则是在字尾加–r和–st。例如：wide→wider→widest。\n\n双音节词以-y, -er, -ow, -ble结尾在字尾加-er / -est：少数以-y, -er, -ow, -ble结尾的双音节形容词，在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：slow→slower→slowest。\n\n以-y结尾的形容词，去掉字尾-y加-ier / -iest：以–y结尾，但–y前是辅音字母的形容词的比较级和最高级是把-y去掉，加上–ier和-iest。例如：lonely→lonelier→loneliest。\n\n形容词字尾“辅元辅”重复字尾再加–er：当形容词或其字尾出现“辅音＋元音＋辅音”现象，也就是最后三个字母和音标的排列是“辅元辅”，在转变为比较级和最高级时，规则是要重复字尾，再加-er。例如：big→bigger→biggest。\n\n好句好句We should look after the old and love the young.（我们应该尊老爱幼。）\n\nI have a beautiful little new white Chinese wooden table.（我有一张新的白色中式木桌，漂亮且小巧。）\n\n\n两个以上的形容词的顺序,（冠词＋数量＋性质＋大小＋形状＋新旧＋颜色＋国籍）＋名词。可背诵例句2辅助记忆\n\nThere must be something wrong with my computer.（我的电脑出了点问题。）\n","plink":"https://dxsummer.gitee.io/posts/4e70975/"},{"title":"C语言菜鸟笔记","date":"2020-04-23T05:18:11.000Z","date_formatted":{"ll":"2020年4月23日","L":"2020/04/23","MM-DD":"04-23"},"updated":"2020-06-26T14:48:52.192Z","content":"此帖记录C语言学习笔记，整合从最初学习C语言遇到的问题到一步步成长数据C 语言中 main()、void main() 和 int main(void) 有什么区别？main()是K&amp;R C的语法，也就是C89，现在可以使用，但是不推荐。int main(void)是c99的语法。void main()不是任何标准定义的，根据维基百科 C语言 的说法，这个是微软自己定义的。\n\nint main(void)表示返回一个整数值，不接收任何参数。main()按照老的C语言标准，不写返回值的函数默认返回类型为整形。空的括号表示可以接收任意个数任意类型的参数。\n\nvoid main() 的空括号表示可以接收任意个数任意类型的参数。在一般函数里void表示没有返回值。但是这个在main函数里面有点特殊,按照C99标准的5.1.2.2.3节描述，程序依然会返回一个unspecified的值。(实际上这一节的内容也隐喻了main函数可以不是int main(void)的形式)\n\n1void pound(int n)如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的声明。\n\nC 标识符只能由字母.下划线和数字组成 且不能以数字开头。int(常量)是求不大于括号内数字 的最大整数1int(3.5)=3float在计算机中存储类型默认为double精度char为1字符，8位\nshort 2字节 16位\nshort int 2字节 16位 输出格式：%hd\nint为2字符或4字符，16位或32位\nfloat实际为4字符，即32位,C语言，float类型值会被自动转换成double类型,即64位\nlong浮点数要占用4字节，32位\ndouble 八字节，64位\nlong long 八字节，64位\nlong double 十六位，128位\n\n默认情况下，编译器假定浮点型float常量是double类型的精度。例如，假设some是float类型的变量，编写下面的语句：\n1some = 4.0 * 2.0; 通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。\n\n在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混淆。没有后缀的浮点型常量是double类型。\n\n123456Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 4 bytes.Type long long has a size of 8 bytes.Type double has a size of 8 bytes.Type long double has a size of 16 bytes.\nfloatfloat类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。\n12345678910/* floaterr.c--演示舍入错误 */#include　&lt;stdio.h&gt;int　main(void)&#123;    float　a,b;    b　=　2.0e20　+　1.0;    a　=　b　-　2.0e20;    printf(\"%f　\\n\",　a);    return　0;&#125;该程序的输出如下\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。\n字符串常量用双引号(“”)括起来的0个或者多个字符组成的序列存储：每个字符串尾自动加一个 ‘\\0’ 作为字符串结束标志\n字符串常量是百一对双引号括起来的字符序列。字符常量可以赋值给字符变量，如char b=&#39;a&#39;;,但不能把一个字符串常量赋给一个字符变量，同时也不能对字符串常量赋值。\n优先级\n算数运算符&gt;关系运算符&gt;赋值运算符\n\n关系运算符的优先级比算术运算符低（包括+和-），比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。\n关系运算符比赋值运算符的优先级高，因此，x_bigger=x&gt;y;相当于x_bigger=(x &gt; y);。\n关系运算符之间有两种不同的优先级。\n高优先级组： &lt;&lt;= &gt;&gt;=\n低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：\nex!=wye==zee与(ex != wye) == zee相同\n首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。\n表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算符”中列出了全部运算符的完整优先级表。\n\n格式化输入字符串%s如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串\n12scanf(\"%s\",s);printf(\"\\n输出%s\",s);123输出abc123 123输出abc123格式输出符%hu hd%hd表示短整数(short int)。\n\n%hu用于输出一个unsigned short int类型的数值百，此类型占两个字节，度范围问为0到65535（2^16-1）\n\n%hhu用于输出一个unsigned short类型答的数值，此类型占一个字节，范围为0到255（2^8-1）\n\n%m.ne、%e%e是按指数的形式输出，比如 4.22e5\ne表示10的N次方，5.2 长度为5，小数点精确度为2，这个本身和复%e没有关系，C语言的输出就是标准就这样。\n%hd：short int 16位\n详细点的说明就是 %m.ne 指定输出的数值共占m位，其中有n位小数制。若数值长度小于m，则左端补空格。若数值长度大于m，则按实际数值输出，小数位保留n位。\n123456#include &lt;stdio.h&gt;main()&#123;\tfloat i=1777777;\tprintf(\"%3.2f\",i); &#125;输出结果：\n11777777.00这是ptintf()的格式。\n\n带格式输出 %#x%#x是带格zd式输出, 效果为在输出前加0x.\n1printf(\"%x %X %#x\\n\", 31, 31, 31); 输出\n11f 1F 0x1f\n输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被忽略。\n1printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\", 6, 6, 6, 6); 输出：  \n1**    6**  006**00006**  006**\n带格式输出 %*s123int a;char b[10];scanf(\"%d%*s\",&amp;a,b);输入为：\n112 abc那么12将会读取到变量a中，但是后面的abc将在读取之后抛弃，不赋予任何变量(例如这里的字符数组b）用*和扫描集配合，可以从输入中只选出需要的内容，而忽略其余的东西。另外，也常用于清空缓冲区。\n1printf(\"%*s\",10,s);意思是输出字符串s，但至少占10个位置，不足的在字符串s左边补空格，这里等同于\n1printf(\"%10s\",s);带格式输入输出 %*d如果转换说明是%*d，那么参数列表中应包含*和 d对应的值\n\n例一 printf()\n\n12scanf(\"%d\", &amp;width);printf(\"The number is :%*d:\\n\", width, number);输出\n126The number is :      256:\n例二 printf()\n\n12scanf(\"%d %d\", &amp;width, &amp;precision);printf(\"Weight = %*.*f\\n\", width, precision, weight);输出\n128 3Weight = 242.500\n例三 scanf()\n\n12scanf(\"%*d %*d %d\", &amp;n);printf(\"The last integer was %d\\n\", n);scanf()指示：跳过两个整数，把第3个整数拷贝给n。下面是一个运行示例：\n122013 2014 2015The last integer was 2015在程序需要读取文件中特定列的内容时，这项跳过功能很有用。\nstrlen()和 sizeof()的区别C语言中没有字符串类型，字符串在内存中是用字符数组表示的。\nstrlen( )：strlen( )求得的是字符串的长度 %u、%lu、%zd\nsizeof( )：sizeof( )计算字符串占的总内存空间 %u、%lu、%zd\n例如字符串  \n1str[20]&#x3D; &#123;“abcdef”&#125;;strlen(str),结果为6\nsizeof(str),结果为20\nx-=y x+=y12x+=y\t/*x=x+y*/x-=y\t/*x=x-y*/scanf（） 的返回值C=scanf() 返回值赋给C\nC表示scanf（）成功收到赋值的个数\n12345678void main()&#123;int a,b,c;    c=scanf(\"%d %d\",&amp;a,&amp;b);    printf(\"%d\",c);&#125;为什么我    输入a 1\tc的值就为0，    输入1 a\tc的值为112345scanf返回接收到的变量值的个数。 int  a,b,c。a 1进去时，试图用字符‘a’对a赋值，肯定是错的，于是退出，返回成功接收到赋值的个数 0.1 a进去时，首先a能获取1.但b不能获取'a',于是返回只是1 如果是  1 1的话，那就都成功，返回2指针1temp = *u;记住，u的值是&amp;x，即x的地址，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。不要写成这样：\n1temp = u; /* 不要这样做 */因为这条语句赋给temp的是x的地址（u的值就是x的地址），而不是x的值。函数要交换的是x和y的值，而不是它们的地址。\n二维数组名、二维数组名取地址、二级指针首先给出几个定义：\n12typedef int (*p1x4)[4];//定义数据类型，p1x4这种类型为指向含4个int元素的1维数组的指针typedef int (*p3x4)[3][4];//定义数据类型，p3x4这种类型为指向含3x4个int元素的2维数组的指针下面从一维数组说起：（定义：int a[4]）\n一维数组名a是个地址，地址类型为：int *\n\n一维数组名取地址&amp;a是个地址，地址类型同：int (*p)[4]， 也即&amp;a指向含4个int元素的一维数组\n\n再看二维数组b[3][4]，这个二维数组也可以可以看成一个含3个成员的一维数组，每一个成员含有4个int元素，依次，仿照一维数组的结论，有：\nb[0]是个一维数组名，也是个地址，地址类型为：int *\n\n&amp;b[0]是个地址，地址类型同：int (*p)[4]， 也即&amp;b[0]指向含4个int元素的一维数组\n更进一步：\n\nb是个地址，地址类型同：int (*p)[4]，也即b指向含4个int元素的一维数组\n\n&amp;b是个地址，地址类型同：int (*p)[3][4]，也即&amp;b指向含3x4个int元素的2维数组\n\n注意：尤其注意上面的（3），这条结论指出了：二维数组名实际上是一维数组的地址！\n总结：\n① 数组名，是指向它的第一个一级成员的指针\n② 数组名取地址，是指向整个数组的指针\nPS：所谓一级成员，举个例子，int a[5]，那么数组a的一级成员就是int型变量；int b[10][5]，数组b的一级成员是int [5]的一维数组\n","plink":"https://dxsummer.gitee.io/posts/4f274412/"},{"title":"加油吧！少年——社会还在逼他们继续奋斗","date":"2020-04-22T05:18:50.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"updated":"2020-06-08T01:56:19.516Z","content":"文章引用知乎，视频源于B站\n问题想的有点多，但以目前能力解决不掉。\n观点不代表大多数。\n不喜欢的直接喷！\n以下是从男方的角度写的。\n一:社会风气\n【也不能说是被当下社会风气影响吧】\n举个身边的例子吧。 \n1、男方自身经济实力不足（没钱）\n  我大致粗略算了算，假设我有一个喜欢我，而且我也喜欢的女孩子，两个人三观还都合得来，那么即使他们家的要求，按照我个人感觉的最低……  \n  我需要大概56万的一笔费用。  也就是在老家桐城结个婚的所有花销。  仅仅是结婚而已。  房子30万首付得自己出吧（后续的贷款两人慢慢还。没毛病吧）  车子最低10万吧？难道面包车也可以么？  还有16万，彩礼+三金+婚宴（婚纱照司仪等等）+烟酒等等一系列所谓的看不见的花销……  16万不过分吧？我感觉。  这还是仅仅只是结婚，结完婚一年内要不要孩子呢？  \n2、这是个现实问题哦。    要的话，媳妇一怀孕最低一年半至两年，所有的花销压力基本上男方负担了吧。  媳妇如果有嫁妆垫一垫也可以，可我是按照最坏的打算准备的。    万一媳妇那边不随嫁妆呢？  \n3、小孩子不生病还好，一生病那钱花的……我大哥家的孩子一个月去医院两三次，一个月光在医院就一两千之多。这让人均工资在5.6000的家庭咋整？\n第二：责任问题  \n如果结婚真是那种到点就上班的活儿，那还好了，关键不是呀。  \n只是因为年轻人感觉到了，结婚对于一个男人/女人来说需要承担什么。  一种极重的责任感。牵一发动全身的感觉。双方父母，老婆孩子，大人还好啦，相对于小孩子来说，家庭条件不好的，从一开始他就落后别人一步了。大多数普通人结了婚，娃娃一生，扔给爷爷奶奶带，自己出去打工。对吧。当然啦，这是没办法的事情，陪伴和赚钱只能二选一。我从道德上表示理解，但个人情感上无法理解。这些在我看来，这是一种极其不负责任的表现。孩子在他小时候的大部分性格形成是需要父母的陪伴的，需要父母言传身教的。父母和爷爷奶奶本质上是不同的，再开明的爷爷奶奶，对待小孩子从情感上就不同于父母。另外没有父母陪伴，孩子没有底气，没有自信，当别的小朋友上学放学有爸妈接送，时间长了他会自己感觉和别人不一样。心里种下了种子，等待的就是若干年后的矛盾和恶性后果。我经常会听到有些家长说:那家小孩不是这样过来的，我们小时候都这样过来的，不也活的好好的，就你不行？我想说的是：你愿意赌那万分之一，那是你的事，我不愿意。重要的是我们90后长大了，有一大部分人都有过这样的经历，那个时候我们被称为“留守儿童”。  我们是经历过的，亲身体验到被留守是什么感觉。可家长们看到的大多数”幸存者”都是有一点点运气在里面的，后面死掉的不知道多少。他们喜欢拿特例当典范，好比人家买彩票中一千万，我买怎么就不中？你看看别人家如何如何，你怎么就不行？或许也因为年轻人怕自己给不了孩子想要的生活，所以宁愿单着。从某方面来说，也可以算是一种逃避和懦弱。万一……我像我父母那样怎么办？我的孩子要重复我的一生么？明知问题在哪儿，可就是无法解决。人们叫嚣着让他们去努力，拼搏，积极向上……一堆堆的大道理扑面而来。可年轻人现在接触的信息比以往更加的激烈和冲突。他们深知这个世界没道理可言。某些人说的都是建立在道德上的道理，现实中，只能精神慰藉。就像我们都知道的“拾金不昧”“见义勇为”这种道德体系的东西，在我看来，这是社会结构的“大纲，骨架”。但流通的血液是权利和金钱。可现如今……人心却不是以前的心了。\n三：认识自己穷，怕给不了她幸福大多数男生认识到自己穷了，这是真的，当今的社会，太过于物质化。谁不希望能有一个童话般的爱情故事？现实就是，柴米油盐酱醋茶会不断的用同一个招式把你从左边捶到右边。再从右边捶到左边。没有物质滋养的爱情，没有光泽，没有保鲜期，古话说的好：贫贱夫妻百事哀。我知道贫贱夫妻百事哀的原译文不是这个意思，但现在来形容另一种也不为过。没有这个赚钱的能力，结了婚说白了:害人害己。害了父母，害了媳妇，害了孩子，害了自己。我希望的是男方可以在结婚前就有一定经济基础，或者工作稳定，有可观的稳定的收入来源，有一笔相对来说能够应付两到三年的花销存款，这是对家人也是对另一半和孩子的一种保障吧。为什么这么说？时代不一样了，过去父母那辈儿结婚，物质条件的需求是啥？冰箱，收音机，摩托车。可以说人人通过努力都能达到，它的可得性要比现在大的多的多。现在呢？我有时回想起父辈们常说的一句:努力奋斗，肯吃苦，就可以把日子过好。现在想想……不以为然。难道那些父辈们的吃苦耐劳，流血流汗还是算不上努力么？或者说他们的努力还不够？那为什么他们努力一辈子，却还要两代人合力都买不起一套房子了？还要绑定下一代二三十年的时间和收入，才能勉强有个“家”？那这样努力，不就是个笑话呢？我不是说努力无用，努力是有用的，可你的努力追不上社会经济发展。这不是笑话，这是活生生的现实。网络上有一句话:你不努力下，你都不知道什么是绝望。年前看上一套房，拼死拼活干一年，攒个十几万去交首付，结果房价涨了。只够买半个房子了。\n【笑哭】社会高速发展所带来的弊端，高房价，高物价，时时刻刻都在冲击着年轻人的三观和对社会美好的期待。\n混迹这么久 我一直在踏步 没有进步，还是会陷入最后的死结 如我所愿 我不是解决 我只是在逃避，最后还是想告诉你 如果当下很难 不要压抑自己 找一个信赖的人 哭一哭诉说一下真的很解压 然后在打起精神面对 多去做一些事情充实自己 看书 或者学一中乐器 给自己找点爱好 因为我们的生活里不能只有责任和义务  活的通透一些自私一些真的很好。\n不管如何，现在年轻人的压力是很大的，无论哪个城市都一样。买房、买车要花钱，结婚要花钱，照顾父母要花钱，抚养小孩要花钱……到处都要钱，然而现在的环境，物价房价飞涨的厉害，以现在大多数年轻人的收入，怎么能实现房车以及稳定情感的目标？很难。\n说句实在话，倘若没有父母的帮扶，绝大多数的人是不可能买车买房的，光靠自己个人打拼，起码得打拼十多年，才能够实现自己的生活愿景。但是又有多少人能够忍得住十多年的时间，等到自己35岁以后再去实现这些事？\n在合适的年纪，做不了符合内心想做的事，这是现代年轻人觉得焦虑、感觉压力大的根本原因。\n现在是越年轻越轻松不了，只有奋斗，才能创造自己想要的生活。但是，当这种生活通过奋斗都还实现不了呢？就只能丧了。\n如果重来一次，你还会读计算机专业吗？\n","plink":"https://dxsummer.gitee.io/posts/ca5d3c1d/"},{"title":"PS简单的抠图方法","date":"2020-04-20T10:45:49.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-06-08T01:56:26.970Z","content":"魔棒与快速选项工具首先把需要抠图的素材拖入PS里，然后对背景图层执行CTRL+J复制。（提示：无论你要做什么，都要先解锁背景图层在对背景图层执行CTRL+J复制）\n\n点击左侧工具栏的魔棒工具，在副本里需要删除的地方，单击鼠标左键，之后会出现蚂蚁线按Delele清除（快速选项工具同理）  \n\n\n最终效果图与对比图\n（提示：用魔棒工具抠图还留有白边，这是我们要用橡皮擦细心的擦去白边，为了看起来不生硬，按住CTRL+鼠标左键单击图层生成选区，然后在选区里右键→羽化【1-2值】→Delele清除）\n通道抠图法首先把需要抠图的素材拖入PS里，然后对背景图层执行CTRL+J复制。（提示：无论你要做什么，都要先解锁背景图层在对背景图层执行CTRL+J复制）\n\n点击来到通道面板下，观察一下那个通道的明暗反差大一些，在抠图的时候，要在反差较大的那个通道来进行操作。通道比较发现，绿色和红色通道都还可以，不过绿色要更好一些，这里我们就选择绿色来进行通道抠图了。\n\n右键复制绿色通道\n\n选中绿色通道，按CTRL+L色阶处理，这能使图片反差更明显\n\n然后用画笔工具把需要清除的地方涂黑（提示：如看不清边缘，请点击RGB图层进行选区，然后再换回绿色通道，用油漆桶涂黑）\n\n之后，用画笔工具，把颜色调成白色，然后我们就可以大胆的把需要保留的地方涂成白色\n\n复制后，还有发现有一些边缘和头发没弄好，如图所示\n\n是不是还发现有一处头发没弄好呢，别急，我们先复制一层原图+蒙版，PNG图层也是。擦完之后要 向下合拼图层 抠图工具及方法\n\n是不是觉得好有点生硬呢，不怕，我们按住CTRL+鼠标左键，点击PNG图层，建立选区。然后在选区里右键羽化【1-2值】，反向选择，Delele清除。如果还觉得生硬就再次羽化。（提示：PNG图层就是指你抠出来的图像）\n\n钢笔与套索工具先用钢笔或套索工具，抠出不要的地方，如果看到有瑕疵的地方就用橡皮擦慢慢调整好。\n","plink":"https://dxsummer.gitee.io/posts/164adefb/"},{"title":"Step 1　先搞懂概念与时态","date":"2020-04-20T02:16:27.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-07-23T07:50:33.876Z","content":"Day01什么是英语语法？\n\n什么是英语语法？\n\n英语语法，指英语中语言的结构规律，主要包括“单词、短语、句型和语法”四个要素。以下就根据这四个要素做细节说明：\n单词英语单词依据在句子中的作用，可分为八大词类，分别为名词、代词、形容词、动词、副词、介词、连词和感叹词。以下为详细说明：\n名词：表示人、地、事、物等的词。名词分为可数名词和不可数名词，可数名词前要加冠词a / an，不可数名词前要加定冠词the，例如：a book, an apple, the air。\n\n代名：表示代替名词或名词短语的形式用词。代名词可以分为：\n\n形容词：用来修饰名词或代词的词。形容词可分为：\n\n动词：是用以表示动作或状态的词，例如：be, go, get, have, run, send等。另外，动词在使用上，要特别注意时态和语态的变化。\n\n副词：可用来修饰动词、形容词和其他副词，也可以用来修饰短语。副词分为：\n\n介词：通常放在名词和代词之前，用来表示名词或代词和其前面词的关系。介词从形式上来分有四种：\n\n连词：用来连接单词、短语、从句和句子的词。连词分为：\n\n感叹词：用以表示强烈的情绪和感情的一种声音或叫喊。例如：Hello! Hurrah! Hi! Oh！等等。\n\n短语短语是由两个或两个以上的英语单词所组合的词语，不包含主语和动词，可以构成句子的一部分，也可以用来当名词、形容词和副词使用。短语主要分为以下五大种类：\n句型句子是按照一定的语法规律组成的，表达一个完整的意义。一个句子一般由两部分构成，即主语部分和动词部分，这两部分也是句子中最主要的成分。而句子的次要成分包括宾语，形容词，副词，主语补语等。首先介绍一下，在一般语法说明中容易使用到的英语缩写：\n及物动词：后面必须跟宾语意义才完整\n\n不及物动词：本身意义完整后面不需要跟宾语\n\n直接宾语：动作的承受者，物\n\n间接宾语：动作对谁，为谁做\n\n\n以下为英语五大基本句型：\n\n句型01：S＋V（主语＋不及物动词）\n\n句型02：S＋V＋SC（主语＋系动词＋表语）此结构中的动词常为系动词，例如：look, seem, appear, prove, become, turn, sound, taste, keep, stay… 等。\n\n句型03：S＋V＋O（主语＋及物动词＋宾语）\n\n句型04：S＋V＋O1＋O2（主语＋双宾动词＋间接宾语＋直接宾语）间接宾语通常会是“人”，直接宾语通常会是“物品”。\n\n句型05：S＋V＋O＋OC（主语＋使役动词＋宾语＋宾语补语）\n\n语法英语语法有一定的规则，它是客观存在的，而不是语言学家规定的。语言学家只是对其进行归纳、整理，并选择恰当的方式把它们描述出来。学习英语语法得注意如下基本规则：\n规则01：两个动词是不能连在一起的。x　I like play piano.（我喜欢弹钢琴。）o　I like to play piano.\n\n规则02：如果一定要同时用两个动词，第二个动词的前面必须加“to”，或是加上“-ing”。例如：x　I like swim.（我喜欢游泳。）o　I like to swim. / I like swimming.\n\n规则03：主语如果是第三人称单数，现在时中的动词必须加“s”，例如：x　She sing very well.（她歌唱得很好。）o　She sings very well.\n\n规则04：绝大多数的否定句，不能直接加not，必须加上助动词或使役动词。例如：x　I not want to go.（我不想离开。）o　I don’t want to go.\n\n规则05：在不定式“to”的后面，必须用动词原形，例如：x　She wants to becomes a good teacher.（她想要变成一位好老师。）o　She wants to become a good teacher.\n\n规则06：英语中有所谓的助动词。英语中有很多助动词，除了do外，can, may, might, would, will, must也是助动词。例如：情态动词+动词原型x　You must practiced your English every day.（你必须每天练习英语。）o　You must practice your English every day.\n\n规则07：大部分的英语问句都要包含助动词，例如：Do you like playing basketball?（你喜欢打篮球吗？）How many books do you have?（你有多少本书？）\n\n规则08：特殊动词随主语变化，另外，英语中有些动词因主语不同而有所变形，例如be动词。I am a good student.（我是一位好学生。）She has a big heart.（她有宽大的胸襟。）They have been to Paris.（他们去过巴黎。）\n\n一般现在时vs．一般过去时\n一般现在时表示经常性、习惯性的动作、行为或者现在的某种状况；一般过去时表示过去某一时间内发生的动作或存在的状态，常与表示过去的时间副词连用，例如：yesterday, last night / week, a month ago, in 1990’s等。\n现在时使用时机与现在时动词连用，依照使用时机分为：\n现在时刻发生的动作或状态。It’s five o’clock now.（现在五点钟了。）\n\n经常性或习惯性的动作，常与always, usually, often, sometimes等频率副词连用。We have three meals every day.（我们每天吃三顿饭。）\n\n主语具备的性格、能力和本质特征等。He likes playing soccer.（他喜欢踢足球。）  \n喜欢某事物，以前就喜欢，还可能持续 like doing  \n表示想要，欲做某事 like to do\n\n客观事实、普遍真理、名言、警句或谚语等。The earth goes around the sun.（地球绕着太阳转。）\n\n按规定、时刻表、计划或安排要发生的动作。通常会用一般现在时表示将来的状态。常用的动词有：begin, start, stop, arrive, come, go, leave, return, open, close, be等。例如：School begins the day after tomorrow.（学校后天开学。）\n\n在由when, before, after, until, as soon as等连接的时间副词从句和if引导的条件副词从句，以一般现在时表示将来的动作。Remember to turn off the light before you leave.（离开之前记得关上电灯。）\n\n在由here、there引导的倒装句中，表示此刻正在发生的动作。There goes the bell.（铃响了。）\n\n过去时使用时机表示过去特定时间发生的动作或状态。My dad won the music award last year.（我爸去年赢得了一项音乐奖。）\n\n表示过去经常或反复发生的动作。She often came to help me when I was in trouble.（我遇到麻烦的时候她总是来帮助我。）  \n\n另外，若是要表示过去的“习惯性”动作，可用would, used to来表达，例如：He used to go to school by bus.（他过去经常坐公共汽车去上课。）\n\ngo是不及物动词，后面跟名词则+to  不及物动词+to+名词  home是副词，所以不用+to\n\narrive+at/in+名词  I often go to school by bike.\n  I go home at 5 o’clock.\n  I arrived in London yesterday.\n  I arrived here just now.\n\n延伸用法，事半功倍！\nLearning Plus!\n\n一般现在时vs．一般过去时的“相同点”两者均可表示人的性格、特征、爱好以及习惯，常与频率副词often, sometimes, seldom, usually, always, once a week等连用。  \nI often play basketball.（我常常打篮球。）  \nI often played basketball when I was at school.（我以前在学校的时候常常打篮球。）\n\n一般现在时vs．一般过去时的“不同点”  \n\n一般现在时表示现阶段发生的动作或状态，以及永恒不变的事实、自然规律，常与时间副词today, every day, every morning, on Sunday等连用。  \n- I ride bike to school every day.（我每天都骑自行车上学。）  \n- Springs return in March.（春天会在三月到来。）\n\n一般过去时表示过去阶段发生的动作或状态，常与时间副词yesterday, last year, last night, the day before yesterday, this morning, two days ago等连用。\n- I lost my mobile phone yesterday.（我昨天弄丟了我的手机。）  \n- She met her ex-boyfriend on the street the day before yesterday.\n  （她前天在路上遇到了她的前男友。）\n\n语法观念例句示范Shelly is my best friend since 10 years ago. 雪莉从10年前开始就是我最好的朋友。\n\nI get up at seven every day. 我每天都七点钟起床。\n\nShe speaks English very well. 她英语说得很好。\n\nWe lived in Thailand ten years ago. 我们十年前住在泰国。\n\nIt was very hot yesterday. 昨天天气很热。\n\nWhen I was a child, I often read comic books. 我小的时候经常看漫画书。\n\nDid you have a good time last night? 你昨天晚上玩得开心吗？\n\nShe stayed in Paris for almost a month. 她在巴黎待了将近一个月。\n\nWendy comes from Canada and speaks good French. 温蒂来自加拿大，而且说得一口好法语。\n\nMandy doesn’t know how to read the map.曼蒂不会看地图。\n\n语法观念辨析练习\n请填入正确时态的动词。\n\n01．I often________(go) to school by bus.\n02．He________(play) basketball every day.\n03．I________(be) hungry now.\n04．They________(go) to the ZOO yesterday.\n05．Mr. Smith________(come) to Hong Kong last Sunday.\n06．His mother________(watch) TV for 8 hours last night.\n07．There________(be) a shop not long ago.\n08．I________(need) a glass of water.\n09．She________(be) a student two years ago.\n10．The river________(run) to the ocean.\n\n正确答案及题目译文：\n\n\n将来时\n将来时表示将来某个时间要发生的动作或存在的状态，也表示将来经常或者重复发生的动作，常与表示将来的时间副词连用，例如：tomorrow, soon, next week, this afternoon…。We will graduate next year.　我们明年毕业。\n将来时的句型构成陈述句：S＋will / shall＋V原形第一人称I, we用shall或will，其余人称都用will。I will call you this afternoon.（我下午会打电话给你。）He believes that he will win the Best Sales of the Year.（他深信他会赢得年度最佳业务员奖。）\n\n否定句：S＋will / shall＋not＋V原形Because John failed his final exam, so his parents will not let him join the band.（约翰的父母不会让他参加乐团，因为他的期末考试考得太差了。）\n\n疑问句：Will / Shall＋S＋V原形？Shall we dance?（我们来跳舞吧？）\n\n\nOf    1. （属于）···的 The wood of this desk is cracked.    2. 某某市 The city of London.    3. 数量 a kind of、a piece of、a bottle of    4. 部分/全部 all of us、most of all    5. 时间  of the year 本年度的 、of year每年的、for the year本年度\n\n将来时使用时机表示将来某个时间点要发生的事She will go to visit the British Museum tomorrow.（她明天会去参观大英博物馆。）\n\n表示不以人意志为转移的自然发展的事。Jack will be 20 next year.（杰克明年将满20岁。）\n\n在疑问句中用来征询听话人意图或愿望。Will you go shopping with me?（你要和我一起逛街吗？）\n\n表示说话时马上要做的事，也就是临时决定要做的动作。A：Tom is in hospital now. He is serious ill.（汤姆现在在医院。他病得很严重。）B：Oh, I’m sorry to hear that, I will go and see him.（太不幸了，我马上就去探望他。）\n\n延伸用法，事半功倍！用“be going to＋动词原形”表示将来  \n表示打算或计划在最近或将来要做的事。  My friend and I are going to travel together this summer.  （我和我朋友打算今年夏天一起去旅游。）\n表示根据某种迹象，在最近或将来将要发生的事情。  Dark clouds are gathering. It is going to rain.（乌云在聚集，看来要下雨了。）\n\n用“be to＋动词原形”表示将来  \n表示按计划、安排要做的事，具有“必要”的强制性意义。  The meeting is to take place tonight.（今晚召开会议。）\n表示约定、责任、命令或注定要发生的动作。  Our plan is to be a failure.（我们的计划注定会失败。）\n官方计划或决定（常见于报纸或广播）。  The President is to visit USA next week.（总统将于下个星期出访美国。）\n用”be about to＋动词原形”表示将来。表示（按计划）即将发生的动作或情况。  My grandpa is about to retire.（我祖父就要退休了。）  She was about to go out when I arrived.（我来的时候她正准备出门。）\n\n用“一般现在时”表示将来 表示一个按照规定、计划、安排或时刻表而即将要发生的情况。通常句中都会包含一个表示将来的时间副词。 The train leaves at three this afternoon.（火车将在下午3点出发。） The film begins in ten minutes.（电影十分钟后开始放映。）  \n\nTIPS! 时间副词、条件副词从句中，从句一般用现在时表示将来，而主句则用将来时。 I will go shopping when I am free. （我空闲的時候就去逛街。）\n\n\n用“现在进行时”表示将来 表示即将发生的将来，多与表示移动的动词come, go, arrive, leave, start, take off等连用。 The doctor is coming to check you in 5 minutes. （医生5分钟之内就会为你做检查。） The train is leaving.（火车离开了。）\n\n用“There will＋be”表示将来 There will be＋名词＋其他补语，但无论后面的是单数名词还是复数名词，be动词必须用原形。 There will be a conference call at 3 p.m. tomorrow.（明天下午3点有个电话会议。）\n\n祈使句＋将来时 句型：祈使句＋and / or＋将来时＋（will） Work hard or you will fail.（努力工作否则你就会失败。） Work hard and you will succeed.（努力工作你就会成功。）\n\n语法观念例句示范My sister will go to Paris on vacation. 我姐姐要去巴黎度假。\n\nI’ll be a good teacher as long as I can pass this test. 只要我能通过这个测验，我就能成为一名优秀的教师。\n\nHe is going to work next week. 下星期他要去工作。\n\nI am going to have a picnic with my co-workers in a few weeks. 几星期后我要和我的同事们一起野餐。\n\nWill you leave for Hong Kong tomorrow? 你明天要去香港吗？\n\nHe is to come to see me at four this afternoon. 他今天下午4点会来见我。\n\nI will meet you at 10 a.m. in the airport tomorrow, Ok? 我们明天早上10点在机场见面，好吗？\n\nShe was about to leave when the phone rang. 她正准备出门的时候，电话响了。\n\nWe are about to finish this project. Don’t give up now. 我们快要完成这个项目了，千万不要现在放弃！\n\nIf it rains tomorrow, the picnic will postpone to next weekend.如果明天下雨，野餐就延期到下个周末举行。\n\n语法观念辨析练习01．He will write to his father as soon as he________Italy.A arrivedB arrivesC is arrivingD will arrive  \n02．My father________fifty years old next year.A is going to beB shall beC is to beD will be  \n03．He said, “Look at these black clouds.____.”A It is to rainB It’ll be rainingC It’s going to rainD It’ll rain  \n04．I hope that you________a good time this evening.A haveB are havingC will haveD has  \n05．There________a basketball match this afternoon.A will haveB will beC hasD have  \n06．We________to the park if the weather is nice tomorrow.A will goB goC goesD to go  \n07．Don’t be late, Lily.The test________at 10 a.m.A is startingB has startedC would startD starts\n08．I don’t know if it________or not tomorrow.A will snowB snowsC has snowedD is snowing\n09．She has bought some cloth. She________herself a dress.A makesB is going to makeC would makeD has made\n10．There________a birthday party for Kevin this Sunday.A shall beB will beC shall going to beD will going to be\n\n正确答案及题目译文：\n\n\nDay02现在进行时vs．过去进行时vs．将来进行时进行时的句型构成\n现在进行时陈述句型：S＋be（is / am /are）＋现在分词（V-ing）I am playing piano with my brother now.（我和我哥哥正在一起弹钢琴。）\n\n否定句型：S＋be（is / am /are）＋not＋现在分词（V-ing）Tony is totally not listening.（汤尼根本就没在听。）\n\n疑问句型：be（is / am /are）＋S＋现在分词（V-ing）?Are you reading now?（你在读书吗？）\n\n过去进行时一般句型：S＋be（was / were）＋现在分词（V-ing）She was trying on a piece of new clothes when her phone rang.（电话响时候她正在试穿一件新衣服。）\n\na piece of 既可以加可数名词，也可以加不可数名词\n\n\n否定句型：S＋be（was / were）＋not＋现在分词（V-ing）I was not speeding!（我当时并没有超速！）\n\n疑问句型：be（was / were）＋S＋现在分词（V-ing）?Were you talking to Tom on the phone at 8 p.m. last night?（你昨晚八点是否在跟汤姆打电话？）\n\n将来进行时一般句型：S＋will be＋现在分词（V-ing）If I continue to go out with you, my mother will soon be very pissing off.（如果我继续跟你出去，我妈妈很快就会非常生气。）\n\n否定句型：S＋will be＋not＋现在分词（V-ing）I hope it won’t still be raining when I have to go to work.（我希望我要上班的时候不要还在下雨。）\n\nwon’t = will not\n\n\n一般句型：Will＋S＋be＋现在分词（V-ing）?Will you be using your notebook tomorrow morning?（你明天早上还会用你的笔记本电脑吗？）\n\n进行时的使用时机\n现在进行时表示现阶段正在进行的动作。常与\n now right now：现在；马上；立刻 at the moment=right now：此刻；现在；目前 for a moment： “一会儿”表示时间的延续，一个段时间。 in a moment = very soon “很快，立即，马上，不久”,一般用于将来时的句子 at present：现在；当今；眼下 for the time being：暂且；眼下；now暂且，就现在来说\n 等时间副词连用，例如： I am looking for someone to talk with now.（我现在想找个人来说说话。）\n\n表示一个在最近按计划要进行的动作。常与一个表示将来的时间副词连用，这种情况仅限于少量动词，如go, come, leave, start, arrive, work, have, stay, play, return等。I am coming to pick you up.（我马上就来接你。）\n\n表示反复发生或持续存在的状态。常与always, constantly, forever等词连用，往往带有说话人的主观色彩，多含抱怨意味。You are always changing your mind with no reason.（你老是毫无理由地改变主意。）\n\n表示强调逐渐变化或改变的过程。常与get, grow, change, become, turn, go, run, begin等动词搭配。My parents are getting old.（我的父母越来越老了。）\n\n过去进行时表示过去的某个时刻或时间正在进行的动作。常与表示过去的时间副词then, at that time, this time yesterday, at six yesterday等连用。 I was reading a novel this morning.（上午我在看小说。）\n\n表示某种强烈感情。常与always, constantly, forever等副词连用。 She was always complaining.（她老是抱怨。）\n\n表示过去某个事件发生时，另一个正在进行的动作。此时，延续性动作用过去进行时，瞬间动作用一般过去时。 I met Ann when I was shopping this morning.（我早上逛街时遇到了安。）\n\nTIPS!\n\n 如果表示的是两个延续性的动作，都用过去进行时。 Some students were playing football,while others were running around the track. （一些学生在踢足球，另一些学生在跑步。）\n\n过去进行时可以表达委婉语气，例如：I was wondering if you can give me a lift.（不知我可否顺便搭你的车。）\n\n表示过去某个时间认为“将来”要发生的事。When his son arrived, the old man is dying.（当他的儿子抵达的时候，这位老人已经奄奄一息。）\n\n将来进行时表示在将来某个时间正在进行的动作。At this time tomorrow, I will be sleeping at home.（明天这个时候我将会在家睡觉。）\n\n表示按计划或安排，将来要发生的动作。We will be spending our summer vacation in Hawaii.（我们将在夏威夷过暑假。）\n\n表示不含意图又未发生的动作。Lucy won’t pay this bill.（露西不肯付这笔钱。）→表意愿Lucy won’t be paying this bill.（不会要求露西来付钱的。）→单纯谈将来情况\n\n表示委婉语气。Will you be having a cup of coffee?（要来杯咖啡吗？）\n\n延伸用法，事半功倍！表示状态或感觉的动词，如果指现在的情况的话，一般不用进行时，而要用一般现在时，这样的动词有：love, like, hate, want, hope, need, wish, know, understand, remember, belong, hear, see, seem, have, sound, taste等，但如果它们的词义改变，也可以用进行时态。\nShe looks pale. What’s wrong with her?（她看起来很苍白。她怎么了吗？）→look此为系动词，意为“看起来，显得”。\nShe is looking for her books.（她在找她的书。）→look在此为实义动词，意为“寻找”。\n语法观念例句示范I was reading the newspaper when the doorbell rang.我正在看报，突然门铃响了。\n\nI’ll be taking holidays soon.不久后我将在度假了。\n\nIt’s raining outside now.现在外面在下雨。\n\nWe are having a meeting now.我们现在正在开会。\n\nI was doing my homework while she is listening music.我在做作业的时候，她正在听音乐。\n\nThis time next week I will be lying on the beach.下个星期的这个时候我就会躺在沙滩上了。\n\nWhen I got to the top of the mountain, the sun was rising.当我到达山顶的时候，太阳正在升起。\n\nThe train is leaving soon.火车马上要开了。\n\nShe will be coming home soon.她不久后就会回家了。\n\nThe leaves are turning yellow.树叶变黄了。\n\n语法观念辨析练习用所给动词的正确形式填空。\n01．I________(clean) my room now.\n02．Jessie________(do) her homework when I called her last night.\n03．What________you________(do) now? I________(sing).\n04．My father________(read) newspaper at ten yesterday.\n05．It________(rain) when I went out yesterday.\n06．David________(play) chess with his grandfather now.\n07．He________(mend) a car now.\n08．This time next day they________(sit) in the cinema.\n09．I________(have) a meeting at 3 o’clock tomorrow afternoon.\n10．What do you think you________(do) at this time next year?\n正确答案及题目译文：\n现在完成时vs．过去完成时vs．将来完成时完成时的句型构成\n现在完成时陈述句型：S＋has / have＋过去分词（p.p.）I have already finished my homework.（我已经完成了我的作业。）\n\n否定句型：S＋has / have＋not＋过去分词（p.p.）Sandy has been a nurse in this hospital for 15 years.（珊蒂已经在这间医院担任护士长达15年了。）\n\n疑问句型：Has / Have＋S＋过去分词（p.p.）?Have you ever seen Peter in past 3 months?（过去3个月内，你看见过彼得吗？）\n\n过去完成时陈述句型：S＋had＋过去分词（p.p.）This proposal had been delivered by Eva before Aaron finished it.（这个计划在艾伦完成以前，伊娃就已经提交出去了。）\n\n否定句型：S＋had＋not＋过去分词（p.p.）I had not finished my work when he visited me last week.（上周他来拜访我以前，我还没有完成工作。）\n\n疑问句型：Had＋S＋过去分词（p.p.）?Had you ever been to a blind date before you married?（你结婚以前曾经参加相亲吗？）\n\n将来完成时陈述句型：S＋shall / will＋have＋过去分词（p.p.）They will have finished the meeting by now.（他们现在应该已经开完会了。）\n\n否定句型：S＋shall / will＋have＋not＋过去分词（p.p.）We will have not made 10 apple pies by the end of today.（我们在今天结束之前不能做完10个苹果派。）\n\n疑问句型：Shall / Will＋S＋have＋过去分词（p.p.）?Will they have already left by the time we get there?（我们到的时候，他们会不会已经离开了？）\n\n完成时的使用时机\n现在完成时表示过去发生的动作对现在所造成的影响。常与just, already, yet, recently, before, twice, three times等时间副词连用，例如：Luckily, I have seen the questions before.（很幸运，我之前就已经看过这些问题。）\n\n表示从过去某一时刻开始一直延续到现在的动作或状态，常与“since＋时间点”、“for＋时间段”，及how long, (ever) since, ever, before, so far, in the last / past few years, up to now, till now等时间副词连用。例如：She has been a PE teacher for five years.（她已经当了五年的体育老师了。）\n\n表示从过去某个时间直到现在的这个时间范围内，不断重复发生的动作或情况，并且这个不断重复的动作可能继续下去，也可能到现在就结束。He has always gone to school by bus.（他总是坐公共汽车上学。）\n\n有时可用于时间或条件副词从句中代替一般现在时，表将来意义。例如：You can have a rest if you have finished your work.（如果你完成了工作就可以休息一下。）\n\n过去完成时表示在过去某一时刻或某一动作之前已经完成了的动作，即“过去的过去”。例如：The train had left before she got to the station.（在她抵达车站之前，火车已经开走了。）\n\n表示从过去某一时刻开始一直延续到另一过去时刻的动作或状态。常与how long, for three days, before等表示一段时间的状语连用。例如：By twelve o’clock, I had worked ten hours.到12点钟时我已经工作了10个小时。\n\n表示未曾实现的希望或打算，即“本来希望或打算做某事（但却没有做）”。常与wish, hope, want, expect, think, suppose, plan, mean, intend, desire等动词连用，例如：I had meant to take a good holiday this year, but I wasn’t able to get away from this job.（本来打算今年好好度假的，但我还是没办法从工作中脱身。）\n\n将来完成时表示在将来某一时刻或某一时刻之前已经完成的动作，往往对将来某一时间产生影响，常与表示将来的时间副词及条件或时间副词从句连用。例如：They will have arrived by now.（她们现在应该已经到了。）If you come at six o’clock, I shall not yet have finished dinner.（你若六点钟可以到，我应该还没吃完晚饭。）When we get there, he will have gone to work.（我们到那里时，他应该已经去上班了。）\n\n 将来时只有have\n\n\n表示一种推测，主语要用第二、第三人称。例如：You will have finished your homework by now.（这时候你应该已经完成了你的作业。）She will have watched this film already.（她恐怕已经看过这场电影了。）\n\n延伸用法，事半功倍！主句与从句中完成时的运用：\n 如果主句中的谓语动词为一般现在时，从句中谓语动词就用现在完成时； 如果主句中谓语动词是一般过去时，从句谓语动词用过去完成时。例如：\n\n\n过去完成时常用于以下固定句型：\n (a) hardly, scarcely, barely＋过去完成时＋when＋一般过去时 Hardly had I got on the bus when it started to move. （公共汽车开车前，我差一点就赶不上了。）\n (b) no sooner＋过去完成时＋than＋一般过去时 No sooner had I got in the office than the manager started to yell at me. （我一到办公室，经理就开始对我吼叫。）\n (c) by (the end of)＋过去时间副词→主语的谓语动词用过去完成时 The experiment had been finished by 4 o’clock yesterday afternoon. （这个实验在昨天下午四点结束。）\n\n语法观念例句示范01．I have just received a letter from my mother.我正好收到一封来自我妈妈的信。\n02．As soon as the sun had set we returned to our hotel.太阳一下山我们就回到了旅馆。\n03．I had not understood the problem until she explained it.直到她给我解释我才明白问题出在哪。\n04．They have seen the film several times.这部电影她们已经看了好几次。\n05．I have lived here for ten years.我已经在这里住了十年了。\n06．Next Monday, I shall have been in this company for a year.到下周一，我到这家公司就满一年了。\n07．He will have gone back to Paris.他想必已经回巴黎去了。\n08．I had meant to go to your party, but something happened.我本打算去你的派对，但突然发生了一点事。\n语法观念辨析练习请选出题目中最适合的选项。\n01．No sooner________than the accident happened.A he had goneB had he goneC his goingD he went.\n02．We have been friends since________.A five yearB five yearsC five years agoD five years before\n03．You________that question three times.A already askedB have already askedC already have askedD asked already\n04．All the machines________by the end of the following week.A were repairedB will be repairedC have been repairedD will have been repaired  \n05．His grandfather________for thirty years.A diedB was deadC has been deadD has died\n06．”Are Alice and Tom still living in London?””No, they________to New York.”A are just movedB have just movedC had just movedD will just move\n07．I lost the dictionary I________.A have boughtB boughtC had boughtD had been bought\n08．I________800 English words by the time I was ten.A learnedB was learningC had learnedD learnt\n正确答案及题目译文：\n完成进行时（现在vs．过去vs．将来）完成时的句型构成\n现在完成进行时基本句型：S＋has / have＋been＋V-ingThe Smith Family has been making sports car for 200 years.（史密斯家族有200年制作跑车的历史。）\n\n否定句型：S＋has / have＋been＋not＋V-ingI have been not dancing for three months.（我已经三个月不跳舞了。）\n\n疑问句型：Has / Have＋S＋been＋V-ing ?Has Enzo been learing English since three years ago?（恩佐从三年前就开始学英语了吗？）\n\n过去完成进行时基本句型：S＋had been＋V-ingEli had been playing games before you got home.（伊莱在你回家之前一直都在玩游戏。）\n\n否定句型：S＋had been＋not＋V-ingAmy had been not working for ten years before I met her.（艾米在我遇到她的十年前就没在工作了。）\n\n疑问句型：Had＋S＋been＋V-ing ?Had your father been driving all day before he went to sleep?（你爸爸在睡觉之前开了一整天的车吗？）\n\n将来完成进行时基本句型：S＋will / shall＋have been＋V-ingWhen Mrs. Wang retires next year, she will have been teaching for 40 years.（当王太太下个月退休时，她就已经教书教了四十年。）\n\n否定句型：S＋will / shall＋not＋have been＋V-ingI won’t have been waiting for you since you keep talking to me like this.（如果你继续这样对我说话，我就不会一直等着你的。）\n\n疑问句型：Will / Shall＋S＋have been＋V-ing ?When Leo goes out tonight, it will have been raining.（当里奥今天晚上出门的时候，外头应该正下着雨。）\n\n完成时的使用时机？\n完成进行时是完成时的强调形式，分为现在完成进行时、过去完成进行时及将来完成进行时。\n现在完成进行时表示从过去某个时候开始一直延续到现在的动作，强调现在仍然在进行，并还可能继续延续下去；\n过去完成进行时表示从过去某一时间开始一直延续到另外一个过去时间的动作，这个动作在当时仍在进行并可能继续延续下去；\n未来完成进行时表示在未来某一时间以前已经完成，或一直持续的动作。\n现在完成进行时表示从过去某个时候开始一直延续到现在的动作。强调现在依然在进行，并还可能继续延续下去。例如： I have been looking for my lost book for two days, but I still haven’t found it. （我已经找我弄丢的书找了两天了，但我仍然没有找到。）\n\n表示根据直接或间接的证据得出的结论。Her eyes are red. She has been crying.（她眼睛红了。她一直在哭。）\n\n过去完成进行时表示从过去某一时间开始一直延续到另外一个过去时间的动作，这个动作在当时仍在进行并可能继续延续下去，例如：We had been waiting for her before she came in.（在她进来之前，我们一直在等她。）\n未来完成进行时表示在将来某一时刻之前开始的一个动作或状态一直延续到将来某一时刻，常与一个以by开头的时间短语连用。例如：By the end of this month, she will have been learning piano for half a year.（到这个月底，她就学钢琴半年了。）\n\n表示一种经常性反复进行的持续性动作。例如：By the end of this month, he will have been climbing mountains for ten years.（到了这个月底他的登山资历就满10年了。）\n\n语法观念例句示范01．We have been living here since 2000.从2000年起我们就住在这里了。\n02．He was out of breath. He had been running.他气喘吁吁。他一直在跑着。\n03．I heard you had been looking for me.我听说你一直在找我。\n04．I have been looking forward to meeting you.我一直盼望着见到你。\n05．Without doubt you have been working very hard.毫无疑问，你工作一向非常努力。\n06．By the end of this year, she will have been teaching for five years.到今年年底，她就当了五年老师了。\n07．On December we will have living here for two years.到12月1日，我们住在这儿就满两年了。\n08．She had been suffering from a bad cold when she took the exam.她在考试之前一直患重感冒。\n09．By the time you arrive tomorrow, she will have been typing for hours.到明天你抵达的时候，她将已经打了数小时的字。\n10．He had been mentioning your name to me.他总是向我提起你的名字。\n语法观念辨析练习请填入正确时态的动词。\n01．We________(wait) for her for two hours.\n02．They________(build) the bridge for six months.\n03．He________(study) abroad for one year.\n04．By the end of this month, I________(work) here for three months.\n05．He________(prepare) his exam till one o’clock this morning.\n06．Up to直到 that time he________(translate) those books.\n07．I wanted to know what________(go) on.\n08．She________(have) treatment治疗 all her life.\n09．By this time next year, we________(do) business with each other for 20 years.\n10．He gave up smoking last year. He________(smoke) for thirty years.\n正确答案及题目译文：\n","plink":"https://dxsummer.gitee.io/posts/8206f3bb/"},{"title":"原子弹制造从入门到精通","date":"2020-04-19T12:27:46.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:56:10.642Z","content":"原子弹制造从入门到精通\n在家闲来无事，于是与圈内大佬谈论了一下原子弹的原理，文章写作参考于谷歌、百度、必应和各位大佬，此文章仅供参考。\n\n准备工作 :我们大约需要３０磅的铀２３５，体积差不多有一个棒球的大小，再配合一些很容易到手的材料，这种炸弹就能使１／３哩以内任何东西化为乌有；２／３哩以内的东西严重受损；在１.２５哩半径内的人都会受到致命的辐射线；辐射尘随风飘扬，能使４０哩内的人都致病。如果它在纽约市引爆，大概有２５万人会死亡，还有４０万人会受伤。这种效果恐怖份子应该会很满意；这种原子弹甚至在战场上也都能派上用场。\n不过，要提醒各位：铀２３５的分量不要超过４５磅，因为对这样多的铀，其引爆的技巧相当困难，单凭业余的机槭工匠，大概是无法适时且有效地把这些东西凑在一起。挺有可能你还没做一半，它就在你面前 BOOM了，那可就真浪费感情。\n\n我个人的偏好是用３６磅或３７磅的铀２３５，因为这样效果不差，而且，如果设计上出点小差错，也不致于有太严重的后果。一旦把足够的材料紧聚在一起，我们最棘手的技术就是得使它们能紧聚在一起维持约半秒钟，这半秒钟的延迟就是技术上最主要的问题。\n\n原因是这样的：当这两堆物质靠太近时，会发生剧烈的反应而产生大量的能量，在瞬间（比一秒钟小很多）迫使这两堆物质分开。这样的结果和爆竹的效果差不多，几百尺外的人根本不知道有这回事。\n\n对一个稍有「自尊」的恐怖份子而言，是不会以此为满足的，对吗？所以，当务之急就是要设计出一套办法，使两堆铀２３５能聚得久一点，好让一些比较惊人的「大事」发生。如果你这位恐怖份子有栋两层楼房（含地下室）、两根火药、１５包水泥、２０立方码的沙石，那么大约只要一个礼拜就可以完工了。全部的费用，除去房租不算，大概只要３，０００美元就够了。根据当前汇率，折合成人民币大概就是 25000元。最后的问题是怎样把铀２３５或钸弄到手，这留待后面再谈。\n\n开始动工：准备妥当后，第一件事就是把分批弄来的铀２３５分成二等分，用一对半球容器装起来，你或可用乙炔喷灯（AcetyleneTorch）来作。\n铀的熔点是４１４。２℃，而乙炔喷灯的燃点是５２６。４℃，因此理论土来说，乙炔喷灯足以熔化铀２３５。也许你应该花几十块耐火砖作个窑，加上一个风箱，效果会此较好；不过如果你有耐心再加上一些运气（因为铀这东西燃烧会 BOOM），乙炔喷灯应该是够用的了。铀熔成液体后，流到半球状的洼槽（制陶瓷用的耐火泥就可派上用场），则第一个半球型作好冷却了，再移开作第二个。\n\n有件事要注意：这时候，在这区域附近不能有人。因为，铀有对人不利的特性。如果铀熔化时你就在现场，那么，你总会吸进一点，嘿嘿…，其结果不是说你会少活几年，而是你只剩下几个钟头好活了！如果你这个恐怖份子确能置个人生死于度外，那当然就不必计较这些了，否则我建议你采用自动控制装置。\n\n当铀熔化时，和它相隔５０尺，再用５吨铅隔离，这样应该足够安全了。将铀２３５分成两堆的工作完成后，你就应分别用铅箱装好。再从二楼挖个洞通到地下室，用一对黑铁管接起来，使总长约２０尺左右。若能用６寸厚的水泥敷于管外可能稍好，不过如果地板够坚实，而且房子是建在岩石上，也可以不必这么麻烦。在放下管子之前，先把装铀的半球形容器的平面朝上放在水泥上，再把管子放置妥当，原子弹就已完工一半了。\n\n为了不使铀散逸，地下室应该用沙、石、水泥和水混合填好，但因为这只要用一次就达到目的了，做得好不好看也无所谓啦。真正要注意的是，管子外面有足够的阻挡力量，使原子弹在 BOOM前铀不致漏出。其实只要半液体状的沙泥混合物，就足以担当大任了。如此这般，原子弹的接收部分就完工了。\n\n引爆部分比较难做，构想之一是将另一个半球容器放在管子的上端，引爆时，让它倒向下面的接收部分就可以了。原理上虽很简单，但有些技术上的困难不易解决，比如说，如果引爆用的半球容器放歪了一点，它就会沿着管子滑下来，这样你想成为恐怖份子的美梦就落空了，因为这种死法不会让人觉得恐怖，只会成为茶余饭后的笑料罢了。\n\n目前可能是最简单而有效的设计，把一个细线织成的罩子（就像夏天防苍蝇的那种），放在管子的上端，再塞进管内，留约３～４寸在外面；这时再把另一段４尺长的管子焊在原来的管子上。若要使连接的部分更牢，可以在此部分钻几个洞，把铁钉插进去。然后拿３尺长的２。５寸铜管，里面装熔化的铅，将引爆的半球容器安在铅底座中一个吻合的凹槽里；另一根铁棍则凿入管子的另一端约一尺，这装置总重量是８０～９５磅。最后，把有螺纹的盖子套在管子上头，等到它能旋得松紧自如时，再将它拿下来，在它上面钻一个洞，使能容得下引爆的装置杆；装置杆则留下６～８寸长露出洞口，杆上并恰留钻一个钉孔。将各种大小不同的钉子试着去配合，最恰当的大小是能合于整个引爆装置（当然，试着配合时暂不在接受管上端作，以免危险）。然后，将 TNT或炸药涂在一个碟子上（最好是咖啡壶中过滤器的底座），再塞进去，并插进一两个雷管。这放在引爆装置杆的四周，再由一两条引线连出来到外面，然后把它旋紧，原子弹就大功告成了。\n\n剩下的工作只是把引线接到定时器上，再把下端的安全针拔掉，然后离开这城市，约１２小时后，这城市就离开这个世界了。定时器一旦引爆，其力量足使另一个安全针脱落，引爆装置就掉到接收部分去，即使不考虑 BOOM产生的加速度，光是重力就足使９５磅的物体由２０尺高空掉下，产生８Ｘ１０的十次方耳格／秒的动能。把 BOOM所生的冲力考虑进去，则接触点有１０的十二次方耳格／秒的动能，可使两个半球容器接触的时间够长，而产生令人满意的效果。\n\n防辐设备：为了要将所有重要的步骤交代清楚，应该再将几个小问题说明一下。例如，前文曾经简略地谈到，用乙炔喷灯时要考虑铀有发火燃烧的可能性。其实，应该说整个机械操作都要在「乳状液槽」中进行。对不太熟悉机械技术操作的人而言，所谓乳状液就是一种看来像牛乳一样的液体，和油有许多相似之处，可是不会发火燃烧。这种乳状液在一般机械工厂供货商处都很容易买到，而且不会有入问你买这种东西干什么？用了这种乳状液，可以使危险降到最低程度。\n事实上，若我们要溶解铀或对铀作机械处理，最好在纯氮的大气中才安全。可是如果你够小心，而且运气又好的话，那么也不必用这种极端安全的方法。辐射的问题是比较麻烦的一点，镭的辐射量和重量成正比，但铀的辐射量和重量却是成指数关系（也是这种性质使它具有 BOOM性）。因为每个半球所装的质量都超过了临界值的一半，所以和它们同在一间房子里非常地危险。只吸进去一点点含放射性尘埃的空气，就意味着你马上要离开这个世界。因此我建议所有的工作人员应有其它的氧气供应，每人口中含个氧气管或可解决这个问题。但要通盘解决辐射的问题可能比较麻烦，不过只要有决心，加上智能和运气，这问题还是可以克服的。\n\n我还要建议采用一种用铅作成外壳而且有动力的轮椅，让操作员坐在里面可以安全地作业。上面只要开个小缝，用铅作的玻璃当窗户，操作员就可以看到外面。铅作的袖子和手套，可以用来作一些需要和铀碰触的机械动作。为了防止辐射外逸，整栋房子的墙壁、地板都需覆盖上一层铅；地下室的天花板也要加上一层铅板，以免接收部分产生辐射的问题。算起来起码要用上６～８吨的铅，以维持基本的安全问题。这么一来，又得多花工夫支撑地板，免得垮下来。\n\n这些工作都作好了，就可以开始动手制造原子弹。如果你想作一道「红烧兔子」大餐，打开食谱第一步就是要抓一只兔子来！同理，现在你也会问：「怎样把铀２３５弄到手？」（铀２３５通常此钸容易拿到。）其实，你只要平时注意看报纸，应该不难知道，核能发电厂里就有。只要由电厂里偷根控制棒出来，把它熔了，再把其中没有用的铀２３８分离出来就成了。\n\n要潜入一个核子反应炉，说起来并不是什么太难的事，尤其大学校园中的核子反应炉，都只有些马马虎虎的安全设施。一般设施就是些带刺铁丝网围墙，门口站了一两个警卫。事前可以作出误闯的样子来几次投石问路，看看有没有什么电子安全装置，大概结果都是根本没有的。可是我们偷偷摸摸的潜进去并没有什么用，因为铀非常的重，不要讲是一个人，就算是一队人马开进去，也搬不到足够的分量出来。尤其这批人马又身装铅甲以防辐射，就更不管用了。\n\n依我之见，干脆偷辆卡车和拖车（要那种特重型的，就是运三峡电站转子的那种），干掉警卫，代以自己人，然后就直闯进去拿你要的东西，很干脆，效率又高。不过，反应器都是装在一个镍－铁合金的球状容器里，容器再浸在水中，通常，旁边会有千斤顶，以便修护时用，所以也可以顺便用来把整个反应炉心起出来放到卡车里。不过要注意一件事，搬动反应器时要拔出一些燃料棒，或是插进一些节制棒，否则你和整个反应器都要化为灰烬。\n\n建议你或可向当时被你挟制的人质请教这方面的技术，以便搬动炉心。此外，整个反应器重约５０吨，加上拖车需要６寸厚的铅板作防护，所以拖车如何拖动６５吨的重量，还是颇伤脑筋的（所以前面要用特重型的拖车，要不然到了地，炉子也搬上车了，却发现拖不动，那不是面子都丢尽了）。或者，你觉得搬走整个反应器不切实际，也可以只带走约１，２００磅的备用燃料棒。\n\n不过千万也要带着石墨或铅，免得燃料棒因不断地反应生热而熔化了。如果你忘了这步骤，回家打开盖子，只会看到一堆熔化了的铀，而且四处散射，可能你当场就一命呜呼而遗笑万年。性命是小，这脸咱可丢不起，所以别忘记拿了１，２００磅的燃料棒之后，要和１５，０００磅的石墨或铅混合。反应器的铀大约含３％的铀２３５（自然界铀则只含０．５％的铀２３５），做原子弹的铀则需要９７％的铀２３５，否则根本不 BOOM。到手的１，２００磅燃料棒，可以提炼出所需要约 36磅的铀２３５，不过要有耐心和经验去分离它。如果你自知无法全部把铀２３５分离出来，就得多弄点燃料棒。\n\n一般说来，以目前的技术，要达到每次增加纯度２５％并没有什么问题，所以你最少要弄到４，８００磅的燃料棒，若能弄到９，６００磅最好。把这些加上去，你总共要带１５万磅（７５吨）的东西。\n\n其次还要找个地方放这些东西，我建议你租间仓库，如用原来那两层楼的建筑来分离铀似乎不太实际，因为这至少需要２万平方尺的空间。\n\n分离高招：下面就要考虑用什么方法来分离铀２３５。对恐怖份子来说，气体扩散法是好方法之一，这也是早期制造原子弹时所采用的，不但可靠又不必太复杂的技术。不过花费较多，而且所用的化学药品更是吓人。\n首先，你要有约１２哩长的特殊玻璃线钢管，并以６０吨的氢氟酸（ＨＦ）形成六氟化铀，然后吹向一具有特殊小孔的膜。因为六氟化铀２３８较重，在经过这层膜时会被陷住而不易透过。每过一次可使铀２３５的成分增加０。５％，如此程序只要反复操作，所得六氟化铀２３５的成分就愈大，最后只要把六氟化铀中的氟分离出来就行了。因为氢氟酸很贵，而且不易取得所以最好是去偷一点来，要不然就先去偷个几百万美金也行。\n\n如果你觉得此路不通，还有其它的办法。你可以在树林里建个滋生反应器（BreederReactor），用铀来作钸，再用化学上的技术分离即可。至于如何建滋生反应器，也不是难事，随便一本大学教科书，都可以告诉你好几种方法。虽然在理论上没有困难，但是也有它实际上的难处。不过如果你刚好有私人用的小河，又有几火车的钠，数量可观的不锈钢管，一百亩与外界隔离的土地，那就没有间题。\n\n如果对这两种方法你都没有兴趣，还有一些有趣的新技术可供参考。你可以先用一块低温磁铁（CryogenicMagnet），它在液态氦的温度（约零下２７０℃）下能保持 20,000高斯的磁扬…不过，唔，不过下面的程序太复杂了… \n\n还有一法是用雷射，因为铀２３８较重，被激光束照射后，运动的偏离角比铀２３５小。所以若在和雷射光垂直的平面上洒上一层铀，则铀２３５、铀２３８可藉其偏离角来分离。此法原理上简单可行，但时间上太慢。一天大概只能处理 20磅的铀（含２３５和２３８），而分离的效率约１２。５％，每处理一次可以产生约１０％的铀２３５，所以要处理９次才能达到原子弹的标准。\n\n如此算来，从９，６００磅磅的燃料棒中分离出３６磅纯度９７％的铀２３５，约需费时四年、。然而，它的辐射量又使你根本没有四年好活，所以还得找三两个志愿者来完成你的未竟之志。因此，若能有愚公移山之志，或可成功，祝你好运 ! \n\n\n","plink":"https://dxsummer.gitee.io/posts/a1b9e5e4/"},{"title":"Page and Post Front-matter","date":"2020-04-19T08:45:59.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:50:57.862Z","content":"Page Front-matter123456789title:date:type: comments: description:top_img:mathjax:katex:aside:\n写法解释\n\ntitle【必需】页面标题\n\ndate【必需】页面创建时间\n\ntype【必需】标签、分类和友情链接三个頁面需要配置\n\ndescription【可选】页面描述\n\ncomments【可选】显示页面评论模块（默认 true)\n\ntop_img【可选】页面顶部图片\n\nmathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\nkatex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n\naside【可选】显示侧边栏 （默认 true)\nPost Front-matter1234567891011121314title:date:tags:categories:keywords:description:top_img:comments：cover:  toc:  toc_number: copyright: mathjax:katex:\n写法解释\n\ntitle【必需】文章标题\n\ndate【必需】文章创建日期\n\ntags【可选】文章标签\n\ncategories【可选】文章分类\n\nkeywords【可选】文章关键字\n\ndescription【可选】文章描述\n\ntop_img【可选】文章顶部图片\n\ncover【可选】文章缩略图（如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空）\n\ncomments【可选】显示文章评论模块（默认 true)\n\ntoc【可选】显示文章TOC（默认为设置中toc的enable配置）\n\ntoc_number【可选】显示toc_number（默认为设置中toc的number配置）\n\ncopyright【可选】显示文章版权模块（默认 true)\n\nmathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\nkatex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n","plink":"https://dxsummer.gitee.io/posts/67dd97ac/"},{"title":"字体、颜色常用代码","date":"2020-04-19T05:17:09.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:50:26.486Z","content":"字体、颜色常用代码常用字体名称中文字体：黑体：SimHei\n宋体：SimSun\n新宋体：NSimSun\n仿宋：FangSong\n楷体：KaiTi\n仿宋_GB2312：FangSong_GB2312\n楷体_GB2312：KaiTi_GB2312\n微软雅黑：Microsoft YaHei\n英文字体：PmingLiu\nImpact\nGeorgia\nTahoma\n- Arial\nBook Antiqua\nCentury Gothic\nCourier New\nTimes New Roman\nVerdana\n其他字体：仿宋：FangSong\n华文细黑：STHeiti Light [STXihei]\n华文黑体：STHeiti\n华文楷体：STKaiti\n华文宋体：STSong\n华文仿宋：STFangsong\n隶书：LiSu\n幼圆：YouYuan\n华文细黑：STXihei\n华文楷体：STKaiti\n华文宋体：STSong\n华文中宋：STZhongsong\n华文仿宋：STFangsong\n方正舒体：FZShuTi\n方正姚体：FZYaoti\n华文彩云：STCaiyun\n华文琥珀：STHupo\n华文隶书：STLiti\n华文行楷：STXingkai\n华文新魏：STXinwei\n常用颜色代码color=maroon\ncolor=grey\ncolor=silver\ncolor=lightgrey\ncolor=HotPink\ncolor=DeepPink\ncolor=VioletRed\ncolor=Purple\ncolor=navy\ncolor=Blue\ncolor=DeepSkyBlue\ncolor=LightSkyBlue\ncolor=aqua\ncolor=DarkTurquoise\ncolor=LightSeaGreen\ncolor=YellowGreen\ncolor=LawnGreen\ncolor=GreenYellow\ncolor=Yellow\ncolor=Tomato\ncolor=red\ncolor=fuchsia\ncolor=MediumOrchid\ncolor=DarkViolet\n颜色表\n颜色名十六进制颜色值颜色\n\nAliceBlue#F0F8FFrgb(240, 248, 255)\n\nAntiqueWhite#FAEBD7rgb(250, 235, 215)\n\nAqua#00FFFFrgb(0, 255, 255)\n\nAquamarine#7FFFD4rgb(127, 255, 212)\n\nAzure#F0FFFFrgb(240, 255, 255)\n\nBeige#F5F5DCrgb(245, 245, 220)\n\nBisque#FFE4C4rgb(255, 228, 196)\n\nBlack#000000rgb(0, 0, 0)\n\nBlanchedAlmond#FFEBCDrgb(255, 235, 205)\n\nBlue#0000FFrgb(0, 0, 255)\n\nBlueViolet#8A2BE2rgb(138, 43, 226)\n\nBrown#A52A2Argb(165, 42, 42)\n\nBurlyWood#DEB887rgb(222, 184, 135)\n\nCadetBlue#5F9EA0rgb(95, 158, 160)\n\nChartreuse#7FFF00rgb(127, 255, 0)\n\nChocolate#D2691Ergb(210, 105, 30)\n\nCoral#FF7F50rgb(255, 127, 80)\n\nCornflowerBlue#6495EDrgb(100, 149, 237)\n\nCornsilk#FFF8DCrgb(255, 248, 220)\n\nCrimson#DC143Crgb(220, 20, 60)\n\nCyan#00FFFFrgb(0, 255, 255)\n\nDarkBlue#00008Brgb(0, 0, 139)\n\nDarkCyan#008B8Brgb(0, 139, 139)\n\nDarkGoldenRod#B8860Brgb(184, 134, 11)\n\nDarkGray#A9A9A9rgb(169, 169, 169)\n\nDarkGreen#006400rgb(0, 100, 0)\n\nDarkKhaki#BDB76Brgb(189, 183, 107)\n\nDarkMagenta#8B008Brgb(139, 0, 139)\n\nDarkOliveGreen#556B2Frgb(85, 107, 47)\n\nDarkorange#FF8C00rgb(255, 140, 0)\n\nDarkOrchid#9932CCrgb(153, 50, 204)\n\nDarkRed#8B0000rgb(139, 0, 0)\n\nDarkSalmon#E9967Argb(233, 150, 122)\n\nDarkSeaGreen#8FBC8Frgb(143, 188, 143)\n\nDarkSlateBlue#483D8Brgb(72, 61, 139)\n\nDarkSlateGray#2F4F4Frgb(47, 79, 79)\n\nDarkTurquoise#00CED1rgb(0, 206, 209)\n\nDarkViolet#9400D3rgb(148, 0, 211)\n\nDeepPink#FF1493rgb(255, 20, 147)\n\nDeepSkyBlue#00BFFFrgb(0, 191, 255)\n\nDimGray#696969rgb(105, 105, 105)\n\nDodgerBlue#1E90FFrgb(30, 144, 255)\n\nFeldspar#D19275rgb(209, 146, 117)\n\nFireBrick#B22222rgb(178, 34, 34)\n\nFloralWhite#FFFAF0rgb(255, 250, 240)\n\nForestGreen#228B22rgb(34, 139, 34)\n\nFuchsia#FF00FFrgb(255, 0, 255)\n\nGainsboro#DCDCDCrgb(220, 220, 220)\n\nGhostWhite#F8F8FFrgb(248, 248, 255)\n\nGold#FFD700rgb(255, 215, 0)\n\nGoldenRod#DAA520rgb(218, 165, 32)\n\nGray#808080rgb(128, 128, 128)\n\nGreen#008000rgb(0, 128, 0)\n\nGreenYellow#ADFF2Frgb(173, 255, 47)\n\nHoneyDew#F0FFF0rgb(240, 255, 240)\n\nHotPink#FF69B4rgb(255, 105, 180)\n\nIndianRed#CD5C5Crgb(205, 92, 92)\n\nIndigo#4B0082rgb(75, 0, 130)\n\nIvory#FFFFF0rgb(255, 255, 240)\n\nKhaki#F0E68Crgb(240, 230, 140)\n\nLavender#E6E6FArgb(230, 230, 250)\n\nLavenderBlush#FFF0F5rgb(255, 240, 245)\n\nLawnGreen#7CFC00rgb(124, 252, 0)\n\nLemonChiffon#FFFACDrgb(255, 250, 205)\n\nLightBlue#ADD8E6rgb(173, 216, 230)\n\nLightCoral#F08080rgb(240, 128, 128)\n\nLightCyan#E0FFFFrgb(224, 255, 255)\n\nLightGoldenRodYellow#FAFAD2rgb(250, 250, 210)\n\nLightGrey#D3D3D3rgb(211, 211, 211)\n\nLightGreen#90EE90rgb(144, 238, 144)\n\nLightPink#FFB6C1rgb(255, 182, 193)\n\nLightSalmon#FFA07Argb(255, 160, 122)\n\nLightSeaGreen#20B2AArgb(32, 178, 170)\n\nLightSkyBlue#87CEFArgb(135, 206, 250)\n\nLightSlateBlue#8470FFrgb(132, 112, 255)\n\nLightSlateGray#778899rgb(119, 136, 153)\n\nLightSteelBlue#B0C4DErgb(176, 196, 222)\n\nLightYellow#FFFFE0rgb(255, 255, 224)\n\nLime#00FF00rgb(0, 255, 0)\n\nLimeGreen#32CD32rgb(50, 205, 50)\n\nLinen#FAF0E6rgb(250, 240, 230)\n\nMagenta#FF00FFrgb(255, 0, 255)\n\nMaroon#800000rgb(128, 0, 0)\n\nMediumAquaMarine#66CDAArgb(102, 205, 170)\n\nMediumBlue#0000CDrgb(0, 0, 205)\n\nMediumOrchid#BA55D3rgb(186, 85, 211)\n\nMediumPurple#9370D8rgb(147, 112, 216)\n\nMediumSeaGreen#3CB371rgb(60, 179, 113)\n\nMediumSlateBlue#7B68EErgb(123, 104, 238)\n\nMediumSpringGreen#00FA9Argb(0, 250, 154)\n\nMediumTurquoise#48D1CCrgb(72, 209, 204)\n\nMediumVioletRed#C71585rgb(199, 21, 133)\n\nMidnightBlue#191970rgb(25, 25, 112)\n\nMintCream#F5FFFArgb(245, 255, 250)\n\nMistyRose#FFE4E1rgb(255, 228, 225)\n\nMoccasin#FFE4B5rgb(255, 228, 181)\n\nNavajoWhite#FFDEADrgb(255, 222, 173)\n\nNavy#000080rgb(0, 0, 128)\n\nOldLace#FDF5E6rgb(253, 245, 230)\n\nOlive#808000rgb(128, 128, 0)\n\nOliveDrab#6B8E23rgb(107, 142, 35)\n\nOrange#FFA500rgb(255, 165, 0)\n\nOrangeRed#FF4500rgb(255, 69, 0)\n\nOrchid#DA70D6rgb(218, 112, 214)\n\nPaleGoldenRod#EEE8AArgb(238, 232, 170)\n\nPaleGreen#98FB98rgb(152, 251, 152)\n\nPaleTurquoise#AFEEEErgb(175, 238, 238)\n\nPaleVioletRed#D87093rgb(216, 112, 147)\n\nPapayaWhip#FFEFD5rgb(255, 239, 213)\n\nPeachPuff#FFDAB9rgb(255, 218, 185)\n\nPeru#CD853Frgb(205, 133, 63)\n\nPink#FFC0CBrgb(255, 192, 203)\n\nPlum#DDA0DDrgb(221, 160, 221)\n\nPowderBlue#B0E0E6rgb(176, 224, 230)\n\nPurple#800080rgb(128, 0, 128)\n\nRed#FF0000rgb(255, 0, 0)\n\nRosyBrown#BC8F8Frgb(188, 143, 143)\n\nRoyalBlue#4169E1rgb(65, 105, 225)\n\nSaddleBrown#8B4513rgb(139, 69, 19)\n\nSalmon#FA8072rgb(250, 128, 114)\n\nSandyBrown#F4A460rgb(244, 164, 96)\n\nSeaGreen#2E8B57rgb(46, 139, 87)\n\nSeaShell#FFF5EErgb(255, 245, 238)\n\nSienna#A0522Drgb(160, 82, 45)\n\nSilver#C0C0C0rgb(192, 192, 192)\n\nSkyBlue#87CEEBrgb(135, 206, 235)\n\nSlateBlue#6A5ACDrgb(106, 90, 205)\n\nSlateGray#708090rgb(112, 128, 144)\n\nSnow#FFFAFArgb(255, 250, 250)\n\nSpringGreen#00FF7Frgb(0, 255, 127)\n\nSteelBlue#4682B4rgb(70, 130, 180)\n\nTan#D2B48Crgb(210, 180, 140)\n\nTeal#008080rgb(0, 128, 128)\n\nThistle#D8BFD8rgb(216, 191, 216)\n\nTomato#FF6347rgb(255, 99, 71)\n\nTurquoise#40E0D0rgb(64, 224, 208)\n\nViolet#EE82EErgb(238, 130, 238)\n\nVioletRed#D02090rgb(208, 32, 144)\n\nWheat#F5DEB3rgb(245, 222, 179)\n\nWhite#FFFFFFrgb(255, 255, 255)\n\nWhiteSmoke#F5F5F5rgb(245, 245, 245)\n\nYellow#FFFF00rgb(255, 255, 0)\n\nYellowGreen#9ACD32rgb(154, 205, 50)\n颜色块配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245&#x2F;&#x2F; 颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FFD700;&#125;&#x2F;&#x2F; 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #5cb85c;&#125;&#x2F;&#x2F; 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #2780e3;&#125;&#x2F;&#x2F; 颜色块-灰span#inline-grey &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #4F4F4F;&#125;&#x2F;&#x2F; 颜色块-红span#inline-red &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FF3030;&#125;&#x2F;&#x2F; 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #9954bb;&#125;&#x2F;&#x2F; 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;&#x2F;&#x2F; 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;&#x2F;&#x2F; 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;&#x2F;&#x2F; 左侧边框灰色块级p#div-border-left-grey &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #4F4F4F;&#125;&#x2F;&#x2F; 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;&#x2F;&#x2F; 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;&#x2F;&#x2F; 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;&#x2F;&#x2F; 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;&#x2F;&#x2F; 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;&#x2F;&#x2F; 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;&#x2F;&#x2F; 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;&#x2F;&#x2F; 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;&#x2F;&#x2F; 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;&#x2F;&#x2F; 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;&#x2F;&#x2F; 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;&#x2F;&#x2F; 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125;","plink":"https://dxsummer.gitee.io/posts/964fa96f/"},{"title":"Step1 数据和C","date":"2020-04-18T10:35:51.000Z","date_formatted":{"ll":"2020年4月18日","L":"2020/04/18","MM-DD":"04-18"},"updated":"2020-06-08T01:45:04.177Z","content":"此经验基于C Primer Plus\n\n一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。\n\n本章介绍以下内容：关键字：int 、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary运算符：sizeof()函数：scanf()整数类型和浮点数类型的区别如何书写整型和浮点型常数，如何声明这些类型的变量如何使用printf()和scanf()函数读写不同类型的值\nC 语言提供两大系列的多种数据类型。本章详细介绍两大数据类型：整数类型和浮点数类型，除此之外，还将介绍常量和变量的区别。\n示例程序12345678910111213141516#include　&lt;stdio.h&gt;int　main(void)&#123;float weight;　 &#x2F;* 你的体重　　　　　　　*&#x2F;float value;　　&#x2F;* 相等重量的白金价值　　　*&#x2F;printf(&quot;Are　you　worth　your　weight　in　platinum?\\n&quot;);printf(&quot;Let&#39;s　check　it　out.\\n&quot;);printf(&quot;Please　enter　your　weight　in　pounds:　&quot;);   &#x2F;* 获取用户的输入*&#x2F;scanf(&quot;%f&quot;,　&amp;weight);  &#x2F;* 假设白金的价格是每盎司$1700　　　　　*&#x2F;                        &#x2F;* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*&#x2F;value &#x3D; 1700.0 * weight * 14.5833;printf(&quot;Your　weight　in　platinum　is　worth　$%.2f.\\n&quot;,　value);printf(&quot;You　are　easily　worth　that!　If　platinum　prices　drop,\\n&quot;);printf(&quot;eat　more　to　maintain　your　value.\\n&quot;);return　0;&#125;提示 错误与警告如果输入程序时打错（如，漏了一个分号），编译器会报告语法错误消息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从double类型转换成float类型可能会丢失数据”。错误消息表明程序中有错，不能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译。特殊的警告与C如何处理1700.0这样的值有关。\n输入该程序时，可以把1700.0改成贵金属白金当前的市价，但是不要改动14.5833，该数是1英镑的金衡盎司数（金衡盎司用于衡量贵金属，而英镑常衡盎司用于衡量人的体重）。\n注意，“enter your weight”的意思是输入你的体重，然后按下Enter或Return键（不要键入体重后就一直等着）。按下Enter键是告知计算机，你已完成输入数据。该程序需要你输入一个数字（如，155），而不是单词（如，too much）。如果输入字母而不是数字，会导致程序出问题。这个问题要用if语句来解决，因此请先输入数字。下面是程序的输出示例：\n123456Are　you　worth　your　weight　in　platinum?Let&#39;s　check　it　out.Please　enter　your　weight　in　pounds:　156Your　weight　in　platinum　is　worth　$3867491.25.You　are　easily　worth　that!　If　platinum　prices　drop,eat　more　to　maintain　your　value.程序调整即使在程序中添加下面一行代码：\n1getchar();程序的输出是否依旧在屏幕上一闪而过？本例，需要调用两次getchar()函数：\n12getchar();getchar();\ngetchar()函数读取下一个输入字符，因此程序会等待用户输入。在这种情况下，键入 156 并按下Enter（或Return）键（发送一个换行符），然后scanf()读取键入的数字，第1个getchar()读取换行符，第2个getchar()让程序暂停，等待输入。\n\n程序中的新元素注意，代码中使用了一种新的变量声明。前面的例子中只使用了整数类型的变量（int），但是本例使用了浮点数类型（float）的变量，以便处理更大范围的数据。float 类型可以储存带小数的数字。\n\n为了打印新类型的变量，在printf()中使用%f来处理浮点值。%.2f中的.2用于精确控制输出，指定输出的浮点数只显示小数点后面两位。\n\nscanf()函数用于读取键盘的输入。%f说明scanf()要读取用户从键盘输入的浮点数，&amp;weight告诉 scanf()把输入的值赋给名为 weight 的变量。scanf()函数使用&amp;符号表明找到 weight变量的地点。\n\n变量与常量数据有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）。\n在示例程序中，weight 是一个变量，14.5833 是一个常量。那么，1700.0 是常量还是变量？在现实生活中，白金的价格不会是常量，但是在程序中，像1700.0这样的价格被视为常量。\n数据：数据类型关键字不仅变量和常量不同，不同的数据类型之间也有差异。一些数据类型表示数字，一些数据类型表示字母（更普遍地说是字符）。C通过识别一些基本的数据类型来区分和使用这些不同的数据类型。如果数据是常量，编译器一般通过用户书写的形式来识别类型（如，42是整数，42.100是浮点数）。但是，对变量而言，要在声明时指定其类型。\n现在，我们先来了解一下 C语言的基本类型关键字。K&amp;C给出了7个与类型相关的关键字。C90标准添加了2个关键字，C99标准又添加了3个关键字。\n\n在C语言中，用int关键字来表示基本的整数类型。后3个关键字（long、short和unsigned）和C90新增的signed用于提供基本整数类型的变式，例如unsigned short int和long long int。char关键字用于指定字母和其他字符（如，#、$、%和*）。\n\n另外，char类型也可以表示较小的整数。float、double和long double表示带小数点的数。_Bool类型表示布尔值（true或false），_complex和_Imaginary分别表示复数和虚数。\n\n通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类型：整数类型和浮点数类型。\n位、字节和字位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存储单元。\n\n最小的存储单元是位（bit），可以储存0或1（或者说，位用于设置“开”或“关”）。虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。\n\n字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C语言对此有不同的定义，请参阅baidu）。既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1的组合。通过二进制编码（仅用0和1便可表示数字），便可表示0～255的整数或一组字符（后面将详细讨论二进制编码，如果感兴趣可以现在浏览一下该章的内容）。\n\n字（word）是设计计算机时给定的自然存储单位。对于8位的微型计算机（如，最初的苹果机）， 1个字长只有8位。从那以后，个人计算机字长增至16位、32位，直到目前的64位。计算机的字长越大，其数据转移越快，允许的内存访问也更多。\n\n整数\n和数学的概念一样，在C语言中，整数是没有小数部分的数。例如，2、−23和2456都是整数。而3.14、0.22和2.000都不是整数。计算机以二进制数字储存整数，例如，整数7以二进制写是111。因此，要在8位字节中储存该数字，需要把前5位都设置成0，后3位设置成1\n\n\n浮点数浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。注意，在一个值后面加上一个小数点，该值就成为一个浮点值。所以，7是整数，7.00是浮点数。显然，书写浮点数有多种形式。稍后将详细介绍e记数法，这里先做简要介绍：3.16E7 表示3.16×107（3.16 乘以10 的7次方）。其中， 107=10000000，7被称为10的指数。\n\n这里关键要理解浮点数和整数的储存方案不同。计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和7在数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成0.7E1。这里，0.7是小数部分，1是指数部分。\n\n\n\n上图演示了一个储存浮点数的例子。当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂。后面位操作将详述相关内容。现在，我们着重讲解这两种类型的实际区别。\n\n整数没有小数部分，浮点数有小数部分。浮点数可以表示的范围比整数大。对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。\n过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距。\nC语言基本数据类型int类型int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整数或零。其取值范围依计算机系统而异。一般而言，储存一个int要占用一个机器字长。因此，早期的16位IBM PC兼容机使用16位来储存一个int值，其取值范围（即int值的取值范围）是-32768～32767。目前的个人计算机一般是32位，因此用32位储存一个int值。现在，个人计算机产业正逐步向着64位处理器发展，自然能储存更大的整数。ISO C规定int的取值范围最小为-32768～32767。一般而言，系统用一个特殊位的值表示有符号整数的正负号。\n初始化变量初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋给变量的值即可。如下所示：\n123int hogs &#x3D; 21;int cows &#x3D; 32, goats &#x3D; 14;int dogs, cats &#x3D; 94; &#x2F;* 有效，但是这种格式很糟糕 *&#x2F;以上示例的最后一行，只初始化了cats，并未初始化dogs。这种写法很容易让人误认为dogs也被初始化为94，所以最好不要把初始化的变量和未初始化的变量放在同一条声明中。\n简而言之，声明为变量创建和标记存储空间，并为其指定初始值\n\nint类型常量上面示例中出现的整数（21、32、14和94）都是整型常量或整型字面量。C语言把不含小数点和指数的数作为整数。因此，22和-44都是整型常量，但是22.0和2.2E1则不是。C语言把大多数整型常量视为int类型，但是非常大的整数除外。详见后面“long常量和long long常量”小节对long int类型的讨论。\n打印int值可以使用printf()函数打印int类型的值。%d指明了在一行中打印整数的位置。%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误。下面演示了一个简单的程序，程序中初始化了一个变量，并打印该变量的值、一个常量值和一个简单表达式的值。另外，程序还演示了如果粗心犯错会导致什么结果。\n1234567891011#include　&lt;stdio.h&gt;int　main(void)&#123;    int　ten　&#x3D;　10;    int　two　&#x3D;　2;    printf(&quot;Doing　it　right:　&quot;);    printf(&quot;%d　minus　%d　is　%d\\n&quot;,ten,2,ten-two);    printf(&quot;Doing　it　wrong:　&quot;);    printf(&quot;%d minus %d is %d\\n&quot;,ten);　&#x2F;&#x2F; 遗漏2个参数    return　0;&#125;编译并运行该程序，输出如下：\n12Doing it right: 10 minus 2 is 8Doing it wrong: 10 minus 16 is 1650287143在第一行输出中，第1个%d对应int类型变量ten；第2个%d对应int类型常量2；第3个%d对应int类型表达式ten - two的值。\n在第二行输出中，第1个%d对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是内存中的任意值（读者在运行该程序时显示的这两个数值会与输出示例中的数值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不同）。\n你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 printf()不寻常的设计。大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确。但是，printf()函数的参数数目不定，可以有1个、2个、3个或更多，编译器也爱莫能助。记住，使用printf()函数时，要确保转换说明的数量与待打印值的数量相等。\n\n当printf没有为%d提供对应的值时，打印出的值是内存中的任意值\n\n八进制和十六进制通常，C语言都假定整型常量是十进制数。然而，许多程序员很喜欢使用八进制和十六进制数。因为8和16都是2的幂，而10却不是。显然，八进制和十六进制记数系统在表达与计算机相关的值时很方便。\n例如，十进制数65536经常出现在16位机中，用十六进制表示正好是10000。另外，十六进制数的每一位的数恰好由4位二进制数表示。例如，十六进制数3是0011，十六进制数5是0101。因此，十六进制数35的位组合（bit pattern）是00110101，十六进制数53的位组合是01010011。这种对应关系使得十六进制和二进制的转换非常方便。但是，计算机如何知道10000是十进制、十六进制还是二进制？在C语言中，用特定的前缀表示使用哪种进制。\n0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制。例如，十进制数16表示成八进制是020。第15章将更全面地介绍进制相关的内容。\n要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也就是说，无论把数字写成16、020或0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码。\n显示八进制和十六进制在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。下面程序演示了一个小程序。回忆一下，在某些集成开发环境（IDE）下编写的代码中插入getchar();语句，程序在执行完毕后不会立即关闭执行窗口。\n123456789&#x2F;* bases.c--以十进制、八进制、十六进制打印十进制数100 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    int　x　&#x3D;　100;    printf(&quot;dec&#x3D;%d;octal&#x3D;%o;hex&#x3D;%x\\n&quot;,x,x,x);    printf(&quot;dec&#x3D;%d;octal&#x3D;%#o;hex&#x3D;%#x\\n&quot;,x,x,x);    return　0;&#125;编译并运行该程序，输出如下：\n12dec &#x3D; 100; octal &#x3D; 144; hex &#x3D; 64dec &#x3D; 100; octal &#x3D; 0144; hex &#x3D; 0x64该程序以3种不同记数系统显示同一个值。printf()函数做了相应的转换。注意，如果要在八进制和十六进制值前显示0和0x前缀，要分别在转换说明中加入#。\n其他整数类型C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。应记住以下几点。\nshort int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。\n\nlong int或long占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是有符号类型。\n\nlong long int或long long（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。\n\nunsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。\n\n在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。\n\n在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。例如，short、short int、signed short、signed short int都表示同一种类型。\n\n声明其他整数类型其他整数类型的声明方式与int类型相同，下面列出了一些例子。不是所有的C编译器都能识别最后3条声明，最后一个例子所有的类型是C99标准新增的。\n123456789long int　estine;long johns;short int　erns;short　ribs;unsigned int　s_count;unsigned　players;unsigned long　headcount;unsigned short　yesvotes;long long　ago;使用多种整数类型的原因为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int类型占用的空间多？因为C语言只规定了short占用的存储空间不能多于int，long占用的存储空间不能少于int。这样规定是为了适应不同的机器。\n例如，过去的一台运行Windows 3的机器上，int类型和short类型都占16位，long类型占32位。后来，Windows和苹果系统都使用16位储存short类型，32位储存int类型和long类型（使用32位可以表示的整数数值超过20亿）。现在，计算机普遍使用64位处理器，为了储存64位的整数，才引入了long long类型。\n现在，个人计算机上最常见的设置是，long long占64位，long占32位，short占16位，int占16位或32位（依计算机的自然字长而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。\nC 标准对基本数据类型只规定了允许的最小大小。对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64位的需求，最小取值范围是[−9223372036854775807,9223372036854775807]；unsigned long long的最小取值范围是[0,18446744073709551615]。如果要开支票，这个数是一千八百亿亿（兆）六千七百四十四万亿零七百三十七亿零九百五十五万一千六百一十五。但是，谁会去数？\nint类型那么多，应该如何选择？首先，考虑unsigned类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正数。\n如果一个数超出了int类型的取值范围，且在long类型的取值范围内时，使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型。\n如果在int设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。\nlong常量和long long常量通常，程序代码中使用的数字（如，2345）都被储存为int类型。如果使用1000000这样的大数字，超出了int类型能表示的范围，编译器会将其视为long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。\n八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。\n有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类型的值。要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小写的L）或L后缀。使用L后缀更好，因为l看上去和数字1很像。因此，在int为16位、long为32位的系统中，会把7作为16位储存，把7L作为32位储存。l或L后缀也可用于八进制和十六进制整数，如020L和0x10L。\n类似地，在支持long long类型的系统中，也可以使用ll或LL后缀来表示long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如5ull、10LLU、6LLU或9Ull。\n整数溢出如果整数超出了相应类型的取值范围会怎样？下面分别将有符号类型和无符号类型的整数设置为比最大值略大，看看会发生什么（printf()函数使用%u说明显示unsigned int类型的值）。\n12345678910&#x2F;* toobig.c-- 超出系统允许的最大int值*&#x2F;#include &lt;stdio.h&gt;int main(void)&#123;    int i&#x3D;2147483647;    unsigned int j&#x3D;4294967295;    printf(&quot;%d %d %d\\n&quot;,i,i+1,i+2);    printf(&quot;%u %u %u\\n&quot;,j,j+1,j+2);    return 0;&#125;在我们的系统下输出的结果是：\n122147483647　　　-2147483648　 -21474836474294967295　　　0　　 1可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在超过最大值时，unsigned int 类型的变量 j 从 0开始；而int类型的变量i则从−2147483648开始。注意，当i超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户。因此，在编程时必须自己注意这类问题。\n溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。以上描述的溢出行为比较有代表性，但是也可能会出现其他情况。\n打印short、long、long long和unsigned类型打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。\nC语言有多种printf()格式。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印unsigned long类型的值。下面程序演示了一些例子。对于支持long long类型的系统，%lld和%llu分别表示有符号和无符号类型。《字符串和格式化输入/输出》将详细介绍转换说明。\n1234567891011121314&#x2F;* print2.c--更多printf()的特性 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    unsigned int un&#x3D;3000000000;     &#x2F;* int为32位和short为16位的系统 *&#x2F;    short　end&#x3D;200;    long　big&#x3D;65537;    long　long　verybig　&#x3D;　12345678908642;    printf(&quot;un&#x3D;%u　and　not　%d\\n&quot;,　un,　un);    printf(&quot;end&#x3D;%hd　and　%d\\n&quot;,　end,　end);    printf(&quot;big&#x3D;%ld　and　not　%hd\\n&quot;,　big,　big);    printf(&quot;verybig&#x3D;%lld　and　not　%ld\\n&quot;,verybig,verybig);    return　0;&#125;在特定的系统中输出如下（输出的结果可能不同）：\n1234un &#x3D; 3000000000 and not -1294967296end &#x3D; 200 and 200big &#x3D; 65537 and not 1verybig&#x3D; 12345678908642 and not 1942899938该例表明，使用错误的转换说明会得到意想不到的结果。第 1 行输出，对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000 和有符号值−129496296 在系统内存中的内部表示完全相同（详见位操作）。\n因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值。在待打印的值大于有符号值的最大值时，会发生这种情况。对于较小的正数（如96），有符号和无符号类型的存储、显示都相同。\n第2行输出，对于short类型的变量end，在printf()中无论指定以short类型（%hd）还是int类型（%d）打印，打印出来的值都相同。这是因为在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值。你可能会提出疑问：为什么要进行转换？h修饰符有什么用？第1个问题的答案是， int类型被认为是计算机处理整数类型时最高效的类型。因此，在short和int类型的大小不同的计算机中，用int类型的参数传递速度更快。第2个问题的答案是，使用h修饰符可以显示较大整数被截断成 short 类型值的情况。\n第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd，printf()只会查看后 16 位，所以显示的值是 1。\n与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。\n本章前面介绍过，程序员必须确保转换说明的数量和待打印值的数量相同。以上内容也提醒读者，程序员还必须根据待打印值的类型使用正确的转换说明。\n\n提示 匹配printf()说明符的类型\n\n在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。\n使用字符：char类型char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码，本书也使用此编码。例如，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65（许多IBM的大型主机使用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可能使用完全不同的编码）。\n标准ASCII码的范围是0～127，只需7位二进制数即可表示。通常，char类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余。许多其他系统（如IMB PC和苹果Macs）还提供扩展ASCII码，也在8位的表示范围之内。一般而言，C语言会保证char类型足够大，以储存系统（实现C语言的系统）的基本字符集。\n许多字符集都超过了127，甚至多于255。例如，日本汉字（kanji）字符集。商用的统一码（Unicode）创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过110000个。国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了ISO/IEC 10646标准。统一码标准也与ISO/IEC 10646标准兼容。\nC语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。\n声明char类型变量char类型变量的声明方式与其他类型变量的声明方式相同。下面是一些例子：\n12char response;char itable, latan;以上声明创建了3个char类型的变量：response、itable和latan。\n字符常量和初始化如果要把一个字符常量初始化为字母 A，不必背下 ASCII 码，用计算机语言很容易做到。通过以下初始化把字母A赋给grade即可：\n1char grade &#x3D; &#39;A&#39;;在C语言中，用单引号括起来的单个字符被称为字符常量（character constant）。编译器一发现’A’，就会将其转换成相应的代码值。单引号必不可少。下面还有一些其他的例子：\n1234char broiled;　　 &#x2F;* 声明一个char类型的变量 *&#x2F;broiled &#x3D; &#39;T&#39;;　　&#x2F;* 为其赋值，正确 *&#x2F;broiled &#x3D; T;　　　&#x2F;* 错误！此时T是一个变量 *&#x2F;broiled &#x3D; &quot;T&quot;;　　&#x2F;* 错误！此时&quot;T&quot;是一个字符串 *&#x2F;如上所示，如果省略单引号，编译器认为T是一个变量名；如果把T用双引号括起来，编译器则认为”T”是一个字符串。字符串的内容将在《字符串和格式化输入/输出》中介绍。\n实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值：\n1char grade &#x3D; 65; &#x2F;* 对于ASCII，这样做没问题，但这是一种不好的编程风格 *&#x2F;在本例中，虽然65是int类型，但是它在char类型能表示的范围内，所以将其赋值给grade没问题。由于65是字母A对应的ASCII码，因此本例是把A赋给grade。注意，能这样做的前提是系统使用ASCII码。其实，用’A’代替65才是较为妥当的做法，这样在任何系统中都不会出问题。因此，最好使用字符常量，而不是数字代码值。\n奇怪的是，C语言将字符常量视为int类型而非char类型。例如，在int为32位、char为8位的ASCII系统中，有下面的代码：\n1char grade &#x3D; &#39;B&#39;;本来’B’对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade）。利用字符常量的这种特性，可以定义一个字符常量’FATE’，即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是’E’。\n非打印字符单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。\n第1种方法前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII值是7，因此可以这样写：1char beep &#x3D; 7;\n第2种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）。图列出了转义序列及其含义。把转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如，假设有下面一行代码：1char nerf &#x3D; &#39;\\n&#39;;稍后打印变量nerf的效果是，在打印机或屏幕上另起一行。\n\n现在，我们来仔细分析一下转义序列。使用C90新增的警报字符（\\a）是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报（在一些系统中，警报字符不起作用）。C标准规定警报字符不得改变活跃位置。标准中的活跃位置（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。\n接下来的转义字符\\b、\\f、\\n、\\r、\\t和\\v是常用的输出设备控制字符。了解它们最好的方式是查看它们对活跃位置的影响。\n换页符（\\f）把活跃位置移至下一页的开始处；\n\n换行符（\\n）把活跃位置移至下一行的开始处；\n\n回车符（\\r）把活跃位置移动到当前行的开始处；\n\n水平制表符（\\t）将活跃位置移至下一个水平制表点（通常是第1个、第9个、第17个、第25个等字符位置）；\n\n垂直制表符（\\v）把活跃位置移至下一个垂直制表点。\n\n这些转义序列字符不一定在所有的显示设备上都起作用。例如，换页符和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动。只有将其输出到打印机上时才会产生前面描述的效果。\n接下来的3个转义序列（\\\\、\\‘、\\“）用于打印\\、&#39;、&quot;字符（由于这些字符用于定义字符常量，是printf()函数的一部分，若直接使用它们会造成混乱）。如果打印下面一行内容：\n1Gramps sez, &quot;a \\ is a backslash.&quot;应这样编写代码：\n1printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash.\\&quot;\\n&quot;);表中的最后两个转义序列（\\0oo和\\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\\）并用单引号括起来。八进制表示格式为/000，可写1～3位八进制进制数字，每位数最大值为7\n例如，如果编译器不识别警报字符（\\a），可以使用ASCII码来代替：\n1beep &#x3D; &#39;\\007&#39;;可以省略前面的 0，’\\07’甚至’\\7’都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。\n从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X。十六进制数表示格式为/xhh，前面的x表示是十六进制，再加上1～2位十六进制数字，所以后面的两个h可以表示两位数，每位数最大值为f\n例如，Ctrl+P字符的ASCII十六进制码是10（相当于十进制的16），可表示为’\\x10’或’\\x010’。下图列出了一些整数类型的不同进制形式。\n\n使用ASCII码时，注意数字和数字字符的区别。例如，字符4对应的ASCII码是52。&#39;4&#39;表示字符4，而不是数值4。\n关于转义序列，读者可能有下面3个问题。\n上面最后一个例子（printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash\\&quot;\\&quot;n&quot;），  为何没有用单引号把转义序列括起来？ 无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。双引号中的字符集合叫作字符串（详见字符串和格式化输入输出）。注意，该例中的其他字符（G、r、a、m、p、s等）都没有用单引号括起来。与此类似，printf(&quot;Hello!\\007\\n&quot;);将打印Hello!并发出一声蜂鸣，而 printf(&quot;Hello!7\\n&quot;);则打印 Hello!7。不是转义序列中的数字将作为普通字符被打印出来。\n\n何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使用’\\f’）和ASCII码（’\\014’）之间选择，请选择前者（即’\\f’）。这样的写法不仅更好记，而且可移植性更高。’\\f’在不使用ASCII码的系统中，仍然有效。\n\n如果要使用ASCII码，为何要写成’\\032’而不是032？首先，’\\032’能更清晰地表达程序员使用字符编码的意图。其次，类似\\032这样的转义序列可以嵌入C的字符串中，如printf(“Hello!\\007\\n”);中就嵌入了\\007。\n\n打印字符printf()函数用%c指明待打印的字符。前面介绍过，一个字符变量实际上被储存为1字节的整数值。因此，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字符。程序清单3.5演示了打印char类型变量的两种方式。\n程序清单3.5 charcode.c程序\n12345678910&#x2F;* charcode.c-显示字符的代码编号 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;char　ch;printf(&quot;Please　enter　a　character.\\n&quot;);scanf(&quot;%c&quot;, &amp;ch);　&#x2F;* 用户输入字符 *&#x2F;printf(&quot;The　code　for　%c　is　%d.\\n&quot;,　ch,　ch);return　0;&#125;运行该程序后，输出示例如下：\n123Please　enter　a　character.CThe　code　for　C　is　67.运行该程序时，在输入字母后不要忘记按下Enter或Return键。随后，scanf()函数会读取用户输入的字符，&amp;符号表示把输入的字符赋给变量ch。接着，printf()函数打印ch的值两次，第1次打印一个字符（对应代码中的%c），第2次打印一个十进制整数值（对应代码中的%d）。注意，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式。\n\n有符号还是无符号有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。请查阅相应的编译器手册，确定正在使用的编译器如何实现char类型。或者，可以查阅limits.h头文件。下一章将详细介绍头文件的内容。\n根据C90标准，C语言允许在关键字char前面使用signed或unsigned。这样，无论编译器默认char是什么类型，signed char表示有符号类型，而unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果只用char处理字符，那么char前面无需使用任何修饰符。\nBool类型C99标准添加了_Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。但原则上它仅间占用1位存储空，因为对0和1而言，1位的存储空间足够了。\n程序通过布尔值可选择执行哪部分代码。\n可移植类型：stdint.h和inttypes.hC 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。\n C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头文件中。  \n例如，int32_t表示32位的有符号整数类型。在使用32位int的系统中，头文件会把int32_t作为int的别名。  \n不同的系统也可以定义相同的类型名。\n\n例如，int为16位、long为32位的系统会把int32_t作为long的别名。然后，使用int32_t类型编写程序，并包含stdint.h头文件时，编译器会把int或long替换成与当前系统匹配的类型。\n上面讨论的类型别名是精确宽度整数类型（exact-width integer type）的示例。int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持。因此，精确宽度整数类型是可选项。\n\n\n如果系统不支持精确宽度整数类型怎么办？ C99和C11提供了第2类别名集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。这组类型集合被称为最小宽度类型（minimum width type）。\n 例如，int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义int8_t类型。尽管如此，该系统仍可使用int_least8_t类型，但可能把该类型实现为16位的整数类型。\n 当然，一些程序员更关心速度而非空间。为此，C99和C11定义了一组可使计算达到最快的类型集合。这组类型集合被称为最快最小宽度类型（fastst minimum width type）。\n\n例如，int_fast8_t被定义为系统中对8位有符号值而言运算最快的整数类型的别名。\n另外，有些程序员需要系统的最大整数类型。为此，C99定义了最大的有符号整数类型intmax_t，可储存任何有效的有符号整数值。类似地，unintmax_t表示最大的无符号整数类型。顺带一提，这些类型有可能比long long和unsigned long类型更大，因为C编译器除了实现标准规定的类型以外，还可利用C语言实现其他类型。例如，一些编译器在标准引入 long long 类型之前，已提前实现了该类型。\nC99 和C11 不仅提供可移植的类型名，还提供相应的输入和输出。\n例如，printf()打印特定类型时要求与相应的转换说明匹配。\n\n如果要打印int32_t类型的值，有些定义使用%d，而有些定义使用%ld，怎么办？\n\nC 标准针对这一情况，提供了一些字符串宏（下章中详细介绍）来显示可移植类型。例如， inttypes.h头文件中定义了PRId32字符串宏，代表打印32位有符号值的合适转换说明（如d或l）。程序清单3.6演示了一种可移植类型和相应转换说明的用法。\n程序清单3.6 altnames.c程序\n1234567891011121314&#x2F;* altnames.c -- 可移植整数类型名 *&#x2F;#include　&lt;stdio.h&gt;#include &lt;inttypes.h&gt; &#x2F;&#x2F; 支持可移植类型int　main(void)&#123;\tint32_t me32;　　 &#x2F;&#x2F; me32是一个32位有符号整型变量\tme32&#x3D;45933945;\tprintf(&quot;First,assume int32_t is int: &quot;);\tprintf(&quot;me32&#x3D;%d\\n&quot;,me32);\tprintf(&quot;Next,let&#39;s not make any assumptions.\\n&quot;);\tprintf(&quot;Instead,use a \\&quot;macro\\&quot; from　inttypes.h:　&quot;);\tprintf(&quot;me32&#x3D;%&quot; PRId32 &quot;\\n&quot;,　me32);\treturn　0;&#125;该程序最后一个printf()中，参数PRId32被定义在inttypes.h中的”d”替换，因而这条语句等价于：\n1printf(&quot;me16 &#x3D; %&quot; &quot;d&quot; &quot;\\n&quot;, me16);在C语言中，可以把多个连续的字符串组合成一个字符串，所以这条语句又等价于：\n1printf(&quot;me16 &#x3D; %d\\n&quot;, me16);下面是该程序的输出，注意，程序中使用了&quot;转义序列来显示双引号：\n123First, assume int32_t is int: me32 &#x3D; 45933945Next, let&#39;s not make any assumptions.Instead, use a &quot;macro&quot; from inttypes.h: me32 &#x3D; 45933945篇幅有限，无法介绍扩展的所有整数类型。本节主要是为了让读者知道，在需要时可进行这种级别的类型控制。附录B中的参考资料VI“扩展的整数类型”介绍了完整的inttypes.h和stdint.h头文件。\n注意 对C99/C11的支持\nC语言发展至今，虽然ISO已发布了C11标准，但是编译器供应商对C99的实现程度却各不相同。在本书第6版的编写过程中，一些编译器仍未实现inttypes.h头文件及其相关功能。\nfloat、double和long double各种整数类型对大多数软件开发项目而言够用了。然而，面向金融和数学的程序经常使用浮点数。C语言中的浮点类型有float、double和long double类型。它们与FORTRAN和Pascal中的real类型一致。前面提到过，浮点类型能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用小数乘以10的幂来表示数字）。该记数系统常用于表示非常大或非常小的数。表3.3列出了一些示例。\n表3.3 记数法示例\n\n第1列是一般记数法；第2列是科学记数法；第3列是指数记数法（或称为e记数法），这是科学记数法在计算机中的写法，e后面的数字代表10的指数。图3.7演示了更多的浮点数写法。\nC标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是10-37～10+37。前一项规定指float类型必须至少精确表示小数点后的6位有效数字，如33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30千克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字。通常，系统储存一个long浮点数要占用32位。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。\n\nC语言提供的另一种浮点类型是double（意为双精度）。double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double类型的值至少有13位有效数字，超过了标准的最低位数规定。\nC语言的第3种浮点类型是long double，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。\n声明浮点型变量 浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子：\n1234float　noah,　jonah;double　trouble;float　planck　&#x3D;　6.63e-34;long　double　gnp;\n浮点型常量 在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。下面是两个有效的浮点型常量：\n12-1.56E+122.87e-3 正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常量示例：\n123453.14159.24e16.8E-5100.不要在浮点型常量中间加空格：1.56 E+12（错误！）\n\n默认情况下，编译器假定浮点型常量是double类型的精度。例如，假设some是float类型的变量，编写下面的语句：\n1some &#x3D; 4.0 * 2.0;通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。\n在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混淆。没有后缀的浮点型常量是double类型。\n\nC99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。如下所示：\n\n10xa.1fp10十六进制a等于十进制10，.1f是1/16加上15/256（十六进制f等于十进制15），p10是210或1024。0xa.1fp10表示的值是(10 + 1/16 + 15/256)×1024（即，十进制10364.0）。\n注意，并非所有的编译器都支持C99的这一特性。\n打印浮点值printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf()）传递参数时，C编译器会把float类型的值自动转换成double类型。程序清单3.7演示了这些特性。\n程序清单3.7 showf_pt.c程序\n1234567891011121314&#x2F;* showf_pt.c -- 以两种方式显示float类型的值 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　aboat　&#x3D;　32000.0;    double　abet　&#x3D;　2.14e9;    long　double　dip　&#x3D;　5.32e-5;    printf(&quot;%f　can　be　written　%e\\n&quot;,　aboat,　aboat);    &#x2F;&#x2F; 下一行要求编译器支持C99或其中的相关特性    printf(&quot;And　it&#39;s　%a　in　hexadecimal,　powers　of　2　notation\\n&quot;,　aboat);    printf(&quot;%f　can　be　written　%e\\n&quot;,　abet,　abet);    printf(&quot;%Lf　can　be　written　%Le\\n&quot;,　dip,　dip);    return　0;&#125;该程序的输出如下，前提是编译器支持C99/C11：\n123432000.000000　can　be　written　3.200000e+04And　it&#39;s　0x1.f4p+14　in　hexadecimal,　powers　of　2　notation2140000000.000000　can　be　written　2.140000e+090.000053　can　be　written　5.320000e-05该程序示例演示了默认的输出效果。下一章将介绍如何通过设置字段宽度和小数位数来控制输出格式。\n浮点值的上溢和下溢假设系统的最大float类型值是3.4E38，编写如下代码：\n12float toobig &#x3D; 3.4E38 * 100.0f;printf(&quot;%e\\n&quot;, toobig);会发生什么？这是一个上溢（overflow）的示例。当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。\n当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。\n还有另一个特殊的浮点值NaN（not a number的缩写）。例如，给asin()函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的值。但是正弦值不能大于1，因此，如果传入的参数大于1，该函数的行为是未定义的。在这种情况下，该函数将返回NaN值，printf()函数可将其显示为nan、NaN或其他类似的内容。\n浮点数舍入错误给定一个数，加上1，再减去原来给定的数，结果是多少？你一定认为是1。但是，下面的浮点运算给出了不同的答案：\n12345678910&#x2F;* floaterr.c--演示舍入错误 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　a,b;    b　&#x3D;　2.0e20　+　1.0;    a　&#x3D;　b　-　2.0e20;    printf(&quot;%f　\\n&quot;,　a);    return　0;&#125;该程序的输出如下：\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。\n浮点数表示法上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011年，该标准被ISO/IEC/IEEE 60559:2011标准收录。该标准作为C99和C11的可选项，符合硬件要求的平台可开启。floaterr.c程序的第3个输出示例即是支持该浮点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工具。详见附录B.5，参考资料V。\n复数和虚数类型许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要使用复数和虚数（VCR芯片就不需要复数）。一般而言，虚数类型都是可选项。C11标准把整个复数软件包都作为可选项。\n简而言之，C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型是float _Imaginary、double _Imaginary和long double _Imaginary。\n如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。\n\n为何 C 标准不直接用 complex 作为关键字来代替_Complex，而要添加一个头文件（该头文件中把complex定义为_Complex）？\n\n因为标准委员会考虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。例如，之前的 C99，许多程序员已经使用 struct complex 定义一个结构来表示复数或者心理学程序中的心理状况（关键字struct用于定义能储存多个值的结构，详见第14章）。让complex成为关键字会导致之前的这些代码出现语法错误。但是，使用struct _Complex的人很少，特别是标准使用首字母是下划线的标识符作为预留字以后。因此，标准委员会选定_Complex作为关键字，在不用考虑名称冲突的情况下可选择使用complex。\n其他类型现在已经介绍完C语言的所有基本数据类型。有些人认为这些类型实在太多了，但有些人觉得还不够用。注意，虽然C语言没有字符串类型，但也能很好地处理字符串。第4章将详细介绍相关内容。\nC语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用到了指针〔指针（pointer）指向变量或其他数据对象位置〕。例如，在 scanf()函数中用到的前缀&amp;，便创建了一个指针，告诉 scanf()把数据放在何处。\n小结：基本数据类型关键字：基本数据类型由11个关键字组成：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。\n\n有符号整型：  有符号整型可用于表示正整数和负整数。\n  int——系统给定的基本整数类型。C语言规定int类型不小于16位。\n  short或short int ——最大的short类型整数小于或等于最大的int类型整数。C语言规定short类型至少占16位。\n  long或long int ——该类型可表示的整数大于或等于最大的int类型整数。C语言规定long类型至少占32位。\n  long long或long long int ——该类型可表示的整数大于或等于最大的long类型整数。Long long类型至少占64位。\n  一般而言，long类型占用的内存比short类型大，int类型的宽度要么和long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供16位的short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long。\n\n无符号整型：\n  无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。在整型类型前加上关键字unsigned表明该类型是无符号整型：unsignedint、unsigned long、unsigned short。单独的unsigned相当于unsigned int。\n\n字符类型：\n  可打印出来的符号（如A、&amp;和+）都是字符。根据定义，char类型表示一个字符要占用1字节内存。出于历史原因，1字节通常是8位，但是如果要表示基本字符集，也可以是16位或更大。\n  char ——字符类型的关键字。有些编译器使用有符号的char，而有些则使用无符号的char。在需要时，可在char前面加上关键字signed或unsigned来指明具体使用哪一种类型。\n\n布尔类型：\n  布尔值表示true和false。C语言用1表示true，0表示false。\n  _Bool ——布尔类型的关键字。布尔类型是无符号 int类型，所占用的空间只要能储存0或1即可。\n\n实浮点类型：\n  实浮点类型可表示正浮点数和负浮点数。\n  float ——系统的基本浮点类型，可精确表示至少-6位有效数字。\n  double ——储存浮点数的范围（可能）更大，能表示比 float 类型更多的有效数字（至少 10位，通常会更多）和更大的指数。\n  long long ——储存浮点数的范围（可能）比double更大，能表示比double更多的有效数字和更大的指数。\n\n复数和虚数浮点数：\n  虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成：\n123456float _Complexdouble _Complexlong double _Complexfloat _Imaginarydouble _Imaginarylong long _Imaginary\n小结：如何声明简单变量\n\n\n选择需要的类型。\n\n使用有效的字符给变量起一个变量名。\n\n按以下格式进行声明：\n 类型说明符 变量名;\n 类型说明符由一个或多个关键字组成。下面是一些示例：\n12int erest;unsigned short cash;\n可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所示：\n1char ch, init, ans;\n在声明的同时还可以初始化变量：\n1float mass &#x3D; 6.0E24;\n类型大小如何知道当前系统的指定类型的大小是多少？运行程序清单3.8，会列出当前系统的各类型的大小。\n123456789101112131415161718程序清单3.8 typesize.c程序&#x2F;&#x2F;* typesize.c -- 打印类型大小 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    &#x2F;* C99为类型大小提供%zd转换说明 *&#x2F;    printf(&quot;Type　int　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(int));    printf(&quot;Type　char　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(char));    printf(&quot;Type　long　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(long));    printf(&quot;Type　long　long　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(long　long));    printf(&quot;Type　double　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(double));    printf(&quot;Type　long　double　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(long　double));    return　0;&#125;sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。\n该程序的输出如下：\n123456Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.Type long long has a size of 8 bytes.Type double has a size of 8 bytes.Type long double has a size of 16 bytes.该程序列出了6种类型的大小，你也可以把程序中的类型更换成感兴趣的其他类型。注意，因为C语言定义了char类型是1字节，所以char类型的大小一定是1字节。而在char类型为16位、double类型为64位的系统中，sizeof给出的double是4字节。在limits.h和float.h头文件中有类型限制的相关信息（下一章将详细介绍这两个头文件）。\n顺带一提，注意该程序最后几行 printf()语句都被分为两行，只要不在引号内部或一个单词中间断行，就可以这样写。\n使用数据类型编写程序时，应注意合理选择所需的变量及其类型。通常，用int或float类型表示数字，char类型表示字符。在使用变量之前必须先声明，并选择有意义的变量名。初始化变量应使用与变量类型匹配的常数类型。例如：\n12int apples &#x3D; 3;　　　 &#x2F;* 正确 *&#x2F;int oranges &#x3D; 3.0;　　&#x2F;* 不好的形式 *&#x2F;与Pascal相比，C在检查类型匹配方面不太严格。C编译器甚至允许二次初始化，但在激活了较高级别警告时，会给出警告。最好不要养成这样的习惯。\n把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。例如，下面的初始化：\n12int cost &#x3D; 12.99;　　 &#x2F;* 用double类型的值初始化int类型的变量 *&#x2F;float pi &#x3D; 3.1415926536;　 &#x2F;* 用double类型的值初始化float类型的变量 *&#x2F;第1个声明，cost的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第2个声明会损失一些精度，因为C只保证了float类型前6位的精度。编译器对这样的初始化可能给出警告。读者在编译程序清单3.1时可能就遇到了这种警告。\n许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 i_前缀表示 int类型，us_前缀表示 unsigned short 类型。这样，一眼就能看出来i_smart 是 int 类型的变量， us_versmart是unsigned short类型的变量。\n参数和陷阱有必要再次提醒读者注意 printf()函数的用法。读者应该还记得，传递给函数的信息被称为参数。例如，printf(&quot;Hello, pal.&quot;)函数调用有一个参数：&quot;Hello,pal.&quot;。双引号中的字符序列（如，”Hello,pal.“）被称为字符串（string），第4章将详细讲解相关内容。现在，关键是要理解无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数。\n与此类似，scanf(&quot;%d&quot;, &amp;weight)函数调用有两个参数：&quot;%d&quot;和&amp;weight。C语言用逗号分隔函数中的参数。printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。例如，前面的程序示例中调用过带一个、两个，甚至三个参数的 printf()函数。程序要知道函数的参数个数才能正常工作。printf()和scanf()函数用第1个参数表明后续有多少个参数，即第1个字符串中的转换说明与后面的参数一一对应。例如，下面的语句有两个%d转换说明，说明后面还有两个参数：\n1printf(&quot;%d cats ate %d cans of tuna\\n&quot;, cats, cans);后面的确还有两个参数：cats和cans。\n程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配。现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确。但是，该机制对printf()和scanf()不起作用，因为这两个函数的参数个数可变。如果参数在匹配上有问题，会出现什么情况？假设你编写了程序清单 3.9中的程序。\n程序清单3.9 badcount.c程序\n12345678910111213&#x2F;* badcount.c -- 参数错误的情况 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    int　n　&#x3D;　4;    int　m　&#x3D;　5;    float　f　&#x3D;　7.0f;    float　g　&#x3D;　8.0f;    printf(&quot;%d\\n&quot;, n, m);　 &#x2F;* 参数太多　*&#x2F;    printf(&quot;%d %d %d\\n&quot;, n); &#x2F;* 参数太少　*&#x2F;    printf(&quot;%d %d\\n&quot;, f, g); &#x2F;* 值的类型不匹配 *&#x2F;    return　0;&#125;XCode 4.6（OS 10.8）的输出如下：\n12344　1　-7063378361606414344　1Microsoft Visual Studio Express 2012（Windows 7）的输出如下：\n12344　0　00　1075576832\n注意，用%d显示float类型的值，其值不会被转换成int类型。在不同的平台下，缺少参数或参数类型不匹配导致的结果不同。\n\n所有编译器都能顺利编译并运行该程序，但其中大部分会给出警告。的确，有些编译器会捕获到这类问题，然而C标准对此未作要求。因此，计算机在运行时可能不会捕获这类错误。如果程序正常运行，很难觉察出来。如果程序没有打印出期望值或打印出意想不到的值，你才会检查 printf()函数中的参数个数和类型是否得当。\n转义序列示例再来看一个程序示例，该程序使用了一些特殊的转义序列。程序清单 3.10 演示了退格（\\b）、水平制表符（\\t）和回车（\\r）的工作方式。这些概念在计算机使用电传打字机作为输出设备时就有了，但是它们不一定能与现代的图形接口兼容。例如，程序清单3.10在某些Macintosh的实现中就无法正常运行。\n程序清单3.10 escape.c程序\n12345678910111213&#x2F;* escape.c -- 使用转移序列 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　salary;    printf(&quot;\\aEnter your desired monthly salary:&quot;);　&#x2F;* 1 *&#x2F;    printf(&quot; $_______\\b\\b\\b\\b\\b\\b\\b&quot;);　　　　　　　 &#x2F;* 2 *&#x2F;    scanf(&quot;%f&quot;,　&amp;salary);    printf(&quot;\\n\\t$%.2f　a　month　is　$%.2f　a　year.&quot;,　salary,    salary * 12.0);　　　　　　　　　　　　　　&#x2F;* 3 *&#x2F;    printf(&quot;\\rGee!\\n&quot;);　　　　　　　　　　　　　　　 &#x2F;* 4 *&#x2F;    return　0;&#125;程序运行情况假设在系统中运行的转义序列行为与本章描述的行为一致（实际行为可能不同。例如，XCode 4.6把\\a、\\b和\\r显示为颠倒的问号），下面我们来分析这个程序。\n第1条printf()语句（注释中标为1）发出一声警报（因为使用了\\a），然后打印下面的内容：\n1Enter your desired monthly salary:因为printf()中的字符串末尾没有\\n，所以光标停留在冒号后面。\n第2条printf()语句在光标处接着打印，屏幕上显示的内容是：\n1Enter your desired monthly salary: $_______冒号和美元符号之间有一个空格，这是因为第2条printf()语句中的字符串以一个空格开始。7个退格字符使得光标左移7个位置，即把光标移至7个下划线字符的前面，紧跟在美元符号后面。通常，退格不会擦除退回所经过的字符，但有些实现是擦除的，这和本例不同。\n假设键入的数据是4000.00（并按下Enter键），屏幕显示的内容应该是：\n1Enter your desired monthly salary: $4000.00键入的字符替换了下划线字符。按下Enter键后，光标移至下一行的起始处。\n第3条printf()语句中的字符串以\\n``\\t开始。换行字符使光标移至下一行起始处。水平制表符使光标移至该行的下一个制表点，一般是第9列（但不一定）。然后打印字符串中的其他内容。执行完该语句后，此时屏幕显示的内容应该是：\n12Enter　your　desired　monthly　salary:　$4000.00$4000.00　a　month　is　$48000.00　a　year.因为这条printf()语句中没有使用换行字符，所以光标停留在最后的点号后面。\n第4条printf()语句以\\r开始。这使得光标回到当前行的起始处。然后打印Gee!，接着\\n使光标移至下一行的起始处。屏幕最后显示的内容应该是：\n12Enter　your　desired　monthly　salary:　$4000.00Gee!　$4000.00　a　month　is　$48000.00　a　year.刷新输出printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：  \n当缓冲区满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区）。\n\n例如，前两个 printf()语句既没有填满缓冲区，也没有换行符，但是下一条 scanf()语句要求用户输入，这迫使printf()的输出被发送到屏幕上。\n\n旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。代码应改为：1printf(&quot;Enter your desired monthly salary:\\n&quot;);\nscanf(&quot;%f&quot;, &amp;salary);无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新缓冲区的方法是使用fflush()函数，详见其他章。\n关键概念C语言提供了大量的数值类型，目的是为程序员提供方便。那以整数类型为例，C认为一种整型不够，提供了有符号、无符号，以及大小不同的整型，以满足不同程序的需求。\n计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别。即使两个32位存储单元储存的位组合完全相同，但是一个解释为float类型，另一个解释为long类型，这两个相同的位组合表示的值也完全不同。\n例如，在PC中，假设一个位组合表示float类型的数256.0，如果将其解释为long类型，得到的值是113246208。C语言允许编写混合数据类型的表达式，但是会进行自动类型转换，以便在实际运算时统一使用一种类型。\n计算机在内存中用数值编码来表示字符。美国最常用的是ASCII码，除此之外C也支持其他编码。字符常量是计算机系统使用的数值编码的符号表示，它表示为单引号括起来的字符，如&#39;A&#39;。\n本章小结C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。\nC规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。\n浮点类型有3种：float、double和C90新增的long double。后面的类型应大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关键字_Complex和_Imaginary与浮点类型的关键字组合（如，double _Complex类型和float _Imaginary类型）来表示这些类型。\n整数可以表示为十进制、八进制或十六进制。0前缀表示八进制数，0x或0X前缀表示十六进制数。例如，32、040、0x20分别以十进制、八进制、十六进制表示同一个值。l或L前缀表明该值是long类型， ll或LL前缀表明该值是long long类型。\n在C语言中，直接表示一个字符常量的方法是：把该字符用单引号括起来，如&#39;Q&#39;、&#39;8&#39;和&#39;$&#39;。C语言的转义序列（如，&#39;\\n&#39;）表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，&#39;\\007&#39;），表示ASCII码中的一个字符。\n浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如，7.38E10）。C99和C11提供了第3种指数表示法，即用十六进制数和2的幂来表示（如，0xa.1fp10）。\nprintf()函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（%）和一个转换字符组成，如%d或%f。\n","plink":"https://dxsummer.gitee.io/posts/e51e6bb3/"},{"title":"hexo搭建+Butterfly主题配置","date":"2020-04-15T07:01:53.000Z","date_formatted":{"ll":"2020年4月15日","L":"2020/04/15","MM-DD":"04-15"},"updated":"2020-06-08T01:59:03.487Z","content":"Hexo基本操作手册此贴 结合简书 俗俗俗俗俗人 与 Butterfly制作人——JerryC 以及 Emil等前辈的经验，方便后人的学习。在此感谢 俗俗俗俗俗人  JerryC  Emil等各位前辈若有问题 请于我留言安装安装Node.js左边的是稳定版本，右边的是最新版双击运行安装包，然后去命令行123node -v# 这时候会出现你的版本号v10.16.3，安装成功&#96;安装Git\n1brew install gitbrew又不知道了？[○･｀Д´･ ○] 别太过分！ 戳这里到brew官网\n安装Hexo1npm install -g hexo-cli官方这里也提到，如果系统未安装Xcode会遇到问题，这时候去Mac的应用商店搜索\n建立博客123hexo init &lt;你所放置的文件地址&gt;cd &lt;你所放置的文件地址&gt;npm install此时你就会看到以下的目录结构\n这就是基础的目录了这里就介绍几个关键的文件和文件夹\n_config.yml网站的配置的信息都存储在这里面，很关键的文件，文章后面会做到详细阐述\nsource这里面是存放用户资源的地方，什么意思呢？也就是博客内容都放在这里面进到目录中，就会发现有一个 _post文件夹 ，这个文件夹就是之后的文档主要文件。\nthemes主题文件夹，放心，之后恶心你的大部分地方都在这里面！\nhexo常用的命令新建文章1hexo new &lt;文章标题&gt; # 可以简写hexo n &lt;文章标题&gt;生成静态文件由于Hexo是用Node.js来进行页面渲染，所以需要生成对应的静态文件\n1hexo generate # 可以简写hexo g启动本地服务器每篇文章总得查看无论是编排、内容，所以我们需要测试，这时候我们就需要本地服务了\n1hexo server # 可以简写hexo s但是运行之前需要确保已经安装 hexo-server 插件\n1npm install hexo-server --save此时服务器就会开启4000端口供你使用，但是可能你的服务器端口被占用了，会提示以下错误\n1FATAL Port 4000 has been used. Try other port instead.此时你需要切换一个端口\n1hexo s -p 5000 # -p 是可以指定端口的操作部署网站辛辛苦苦打理了这么久的博客，不上传到服务器上展（zhuang）示（bi）一下，怎么对得起自己\n1hexo deploy # 可以简写 hexo d这里涉及到几个知识点\n\n需要先渲染博客，也就是hexo g（可以hexo g -d一步操作）还需要配置博客目录下 _config.yml 文件中的deploy模块\n\n12345# 之后会教大家如何操作deploy:    type: git    repo: &lt;git地址&gt;    branch: master其余的命令实际上用到真的不多，万一需要，百度就可以了\n安装主题戳这里到Hexo的插件库\n该博客的主题hexo-theme-butterfly 是基于Molunerfinn的hexo-theme-melody的基础上进行开发的。\n安装hexo-theme-butterfly在博客的根目录\n1git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly或者想用最新的分支的话\n1git clone -b dev https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly替换主题博客根目录\n1打开config.yml然后将\n1theme: Butterfly博客配置文章front-matter12345678910111213title:date:tags:categories:keywords:description:top_img: （除非特定需要，可以不寫）comments: 是否展示评论系统（true.展示 false.不展示）description: 节选，如果不填就默认从文章中选择配置的长度cover:  首页缩略图toc:  是否显示toctoc_number: 是否显示toc数字copyright: 是否显示版权1234# 节选内容auto_excerpt:  enable: true  length: 150系统中英文替换替换主题后你会发现首页的菜单一开始是英文名字，或者不是自己想要的样子，怎么办？配置 _config.yml\n1language: zh-CN12# 进入主题文件夹cd themes&#x2F;Butterfly会发现这里也有一个 _config.yml 文件，这个文件是掌管整套系统主题相关的配置，个人觉得重要程度的比重要比前面博客根目录的同名文件要重要，当然缺一不可。\n编辑这个文件\n123456789101112# 可以像俗人一样把原本的英文名修改成中文，这样就会完全解决切换不彻底问题menu:  首页: &#x2F; || fa fa-home  时间轴: &#x2F;archives&#x2F; || fa fa-archive  留言板: &#x2F;message&#x2F; || fa fa-coffee  标签: &#x2F;tags&#x2F; || fa fa-tags  分类: &#x2F;categories&#x2F; || fa fa-folder-open  链接: &#x2F;link&#x2F; || fa fa-link  关于: &#x2F;about&#x2F; || fa fa-heart  列表||fa fa-list:    - 音乐 || &#x2F;music&#x2F; || fa fa-music    - 视频 || &#x2F;movies&#x2F; || fa fa-film这里如果需要新增菜单栏目的话，记得这样的规律\n名称 || 路径 || icon新增菜单此时发现点击页面都是空白\n这时候就需要新增页面的操作了，但是注意这里的新增和新增文章不同，这里需要加上分类\n12# 新增标签hexo new page tags在博客的根目录访问\n1source&#x2F;tags&#x2F;index.md发现这是一个文档文件\n是的，基本上大同小异，但是要注意，由于主题的底层已经加上了对该页面的效果，所以需要遵循命名规范后修改文档\n123title: 标签date: 2019-10-01 10:00:00type: &quot;tags&quot;此时首页的标签按钮已经展示对应的页面内容了，其余的页面同理。\n友情链接前往你的Hexo根目录\n输入 hexo new page link\n找到 source/link/index.md 这个文件\n编辑这个文件123title: 链接date: 2019-10-01 10:00:00type: &quot;link&quot;注意，主题中配置友情链接的位置不是在该文件本身，而是需要你去 创建 source/_data目录，并且新建文件 link.yml12345678910111213class:  class_name: 友情链接  link_list:    1:      name: 名称      link: 地址      avatar: 头像      descr: 描述    #2:    #  name: xxxxxx    #  link: https:&#x2F;&#x2F;www.xxxxxxcn&#x2F;    #  avatar: https:&#x2F;&#x2F;xxxxx&#x2F;avatar.png    #  descr: xxxxxxx\n同时，可以在themes/Butterfly/_config.yml文件中，写上个人博客的信息，方便他人帮忙转载\n12345678Flink:  headline: 友情链接  info_headline: 我的Blog资料  name: Blog 名字： Dx  address: Blog 地址： https:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;  avatar: Blog 头像： https:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;img&#x2F;avatar.png  info: Blog 简介： 生命不息,折騰不止|  comment: 如果需要交换链接，请给我留言，谢谢~代码高亮Butterfly支持五种高亮样式：\ndefault\ndarker\npale night\nlight\nocean\n配置 _config.yml\n1highlight_theme: light复制配置 _config.yml\n12345678910111213# Highlight theme# ---------------highlight_theme: lighthighlight_copy: true    #代碼複製按鈕highlight_lang: true     #代碼語言顯示highlight_shrink: false #代碼框不展開，需點擊 &#39;&gt;&#39; 打開# copy setting# 是否禁止複製（如果禁止，highlight_copy的功能將無效)# copyright 複製的内容後面加上版權信息copy:  enable: true  # true 開啓 &#x2F; false 禁止  copyright: true换行在默认情况下，配置中是不开启换行功能的，如果不希望在代码中有横向滚动条，可以开启这个功能。配置 _config.yml\n123456code_word_wrap: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace:社交图标戳这里到对应的图标中心\n配置 _config.yml\n1234social:  fa fa-weixin: http:&#x2F;&#x2F;iblog.thatwang.com&#x2F;qrcode_for_gh_706ce3f91494_258.jpg  fa fa-weibo: http:&#x2F;&#x2F;weibo.cn&#x2F;wordpole9981  fa fa-qq: https:&#x2F;&#x2F;jq.qq.com&#x2F;?_wv&#x3D;1027&amp;k&#x3D;5E3IUHu文章版权配置 _config.yml\n1234post_copyright:  enable: true  license: CC BY-NC-SA 4.0  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;是否开启版权\n1copyright: false文章打赏配置 _config.yml\n123456789reward:  enable: true  QR_code:    - itemlist:        img: &#x2F;img&#x2F;wechat.jpg        text: 微信    - itemlist:        img: &#x2F;img&#x2F;alipay.jpg        text: 支付宝头像配置 _config.yml\n1avatar: https:&#x2F;&#x2F;xxxx&#x2F;avatar.png文章目录配置 _config.yml\n123toc:  enable: true  number: true  # 显示章节数字相关文章配置 _config.yml\n123related_post:  enable: true  limit: 6         # 显示推荐文章数量博客年份配置 _config.yml\n1since: 2018页脚配置 _config.yml\n1footer_custom_text: &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.thatwang.com&#x2F;&quot;&gt;Everybody&#39;s good at something.&lt;&#x2F;a&gt;夜间模式Apple都有这模式了，我们也不能输呀\n配置 _config.yml\n12darkmode:  enable: true阅读模式阅读模式会去除文章以外的内容\n配置 _config.yml\n12readmode:  enable: true侧边栏设置配置 _config.yml\n123456789aside:  position: right # left or right  card_author: true  card_announcement: true  card_recent_post: true  card_categories: true  card_tags: true  card_archives: true  card_webinfo: true访问人数配置 _config.yml\n1234busuanzi:  site_uv: true  site_pv: true  page_pv: true运行时间配置 _config.yml\n123456runtimeshow:  enable: true  start_date: 6&#x2F;7&#x2F;2018 00:00:00    ##博客开通时间  # 格式: 月&#x2F;日&#x2F;年 时间  # 也可以写成 年&#x2F;月&#x2F;日 时间相册文章页面编辑以下markdown格式内容\n123&#123;% gallery %&#125;markdown 圖片格式&#123;% endgallery %&#125;评论戳这个leancloud服务\n其实Hexo能支持很多评论系统，但是用下来，就leancloud这个最舒服，最方便\n配置 _config.yml\n123456789101112valine:  enable: true # if you want use valine,please set this value is true  appId: 配置中心查看  # leancloud application app id  appKey: key  # leancloud application app key  notify: false # valine mail notify (true&#x2F;false) https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki  verify: false # valine verify code (true&#x2F;false)  pageSize: 10 # comment list page size  avatar: robohash  # gravatar style https:&#x2F;&#x2F;valine.js.org&#x2F;#&#x2F;avatar  lang: zh-cn # i18n: zh-cn&#x2F;en  placeholder: 来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～ # valine comment input placeholder(like: Please leave your footprints )  guest_info: nick,mail,link #valine comment header info  bg: &#x2F;img&#x2F;comment_bg.png  # valine background注册登录\n创建应用\n获取key\n此时就安装好了评论系统，就这么简单\n音乐同样是使用leancloud服务\n前面的注册逻辑与评论一样，接下来就是存储环节\n加入单条音乐播放器的页面\n1&#123;% aplayer &quot;可以了&quot; &quot;陈奕迅&quot; &quot;https:&#x2F;&#x2F;xxx.xxx.com&#x2F;92b3af330d2274b1fa55.mp3&quot; &quot;https:&#x2F;&#x2F;xxx.xxx.com&#x2F;xx.png&quot; &quot;autoplay&quot; %&#125;加入列表音乐播放器的页面\n1&#123;% aplayerlist %&#125;&#123;&quot;narrow&quot;: false,&quot;autoplay&quot;: true,&quot;showlrc&quot;: 3,&quot;mode&quot;: &quot;random&quot;,&quot;music&quot;: [&#123;&quot;title&quot;: &quot;美好事物&quot;,&quot;author&quot;: &quot;房东的猫&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;945198c4909674765644.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;6e0e9e63cb0733f7ff12.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;,&#123;&quot;title&quot;: &quot;尚好的青春&quot;,&quot;author&quot;: &quot;云の泣&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;5b42b829b8ae08ccabe0.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;889df742eca5261f2fc5.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;,&#123;&quot;title&quot;: &quot;预谋邂逅&quot;,&quot;author&quot;: &quot;阿肆&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;1bd4f91441982710bcad.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;f72d61579f74d4ff9ce0.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;]&#125;&#123;% endaplayerlist %&#125;即可\n分享配置 _config.yml\n123sharejs:  enable: true  sites: wechat,weibo,qq搜索安装 hexo-generator-search，根据文档做对应配置\n配置 _config.yml\n12345local_search:  enable: true  labels:    input_placeholder: 试试看能找到啥宝藏吧!    hits_empty: &quot;客官，本店还未提供该服务: $&#123;query&#125;&quot; # if there are no result自定义主题配置 _config.yml\n1234567891011theme_color:   enable: true   main: &quot;#696969&quot;   paginator: &quot;#00c4b6&quot;   button_hover: &quot;#FF7242&quot;   text_selection: &quot;#00c4b6&quot;   link_color: &quot;#99a9bf&quot;   meta_color: &#39;#858585&#39;   hr_color: &quot;#A4D8FA&quot;   read-mode-bg_color: &#39;#FAF9DE&#39;   inline-code-color: &#39;#F47466&#39;打字效果配置 _config.yml\n12activate_power_mode:  enable: true动态彩带配置 _config.yml\n123canvas_ribbon_piao:  enable: true  mobile: false # false 手机端不显示 true 手机端显示背景线条配置 _config.yml\n1234567canvas_nest:  enable: true  color: &#39;0,0,255&#39; #color of lines, default: &#39;0,0,0&#39;; RGB values: (R,G,B).(note: use &#39;,&#39; to separate.)  opacity: 0.7 # the opacity of line (0~1), default: 0.5.  zIndex: -1 # z-index property of the background, default: -1.  count: 99 # the number of lines, default: 99.  mobile: false #  false 手机端不显示 true 手机端显示鼠标点击效果配置 _config.yml\n123456fireworks:  enable: true  # 點擊出現愛心click_heart:  enable: true首页弹幕座右铭配置 _config.yml\n12345678# 主頁subtitle# 打字效果# (如果有英文逗號&#39; , &#39;，請使用轉義字符 &amp;#44;)subtitle:  enable: true  sub:    - 努力不一定能成功&amp;#44;但是永远不会后悔    - Hard work may not always result in success&amp;#44;but it will never result in regret更新优化更新\n设置foot调整页脚高度，去除驱动和主题描述，，修改 By 字母为红色爱心。\n在路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug 下，将 By 替换为以下内容\n12Styl&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n123456789Code.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n自定义字体、鼠标指针样式引用格式\n123@font-face &#123; font-family:MyFont;src: url(https:xxx)&#125;body&#123;font-family:MyFont!important;&#125;\n引用方法：将引用代码添加到 D:\\blog\\themes\\Butterfly\\source\\css\\_third-partynormalize.min.css 末尾即可，鼠标样式亦是如此。\n\n鼠标样式\n\n引用格式123456789body &#123;cursor: url(https:&#x2F;&#x2F;xxx),    default;&#125;a,img &#123;    cursor: url(https:&#x2F;&#x2F;xxx),        default;&#125;\n","plink":"https://dxsummer.gitee.io/posts/10474aaf/"},{"title":"hexo的目录结构","date":"2020-04-13T06:21:52.000Z","date_formatted":{"ll":"2020年4月13日","L":"2020/04/13","MM-DD":"04-13"},"updated":"2020-06-08T01:51:17.822Z","content":"hexo的目录结构效果预览今天来整理一下hexo的目录结构，了解hexo每个目录的作用，并且设置全局配置文件 _config.yml 的相关参数，初步定义属于你自己的博客。我们开始吧.\n主目录结构12345678|-- _config.yml|-- package.json|-- scaffolds|-- source   |-- _posts|-- themes|-- .gitignore|-- package.json主目录介绍_config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。\npackage.jsonhexo框架的参数和所依赖插件，如下：\n12345678910111213141516171819&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;3.2.0&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^3.2.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;,    &quot;hexo-server&quot;: &quot;^0.2.0&quot;  &#125;&#125;scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。\nsource这个目录很重要，新建的文章都是在保存在这个目录下的._posts 。需要新建的博文都放在 _posts 目录下。_posts 目录下是一个个 markdown 文件。你应该可以看到一个hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。\nthemes网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题，我的子目录如下：\n12|-- landscape  &#x2F;&#x2F;默认主题|-- hexo-theme-next  &#x2F;&#x2F;第三方主题你也可以自己下载主题放到该文件下,hexo主题传送门\n_config.yml文件_config.yml 采用YAML语法格式，具体语法自行学习 。具体配置可以参考官方文档，_config.yml 文件中的内容，并对主要参数做简单的介绍\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Hexo Configuration## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;# Sitetitle: Hexo #网站标题subtitle:   #网站副标题description:  #网站描述author: John Doe  #作者language:    #语言timezone:    #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;yoursite.com   #你的站点Urlroot: &#x2F;                       #站点的根目录permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;   #文章的 永久链接 格式   permalink_defaults:    #永久链接中各部分的默认值# Directory   source_dir: source   #资源文件夹，这个文件夹用来存放内容public_dir: public     #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags         # 标签文件夹     archive_dir: archives    #归档文件夹category_dir: categories      #分类文件夹code_dir: downloads&#x2F;code     #Include code 文件夹i18n_dir: :lang                #国际化（i18n）文件夹skip_render:                #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post     #预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0     #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false  #是否显示草稿post_asset_folder: false  #是否启动 Asset 文件夹relative_link: false      #把链接改为与根目录的相对位址    future: true                #显示未来的文章highlight:                    #内容中代码块的设置      enable: true  line_number: true  auto_detect: false  tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:          #分类别名tag_map:            #标签别名# Date &#x2F; Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;date_format: YYYY-MM-DD         #日期格式time_format: HH:mm:ss        #时间格式    # Pagination## Set per_page to 0 to disable paginationper_page: 10    #分页数量pagination_dir: page  # Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: landscape   #主题名称# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html#  部署部分的设置deploy:       type:  #类型，常用的git\n网站存放在子目录如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。\n\nhexo的目录结构基本介绍完了，具体人配置需要在用的时候在启用。\n完整hexo教程，请访问hexo搭建个人博客\n","plink":"https://dxsummer.gitee.io/posts/48b5ba15/"},{"title":"Markdown教程","date":"2020-04-12T04:41:40.000Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2020-06-08T01:52:30.503Z","content":"Markdown教程1.Markdown标题二级标题三级标题123# 一级标题## 二级标题###三级标题2.段落格式字体斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n*斜体文本*  \n_斜体文本_  \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___分隔线\n\n12-------*******删除线、下划、脚注BAIDU.COM带下划线文本你们好,大家好\n1234~~BAIDU.COM~~   &lt;u&gt;带下划线文本&lt;&#x2F;u&gt;  你们好,[大家好][大家好]: hello3.Markdown列表无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记:  \n无序列表项\n无序列表项\n无序列表项   \n123* 无序列表项* 无序列表项* 无序列表项有序列表有序列表使用数字并加上 . 号来表示\n有序列表1\n有序列表2\n有序列表3\n1231. 有序列表12. 有序列表23. 有序列表3列表嵌套第一项：第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n第二项：第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n1234561. 第一项：- 第一项嵌套的第一个元素- 第一项嵌套的第二个元素2. 第二项：- 第二项嵌套的第一个元素- 第二项嵌套的第二个元素4.Markdown 区块区块引用\n这是一段引用段落，将会被高亮显示最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n1234&gt;这是一段引用段落，将会被高亮显示  &gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套区块中使用列表\n区块中使用列表\n第一项\n第二项  \n第一项\n第二项\n第三项\n\n123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项  &gt; + 第一项&gt; + 第二项&gt; + 第三项列表中使用区块第一项\n菜鸟教程学的不仅是技术更是梦想\n\n\n第二项1234* 第一项    &gt; 菜鸟教程      &gt; 学的不仅是技术更是梦想* 第二项\n5.Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）\nprintf() 函数\n1&#96;printf()&#96; 函数代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。  \njavascript\n$(document).ready(function () {\nalert(&apos;RUNOOB&apos;);\n});6.Markdown 链接超链接百度https://www.baidu.com/\n123[超链接名称](链接地址)或&lt;链接地址&gt;高级链接这个链接用 1 作为网址变量 Google这个链接用 runoob 作为网址变量 Runoob然后在文档的结尾为变量赋值（网址）\n123456这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;  [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F;7.Markdown 图片图片\n12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)使用实例：\n12![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png)![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png &quot;RUNOOB&quot;)当然，你也可以像网址那样对图片网址使用变量:  \n123这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.pngMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png&quot; width&#x3D;&quot;50%&quot;&gt;8.Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。| Tables        | Are           | Cool  || ————- |:————-:| —–:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |\n12345| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |对齐方式我们可以设置表格的对齐方式：\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。  \n实例如下：\n\n1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |9.Markdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：\n1使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑输出结果为：\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n12**文本加粗** \\*\\* 正常显示星号 \\*\\*输出结果为：\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n123456789101112\\   反斜线&#96;   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n12345678$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 &#x3D;  \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$输出结果：\n以下几个实例效果图如下：\n1、横向流程图源码格式：\n123456graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[横向流程图]2、竖向流程图源码格式：\n123456graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a&#x3D;1| D[结果1]    C --&gt; |a&#x3D;2| E[结果2]    F[竖向流程图]3、标准流程图源码格式：\n123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op4、标准流程图源码格式（横向）：\n123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op5、UML时序图源码样例：\n12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？6、UML时序图源码复杂样例：\n1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩7、UML标准时序图样例：\n123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!8、甘特图样例：\n12345678910111213141516171819%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h\n文字色块\nMarkDown 自带的文字高亮，其他方法就看第 3 点\n\n高亮文字\n1&lt;mark&gt;高亮文字&lt;&#x2F;mark&gt;\n利用 HTML 表格标签的 bgcolor 属性来实现文字背景色（整行填充背景），写法如下，文末附有常用颜色表。\n\n这里的背景色是：ForestGreen1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;PowderBlue&gt;这里的背景色是：PowderBlue&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;\n文字色块利用 span 标签赋予样式，引用边框用 p 标签变色。当然编辑器里无法预览效果\n\n黄色色块 绿色色块 蓝色色块 灰色色块 红色色块 紫色色块\n123456&lt;span id&#x3D;&quot;inline-yellow&quot;&gt;黄色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-green&quot;&gt;绿色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-blue&quot;&gt;蓝色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-grey&quot;&gt;灰色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-red&quot;&gt;红色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-purple&quot;&gt;紫色色块&lt;&#x2F;span&gt;\nCSS 样式里添加自定义颜色块，在文章中引用，主题不同配置有所差异，例如 NexT 主题在blog\\themes\\next\\source\\css\\_custom 下添加以下内容，Butterfly 主题在 blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下添加（不用在意符号，直接添加即可），各举一例，其余色块见其他文章。色块的所有配置传送点\n\n左边框红色块级\n右边框红色块级\n上边框蓝色块级CSS 样式里添加自定义颜色块，Butterfly 在 blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下添加（不用在意符号，直接添加即可）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F; 颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#000;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FFD700;&#125;    &#x2F;&#x2F; 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;&#x2F;&#x2F; 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;&#x2F;&#x2F; 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;&#x2F;&#x2F; 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;文章中添加代码\n左边框红色块级\n 右边框红色块级\n 上边框蓝色块级123&lt;p id&#x3D;&quot;div-border-left-red&quot;&gt;左边框红色块级&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;div-border-right-red&quot;&gt;右边框红色块级&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;div-border-top-blue&quot;&gt;上边框蓝色块级&lt;&#x2F;p&gt;\n字体样式\nMarkDown嵌入HTML文字样式即可，字体名称及颜色代码可在字体、颜色常用代码找到\n\n这是黑体字\n1&lt;font face&#x3D;&quot;黑体&quot;&gt;这是黑体字&lt;&#x2F;font&gt;这是微软雅黑\n1&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;这是微软雅黑&lt;&#x2F;font&gt;这是华文彩云\n1&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;这是华文彩云&lt;&#x2F;font&gt;三号蓝色黑体\n1&lt;font color&#x3D;#0099ff size&#x3D;3 face&#x3D;&quot;黑体&quot;&gt;三号蓝色黑体&lt;&#x2F;font&gt;四号青色字\n1&lt;font color&#x3D;#00ffff size&#x3D;4&gt;四号青色字&lt;&#x2F;font&gt;五号灰色字\n1&lt;font color&#x3D;gray size&#x3D;5&gt;五号灰色字&lt;&#x2F;font&gt;","plink":"https://dxsummer.gitee.io/posts/c079e252/"},{"title":"About","date":"2020-05-25T09:28:23.000Z","date_formatted":{"ll":"2020年5月25日","L":"2020/05/25","MM-DD":"05-25"},"updated":"2020-10-10T03:49:35.449Z","content":"\n\n  [Dx的博客🐷]\n  \n    \n    \n    \n    \n    与&nbsp;\n    DxSummer&nbsp;\n    （\n    \n    技术的进步总是从痛苦开始\n    \n    ）\n    \n    交流中...\n    \n    \n    \n    \n  \n\n\n\nbot_ui_ini()\n\n\n\n","plink":"https://dxsummer.gitee.io/about/"}]