[{"title":"数据结构(蓝桥杯)","date":"2022-03-11T12:44:49.000Z","date_formatted":{"ll":"2022年3月11日","L":"2022/03/11","MM-DD":"03-11"},"updated":"2022-03-17T15:29:46.715Z","content":"算法分析时间复杂度分析System.currentTimeMillis()\n123456789101112131415public class FileDemo &#123;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();        int sum = 0;        int n = 100;        for (int i = 1; i &lt;= n; i++) &#123;            sum += i;        &#125;        System.out.println(\"sum:\" + sum);        long end = System.currentTimeMillis();        System.out.println(end - start);    &#125;&#125;空间复杂度分析java中常见内存占用1.基本数据类型内存占用情况:\n\n数据类型内存占用字节数\n\nbyte1\n\nshort2\n\nint4\n\nlong8\n\nfloat4\n\ndouble8\n\nboolean1\n\nchar2\n2.计算机访问内存的方式都是一次一个字节\n\n3.一个引用(机器地址)需要8个字节表示:\n例如: Date date = new Date(),则date这个变量需要占用8个字节来表示\n4.创建一个对象，比如new Date()，除了Date对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也 有内存开销，每个对象的自身开销是16个字节，用来保存对象的头信息。\n5.一般内存的使用，如果不够8个字节，都会被自动填充为8字节:\n1234567public class A&#123;\tpublic int a = 1;&#125;通过new A() 创建一个对象的内存占用如下：\t1. 整型成员变量a占用4个字节\t2. 对象本身占用16个字节那么创建该对象总共需要20个字节，但由于不是以8为单位，会自动填充为24个字节6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要 24字节的头信息 (16个自己的对象开销，4字节用于保存长度以及4个填充字节)  再加上保存值所需的内存。\n算法的空间复杂度案例:\n对指定的数组元素进行反转，并返回反转的内容。\n解法一:\n12345678910public static int[] reverse1(int[] arr) &#123;    int n = arr.length;// 申请4个字节    int temp;// 申请4个字节    for (int start = 0, end = n - 1; start &lt;= end; start++, end--) &#123;        temp = arr[start];        arr[start] = arr[end];        arr[end] = temp;    &#125;    return arr;&#125;解法二:\n12345678public static int[] reverse2(int[] arr) &#123;    int n = arr.length;// 申请4个字节    int[] temp = new int[n]; // 申请n*4个字节+数组自身头信息开销24个字节    for (int i = n - 1; i &gt;= 0; i--) &#123;        temp[n - 1 - i] = arr[i];    &#125;    return temp;&#125;忽略判断条件占用的内存，我们得出的内存占用情况如下: \n算法一: \n不管传入的数组大小为多少，始终额外申请4+4=8个字节; \n算法二:\n4+4n+24=4n+28; \n根据大O推导法则，算法一的空间复杂度为O(1),算法二的空间复杂度为O(n),所以从空间占用的角度讲，算法一要优于算法二。 \n由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化(例如即时编译)，我们无法精确的评估一个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。 \n由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。\n但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几 kb，这个时候对算法的空间复杂度就有要求了，但是一般做java开发的，基本上都是服务器开发，一般不存在这样 的问题。\n排序简单排序在java的开发工具包jdk中，已经给我们提供了很多数据结构与算法的实现，比如List，Set，Map，Math等等，都 是以API的方式提供，这种方式的好处在于一次编写，多处使用。我们借鉴jdk的方式，也把算法封装到某个类中， 那如果是这样，在我们写java代码之前，就需要先进行API的设计，设计好之后，再对这些API进行实现。\n就比如我们先设计一套API如下:\n\n类名ArrayList\n\n构造方法ArrayList():创建ArrayList对象\n\n成员方法1.  boolean add(E e):向集合中添加元素2.  E remove(int index):从集合中删除指定的元素\nComparable接口介绍由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序 规则的，在这里我们以案例的形式对Comparable接口做一个简单的回顾。\n需求: 1.定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则;\n 2.定义测试类Test，在测试类Test中定义测试方法Comparable getMax(Comparable c1,Comparable c2)完成测试\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758// 学生类class Student implements Comparable&lt;Student&gt; &#123;    private String username;    private int age;    public String getUsername() &#123;        return username;    &#125;    public void setUsername(String username) &#123;        this.username = username;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public String toString() &#123;        return \"Student&#123;\" +                \"username='\" + username + '\\'' + \", age=\" + age +                '&#125;';    &#125;    // 定义比较规则    @Override    public int compareTo(Student o) &#123;        return this.getAge() - o.getAge();    &#125;&#125;// 测试类public class Test &#123;    public static void main(String[] args) &#123;        Student stu1 = new Student();        stu1.setUsername(\"zhangsan\");        stu1.setAge(17);        Student stu2 = new Student();        stu2.setUsername(\"lisi\");        stu2.setAge(19);        Comparable max = getMax(stu1, stu2);        System.out.println(max);    &#125;    // 测试方法，获取两个元素中的较大值    public static Comparable getMax(Comparable c1, Comparable c2) &#123;        int cmp = c1.compareTo(c2);        if (cmp &gt;= 0) &#123;            return c1;        &#125; else &#123;            return c2;        &#125;    &#125;&#125;冒泡排序冒泡排序(Bubble Sort)，是一种计算机科学领域的较简单的排序算法。 需求:\n排序前:{4,5,6,3,2,1}\n排序后:{1,2,3,4,5,6} \n排序原理:\n比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。\n对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。\n\n\n冒泡排序API设计:\n\n类名Bubble\n\n构造方法Bubble() : 创建Bubble对象\n\n成员方法1.public static void sort(Comparable[] a):对数组内的元素进行排序2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w3.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值\n12345678910111213141516171819202122232425262728293031323334353637383940// 排序代码public class Bubble &#123;    /*     * 对数组a中的元素进行排序     */    public static void sort(Comparable[] a) &#123;        for (int i = a.length - 1; i &gt; 0; i--) &#123;            for (int j = 0; j &lt; i; j++) &#123;                if (greater(a[j], a[j + 1])) &#123;                    exch(a, j, j + 1);                &#125;            &#125;        &#125;    &#125;    /*     * 比较v元素是否大于w元素     */    private static boolean greater(Comparable v, Comparable w) &#123;        return v.compareTo(w) &gt; 0;    &#125;    /*     * 数组元素i和j交换位置     */    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) &#123;        Integer[] a = &#123; 4, 5, 6, 3, 2, 1 &#125;;        Bubble.sort(a);        System.out.println(Arrays.toString(a));    &#125;&#125;冒泡排序的时间复杂度分析 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以， 我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。\n在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么: \n元素比较的次数为:\n(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;\n元素交换的次数为:\n(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;\n总执行次数为:\n(N^2/2-N/2)+(N^2/2-N/2)=N^2-N; \n按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的时间复杂度为O(N^2)\n选择排序选择排序是一种更加简单直观的排序方法。\n需求:\n排序前:{4,6,8,7,9,2,10,1} \n排序后:{1,2,4,5,7,8,9,10}\n排序原理:\n每一次遍历的过程中，都假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较，如果当前索引处 的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引\n交换第一个索引处和最小值所在的索引处的值\n\n\n\n类别Selection\n\n构造方法Selection():创建Selection对象\n\n成员方法1.public static void sort(Comparable[] a):对数组内的元素进行排序2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w 3.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 排序代码import java.util.Arrays;class Selection &#123;    /*     * 对数组a中的元素进行排序     */    public static void sort(Comparable[] a) &#123;        for (int i = 0; i &lt;= a.length - 2; i++) &#123;            // 假定本次遍历，最小 值 所在的索引是i            int minIndex = i;            for (int j = i + 1; j &lt; a.length; j++) &#123;                if (greater(a[minIndex], a[j])) &#123;                    // 跟换最小值 所 在的索引                    minIndex = j;                &#125;            &#125;            // 交换i索引处和minIndex索引处的值            exch(a, i, minIndex);        &#125;    &#125;    /*     * 比较v元素是否大于w元素     */    private static boolean greater(Comparable v, Comparable w) &#123;        return v.compareTo(w) &gt; 0;    &#125;    /*     * 数组元素i和j交换位置     */    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) &#123;        Integer[] a = &#123; 4, 6, 8, 7, 9, 2, 10, 1 &#125;;        Selection.sort(a);        System.out.println(Arrays.toString(a));    &#125;&#125;选择排序的时间复杂度分析:\n选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据交换次数和数据比较次数:\n数据比较次数:\n(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;\n数据交换次数:\nN-1 \n时间复杂度:N^2/2-N/2+(N-1)=N^2/2+N/2-1;\n根据大O推导法则，保留最高阶项，去除常数因子，时间复杂度为O(N^2);\n插入排序插入排序(Insertion sort)是一种简单直观且稳定的排序算法。\n需求: 排序前:{4,3,2,10,12,1,5,6} 排序后:{1,2,3,4,5,6,10,12}\n排序原理:\n1.把所有的元素分为两组，已经排序的和未排序的; \n2.找到未排序的组中的第一个元素，向已经排序的组中进行插入;\n3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待 插入元素放到这个位置，其他的元素向后移动一位;\n\n\n插入排序API设计:\n\n类别Insertion\n\n构造方法Insertion():创建Insertion对象\n\n成员方法1.public static void sort(Comparable[] a):对数组内的元素进行排序2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w  3.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值\n插入排序代码实现:\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import java.util.Arrays;class Insertion &#123;    /*     * 对数组a中的元素进行排序     */    public static void sort(Comparable[] a) &#123;        for (int i = 1; i &lt; a.length; i++) &#123;            // 当前元素为a[i],依次和i前面的元素比较，找到一个小于等于a[i]的元素            for (int j = i; j &gt; 0; j--) &#123;                if (greater(a[j - 1], a[j])) &#123;                    // 交换元素                    exch(a, j - 1, j);                &#125; else &#123;                    // 找到了该元素，结束                    break;                &#125;            &#125;        &#125;    &#125;    /*     * 比较v元素是否大于w元素     */    private static boolean greater(Comparable v, Comparable w) &#123;        return v.compareTo(w) &gt; 0;    &#125;    /*     * 数组元素i和j交换位置     */    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Integer[] a = &#123; 4, 3, 2, 10, 12, 1, 5, 6 &#125;;        Insertion.sort(a);        System.out.println(Arrays.toString(a));    &#125;&#125;插入排序的时间复杂度分析\n插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复 杂度，主要分析一下内层循环体的执行次数即可。\n最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么: \n比较的次数为: \n(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; \n交换的次数为:\n(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; \n总执行次数为:\n(N^2/2-N/2)+(N^2/2-N/2)=N^2-N; \n按照大O推导法则，保留函数中的最高阶项那么最终插入排序的时间复杂度为O(N^2).\n高级排序之前我们学习过基础排序，包括冒泡排序，选择排序还有插入排序，并且对他们在最坏情况下的时间复杂度做了分 析，发现都是O(N^2)，而平方阶通过我们之前学习算法分析我们知道，随着输入规模的增大，时间成本将急剧上升，所以这些基本排序方法不能处理更大规模的问题，接下来我们学习一些高级的排序算法，争取降低算法的时间 复杂度最高阶次幂。\n希尔排序希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本\n前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组 元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真 正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到 更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数， 这样的需求如何实现呢?接下来我们来看看希尔排序的原理。\n需求: \n排序前:{9,1,2,5,7,4,8,6,3,5} \n排序后:{1,2,3,4,5,5,6,7,8,9}\n排序原理: \n选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组; \n对分好组的每一组数据完成插入排序;\n减小增长量，最小减为1，重复第二步操作。\n\n增长量h的确定:增长量h的值每一固定的规则，我们这里采用以下规则:\n12345678int h = 1;while(h&lt;数组的长度/2)&#123;    h=2*h+1; // 1 3 7 15&#125;// 循环结束后我们就可以确定h的最大值h的减小规则：\t\th=h/2;希尔排序的API设计:\n\n类别shell\n\n构造方法Shell():创建Shell对象\n\n成员方法1.public static void sort(Comparable[] a):对数组内的元素进行排序2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w3.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值\n希尔排序的代码实现:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import java.util.Arrays;class Shell &#123;    /*        对数组a中的元素进行排序    */    public static void sort(Comparable[] a) &#123;        int N = a.length;        // 确定增长量h的最大值        int h = 1;        while (h &lt; N / 2) &#123;            h = h * 2 + 1;        &#125;        // 当增长量h小于1，排序结束        while (h &gt;= 1) &#123;            // 找到待插入的元素            for (int i = h; i &lt; N; i++) &#123;                // a[i]就是待插入的元素                //把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中                for (int j = i; j &gt;= h; j -= h) &#123;                    //a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么 交换位置，如果不小于，a[j]大，则插入完成。                    if (greater(a[j - h], a[j])) &#123;                        exch(a, j, j - h);                    &#125; else &#123;                        break;                    &#125;                &#125;            &#125;            h /= 2;        &#125;    &#125;    /*        比较v元素是否大于w元素    */    private static boolean greater(Comparable v, Comparable w) &#123;        return v.compareTo(w) &gt; 0;    &#125;    /*        数组元素i和j交换位置     */    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;public class Test &#123;    public static void main(String[] args) &#123;        Integer[] a = &#123;9, 1, 2, 5, 7, 4, 8, 6, 3, 5&#125;;        Shell.sort(a);        System.out.println(Arrays.toString(a));    &#125;&#125;希尔排序的时间复杂度分析\n在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最 好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。\n我们可以使用事后分析法对希尔排序和插入排序做性能比较。\n在资料的测试数据文件夹下有一个reverse_shell_insertion.txt文件，里面存放的是从100000到1的逆向数据，我们 可以根据这个批量数据完成测试。测试的思想:在执行排序前前记录一个时间，在排序完成后记录一个时间，两个 时间的时间差就是排序的耗时。\n希尔排序和插入排序性能比较测试代码:\n12345678910111213141516171819202122232425262728293031323334353637383940import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStreamReader;import java.util.ArrayList;public class SortCompare &#123;    public static void main(String[] args) throws Exception &#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        //读取reverse_arr.txt文件        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"reverse_shell_insertion.txt\")));        String line = null;        while ((line = reader.readLine()) != null) &#123;            //把每一个数字存入到集合中            list.add(Integer.valueOf(line));        &#125;        reader.close();        //把集合转换成数组        Integer[] arr = new Integer[list.size()];        list.toArray(arr);        testInsertion(arr);//使用插入排序耗时:20859        testShell(arr);//使用希尔排序耗时:31    &#125;    public static void testInsertion(Integer[] arr) &#123;        //使用插入排序完成测试        long start = System.currentTimeMillis();        Insertion.sort(arr);        long end = System.currentTimeMillis();        System.out.println(\"使用插入排序耗时:\" + (end - start));    &#125;    public static void testShell(Integer[] arr) &#123;        //使用希尔排序完成测试        long start = System.currentTimeMillis();        Shell.sort(arr);        long end = System.currentTimeMillis();        System.out.println(\"使用希尔排序耗时:\" + (end - start));    &#125;&#125;通过测试发现，在处理大批量数据时，希尔排序的性能确实高于插入排序。\n归并排序递归定义:\n定义方法时，在方法内部调用方法本身，称之为递归.\n1234public void show()&#123;   \tSystem.out.println(\"aaaa\");   \tshow();&#125;作用:\n它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。\n注意事项:\n 在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。\n\n需求: 请定义一个方法，使用递归完成求N的阶乘;\n12345678分析:1!: 12!: 2*1=2*1!3!: 3*2*1=3*2!4!: 4*3*2*1=4*3!...n!: n*(n-1)*(n-2)...*2*1=n*(n-1)!所以，假设有一个方法factorial(n)用来求n的阶乘，那么n的阶乘还可以表示为n*factorial(n-1)代码实现:\n12345678910111213class Test &#123;    public static void main(String[] args) throws Exception &#123;        int result = factorial(5);        System.out.println(result);    &#125;    public static int factorial(int n) &#123;        if (n == 1) &#123;            return 1;        &#125;        return n * factorial(n - 1);    &#125;&#125;归并排序归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列;即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。\n需求: \n排序前:{8,4,5,7,1,3,6,2} \n排序后:{1,2,3,4,5,6,7,8} \n排序原理:\n1.尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。\n2.将相邻的两个子组进行合并成一个有序的大组; \n3.不断的重复步骤2，直到最终只有一个组为止。\n\n\n归并排序API设计:\n\n类别Merge\n\n构造方法Merge():创建Merge对象\n\n成员方法1.public static void sort(Comparable[] a):对数组内的元素进行排序2.private static void sort(Comparable[] a, int lo, int hi):对数组a中从索引lo到索引hi之间的元素进 行排序3.private static void merge(Comparable[] a, int lo, int mid, int hi):从索引lo到所以mid为一个子 组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组(从 索引lo到索引hi)4.private static boolean less(Comparable v,Comparable w):判断v是否小于w5.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值\n\n成员变量1.private static Comparable[] assist:完成归并操作需要的辅助数组\n归并原理:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import java.util.Arrays;//排序代码public class Merge &#123;    private static Comparable[] assist;//归并所需要的辅助数组    /*        对数组a中的元素进行排序     */    public static void sort(Comparable[] a) &#123;        assist = new Comparable[a.length];        int lo = 0;        int hi = a.length - 1;        sort(a, lo, hi);    &#125;    /*         对数组a中从lo到hi的元素进行排序     */    private static void sort(Comparable[] a, int lo, int hi) &#123;        if (hi &lt;= lo) &#123;            return;        &#125;        int mid = lo + (hi - lo) / 2;        //对lo到mid之间的元素进行排序;        sort(a, lo, mid);        //对mid+1到hi之间的元素进行排序;        sort(a, mid + 1, hi);        //对lo到mid这组数据和mid到hi这组数据进行归并         merge(a, lo, mid, hi);    &#125;    /*         对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并     */    private static void merge(Comparable[] a, int lo, int mid, int hi) &#123;        //lo到mid这组数据和mid+1到hi这组数据归并到辅助数组assist对应的索引处         int i = lo;//定义一个指针，指向assist数组中开始填充数据的索引        int p1 = lo;//定义一个指针，指向第一组数据的第一个元素        int p2 = mid + 1;//定义一个指针，指向第二组数据的第一个元素        //比较左边小组和右边小组中的元素大小，哪个小，就把哪个数据填充到assist数组中         while (p1 &lt;= mid &amp;&amp; p2 &lt;= hi) &#123;            if (less(a[p1], a[p2])) &#123;                assist[i++] = a[p1++];            &#125; else &#123;                assist[i++] = a[p2++];            &#125;        &#125;        //上面的循环结束后，如果退出循环的条件是p1&lt;=mid，则证明左边小组中的数据已经归并完毕，如果退 出循环的条件是p2&lt;=hi,则证明右边小组的数据已经填充完毕;        //所以需要把未填充完毕的数据继续填充到assist中      \t//下面两个循环，只会执行其中的一个         while (p1 &lt;= mid) &#123;            assist[i++] = a[p1++];        &#125;        while (p2 &lt;= hi) &#123;            assist[i++] = a[p2++];        &#125;        //到现在为止，assist数组中，从lo到hi的元素是有序的，再把数据拷贝到a数组中对应的索引处        for (int index = lo; index &lt;= hi; index++) &#123;            a[index] = assist[index];        &#125;    &#125;    /*        比较v元素是否小于w元素    */    private static boolean less(Comparable v, Comparable w) &#123;        return v.compareTo(w) &lt; 0;    &#125;    /*         数组元素i和j交换位置     */    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable t = a[i];        a[i] = a[j];        a[j] = t;    &#125;&#125;//测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Integer[] arr = &#123;8, 4, 5, 7, 1, 3, 6, 2&#125;;        Merge.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;&#125;归并排序时间复杂度分析:\n归并排序是分治思想的最典型的例子，上面的算法中，对a[lo…hi]进行排序，先将它分为a[lo…mid]和a[mid+1…hi] 两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果 一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。\n用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆log8次，值为3，所以 树共有3层,那么自顶向下第k层有2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较。因此每层 的比较次数为 2^k * 2^(3-k)=2^3,那么3层总共为 3*2^3。\n假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面32^3中 的3这个层数，最终得出的归并排序的时间复杂度为:log2(n)\\ 2^(log2(n))=log2(n)*n,根据大O推导法则，忽略底 数，最终归并排序的时间复杂度为O(nlogn);\n归并排序的缺点:\n需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。\n归并排序与希尔排序性能测试:\n之前我们通过测试可以知道希尔排序的性能是由于插入排序的，那现在学习了归并排序后，归并排序的效率与希尔排序的效率哪个高呢?我们使用同样的测试方式来完成一样这两个排序算法之间的性能比较。\n在资料的测试数据文件夹下有一个reverse_arr.txt文件，里面存放的是从1000000到1的逆向数据，我们可以根据 这个批量数据完成测试。测试的思想:在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时 间差就是排序的耗时。\n希尔排序和插入排序性能比较测试代码:\n12345678910111213141516171819202122232425262728293031323334353637383940import java.io.BufferedReader;import java.io.FileInputStream;import java.io.InputStreamReader;import java.util.ArrayList;public class SortCompare &#123;    public static void main(String[] args) throws Exception &#123;        ArrayList&lt;Integer&gt; list = new ArrayList&lt;&gt;();        //读取a.txt文件        BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(\"reverse_merge_shell.txt\")));        String line = null;        while ((line = reader.readLine()) != null) &#123;            //把每一个数字存入到集合中             list.add(Integer.valueOf(line));        &#125;        reader.close();        //把集合转换成数组        Integer[] arr = new Integer[list.size()];        list.toArray(arr);        testMerge(arr);//使用归并排序耗时:1200         testShell(arr);//使用希尔排序耗时:1277    &#125;    public static void testMerge(Integer[] arr) &#123;        //使用插入排序完成测试        long start = System.currentTimeMillis();        Merge.sort(arr);        long end = System.currentTimeMillis();        System.out.println(\"使用归并排序耗时:\" + (end - start));    &#125;    public static void testShell(Integer[] arr) &#123;        //使用希尔排序完成测试        long start = System.currentTimeMillis();        Shell.sort(arr);        long end = System.currentTimeMillis();        System.out.println(\"使用希尔排序耗时:\" + (end - start));    &#125;&#125;通过测试，发现希尔排序和归并排序在处理大批量数据时差别不是很大。\n快速排序快速排序是对冒泡排序的一种改进。它的基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n需求:\n排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}\n排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9}\n排序原理: \n首先设定一个分界值，通过该分界值将数组分成左右两部分;\n将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于 或等于分界值，而右边部分中各元素都大于或等于分界值;\n然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两 部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。\n重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当 左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。\n\n\n类别Quick\n\n构造方法Quick():创建Quick对象\n\n成员方法1.public static void sort(Comparable[] a):对数组内的元素进行排序2.private static void sort(Comparable[] a, int lo, int hi):对数组a中从索引lo到索引hi之间的元素 进行排序3.public static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引 lo到索引 hi之间的元 素进行分组，并返回分组界限对应的索引4.private static boolean less(Comparable v,Comparable w):判断v是否小于w5.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值\n切分原理:\n把一个数组切分成两个子数组的基本思想: \n1.找一个基准值，用两个指针分别指向数组的头部和尾部; \n2.先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置; \n3.再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置; \n4.交换当前左边指针位置和右边指针位置的元素; \n5.重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。\n 快速排序代码实现:\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273import java.util.Arrays;//排序代码public class Quick &#123;    public static void sort(Comparable[] a) &#123;        int lo = 0;        int hi = a.length - 1;        sort(a, lo, hi);    &#125;    private static void sort(Comparable[] a, int lo, int hi) &#123;        if (hi &lt;= lo) &#123;            return;        &#125;        //对a数组中，从lo到hi的元素进行切分        int partition = partition(a, lo, hi);        //对左边分组中的元素进行排序        //对右边分组中的元素进行排序        sort(a, lo, partition - 1);        sort(a, partition + 1, hi);    &#125;    public static int partition(Comparable[] a, int lo, int hi) &#123;        Comparable key = a[lo];//把最左边的元素当做基准值        int left = lo;//定义一个左侧指针，初始指向最左边的元素        int right = hi + 1;//定义一个右侧指针，初始指向左右侧的元素下一个位置 //进行切分        while (true) &#123;            //先从右往左扫描，找到一个比基准值小的元素            while (less(key, a[--right])) &#123;//循环停止，证明找到了一个比基准值小的元素                if (right == lo) &#123;                    break;//已经扫描到最左边了，无需继续扫描                &#125;            &#125;            //再从左往右扫描，找一个比基准值大的元素            while (less(a[++left], key)) &#123;//循环停止，证明找到了一个比基准值大的元素                if (left == hi) &#123;                    break;//已经扫描到了最右边了，无需继续扫描                &#125;            &#125;            if (left &gt;= right) &#123; //扫描完了所有元素，结束循环                break;            &#125; else &#123; //交换left和right索引处的元素                exch(a, left, right);            &#125;        &#125;        //交换最后rigth索引处和基准值所在的索引处的值        exch(a, lo, right);        return right;//right就是切分的界限    &#125;    /* 数组元素i和j交换位置     */    private static void exch(Comparable[] a, int i, int j) &#123;        Comparable t = a[i];        a[i] = a[j];        a[j] = t;    &#125;    /* 比较v元素是否小于w元素     */    private static boolean less(Comparable v, Comparable w) &#123;        return v.compareTo(w) &lt; 0;    &#125;&#125;//测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Integer[] arr = &#123;6, 1, 2, 7, 9, 3, 4, 5, 8&#125;;        Quick.sort(arr);        System.out.println(Arrays.toString(arr));    &#125;&#125;快速排序和归并排序的区别:\n快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的:归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。\n快速排序时间复杂度分析:\n快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个 快速排序的时间复杂度和切分的次数相关。\n最优情况:每一次切分选择的基准数字刚好将当前序列等分。\n如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，最优情况下快 速排序的时间复杂度为O(nlogn);\n最坏情况:每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总 共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2);\n平均情况:每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对 平均情况的时间复杂度做证明了。\n排序的稳定性稳定性的定义:\n数组arr中有若干元素，其中A元素和B元素相等，并且A元素在B元素前面，如果使用某种排序算法排序后，能够保 证A元素依然在B元素的前面，可以说这个该算法是稳定的。\n稳定性的意义:\n如果一组数据只需要一次排序，则稳定性一般是没有意义的，如果一组数据需要多次排序，稳定性是有意义的。例如要排序的内容是一组商品对象，第一次排序按照价格由低到高排序，第二次排序按照销量由高到低排序，如果第二次排序使用稳定性算法，就可以使得相同销量的对象依旧保持着价格高低的顺序展现，只有销量不同的对象才需要重新排序。这样既可以保持第一次排序的原有意义，而且可以减少系统开销。\n第一次按照价格从低到高排序:\n\n商品名称价格销量\n\n三星Note9399921\n\n华为mate30499965\n\n华为p30599965\n\nIphone 11689932\n第二次按照销量进行从高到低排序:\n\n商品名称价格销量\n\n华为mate30499965\n\n华为p30599965\n\nIphone 11689932\n\n三星Note9399921\n常见排序算法的稳定性:\n冒泡排序:\n只有当arr[i]&gt;arr[i+1]的时候，才会交换元素的位置，而相等的时候并不交换位置，所以冒泡排序是一种稳定排序 算法。\n选择排序:\n选择排序是给每个位置选择当前元素最小的,例如有数据{5(1)，8 ，5(2)， 2， 9 },第一遍选择到的最小元素为2，所以5(1)会和2进行交换位置，此时5(1)到了5(2)后面，破坏了稳定性，所以选择排序是一种不稳定的排序算法。 \n插入排序:\n比较是从有序序列的末尾开始，也就是想要插入的元素和已经有序的最大者开始比起，如果比它大则直接插入在其后面，否则一直往前找直到找到它该插入的位置。如果碰见一个和插入元素相等的，那么把要插入的元素放在相等元素的后面。所以，相等元素的前后顺序没有改变，从原无序序列出去的顺序就是排好序后的顺序，所以插入排序是稳定的。\n希尔排序:\n希尔排序是按照不同步长对元素进行插入排序 ,虽然一次插入排序是稳定的，不会改变相同元素的相对顺序，但在 不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，最后其稳定性就会被打乱，所以希尔排序是不 稳定的。\n归并排序:\n归并排序在归并的过程中，只有arr[i]&lt;arr[i+1]的时候才会交换位置，如果两个元素相等则不会交换位置，所以它并不会破坏稳定性，归并排序是稳定的。\n快速排序:\n快速排序需要一个基准值，在基准值的右侧找一个比基准值小的元素，在基准值的左侧找一个比基准值大的元素，然后交换这两个元素，此时会破坏稳定性，所以快速排序是一种不稳定的算法。\n线性表线性表是最基本、最简单、也是最常用的一种数据结构。一个线性表是n个具有相同特性的数据元素的有限序列。\n前驱元素: \n若A元素在B元素的前面，则称A为B的前驱元素\n后继元素: \n若B元素在A元素的后面，则称B为A的后继元素\n线性表的特征: 数据元素之间具有一种“一对一”的逻辑关系。\n第一个数据元素没有前驱，这个数据元素被称为头结点;\n\n最后一个数据元素没有后继，这个数据元素被称为尾结点;\n\n除了第一个和最后一个数据元素外，其他数据元素有且仅有一个前驱和一个后继。\n\n如果把线性表用数学语言来定义，则可以表示为(a1,…ai-1,ai,ai+1,…an)，ai-1领先于ai,ai领先于ai+1，称ai-1是ai的 前驱元素，ai+1是ai的后继元素\n线性表的分类:\n线性表中数据存储的方式可以是顺序存储，也可以是链式存储，按照数据的存储方式不同，可以把线性表分为顺序表和链表。\n顺序表顺序表是在计算机内存中以数组的形式保存的线性表，线性表的顺序存储是指用一组地址连续的存储单元，依次存储线性表中的各个元素、使得线性表中再逻辑结构上响铃的数据元素存储在相邻的物理存储单元中，即通过数据元素物理存储的相邻关系来反映数据元素之间逻辑上的相邻关系。\n顺序表的实现顺序表API设计:\n\n类别SequenceList\n\n构造方法SequenceList(int capacity):创建容量为capacity的SequenceList对象\n\n成员方法1.public void clear():空置线性表2.publicboolean isEmpty():判断线性表是否为空，是返回true，否返回false3.public int length():获取线性表中元素的个数4.public T get(int i):读取并返回线性表中的第i个元素的值5.public void insert(int i,T t):在线性表的第i个元素之前插入一个值为t的数据元素。6.public void insert(T t):向线性表中添加一个元素t7.public T remove(int i):删除并返回线性表中第i个数据元素。8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返 回-1\n\n成员变量1.private T[] eles:存储元素的数组2.private int N:当前线性表的长度\n顺序表的代码实现:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114//顺序表代码class SequenceList&lt;T&gt; &#123;    //存储元素的数组    private T[] eles; //记录当前顺序表中的元素个数    private int N;    //构造方法    public SequenceList(int capacity) &#123;        eles = (T[]) new Object[capacity];        N = 0;    &#125;    //将一个线性表置为空表    public void clear() &#123;        N = 0;    &#125;    //判断当前线性表是否为空表    public boolean isEmpty() &#123;        return N == 0;    &#125;    //获取线性表的长度    public int length() &#123;        return N;    &#125;    //获取指定位置的元素    public T get(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"当前元素不存在!\");        &#125;        return eles[i];    &#125;    //向线型表中添加元素t    public void insert(T t) &#123;        if (N == eles.length) &#123;            throw new RuntimeException(\"当前表已满\");        &#125;        eles[N++] = t;    &#125;    //在i元素处插入元素t    public void insert(int i, T t) &#123;        if (i == eles.length) &#123;            throw new RuntimeException(\"当前表已满\");        &#125;        if (i &lt; 0 || i &gt; N) &#123;            throw new RuntimeException(\"插入的位置不合法\");        &#125;        //把i位置空出来，i位置及其后面的元素依次向后移动一位        for (int index = N; index &gt; i; index--) &#123;            eles[index] = eles[index - 1];        &#125;        //把t放到i位置处        eles[i] = t;        //元素数量+1        N++;    &#125;    //删除指定位置i处的元素，并返回该元素    public T remove(int i) &#123;        if (i &lt; 0 || i &gt; N - 1) &#123;            throw new RuntimeException(\"当前要删除的元素不存在\");        &#125;        //记录i位置处的元素        T result = eles[i];        //把i位置后面的元素都向前移动一位        for (int index = i; index &lt; N - 1; index++) &#123;            eles[index] = eles[index + 1];        &#125;        //当前元素数量-1        N--;        return result;    &#125;    //查找t元素第一次出现的位置    public int indexOf(T t) &#123;        if (t == null) &#123;            throw new RuntimeException(\"查找的元素不合法\");        &#125;        for (int i = 0; i &lt; N; i++) &#123;            if (eles[i].equals(t)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;&#125;//测试代码public class SequenceListTest &#123;    public static void main(String[] args) &#123;        //创建顺序表对象        SequenceList&lt;String&gt; sl = new SequenceList&lt;&gt;(10);        //测试插入        sl.insert(\"姚明\");        sl.insert(\"科比\");        sl.insert(\"麦迪\");        sl.insert(1, \"詹姆斯\");        //测试获取        String getResult = sl.get(1);        System.out.println(\"获取索引1处的结果为:\" + getResult); //测试删除        String removeResult = sl.remove(0);        System.out.println(\"删除的元素是:\" + removeResult);        //测试清空        sl.clear();        System.out.println(\"清空后的线性表中的元素个数为:\" + sl.length());    &#125;&#125;顺序表的遍历一般作为容器存储数据，都需要向外部提供遍历的方式，因此我们需要给顺序表提供遍历方式。\n在java中，遍历集合的方式一般都是用的是foreach循环，如果想让我们的SequenceList也能支持foreach循环，则 需要做如下操作:\n让SequenceList实现Iterable接口，重写iterator方法; \n在SequenceList内部提供一个内部类SIterator,实现Iterator接口，重写hasNext方法和next方法;\n代码:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144package test1;import java.util.Iterator;//顺序表代码class SequenceList&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 存储元素的数组    private T[] eles;   \t// 记录当前顺序表中的元素个数    private int N;    // 构造方法    public SequenceList(int capacity) &#123;        eles = (T[]) new Object[capacity];        N = 0;    &#125;    // 将一个线性表置为空表    public void clear() &#123;        N = 0;    &#125;    // 判断当前线性表是否为空表    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 获取线性表的长度    public int length() &#123;        return N;    &#125;    // 获取指定位置的元素    public T get(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"当前元素不存在!\");        &#125;        return eles[i];    &#125;    // 向线型表中添加元素t    public void insert(T t) &#123;        if (N == eles.length) &#123;            throw new RuntimeException(\"当前表已满\");        &#125;        eles[N++] = t;    &#125;    // 在i元素处插入元素t    public void insert(int i, T t) &#123;        if (i == eles.length) &#123;            throw new RuntimeException(\"当前表已满\");        &#125;        if (i &lt; 0 || i &gt; N) &#123;            throw new RuntimeException(\"插入的位置不合法\");        &#125;        // 把i位置空出来，i位置及其后面的元素依次向后移动一位        for (int index = N; index &gt; i; index--) &#123;            eles[index] = eles[index - 1];        &#125;        // 把t放到i位置处        eles[i] = t;        // 元素数量+1        N++;    &#125;    // 删除指定位置i处的元素，并返回该元素    public T remove(int i) &#123;        if (i &lt; 0 || i &gt; N - 1) &#123;            throw new RuntimeException(\"当前要删除的元素不存在\");        &#125;        // 记录i位置处的元素        T result = eles[i];        // 把i位置后面的元素都向前移动一位        for (int index = i; index &lt; N - 1; index++) &#123;            eles[index] = eles[index + 1];        &#125;        // 当前元素数量-1        N--;        return result;    &#125;    // 查找t元素第一次出现的位置    public int indexOf(T t) &#123;        if (t == null) &#123;            throw new RuntimeException(\"查找的元素不合法\");        &#125;        for (int i = 0; i &lt; N; i++) &#123;            if (eles[i].equals(t)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    // 打印当前线性表的元素    public void showEles() &#123;        for (int i = 0; i &lt; N; i++) &#123;            System.out.print(eles[i] + \" \");        &#125;        System.out.println();    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new SIterator();    &#125;    private class SIterator implements Iterator &#123;        private int cur;        public SIterator() &#123;            this.cur = 0;        &#125;        @Override        public boolean hasNext() &#123;            return cur &lt; N;        &#125;        @Override        public T next() &#123;            return eles[cur++];        &#125;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        SequenceList&lt;String&gt; squence = new SequenceList&lt;&gt;(5); // 测试遍历        squence.insert(0, \"姚明\");        squence.insert(1, \"科比\");        squence.insert(2, \"麦迪\");        squence.insert(3, \"艾佛森\");        squence.insert(4, \"卡特\");        for (String s : squence) &#123;            System.out.println(s);        &#125;    &#125;&#125;顺序表容量可变在之前的实现中，当我们使用SequenceList时，先new SequenceList(5)创建一个对象，创建对象时就需要指定容 器的大小，初始化指定大小的数组来存储元素，当我们插入元素时，如果已经插入了5个元素，还要继续插入数 据，则会报错，就不能插入了。这种设计不符合容器的设计理念，因此我们在设计顺序表时，应该考虑它的容量的 伸缩性。\n考虑容器的容量伸缩性，其实就是改变存储数据元素的数组的大小，那我们需要考虑什么时候需要改变数组的大小?\n添加元素时: \n添加元素时，应该检查当前数组的大小是否能容纳新的元素，如果不能容纳，则需要创建新的容量更大的数组，我们这里创建一个是原数组两倍容量的新数组存储元素。\n\n移除元素时:\n移除元素时，应该检查当前数组的大小是否太大，比如正在用100个容量的数组存储10个元素，这样就会造成内存 空间的浪费，应该创建一个容量更小的数组存储元素。如果我们发现数据元素的数量不足数组容量的1/4，则创建 一个是原数组容量的1/2的新数组存储元素。\n\n顺序表的容量可变代码:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184import java.util.Iterator;//顺序表代码class SequenceList&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 存储元素的数组    private T[] eles;    // 记录当前顺序表中的元素个数    private int N;    // 构造方法    public SequenceList(int capacity) &#123;        eles = (T[]) new Object[capacity];        N = 0;    &#125;    // 将一个线性表置为空表    public void clear() &#123;        N = 0;    &#125;    // 判断当前线性表是否为空表    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 获取线性表的长度    public int length() &#123;        return N;    &#125;    // 获取指定位置的元素    public T get(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"当前元素不存在!\");        &#125;        return eles[i];    &#125;    // 向线型表中添加元素t    public void insert(T t) &#123;        if (N == eles.length) &#123;            resize(eles.length * 2);        &#125;        eles[N++] = t;    &#125;    // 在i元素处插入元素t    public void insert(int i, T t) &#123;        if (i &lt; 0 || i &gt; N) &#123;            throw new RuntimeException(\"插入的位置不合法\");        &#125;        // 元素已经放满了数组，需要扩容        if (N == eles.length) &#123;            resize(eles.length * 2);        &#125;        // 把i位置空出来，i位置及其后面的元素依次向后移动一位        for (int index = N; index &gt; i; index--) &#123;            eles[index] = eles[index - 1];        &#125;        // 把t放到i位置处        eles[i] = t;        // 元素数量+1        N++;    &#125;    // 删除指定位置i处的元素，并返回该元素    public T remove(int i) &#123;        if (i &lt; 0 || i &gt; N - 1) &#123;            throw new RuntimeException(\"当前要删除的元素不存在\");        &#125;        // 记录i位置处的元素        T result = eles[i];        // 把i位置后面的元素都向前移动一位        for (int index = i; index &lt; N - 1; index++) &#123;            eles[index] = eles[index + 1];        &#125;        // 当前元素数量-1        N--;        // 当元素已经不足数组大小的1/4，则重置数组的大小        if (N &gt; 0 &amp;&amp; N &lt; eles.length / 4) &#123;            resize(eles.length / 2);        &#125;        return result;    &#125;    // 查找t元素第一次出现的位置    public int indexOf(T t) &#123;        if (t == null) &#123;            throw new RuntimeException(\"查找的元素不合法\");        &#125;        for (int i = 0; i &lt; N; i++) &#123;            if (eles[i].equals(t)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    // 打印当前线性表的元素    public void showEles() &#123;        for (int i = 0; i &lt; N; i++) &#123;            System.out.print(eles[i] + \" \");        &#125;        System.out.println();    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new SIterator();    &#125;    private class SIterator implements Iterator &#123;        private int cur;        public SIterator() &#123;            this.cur = 0;        &#125;        @Override        public boolean hasNext() &#123;            return cur &lt; N;        &#125;        @Override        public T next() &#123;            return eles[cur++];        &#125;    &#125;    // 改变容量    private void resize(int newSize) &#123;        // 记录旧数组        T[] temp = eles;        // 创建新数组        eles = (T[]) new Object[newSize];        // 把旧数组中的元素拷贝到新数组        for (int i = 0; i &lt; N; i++) &#123;            eles[i] = temp[i];        &#125;    &#125;    public int capacity() &#123;        return eles.length;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        SequenceList&lt;String&gt; squence = new SequenceList&lt;&gt;(5);        // 测试遍历        squence.insert(0, \"姚明\");        squence.insert(1, \"科比\");        squence.insert(2, \"麦迪\");        squence.insert(3, \"艾佛森\");        squence.insert(4, \"卡特\");        System.out.println(squence.capacity());        squence.insert(5, \"aa\");        System.out.println(squence.capacity());        squence.insert(5, \"aa\");        squence.insert(5, \"aa\");        squence.insert(5, \"aa\");        squence.insert(5, \"aa\");        squence.insert(5, \"aa\");        System.out.println(squence.capacity());        squence.remove(1);        squence.remove(1);        squence.remove(1);        squence.remove(1);        squence.remove(1);        squence.remove(1);        squence.remove(1);        System.out.println(squence.capacity());    &#125;&#125;顺序表的时间复杂度get(i):不难看出，不论数据元素量N有多大，只需要一次eles[i]就可以获取到对应的元素，所以时间复杂度为O(1);\ninsert(int i,T t):每一次插入，都需要把i位置后面的元素移动一次，随着元素数量N的增大，移动的元素也越多，时 间复杂为O(n);\nremove(int i):每一次删除，都需要把i位置后面的元素移动一次，随着数据量N的增大,移动的元素也越多，时间复 杂度为O(n);\n由于顺序表的底层由数组实现，数组的长度是固定的，所以在操作的过程中涉及到了容器扩容操作。这样会导致顺序表在使用过程中的时间复杂度不是线性的，在某些需要扩容的结点处，耗时会突增，尤其是元素越多，这个问题越明显\njava中ArrayList实现java中ArrayList集合的底层也是一种顺序表，使用数组实现，同样提供了增删改查以及扩容等功能。 \n是否用数组实现; 是\n\n有没有扩容操作; 有\n\n有没有提供遍历方式;  有\n\n链表之前我们已经使用顺序存储结构实现了线性表，我们会发现虽然顺序表的查询很快，时间复杂度为O(1),但是增删的 效率是比较低的，因为每一次增删操作都伴随着大量的数据元素移动。这个问题有没有解决方案呢?有，我们可以 使用另外一种存储结构实现线性表，链式存储结构。\n链表是一种物理存储单元上非连续、非顺序的存储结构，其物理结构不能只管的表示数据元素的逻辑顺序，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。链表由一系列的结点(链表中的每一个元素称为结点)组成，结点可以在运行时动态生成。\n 那我们如何使用链表呢?按照面向对象的思想，我们可以设计一个类，来描述结点这个事物，用一个属性描述这个结点存储的元素，用来另外一个属性描述这个结点的下一个结点\n结点API设计:\n\n类名Node\n\n构造方法Node(T t,Node next) : 创建Node对象\n\n成员变量T item:存储数据Node next:指向下一个结点\n结点类实现:\n123456789101112public class Node&lt;T&gt; &#123;    // 存储元素    public T item;    // 指向下一个结点    public Node next;    public Node(T item, Node next) &#123;        this.item = item;        this.next = next;    &#125;&#125;生成链表:\n1234567891011121314public static void main(String[] args) throws Exception &#123;     //构建结点    Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(11, null);     Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(13, null);     Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(12, null);     Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(8, null);     Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(9, null);        //生成链表    first.next = second;     second.next = third;     third.next = fourth;     fourth.next = fifth;&#125;单向链表单向链表是链表的一种，它由多个结点组成，每个结点都由一个数据域和一个指针域组成，数据域用来存储数据，指针域用来指向其后继结点。链表的头结点的数据域不存储数据，指针域指向第一个真正存储数据的结点。\n\n单向链表API设计\n类名LinkList\n\n构造方法LinkList() : 创建LinkList 对象\n\n成员方法1.public void clear():空置线性表2.publicboolean isEmpty():判断线性表是否为空，是返回true，否返回false3.public int length():获取线性表中元素的个数4.public T get(int i):读取并返回线性表中的第i个元素的值5.public void insert(T t):往线性表中添加一个元素;6.public void insert(int i,T t):在线性表的第i个元素之前插入一个值为t的数据元素。7.public T remove(int i):删除并返回线性表中第i个数据元素。8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则返回-1。\n\n成员内部类private class Node:结点类\n\n成员变量1.private Node head:记录首结点2.private int N:记录链表的长度\n单向链表代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package test1;//单向列表代码import java.util.Iterator;class LinkList&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 记录头结点    private Node head;    // 记录链表的长度    private int N;    public LinkList() &#123;        // 初始化头结点        head = new Node(null, null);        N = 0;    &#125;    // 清空链表    public void clear() &#123;        head.next = null;        head.item = null;        N = 0;    &#125;    // 获取链表的长度    public int length() &#123;        return N;    &#125;    // 判断链表是否为空    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 获取指定位置i出的元素    public T get(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法!\");        &#125;        Node n = head.next;        for (int index = 0; index &lt; i; index++) &#123;            n = n.next;        &#125;        return n.item;    &#125;    // 向链表中添加元素t    public void insert(T t) &#123;        // 找到最后一个节点        Node n = head;        while (n.next != null) &#123;            n = n.next;        &#125;        Node newNode = new Node(t, null);        n.next = newNode;        // 链表长度+1        N++;    &#125;    // 向指定位置i处，添加元素t    public void insert(int i, T t) &#123;        // if (i &lt; 0 || i &gt;= N) &#123;        // throw new RuntimeException(\"位置不合法!\");        // &#125;        // 寻找位置i之前的结点        Node pre = head;        for (int index = 0; index &lt;= i - 1; index++) &#123;            pre = pre.next;        &#125;        // 位置i的结点        Node curr = pre.next;        // 构建新的结点，让新结点指向位置i的结点        Node newNode = new Node(t, curr);        // 让之前的结点指向新结点        pre.next = newNode;        // 长度+1        N++;    &#125;    // 删除指定位置i处的元素，并返回被删除的元素    public T remove(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法\");        &#125;        // 寻找i之前的元素        Node pre = head;        for (int index = 0; index &lt;= i - 1; index++) &#123;            pre = pre.next;        &#125;        // 当前i位置的结点        Node curr = pre.next;        // 前一个结点指向下一个结点，删除当前结点        pre.next = curr.next;        // 长度-1        N--;        return curr.item;    &#125;    // 查找元素t在链表中第一次出现的位置    public int indexOf(T t) &#123;        Node n = head;        for (int i = 0; n.next != null; i++) &#123;            n = n.next;            if (n.item.equals(t)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    // 结点类    private class Node &#123;        // 存储数据        T item;        // 下一个结点        Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new LIterator();    &#125;    private class LIterator implements Iterator&lt;T&gt; &#123;        private Node n;        public LIterator() &#123;            this.n = head;        &#125;        @Override        public boolean hasNext() &#123;            return n.next != null;        &#125;        @Override        public T next() &#123;            n = n.next;            return n.item;        &#125;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        LinkList&lt;String&gt; list = new LinkList&lt;&gt;();        list.insert(0, \"张三\");        list.insert(1, \"李四\");        list.insert(2, \"王五\");        list.insert(3, \"赵六\");        // 测试length方法        for (String s : list) &#123;            System.out.println(s);        &#125;        System.out.println(list.length());        System.out.println(\"-------------------\");        // 测试get方法        System.out.println(list.get(2));        System.out.println(\"------------------------\");        // 测试remove方法        String remove = list.remove(1);        System.out.println(remove);        System.out.println(list.length());        System.out.println(\"----------------\");        for (String s : list) &#123;            System.out.println(s);        &#125;    &#125;&#125;双向链表双向链表也叫双向表，是链表的一种，它由多个结点组成，每个结点都由一个数据域和两个指针域组成，数据域用 来存储数据，其中一个指针域用来指向其后继结点，另一个指针域用来指向前驱结点。链表的头结点的数据域不存 储数据，指向前驱结点的指针域值为null，指向后继结点的指针域指向第一个真正存储数据的结点。\n\n按照面向对象的思想，我们需要设计一个类，来描述结点这个事物。由于结点是属于链表的，所以我们把结点类作 为链表类的一个内部类来实现\n结点API设计\n类名Node\n\n构造方法Node(T t,Node pre,Node next) : 创建Node对象\n\n成员变量T item:存储数据Node next:指向下一个结点Node pre:指向上一个结点\n双向链表API设计\n类名TowWayLinkList\n\n构造方法TowWayLinkList():创建TowWayLinkList对象\n\n成员方法1.public void clear():空置线性表2.publicboolean isEmpty():判断线性表是否为空，是返回true，否返回false3.public int length():获取线性表中元素的个数4.public T get(int i):读取并返回线性表中的第i个元素的值5.public void insert(T t) : 往线性表中添加一个元素;6.public void insert(int i,T t):在线性表的第i个元素之前插入一个值为t的数据元素。7.public T remove(int i):删除并返回线性表中第i个数据元素。8.public int indexOf(T t):返回线性表中首次出现的指定的数据元素的位序号，若不存在，则 返回-1。9.public T getFirst():获取第一个元素10.public T getLast():获取最后一个元素\n\n成员内部 类private class Node:结点类\n\n成员变量1.private Node first:记录首结点2.private Node last:记录尾结点3.private int N:记录链表的长度\n双向链表代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206//双向链表代码import java.util.Iterator;class TowWayLinkList&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 首结点    private Node head;    // 最后一个结点    private Node last;    // 链表的长度    private int N;    public TowWayLinkList() &#123;        last = null;        head = new Node(null, null, null);        N = 0;    &#125;    // 清空链表    public void clear() &#123;        last = null;        head.next = last;        head.pre = null;        head.item = null;        N = 0;    &#125;    // 获取链表长度    public int length() &#123;        return N;    &#125;    // 判断链表是否为空    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 插入元素t    public void insert(T t) &#123;        if (last == null) &#123;            last = new Node(t, head, null);            head.next = last;        &#125; else &#123;            Node oldLast = last;            Node node = new Node(t, oldLast, null);            oldLast.next = node;            last = node;        &#125;        // 长度+1        N++;    &#125;    // 向指定位置i处插入元素t    public void insert(int i, T t) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法\");        &#125;        // 找到位置i的前一个结点        Node pre = head;        for (int index = 0; index &lt; i; index++) &#123;            pre = pre.next;        &#125;        // 当前结点        Node curr = pre.next;        // 构建新结点        Node newNode = new Node(t, pre, curr);        curr.pre = newNode;        pre.next = newNode;        // 长度+1        N++;    &#125;    // 获取指定位置i处的元素    public T get(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法\");        &#125;        // 寻找当前结点        Node curr = head.next;        for (int index = 0; index &lt; i; index++) &#123;            curr = curr.next;        &#125;        return curr.item;    &#125;    // 找到元素t在链表中第一次出现的位置    public int indexOf(T t) &#123;        Node n = head;        for (int i = 0; n.next != null; i++) &#123;            n = n.next;            if (n.item.equals(t)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    // 删除位置i处的元素，并返回该元素    public T remove(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法\");        &#125;        // 寻找i位置的前一个元素        Node pre = head;        for (int index = 0; index &lt; i; index++) &#123;            pre = pre.next;        &#125;        // i位置的元素        Node curr = pre.next;        // i位置的下一个元素        Node curr_next = curr.next;        pre.next = curr_next;        curr_next.pre = pre;        // 长度-1;        N--;        return curr.item;    &#125;    // 获取第一个元素    public T getFirst() &#123;        if (isEmpty()) &#123;            return null;        &#125;        return head.next.item;    &#125;    // 获取最后一个元素    public T getLast() &#123;        if (isEmpty()) &#123;            return null;        &#125;        return last.item;    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new TIterator();    &#125;    private class TIterator implements Iterator &#123;        private Node n;        public TIterator() &#123;            this.n = head;        &#125;        @Override        public boolean hasNext() &#123;            return n.next != null;        &#125;        @Override        public Object next() &#123;            n = n.next;            return n.item;        &#125;    &#125;    // 结点类    private class Node &#123;        public Node(T item, Node pre, Node next) &#123;            this.item = item;            this.pre = pre;            this.next = next;        &#125;        // 存储数据        public T item;        // 指向上一个结点        public Node pre;        // 指向下一个结点        public Node next;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        TowWayLinkList&lt;String&gt; list = new TowWayLinkList&lt;&gt;();        list.insert(\"乔峰\");        list.insert(\"虚竹\");        list.insert(\"段誉\");        list.insert(1, \"鸠摩智\");        list.insert(3, \"叶二娘\");        for (String str : list) &#123;            System.out.println(str);        &#125;        System.out.println(\"----------------------\");        String tow = list.get(2);        System.out.println(tow);        System.out.println(\"-------------------------\");        String remove = list.remove(3);        System.out.println(remove);        System.out.println(list.length());        System.out.println(\"--------------------\");        System.out.println(list.getFirst());        System.out.println(list.getLast());    &#125;&#125;java中LinkedList实现java中LinkedList集合也是使用双向链表实现，并提供了增删改查等相关方法\n底层是否用双向链表实现; \n\n结点类是否有三个域\n\n链表的复杂度分析get(int i):每一次查询，都需要从链表的头部开始，依次向后查找，随着数据元素N的增多，比较的元素越多，时间复杂度为O(n)\ninsert(int i,T t):每一次插入，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n);\nremove(int i):每一次移除，需要先找到i位置的前一个元素，然后完成插入操作，随着数据元素N的增多，查找的元素越多，时间复杂度为O(n) \n相比较顺序表，链表插入和删除的时间复杂度虽然一样，但仍然有很大的优势，因为链表的物理地址是不连续的，它不需要预先指定存储空间大小，或者在存储过程中涉及到扩容等操作,,同时它并没有涉及的元素的交换。 \n相比较顺序表，链表的查询操作性能会比较低。因此，如果我们的程序中查询操作比较多，建议使用顺序表，增删操作比较多，建议使用链表。\n链表反转单链表的反转，是面试中的一个高频题目。 \n需求:\n原链表中数据为:1-&gt;2-&gt;3&gt;4\n反转后链表中数据为:4-&gt;3-&gt;2-&gt;1 \n反转API:\npublic void reverse():对整个链表反转\npublic Node reverse(Node curr):反转链表中的某个结点curr,并把反转后的curr结点返回\n使用递归可以完成反转，递归反转其实就是从原链表的第一个存数据的结点开始，依次递归调用反转每一个结点，直到把最后一个结点反转完毕，整个链表就反转完毕。\n\n代码：\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209package test1;//单向列表代码import java.util.Iterator;class LinkList&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 记录头结点    private Node head;    // 记录链表的长度    private int N;    public LinkList() &#123;        // 初始化头结点        head = new Node(null, null);        N = 0;    &#125;    // 清空链表    public void clear() &#123;        head.next = null;        head.item = null;        N = 0;    &#125;    // 获取链表的长度    public int length() &#123;        return N;    &#125;    // 判断链表是否为空    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 获取指定位置i出的元素    public T get(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法!\");        &#125;        Node n = head.next;        for (int index = 0; index &lt; i; index++) &#123;            n = n.next;        &#125;        return n.item;    &#125;    // 向链表中添加元素t    public void insert(T t) &#123;        // 找到最后一个节点        Node n = head;        while (n.next != null) &#123;            n = n.next;        &#125;        Node newNode = new Node(t, null);        n.next = newNode;        // 链表长度+1        N++;    &#125;    // 向指定位置i处，添加元素t    public void insert(int i, T t) &#123;        // if (i &lt; 0 || i &gt;= N) &#123;        // throw new RuntimeException(\"位置不合法!\");        // &#125;        // 寻找位置i之前的结点        Node pre = head;        for (int index = 0; index &lt;= i - 1; index++) &#123;            pre = pre.next;        &#125;        // 位置i的结点        Node curr = pre.next;        // 构建新的结点，让新结点指向位置i的结点        Node newNode = new Node(t, curr);        // 让之前的结点指向新结点        pre.next = newNode;        // 长度+1        N++;    &#125;    // 删除指定位置i处的元素，并返回被删除的元素    public T remove(int i) &#123;        if (i &lt; 0 || i &gt;= N) &#123;            throw new RuntimeException(\"位置不合法\");        &#125;        // 寻找i之前的元素        Node pre = head;        for (int index = 0; index &lt;= i - 1; index++) &#123;            pre = pre.next;        &#125;        // 当前i位置的结点        Node curr = pre.next;        // 前一个结点指向下一个结点，删除当前结点        pre.next = curr.next;        // 长度-1        N--;        return curr.item;    &#125;    // 查找元素t在链表中第一次出现的位置    public int indexOf(T t) &#123;        Node n = head;        for (int i = 0; n.next != null; i++) &#123;            n = n.next;            if (n.item.equals(t)) &#123;                return i;            &#125;        &#125;        return -1;    &#125;    // 结点类    private class Node &#123;        // 存储数据        T item;        // 下一个结点        Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new LIterator();    &#125;    private class LIterator implements Iterator&lt;T&gt; &#123;        private Node n;        public LIterator() &#123;            this.n = head;        &#125;        @Override        public boolean hasNext() &#123;            return n.next != null;        &#125;        @Override        public T next() &#123;            n = n.next;            return n.item;        &#125;    &#125;    public void reverse() &#123;        if (N == 0) &#123;            // 当前是空链表，不需要反转            return;        &#125;        reverse(head.next);    &#125;    /*     *     * @param curr 当前遍历的结点     *      * @return 反转后当前结点上一个结点     */    public Node reverse(Node curr) &#123;        // 已经到了最后一个元素        if (curr.next == null) &#123;            // 反转后，头结点应该指向原链表中的最后一个元素            head.next = curr;            return curr;        &#125;        // 当前结点的上一个结点        Node pre = reverse(curr.next);        pre.next = curr;         // 当前结点的下一个结点设为null        curr.next = null;         // 返回当前结点        return curr;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        LinkList&lt;String&gt; list = new LinkList&lt;&gt;();        list.insert(0, \"张三\");        list.insert(1, \"李四\");        list.insert(2, \"王五\");        list.insert(3, \"赵六\");        // 测试length方法        for (String s : list) &#123;            System.out.println(s);        &#125;        System.out.println(\"链表长度：\"+list.length());        System.out.println(\"-------------------\");        // 单链表翻转        list.reverse();        System.out.println(\"----------------\");        for (String s : list) &#123;            System.out.println(s);        &#125;    &#125;&#125;快慢指针快慢指针指的是定义两个指针，这两个指针的移动速度一块一慢，以此来制造出自己想要的差值，这个差值可以然我们找到链表上相应的结点。一般情况下，快指针的移动步长为慢指针的两倍 \n中间值问题我们先来看下面一段代码，然后完成需求。\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package test1;//测试类public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Node&lt;String&gt; first = new Node&lt;String&gt;(\"aa\", null);        Node&lt;String&gt; second = new Node&lt;String&gt;(\"bb\", null);        Node&lt;String&gt; third = new Node&lt;String&gt;(\"cc\", null);        Node&lt;String&gt; fourth = new Node&lt;String&gt;(\"dd\", null);        Node&lt;String&gt; fifth = new Node&lt;String&gt;(\"ee\", null);        Node&lt;String&gt; six = new Node&lt;String&gt;(\"ff\", null);        Node&lt;String&gt; seven = new Node&lt;String&gt;(\"gg\", null);        // 完成结点之间的指向        first.next = second;        second.next = third;        third.next = fourth;        fourth.next = fifth;        fifth.next = six;        six.next = seven;        // 查找中间值        String mid = getMid(first);        System.out.println(\"中间值为:\" + mid);    &#125;    /*     * @param first 链表的首结点     * @return 链表的中间结点的值     */    public static String getMid(Node&lt;String&gt; first) &#123;        // 定义两个指针        Node&lt;String&gt; fast = first;        Node&lt;String&gt; slow = first;        // 使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，慢指针指向的节点为中间值        while (fast != null &amp;&amp; fast.next != null) &#123;            fast = fast.next.next;            slow = slow.next;        &#125;        return slow.item;    &#125;    // 结点类    private static class Node&lt;T&gt; &#123;        // 存储数据        T item;        // 下一个结点        Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;需求: \n请完善测试类Test中的getMid方法，可以找出链表的中间元素值并返回。\n利用快慢指针，我们把一个链表看成一个跑道，假设a的速度是b的两倍，那么当a跑完全程后，b刚好跑一半，以 此来达到找到中间节点的目的。\n如下图，最开始，slow与fast指针都指向链表第一个节点，然后slow每次移动一个指针，fast每次移动两个指针。\n代码：\n123456789101112131415/*    * @param first 链表的首结点    * @return 链表的中间结点的值    */public static String getMid(Node&lt;String&gt; first) &#123;    // 定义两个指针    Node&lt;String&gt; fast = first;    Node&lt;String&gt; slow = first;    // 使用两个指针遍历链表，当快指针指向的结点没有下一个结点了，就可以结束了，慢指针指向的节点为中间值    while (fast != null &amp;&amp; fast.next != null) &#123;        fast = fast.next.next;        slow = slow.next;    &#125;    return slow.item;&#125;单向链表是否有环问题12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667package test1;//测试类public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Node&lt;String&gt; first = new Node&lt;String&gt;(\"aa\", null);        Node&lt;String&gt; second = new Node&lt;String&gt;(\"bb\", null);        Node&lt;String&gt; third = new Node&lt;String&gt;(\"cc\", null);        Node&lt;String&gt; fourth = new Node&lt;String&gt;(\"dd\", null);        Node&lt;String&gt; fifth = new Node&lt;String&gt;(\"ee\", null);        Node&lt;String&gt; six = new Node&lt;String&gt;(\"ff\", null);        Node&lt;String&gt; seven = new Node&lt;String&gt;(\"gg\", null);        // 完成结点之间的指向        first.next = second;        second.next = third;        third.next = fourth;        fourth.next = fifth;        fifth.next = six;        six.next = seven;        // 产生环        seven.next = third;        // 判断链表是否有环        boolean circle = isCircle(first);        System.out.println(\"first链表中是否有环:\" + circle);    &#125;    /*     * 判断链表中是否有环     *      * @param first 链表首结点     *      * @return ture为有环，false为无环     */    public static boolean isCircle(Node&lt;String&gt; first) &#123;        // 定义快慢指针        Node&lt;String&gt; fast = first;        Node&lt;String&gt; slow = first;        // 遍历链表，如果快慢指针指向了同一个结点，则证明有环        while (fast != null &amp;&amp; fast.next != null) &#123;            // 变换fast和slow            fast = fast.next.next;            slow = slow.next;            if (fast.equals(slow)) &#123;                return true;            &#125;        &#125;        return false;    &#125;    // 结点类    private static class Node&lt;T&gt; &#123;        // 存储数据        T item;        // 下一个结点        Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;需求: 请完善测试类Test中的isCircle方法，返回链表中是否有环。\n使用快慢指针的思想，还是把链表比作一条跑道，链表中有环，那么这条跑道就是一条圆环跑道，在一条圆环跑道中，两个人有速度差，那么迟早两个人会相遇，只要相遇那么就说明有环。\n有环链表入口问题图片cc就是入口\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105package test1;//测试类public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Node&lt;String&gt; first = new Node&lt;String&gt;(\"aa\", null);        Node&lt;String&gt; second = new Node&lt;String&gt;(\"bb\", null);        Node&lt;String&gt; third = new Node&lt;String&gt;(\"cc\", null);        Node&lt;String&gt; fourth = new Node&lt;String&gt;(\"dd\", null);        Node&lt;String&gt; fifth = new Node&lt;String&gt;(\"ee\", null);        Node&lt;String&gt; six = new Node&lt;String&gt;(\"ff\", null);        Node&lt;String&gt; seven = new Node&lt;String&gt;(\"gg\", null);        // 完成结点之间的指向        first.next = second;        second.next = third;        third.next = fourth;        fourth.next = fifth;        fifth.next = six;        six.next = seven;        // 产生环        seven.next = third;        // 判断链表是否有环        boolean circle = isCircle(first);        System.out.println(\"first链表中是否有环:\" + circle);        // 查找环的入口结点        Node&lt;String&gt; entrance = getEntrance(first);        System.out.println(\"first链表中环的入口结点元素为:\" + entrance.item);    &#125;    /*     * 判断链表中是否有环     *      * @param first 链表首结点     *      * @return ture为有环，false为无环     */    public static boolean isCircle(Node&lt;String&gt; first) &#123;        // 定义快慢指针        Node&lt;String&gt; fast = first;        Node&lt;String&gt; slow = first;        // 遍历链表，如果快慢指针指向了同一个结点，则证明有环        while (fast != null &amp;&amp; fast.next != null) &#123;            // 变换fast和slow            fast = fast.next.next;            slow = slow.next;            if (fast.equals(slow)) &#123;                return true;            &#125;        &#125;        return false;    &#125;    /**     * 查找有环链表中环的入口结点 * @param first 链表首结点     *      * @return 环的入口结点     */    public static Node getEntrance(Node&lt;String&gt; first) &#123;        // 定义快慢指针        Node&lt;String&gt; fast = first;        Node&lt;String&gt; slow = first;        Node&lt;String&gt; temp = null;        // 遍历链表，先找到环（快慢指针相遇），准备一个临时指针，指向链表的首结点，继续遍历，直到慢指针和临时指针相遇，那么相遇时所指向的结点就是环的入口        while (fast != null &amp;&amp; fast.next != null) &#123;            // 变换快慢指针            fast = fast.next.next;            slow = slow.next;            // 判断快慢指针是否相遇            if (fast.equals(slow)) &#123;                temp = first;                continue;            &#125;            // 让临时结点变换            if (temp != null) &#123;                temp = temp.next;                // 判断临时指针是否和慢指针相遇                if (temp.equals(slow)) &#123;                    break;                &#125;            &#125;        &#125;        return temp;    &#125;    // 结点类    private static class Node&lt;T&gt; &#123;        // 存储数据        T item;        // 下一个结点        Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;需求: 请完善Test类中的getEntrance方法，查找有环链表中环的入口结点。\n当快慢指针相遇时，我们可以判断到链表中有环，这时重新设定一个新指针指向链表的起点，且步长与慢指针一样 为1，则慢指针与“新”指针相遇的地方就是环的入口。证明这一结论牵涉到数论的知识，这里略，只讲实现。\n循环列表循环链表，顾名思义，链表整体要形成一个圆环状。在单向链表中，最后一个节点的指针为null，不指向任何结点，因为没有下一个元素了。要实现循环链表，我们只需要让单向链表的最后一个节点的指针指向头结点即可。\n\n123456789101112131415161718192021public class Test &#123;    public static void main(String[] args) throws Exception &#123;        // 构建结点        Node&lt;Integer&gt; first = new Node&lt;Integer&gt;(1, null);        Node&lt;Integer&gt; second = new Node&lt;Integer&gt;(2, null);        Node&lt;Integer&gt; third = new Node&lt;Integer&gt;(3, null);        Node&lt;Integer&gt; fourth = new Node&lt;Integer&gt;(4, null);        Node&lt;Integer&gt; fifth = new Node&lt;Integer&gt;(5, null);        Node&lt;Integer&gt; six = new Node&lt;Integer&gt;(6, null);        Node&lt;Integer&gt; seven = new Node&lt;Integer&gt;(7, null);        // 构建单链表        first.next = second;        second.next = third;        third.next = fourth;        fourth.next = fifth;        fifth.next = six;        six.next = seven;        // 构建循环链表,让最后一个结点指向第一个结点        seven.next = first;    &#125;&#125;约瑟夫问题问题描述:\n传说有这样一个故事，在罗马人占领乔塔帕特后，39 个犹太人与约瑟夫及他的朋友躲到一个洞中，39个犹太人决 定宁愿死也不要被敌人抓到，于是决定了一个自杀方式，41个人排成一个圆圈，第一个人从1开始报数，依次往后，如果有人报数到3，那么这个人就必须自杀，然后再由他的下一个人重新从1开始报数，直到所有人都自杀身亡 为止。然而约瑟夫和他的朋友并不想遵从。于是，约瑟夫要他的朋友先假装遵从，他将朋友与自己安排在第16个与 第31个位置，从而逃过了这场死亡游戏 。\n问题转换: \n41个人坐一圈，第一个人编号为1，第二个人编号为2，第n个人编号为n。 \n1.编号为1的人开始从1报数，依次向后，报数为3的那个人退出圈; \n2.自退出那个人开始的下一个人再次从1开始报数，以此类推; \n3.求出最后退出的那个人的编号。\n图示:\n解题思路:\n1.构建含有41个结点的单向循环链表，分别存储1~41的值，分别代表这41个人; 】\n2.使用计数器count，记录当前报数的值;\n3.遍历链表，每循环一次，count++; \n4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0;\n代码:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Test &#123;    public static void main(String[] args) throws Exception &#123;        // 1.构建循环链表        Node&lt;Integer&gt; first = null;        // 记录前一个结点        Node&lt;Integer&gt; pre = null;        for (int i = 1; i &lt;= 41; i++) &#123;            // 第一个元素            if (i == 1) &#123;                first = new Node&lt;&gt;(i, null);                pre = first;                continue;            &#125;            // 如果不是第一个结点            Node&lt;Integer&gt; node = new Node&lt;&gt;(i, null);            pre.next = node;            pre = node;            // 如果是最后一个结点，那么需要让最后一个结点的下一个结点变为first，变为循环链表了            if (i == 41) &#123;                // 构建循环链表，让最后一个结点指向第一个结点                pre.next = first;            &#125;        &#125;        // 2.使用count，记录当前的报数值        int count = 0;        // 3.遍历链表，每循环一次，count++        // 记录每一次遍历拿到的结点，默认从首结点开始        Node&lt;Integer&gt; n = first;        // 记录当前结点的上一个结点        Node&lt;Integer&gt; before = null;        while (n != n.next) &#123;            // 4.判断count的值，如果是3，则从链表中删除这个结点并打印结点的值，把count重置为0;            count++;            if (count == 3) &#123;                // 删除当前结点                before.next = n.next;                System.out.print(n.item + \",\");                count = 0;                n = n.next;            &#125; else &#123;                before = n;                n = n.next;            &#125;        &#125;        /* 打印剩余的最后那个人 */        System.out.println(n.item);    &#125;    // 结点类    private static class Node&lt;T&gt; &#123;        // 存储数据        T item;        // 下一个结点        Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;栈栈概述生活中的栈存储货物或供旅客住宿的地方,可引申为仓库、中转站 。例如我们现在生活中的酒店，在古时候叫客栈，是供旅客 休息的地方，旅客可以进客栈休息，休息完毕后就离开客栈。\n计算机中的栈我们把生活中的栈的概念引入到计算机中，就是供数据休息的地方，它是一种数据结构，数据既可以进入到栈中，又可以从栈中出去。\n栈是一种基于先进后出(FILO)的数据结构，是一种只能在一端进行插入和删除操作的特殊线性表。它按照先进后出 的原则存储数据，先进入的数据被压入栈底，最后的数据在栈顶，需要读数据的时候从栈顶开始弹出数据(最后一 个数据被第一个读出来)。\n我们称数据进入到栈的动作为压栈，数据从栈中出去的动作为弹栈。\n栈的实现栈API设计\n类名Stack\n\n构造方法Stack):创建Stack对象\n\n成员方法1.public boolean isEmpty():判断栈是否为空，是返回true，否返回false 2.public int size():获取栈中元素的个数3.public T pop():弹出栈顶元素4.public void push(T t):向栈中压入元素t\n\n成员变量1.private Node head:记录首结点2.private int N:当前栈的元素个数\n栈代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495//栈代码import java.util.Iterator;class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 记录首结点    private Node head;    // 栈中元素的个数    private int N;    public Stack() &#123;        head = new Node(null, null);        N = 0;    &#125;    // 判断当前栈中元素个数是否为0    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 把t元素压入栈    public void push(T t) &#123;        Node oldNext = head.next;        Node node = new Node(t, oldNext);        head.next = node;        // 个数+1        N++;    &#125;    // 弹出栈顶元素    public T pop() &#123;        Node oldNext = head.next;        if (oldNext == null) &#123;            return null;        &#125;        // 删除首个元素        head.next = head.next.next;        // 个数-1        N--;        return oldNext.item;    &#125;    // 获取栈中元素的个数    public int size() &#123;        return N;    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new SIterator();    &#125;    private class SIterator implements Iterator&lt;T&gt; &#123;        private Node n = head;        @Override        public boolean hasNext() &#123;            return n.next != null;        &#125;        @Override        public T next() &#123;            n = n.next;            return n.item;        &#125;    &#125;    private class Node &#123;        public T item;        public Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;// 测试代码public class Test &#123;    public static void main(String[] args) throws Exception &#123;        Stack&lt;String&gt; stack = new Stack&lt;&gt;();        stack.push(\"a\");        stack.push(\"b\");        stack.push(\"c\");        stack.push(\"d\");        for (String str : stack) &#123;            System.out.println(str + \" \");        &#125;        System.out.println(\"-----------------------------\");        String result = stack.pop();        System.out.println(\"弹出了元素:\" + result);        System.out.println(stack.size());    &#125;&#125;案例括号匹配问题问题描述:\n12345678给定一个字符串，里边可能包含\"()\"小括号和其他字符，请编写程序检查该字符串的中的小括号是否成对出现。例如:\"(上海)(长安)\":正确匹配 \"上海((长安))\":正确匹配 \"上海(长安(北京)(深圳)南京)\":正确匹配 \"上海(长安))\":错误匹配 \"((上海)长安\":错误匹配示例代码:\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import java.util.Iterator;public class BracketsMatch &#123;    public static void main(String[] args) &#123;        String str = \"(上海(长安)())\";        boolean match = isMatch(str);        System.out.println(str + \"中的括号是否匹配:\" + match);    &#125;    /*     * 判断str中的括号是否匹配     *      * @param str 括号组成的字符串     *      * @return 如果匹配，返回true，如果不匹配，返回false     */    public static boolean isMatch(String str) &#123;        // 1.创建一个栈用来存储左括号        Stack&lt;String&gt; chars = new Stack&lt;&gt;();        // 2.从左往右遍历字符串，拿到每一个字符        for (int i = 0; i &lt; str.length(); i++) &#123;            String currChar = str.charAt(i) + \"\";            // 3.判断该字符是不是左括号，如果是，放入栈中存储            if (currChar.equals(\"(\")) &#123;                chars.push(currChar);            &#125; else if (currChar.equals(\")\")) &#123;                // 4.判断该字符是不是右括号，如果不是，继续下一次循                // 5.如果该字符是右括号，则从栈中弹出一个元素t;                String t = chars.pop();                // 6.判断元素t是否为null，如果不是，则证明有对应的左括号，如果不是，则证明没有对应的                if (t == null) &#123;                    return false;                &#125;            &#125;        &#125;        // 7.循环结束后，判断栈中还有没有剩余的左括号，如果有，则不匹配，如果没有，则匹配        if (chars.size() == 0) &#123;            return true;        &#125; else &#123;            return false;        &#125;    &#125;&#125;class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 记录首结点    private Node head;    // 栈中元素的个数    private int N;    public Stack() &#123;        head = new Node(null, null);        N = 0;    &#125;    // 判断当前栈中元素个数是否为0    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 把t元素压入栈    public void push(T t) &#123;        Node oldNext = head.next;        Node node = new Node(t, oldNext);        head.next = node;        // 个数+1        N++;    &#125;    // 弹出栈顶元素    public T pop() &#123;        Node oldNext = head.next;        if (oldNext == null) &#123;            return null;        &#125;        // 删除首个元素        head.next = head.next.next;        // 个数-1        N--;        return oldNext.item;    &#125;    // 获取栈中元素的个数    public int size() &#123;        return N;    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new SIterator();    &#125;    private class SIterator implements Iterator&lt;T&gt; &#123;        private Node n = head;        @Override        public boolean hasNext() &#123;            return n.next != null;        &#125;        @Override        public T next() &#123;            n = n.next;            return n.item;        &#125;    &#125;    private class Node &#123;        public T item;        public Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;逆波兰表达式求值问题逆波兰表达式求值问题是我们计算机中经常遇到的一类问题，要研究明白这个问题，首先我们得搞清楚什么是逆波兰表达式?要搞清楚逆波兰表达式，我们得从中缀表达式说起。\n中缀表达式:\n中缀表达式就是我们平常生活中使用的表达式，例如:1+3*2,2-(1+3)等等，中缀表达式的特点是:二元运算符总 是置于两个操作数中间。\n中缀表达式是人们最喜欢的表达式方式，因为简单，易懂。但是对于计算机来说就不是这样了，因为中缀表达式的运算顺序不具有规律性。不同的运算符具有不同的优先级，如果计算机执行中缀表达式，需要解析表达式语义，做大量的优先级相关操作。\n逆波兰表达式(后缀表达式):\n逆波兰表达式是波兰逻辑学家J・卢卡西维兹(J・ Lukasewicz)于1929年首先提出的一种表达式的表示方法，后缀表达式的特点:运算符总是放在跟它相关的操作数之后。\n\n中缀表达式逆波兰表达式\n\na+bab+\n\na+(b-c)abc-+\n\na+(b-c)*dabc-d*+\n\na*(b-c)+dabc-*d+\n需求:\n给定一个只包含加减乘除四种运算的逆波兰表达式的数组表示方式，求出该逆波兰表达式的结果。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150package test1;import java.util.Iterator;public class ReversePolishNotation &#123;    public static void main(String[] args) &#123;        // 中缀表达式3*(17-15)+18/6的逆波兰表达式如下        String[] notation = &#123; \"3\", \"17\", \"15\", \"-\", \"*\", \"18\", \"6\", \"/\", \"+\" &#125;;        int result = caculate(notation);        System.out.println(\"逆波兰表达式的结果为:\" + result);    &#125;    /*     * @param notaion 逆波兰表达式的数组表示方式     *      * @return 逆波兰表达式的计算结果     */    public static int caculate(String[] notaion) &#123;        // 1.创建一个栈对象oprands存储操作数        Stack&lt;Integer&gt; oprands = new Stack&lt;&gt;();        // 2.从左往右遍历逆波兰表达式，得到每一个字符串        for (int i = 0; i &lt; notaion.length; i++) &#123;            String curr = notaion[i];            // 3.判断该字符串是不是运算符，如果不是，把该该操作数压入oprands栈中            Integer o1;            Integer o2;            Integer result;            switch (curr) &#123;                case \"+\":                    // 4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2                    o1 = oprands.pop();                    o2 = oprands.pop();                    // 5.使用该运算符计算o1和o2，得到结果result                    result = o2 + o1;                    // 6.把该结果压入oprands栈中                    oprands.push(result);                    break;                case \"-\":                    // 4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2                    o1 = oprands.pop();                    o2 = oprands.pop();                    // 5.使用该运算符计算o1和o2，得到结果result                    result = o2 - o1;                    // 6.把该结果压入oprands栈中                    oprands.push(result);                    break;                case \"*\":                    // 4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2                    o1 = oprands.pop();                    o2 = oprands.pop();                    // 5.使用该运算符计算o1和o2，得到结果result                    result = o2 * o1;                    // 6.把该结果压入oprands栈中                    oprands.push(result);                    break;                case \"/\":                    // 4.如果是运算符，则从oprands栈中弹出两个操作数o1,o2                    o1 = oprands.pop();                    o2 = oprands.pop();                    // 5.使用该运算符计算o1和o2，得到结果result                    result = o2 / o1;                    // 6.把该结果压入oprands栈中                    oprands.push(result);                    break;                default:                    oprands.push(Integer.parseInt(curr));                    break;            &#125;        &#125;        // 7.遍历结束后，拿出栈中最终的结果返回        Integer result = oprands.pop();        return result;    &#125;&#125;// 栈代码class Stack&lt;T&gt; implements Iterable&lt;T&gt; &#123;    // 记录首结点    private Node head;    // 栈中元素的个数    private int N;    public Stack() &#123;        head = new Node(null, null);        N = 0;    &#125;    // 判断当前栈中元素个数是否为0    public boolean isEmpty() &#123;        return N == 0;    &#125;    // 把t元素压入栈    public void push(T t) &#123;        Node oldNext = head.next;        Node node = new Node(t, oldNext);        head.next = node;        // 个数+1        N++;    &#125;    // 弹出栈顶元素    public T pop() &#123;        Node oldNext = head.next;        if (oldNext == null) &#123;            return null;        &#125;        // 删除首个元素        head.next = head.next.next;        // 个数-1        N--;        return oldNext.item;    &#125;    // 获取栈中元素的个数    public int size() &#123;        return N;    &#125;    @Override    public Iterator&lt;T&gt; iterator() &#123;        return new SIterator();    &#125;    private class SIterator implements Iterator&lt;T&gt; &#123;        private Node n = head;        @Override        public boolean hasNext() &#123;            return n.next != null;        &#125;        @Override        public T next() &#123;            n = n.next;            return n.item;        &#125;    &#125;    private class Node &#123;        public T item;        public Node next;        public Node(T item, Node next) &#123;            this.item = item;            this.next = next;        &#125;    &#125;&#125;队列队列是一种基于先进先出(FIFO)的数据结构，是一种只能在一端进行插入,在另一端进行删除操作的特殊线性表，它按照先进先出的原则存储数据，先进入的数据，在读取数据时先读被读出来。\n","plink":"https://dxsummer.gitee.io/posts/10b828c8/"},{"title":"Macbook优化","date":"2022-01-19T12:44:01.000Z","date_formatted":{"ll":"2022年1月19日","L":"2022/01/19","MM-DD":"01-19"},"updated":"2022-01-21T16:20:23.341Z","content":"关闭聚焦问题背景有时候忽然发现风扇转到特别厉害，打开的应用程序并不多。打开活动监视器，可以看到 mds、mds_stores、mdworker 占用很高的 cpu 和 内存 资源。\n\nSpotlight 中文名称为 聚焦，就是按下 Command + 空格 弹窗的那个搜索框。\n问题处理以上是 聚焦 的功能说明，因为我很少使用这些功能，所以我选择了禁止 聚焦 索引文件。\n1sudo mdutil -a -i off如果需要再次使用，可以通过以下命令重新开启。\n1sudo mdutil -a -i on","plink":"https://dxsummer.gitee.io/posts/3c3fd7cd/"},{"title":"用pmset管理macOS的睡眠","date":"2022-01-19T12:44:01.000Z","date_formatted":{"ll":"2022年1月19日","L":"2022/01/19","MM-DD":"01-19"},"updated":"2022-01-20T06:18:35.706Z","content":"用 pmset 管理 macOS 的睡眠\nPower Manager Setting (pmset) 是 macOS 的系统级电池管理工具，通过调整 macOS 的睡眠计划，可以让Mac睡得更「好」，达到 「插电响应快，断电用得久」 的理想目标。\n\nMac 是怎么睡觉的？Mac 的睡觉分成两种，「睡眠」 (sleep) 和 「休眠」 (hibernate)。简单点说，睡眠和休眠就好比人的小憩和睡大觉，小憩醒得快，睡大觉就醒得慢。\n当你长时间不操作 Mac 或把 MacBook 的盖子合上或点击 Apple Logo 菜单下的 Sleep 选项，系统会进入「睡眠」状态，由于数据仍存储在内存中，此时系统可以被快速唤醒，快速恢复到睡眠前的状态。\n在「睡眠」一段时间后，Mac 会根据你的设定进入更深一层的 「休眠」 状态，此时 Mac 会考虑将内存中的数据作为一个镜像写入到硬盘中（GB 级别大小），然后放弃内存供电，达到更加省电的目的。此时唤醒系统，数据需要从硬盘重新装载至内存，耗时长，速度慢。\n总结一下，「睡眠」和「休眠」的主要区别：\n唤醒速度快慢\n是否向内存供电\n是否向硬盘写入内存镜像\n当然，Mac 到底要怎么「睡」，我们是可以通过 pmset 调整的。\nmacOS 系统睡眠流程如图所示，当我们不使用 Mac 时，一段时候后，系统先进入 sleep 状态，然后根据 hibernatemode 的模式，决定将镜像数据写入内存还是硬盘。\nstandby 和 autopoweroff 相当于两个并行的模式计时器，Mac 会根据当前供电条件作出模式的选择，在计时器阶段内，当时间条件满足，Mac 就会将镜像写入硬盘并休眠。\npmset 用法1sudo pmset [-选项] &lt;参数&gt;例子：\npmset -g custom：查看当前所有休眠计划\npmset -g cap：查看当前供电条件下可以调节的参数\nsudo pmset restoredefaults：还原全部设置\n常用选项pmset -a：调整任何条件下的休眠计划\npmset -c：调整外部供电的休眠计划\npmset -b：调整电池供电的休眠计划\npmset -g：查看计划\n常用参数更多参数在终端运行 $ man pmset, 查阅 pmset 的说明\n搜索关键字方法：/关键字   例 ： /sleep\nsleepsleep 控制进入休眠所需要的空闲时间\n【sleep &gt;= disksleep &gt;= display sleep】\nhibernatemode\nhibernatemode supports values of 0, 3, or 25. Whether or not a hibernation image gets written is also dependent on the values of standby and autopoweroff.\n\nhibernatemode 负责管理休眠模式。值得注意的是，休眠时的内存镜像是否写入硬盘，除了受 hibernatemode 的控制，还和 standby 以及 autopoweroff 的值有关。\nhibernatemode 有 3 种休眠模式可选择\nhibernatemode = 0\n\niMac, Mac Mini等 Mac桌面设备默认参数\n持续向内存供电，将数据保留在内存\n唤醒速度快，减少硬盘占用\n数据有丢失风险\n耗电量大\n\nhibernatemode = 25\n\n将数据写入硬盘\n不向内存供电，将内存镜像直接写入硬盘\n数据不易丢失，镜像占用硬盘空间\n唤醒速度慢\n耗电量少\n\nhibernatemode = 3\n\nMacBook 笔记本设备默认参数\nsafe sleep, 数据既写入内存又写入硬盘\n持续向内存供电\n唤醒时，根据设备电量自动选择从 内存/硬盘 恢复\n\n\n具体说明下hibernatemode参数，详细如下：\n\n\nMac的sleep mode在os x系统里有一个准确的叫法是HibernateMode，它有三个值：0、25、3Mode: 0当 HibernateMode 的值为 0 时 ，设备里除了 RAM（内存）外，键盘，显示器，鼠标等所有内外工作模块都会断开电源（或电池供应），此时系统不会将内存的数据写入硬盘，如果到设备被再次唤醒之前，电源线一直接入或者电池电量足够，那么用户在开盖后可立刻唤醒 Mac。这种模式的优点明显，就是她不会向硬盘写数据，也就是设备在深度睡眠（一般成为休眠）时不会产生内存镜像，即能减少硬盘的占用率，也能让唤醒操作立刻完成。但请注意，许多事情有优点也有缺点，那就是当设备处于睡眠过程中时，电源线没插上，电池电量耗尽，那内存的供电就会自动中断，内存里保存的数据也会自动清除。OS X系统自身默认没有选择它。Mode: 25当 HibernateMode 的值为 25 时，设备里所有模块均断电，内存数据被全部写入硬盘，硬盘里有一个专门负责“休眠”的内存镜像文件，当设备从“休眠”中恢复时，会自动调用保存好的内存镜像文件，将数据重新写回内存中，受硬盘的输入输出速率影响，这个过程会很漫长，所以许多朋友会在唤醒时看到屏幕里有进度条，千万别认为你的设备硬件不够用了，该换电脑了，别听奸商的忽悠，Mac 的产品寿命可比手机长多了，回到正题，在数据被完全写回内存后，Mac 才能被完全唤醒。这种模式优点明显，无需单独为内存供电，内存的数据不容易被丢失，缺点就是唤醒时间较长。Mode: 3第三项值就是 OS X 默认选择的，这种状态下也叫：“Safe Sleep”，人们还叫她是“混合休眠模式”，这种模式结合了前两种模式的长处，设备进入睡眠后，内存仍然保持供电，但仍然会将数据写入硬盘，这样内存的数据就同时被保存在两个硬件模块里，如果在唤醒时，设备电量充足（或够用），那 Mac 就会像 Mode 0 一样快速被唤醒，如果唤醒操作前，设备电量已不足了或者已经被耗尽，此时插上电源线后，系统会自动从硬盘里的内存镜像文件中恢复内存，而唤醒过程和 Mode 1 一样慢。这种模式优缺点就不用再用我说了吧，非常灵活。\n\n\nstandby\nstandby causes kernel power management to automatically hibernate a machine after it has slept for a specified time period.\n\nstandby 是 Mac 在休眠时的计时器，当满足时间条件，Mac就会由「睡眠」状态转至「休眠」状态。\nstandby模式需要以下条件：\n电池供电\n没有外接设备\n没有网络活动\n没有外接显示器\n在满足条件的前提下， standbydelayhigh/low 秒后，会进行休眠。比较人性化的的一点是，standby 提供了两个倒计时，通过一个阈值 (highstandbythreshold) 进行控制。\nhighstandbythresholdhighstandbythreshold(电池剩余电量百分比)它是standbydelay模式选择阈值，默认 50% 电量。\n高于阈值，采用 standbydelayhigh 计算时间。\n低于阈值，采用 standbydelaylow 计算时间。\nautopoweroff\nautopoweroff is enabled by default on supported platforms as an implementation of Lot 6 to the European Energy-related Products Directive. After sleeping for  seconds, the system will write a hibernation image and go into a lower power chipset sleep. Wakeups from this state will take longer than wakeups from regular sleep.\n\nautppoweroff 是为了满足 欧盟能源效率 Lot 6 条例（关于待机和关闭模式的要求）而设计的，但并不是全部设备都有这个这个设定，需要通过 pmset -g cap 查看是否能调节此项参数。\nautopoweroff模式需要满足以下条件：\n外部电源供电\n没有外接设备\n没有网络活动\n在满足条件的前提下, autopoweroffdelay秒后，系统会写入内存镜像然后休眠。与上文提到的 standby 不同，autppoweroff 更多是为了连接外部电源充电时设计的。\npowernap在配备闪存的 Mac 电脑上，电能小憩功能可让某些 Mac 电脑即使处于睡眠状态，也可以保持最新。当 Mac 进入睡眠状态后，电能小憩功能会定期激活以更新信息。所更新的信息取决于您的 Mac 是使用电池供电（Mac 笔记本电脑）还是接入了电源适配器（Mac 笔记本电脑或 Mac 台式电脑）。\n当 Mac 处于睡眠状态并使用电池供电时，电能小憩功能会：\n检查“邮件”中的新邮件\n更新“日历”中的日程\n更新其他 iCloud 日程\n将 Mac 接入电源适配器时，电能小憩功能还能进行诸如下载软件更新和执行时间机器备份等活动。\nwomp以太网数据包唤醒（值=0/1）。与“节能器”首选项中的“唤醒网络访问”相同。\nttyskeepawake当任何tty(例如，远程登录会话)处于“活动”状态时，防止空闲系统休眠。仅当TTY的空闲时间超过系统休眠计时器时，TTY才是“不活动的”。(值=0/1)\ngpuswitchgpuswitch 这个参数用于管理显卡的选择，适合有独立显卡/外置显卡的 Mac\ngpuswitch=0 只使用集成显卡\ngpuswitch=1 只使用独立显卡\ngpuswitch=2 自动切换显卡\n调节这个参数可以避免在电池供电时使用耗电量高的独立显卡，以节省电量。\n其他常用参数lidwake：开盖时是否唤醒\ntcpkeepalive：合盖时是否保存网络连接\ndisplaysleep：屏幕休眠时间\ndisksleep： 硬盘休眠时间\nacwake: 被同一 iCloud ID 下的设备唤醒\n在终端输入：pmset -g custom  这个命令可以显示系统所有的电源设置（更详细的介绍请看Apple开发者文档）：\n\nBattery Power用电池时的电源设置\n\nAC Power外接电源时的电源设置\n\nlidwake当屏幕掀开的时候唤醒Mac，1是开启 0是关闭\n\nautopoweroff如果Mac处于睡眠状态经过指定的时间后，自动把内存数据写入硬盘，并切断所有部件的电源，进入休眠状态，1是开启 0是关闭。\n\nautopoweroffdelay启用autopoweroff功能的时间，也就是上面说的那个“指定的时间”，单位是秒\n\nstandby功能跟autopoweroff一样，不过仅在hibernatemode为3的时候起作用，1是开启 0是关闭。\n\nstandbydelay启用standby功能的时间，单位也是秒\n\nttyskeepawake远程用户正在活动时防止Mac进入睡眠，1是开启 0是关闭\n\nhibernatemode睡眠模式\n\ndarkwakes这个就是Power Nap，你可以在系统偏好设置里选择开或关，跟在这里设置是一样的，1是开启 0是关闭\n\nhibernatefile内存镜像存放的地址，这个也可以更改，不过路径必需是root下的路径\n\ndisplaysleepMac闲置多长时间后进入显示器睡眠，单位是分钟，这个时间不能长于sleep下设置的时间\n\nsleepMac闲置多长时间后进入睡眠，这个系统偏好设置里也有，单位是分钟\n\nacwake电源改变时唤醒，也就是插上或者拔掉外置电源时唤醒Mac，1是开启 0是关闭\n\nhalfdim显示器睡眠时使显示器亮度改变为当前亮度的一半，1是开启 0是关闭。如果关闭这个功能的话，显示器睡眠会直接关掉显示器。\n\nlessbright使用电池时使显示器亮度暗一点，系统偏好设置里也有这个，1是开启 0是关闭\n\ndisksleepMac闲置多长时间后关闭硬盘。这个系统偏好里也有，只不过换了一个字眼—如果可能，使硬盘进入睡眠—勾上这个的话系统就会自动根据sleep的时间设一个合适的时间。单位是秒，这个时间不能长于sleep下设置的时间\n\nsleepservice\n\nwomp网络远程唤醒，1是开启 0是关闭\n\nnetworksleep这个设置影响Mac在睡眠的过程中如何提供网络共享服务\n1234567891011121314151617181920212223242526272829303132333435lidwake// 当屏幕掀开的时候唤醒Mac，1是开启  0是关闭 autopoweroff// 如果Mac处于睡眠状态经过指定的时间后，自动把内存数据写入硬盘，并切断所有部件的电源，进入休眠状态，1是开启  0是关闭。但是LZ发现就算是处于开启状态，这个功能也并没有起作用，你可以不管它，也可以关掉 autopoweroffdelay//启用autopoweroff功能的时间，也就是上面说的那个“指定的时间”，单位是秒 standby//功能跟autopoweroff一样，不过仅在hibernatemode为3的时候起作用，1是开启 0是关闭。不过LZ一直没搞明白autopoweroff跟standby有什么不一样，按理说应该是不一样的 standbydelay//启用standby功能的时间，单位也是秒 ttyskeepawake//远程用户正在活动时防止Mac进入睡眠，1是开启  0是关闭 hibernatemode//睡眠模式 darkwakes//这个就是Power Nap，你可以在系统偏好设置里选择开或关，跟在这里设置是一样的，1是开启  0是关闭 hibernatefile//内存镜像存放的地址，这个也可以更改，不过路径必需是root下的路径 displaysleep//Mac闲置多长时间后进入显示器睡眠，2013款Air的系统偏好设置里已经没有这个选项了，Pro是有的，不过其实你可以通过pmset来修改。单位是分钟，这个时间不能长于sleep下设置的时间 sleep//Mac闲置多长时间后进入睡眠，这个系统偏好设置里也有，单位是分钟 acwake//电源改变时唤醒，也就是插上或者拔掉外置电源时唤醒Mac，1是开启  0是关闭 halfdim//显示器睡眠时使显示器亮度改变为当前亮度的一半，1是开启  0是关闭。如果关闭这个功能的话，显示器睡眠会直接关掉显示器。 lessbright//使用电池时使显示器亮度暗一点，系统偏好设置里也有这个，1是开启  0是关闭 disksleep//Mac闲置多长时间后关闭硬盘。这个系统偏好里也有，只不过换了一个字眼—如果可能，使硬盘进入睡眠—勾上这个的话系统就会自动根据sleep的时间设一个合适的时间。单位是秒，这个时间不能长于sleep下设置的时间 sleepservice//LZ还没搞清楚这个是干嘛的，请知道的锋友解释下。 womp//网络远程唤醒，1是开启  0是关闭 networksleep//这个设置影响Mac在睡眠的过程中如何提供网络共享服务，LZ也不太清楚是什么，最好就不要动。个人设置方案我个人所希望的休眠计划是：外接供电条件下响应尽可能快，电池供电条件下耗电少。\n⚡️ 外部供电下的 pmset 设置在进行外部供电的时候，我希望 MacBook 是处于一个 「时刻准备着」 的状态（参考 iMac ），因此我希望我的 Mac能清醒更久，并且永不 「休眠」。因此我会作出以下设置：\n永不休眠：\nhibernatemode 设置成 0，让外部电源持续给内存供电。\n关闭 standyby 和 autopoweroff 模式，阻止 MacBook 休眠。\n详细设置：\n1234567891011121314151617181920// 25 分钟后进入睡眠，延长清醒时间sudo pmset -c sleep 25// 显示器睡眠时间：3 分钟sudo pmset -c displaysleep 3// 硬盘睡眠时间：10 分钟sudo pmset -c disksleep 10// 内存供电，内存镜像不写入硬盘sudo pmset -c hibernatemode 0// 关闭 standby 模式sudo pmset -c standby 0// 关闭 autopoweroffsudo pmset -c autopoweroff 0// 休眠时持续联网sudo pmset -c tcpkeepalive 1🔋电池供电下的 pmset 设置在通过电池供电的时候，我希望 Mac 能耗电少一些，同时「休眠」后唤醒速度不太慢。因此我会作出以下设置：\nhibernatemode 为 3，将镜像数据既写入内存又写入硬盘，同时对内存只供电一段时间。\nstandby 的电量阈值设置成 75%，当电量低于 75% stanby的计时器就使用 standbydelaylow 作为休眠倒计时。\ntcpkeepalive 设置成 0, 休眠时电脑将会断网，以节省电量。但此时无法进行下载工作，FindMy 也无法定位。\nproximitywake 设置成 0, 关闭被同一网络下的同 iCloud 设备唤醒\n详细设置：\n1234567891011121314151617181920212223242526272829303132333435// 10 分钟后进入睡眠sudo pmset -b sleep 10//关闭电能小憩sudo pmset -b powernap 0 //关闭ttyskeepawakesudo pmset -b ttyskeepawake 0// 休眠时内存供电sudo pmset -b hibernatemode 0//开启自动睡眠转休眠sudo pmset -b standby 1// 显示器休眠时间：3 分钟sudo pmset -b displaysleep 3// 硬盘睡眠时间：10 分钟sudo pmset -b disksleep 10// 休眠时断网sudo pmset -b tcpkeepalive 0// 高电量下 standby: 4小时sudo pmset -b standbydelayhigh 14400// 低电量下 standby: 2小时sudo pmset -b standbydelaylow 7200//standby 电量阈值：50%sudo pmset -b highstandbythreshold 50//关闭电源和电池供电切换时唤醒sudo pmset -a acwake 0参考资料:\nStackExchange: Difference between autopoweroff and standby in pmset\ntutsplus: How to Hibernate a Mac\nWikiPedia: pmset\n\nP.S. 「Hibernate」 英文直译为「睡得深的睡眠，如冬眠」，本文取「休眠」之义，以表达设备的低功耗运作。\n\n","plink":"https://dxsummer.gitee.io/posts/3c3fd7cd/"},{"title":"解决github图片加载不出来","date":"2022-01-15T10:37:25.000Z","date_formatted":{"ll":"2022年1月15日","L":"2022/01/15","MM-DD":"01-15"},"updated":"2022-01-16T07:40:38.467Z","content":"网上会搜到很多方法，大部分都是修改hosts文件但是ip好像隔一段时间就会换掉，导致一些教程会有时效性根据其他教程来修改hosts文件ip的话，首先需要自己去查ip\n1、查ip地址https://www.ipaddress.com/\n输入：avatars. Githubusercontent.com\n2、配置hosts文件文件位置：C:\\Windows\\System32\\drivers\\etc\nmac：/etc/host\n1234567891011140.82.114.6 api.github.com199.232.68.133 avatars0.githubusercontent.com199.232.68.133 avatars1.githubusercontent.com199.232.68.133 avatars2.githubusercontent.com199.232.68.133 avatars3.githubusercontent.com199.232.68.133 Build software better, together199.232.68.133 avatars5.githubusercontent.com199.232.68.133 avatars6.githubusercontent.com199.232.68.133 avatars7.githubusercontent.com199.232.68.133 Build software better, together199.232.68.133 raw.githubusercontent.com*上面ip会有时效性，2020.08.14测试可用 *保存时可能会提示权限问题，要以管理员身份运行 *图片大部分都是在avatars[0-9].githubusercontent.com里面，如果上面这些还有未加载出的图片或链接报错，可通过第一步查ip自行添加\n","plink":"https://dxsummer.gitee.io/posts/7cd4f2fa/"},{"title":"mac版ghub安装完成后卡登陆界面","date":"2022-01-15T06:14:28.000Z","date_formatted":{"ll":"2022年1月15日","L":"2022/01/15","MM-DD":"01-15"},"updated":"2022-01-16T07:00:58.051Z","content":"访达里面点「应用程序」，找到G hub程序\n\n右键，点击「显示包内容」\n\n点击「Contents」&gt;「MacOS」&gt;「lghub_updater」\n\n在点击ghub_updater的时候需要在【安全性与隐私】里给一个「输入监听」的权限，然后在启动程序就OK了。\n\n然后，点击「Contents」&gt;「MacOS」&gt;lghub，这样就能启动你的Ghub了。\n\n","plink":"https://dxsummer.gitee.io/posts/25da7a66/"},{"title":"JavaWeb","date":"2021-12-31T12:35:52.000Z","date_formatted":{"ll":"2021年12月31日","L":"2021/12/31","MM-DD":"12-31"},"updated":"2022-01-13T11:51:44.856Z","content":"\n标准说明\n\n结构HTML\n\n表现CSS\n\n行为Javascript\nHtmlhtml语法规范双标签：&lt;html&gt;&lt;/html&gt;\n单标签：&lt;br/&gt;\n1234567891011&lt;!DOCTYPE html&gt; \t文档声明标签 当前文档使用html5&lt;html lang=\"en\"&gt;\t根标签 lang定义语言为英文 zh-CN中文    &lt;head&gt;\t\t\t头部标签        &lt;meta charset=\"utf-8\"&gt;\t\t字符集采用utf-8\t        &lt;title&gt;无标题文档&lt;/title&gt;\t 标题    &lt;/head&gt;    &lt;body&gt;\t页面内容        内容    &lt;/body&gt;&lt;/html&gt;字符集&lt;meta charset=&quot;utf-8&quot;&gt;\n\nGB2312简体中文\n\nBIG5繁体中文\n\nGBK简体/繁体中文\n\nUTF-8万国码\nVSCode安装插件EXTENSIONS\n插件作用\n\nOpen in browser右击选择浏览器打开html文件\n\nJS-CSS-HTML Formatter每次保存，都会自动格式化js css和html代码\n\nAuto Rename Tag自动重命名配对的HTML/XML标签\n\nCSS Peek追踪至样式\n使用新建文件\n\n保存为.html\n\nCtrl+加号/减号 放大缩小视图\n\n生成页面骨架结构 输入!按下Tab\n\nOpen In Default Browser (Alt+B) 预览\n\n常用标签123&lt;h1&gt;一级标题&lt;/h1&gt;&lt;p&gt;段落标签&lt;/p&gt;&lt;br /&gt;换行标签文本格式化标签\n加粗&lt;strong&gt;&lt;/strong&gt;或者&lt;b&gt;&lt;/b&gt;推荐&lt;strong&gt;&lt;/strong&gt;\n\n倾斜&lt;em&gt;&lt;/em&gt; &lt;i&gt;&lt;/i&gt;&lt;em&gt;&lt;/em&gt;\n\n删除线&lt;del&gt;&lt;/del&gt; &lt;s&gt;&lt;/s&gt;&lt;del&gt;&lt;/del&gt;\n\n下划线&lt;ins&gt;&lt;/ins&gt; &lt;u&gt;&lt;/u&gt;&lt;ins&gt;&lt;/ins&gt;\n布局标签&lt;div&gt;&lt;/div&gt;         一行只能放一个div标签    大盒子\n&lt;span&gt;&lt;/span&gt;     一行能放多个span标签    小盒子\n图像标签、路径1&lt;img src=\"图像URL\" /&gt;\n属性属性值说明\n\nsrc图片路径必须属性\n\nalt文本替换文本 。图像不能显示的文字\n\ntitle文本提示文本 。鼠标放到图像上，显示的文字\n\nwidth像素图像宽度\n\nheight像素图像高度\n\nborder像素图像边框粗细\n\n相对路径\n\n\n同一级路径&lt;img src=&quot;baidu.gif&quot; /&gt;\n\n下一级路径/&lt;img src=&quot;images/baidu.gif&quot; /&gt;\n\n上一级路径../&lt;img src=&quot;../baidu.gif&quot; /&gt;\n超链接标签1&lt;a href=\"跳转目标\" target=\"目标弹出方式\"&gt;文本或图像&lt;/a&gt;\nhref目标url地址\n\ntarget链接页面打开方式，_self默认值，_blank新窗口打开\n\n下载链接 ，链接的文件是.exe或者.zip等压缩包形式\n\n1 &lt;a href=\"img.zip\"&gt;下载文件&lt;/a&gt;锚点链接#名字\n12&lt;a href=\"#two\"&gt;第二集&lt;/a&gt;&lt;h3 id=\"two\"&gt;第二集&lt;/h3&gt;\t目标位置，添加id属性特殊字符\n显示结果描述实体名称实体编号\n\n空格&amp;nbsp;&amp;#160;\n\n&lt;小于号&amp;lt;&amp;#60;\n\n&gt;大于号&amp;gt;&amp;#62;\n\n&amp;和号&amp;amp;&amp;#38;\n\n“引号&amp;quot;&amp;#34;\n\n‘撇号&amp;apos;(IE不支持)&amp;#39;\n\n￠分（cent）&amp;cent;&amp;#162;\n\n£镑（pound）&amp;pound;&amp;#163;\n\n¥元（yen）&amp;yen;&amp;#165;\n\n€欧元（euro）&amp;euro;&amp;#8364;\n\n§小节&amp;sect;&amp;#167;\n\n©版权（copyright）&amp;copy;&amp;#169;\n\n®注册商标&amp;reg;&amp;#174;\n\n™商标&amp;trade;&amp;#8482;\n\n×乘号&amp;times;&amp;#215;\n\n÷除号&amp;divide;&amp;#247;\n表格行 &lt;tr&gt;&lt;/tr&gt;\n列 &lt;td&gt;&lt;/td&gt;\n12345&lt;table&gt;\t&lt;tr&gt;\t\t&lt;td&gt;&lt;/td&gt;\t&lt;/tr&gt;&lt;/table&gt;\n属性属性值描述\n\nalignleft,center,right表格相对周围元素的对齐方式\n\nborder1表格边框，默认0\n\ncellpadding像素值单元边沿与内容之间的空白 默认值1\n\ncellspacing像素值规定单元格之间的空白，默认值2px\n\nwidth像素值 百分比表格宽度\n表头单元格表头会加粗 &lt;th&gt;&lt;/th&gt;\n\n    \n        姓名性别年龄\n    \n    \n        刘德华男55\n    \n12345678&lt;table style=\"width:300px;\"&gt;\t&lt;tr&gt;\t\t&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;\t&lt;/tr&gt;    &lt;tr&gt;    \t&lt;td&gt;刘德华&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;55&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;表格结构标签&lt;thead&gt;&lt;/thead&gt;表格的头部区域 内含&lt;tr&gt;&lt;th&gt;&lt;/th&gt;&lt;/tr&gt;\n&lt;tbody&gt;&lt;/tbody&gt;表格的主体区域 内含&lt;tr&gt;&lt;td&gt;&lt;/td&gt;&lt;/tr&gt;\n123456789101112&lt;table&gt;    &lt;thead&gt;        &lt;tr&gt;\t\t\t&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt;\t\t&lt;/tr&gt;    &lt;/thead&gt;    &lt;tbody&gt;        &lt;tr&gt;    \t\t&lt;td&gt;刘德华&lt;/td&gt;&lt;td&gt;男&lt;/td&gt;&lt;td&gt;55&lt;/td&gt;    \t&lt;/tr&gt;    &lt;/tbody&gt;&lt;/table&gt;合并单元格目标单元格：上/左侧\n跨行合并：rowspan=”合并单元格的个数”\n跨列合并：colspan=”合并单元格的个数”\n\n    \n        \n    \n    \n        \n    \n    \n        \n    \n\n1. 确定是跨行/跨列合并\n2. 找到**目标单元格**，写上合并方式 ``\n3. **删除多余的单元格**1234567891011&lt;table width=\"150px\" height=\"100px\" border=\"3\" cellspacing=\"0\"&gt;\t&lt;tr&gt;\t\t&lt;td&gt;&lt;/td&gt;&lt;td colspan=\"2\"&gt;&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td rowspan=\"2\"&gt;&lt;/td&gt;&lt;td &gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;\t&lt;/tr&gt;\t&lt;tr&gt;\t\t&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;\t&lt;/tr&gt;&lt;/table&gt;列表\n常用来布局，显示数据\n\n无序列表（重点）\n    列表项1\n    列表项2\n    列表项3\n12345&lt;ul&gt;\t&lt;li&gt;列表项1&lt;/li&gt;\t&lt;li&gt;列表项2&lt;/li&gt;\t&lt;li&gt;列表项3&lt;/li&gt;&lt;/ul&gt;有序列表\n    列表项1\n    列表项2\n    列表项3\n12345&lt;ol&gt;\t&lt;li&gt;列表项1&lt;/li&gt;\t&lt;li&gt;列表项2&lt;/li&gt;\t&lt;li&gt;列表项3&lt;/li&gt;&lt;/ol&gt;自定义列表\n    关注我们\n    新浪微博\n    官方微博\n    联系我们\n123456&lt;dl&gt;\t&lt;dt&gt;关注我们&lt;/dt&gt;\t&lt;dd&gt;新浪微博&lt;/dd&gt;\t&lt;dd&gt;官方微博&lt;/dd&gt;\t&lt;dd&gt;联系我们&lt;/dd&gt;&lt;/dl&gt;去掉li前面的小圆点1list-style: none;表单表单表单域\n表单控件（表单元素）\n提示信息\n\n表单域&lt;form&gt;&lt;/form&gt; 用户信息的收集和传递，把表单元素信息提交给服务器\n123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单域名称\"&gt;\t各种表单元素控件&lt;/form&gt;\n属性属性值作用\n\nactionurl地址指定接收并处理表单数据的服务器程序的url地址\n\nmethodget/post设置表单数据的提交方式，get/post\n\nname名称表单的名称，区分同一个页面中的多个表单域\n表单元素（表单控件）输入 input\n\n&lt;input&gt;属性属性值描述\n\nname用户自定义&lt;input&gt;元素名称\n\nvalue用户自定义&lt;input&gt;元素的值。多选时，被选中后会返回value的值\n\ncheckedchecked&lt;input&gt;首次加载时默认被选中\n\nmaxlength正整数输入字段中的字符的最大长度\n\nplaceholder自定义文本框中提示信息\n\nonclick点击时的动作\n\n\n    用户名:\n    密码:\n    上传头像：\n    爱好: \n    吃饭 \n    睡觉\n    \n    \n    \n\n12345678910111213&lt;input type=\"属性\" /&gt;&lt;form action\"XXX.php\" method=\"get\"&gt;    用户名:&lt;input type=\"text\" name=\"usename\" maxlength=\"3\" placeholder=\"请输入\"&gt;    密码:&lt;input type=\"password\"&gt;&lt;br/&gt;    上传头像：&lt;input type=\"file\" name=\"提交\"&gt;    爱好:     吃饭&lt;input type=\"checkbox\" name=\"hobby\" checked=\"checked\" value=\"吃饭\"&gt;     睡觉&lt;input type=\"checkbox\" name=\"hobby\" value=\"睡觉\"&gt;&lt;br&gt;    &lt;input type=\"submit\" value=\"开始注册\"&gt;    &lt;input type=\"reset\" value=\"重置\"&gt;    &lt;input type=\"button\" value=\"发送验证码\"&gt;&lt;/form&gt;\ntype属性值描述\n\nbutton可点击按钮，通过JavaScript启动脚本\n\ncheckbox复选框,name值必须有相同的名字 才能实现多选\n\nfile输入字段和浏览按钮 供文件上传\n\nhidden隐藏的输入字段\n\nimage图像形式的提交按钮\n\npassword密码字段，字符被隐藏\n\nradio单选按钮，name值必须有相同的名字 才能实现多选一\n\nreset重置按钮，清楚表单中所有数据\n\nsubmit提交按钮，把表单数据发送到服务器\n\ntext单行的输入字段，输入文本，默认宽度20个字符\nlable标签&lt;label&gt;标签用于绑定一个表单元素当点击。&lt;label&gt;标签内的文本时，浏览器就会自动将焦点(光标)转到或者选择对应的表单元素上,用来增加用户体验.\n\n    用户名:\n    \n    性别：\n    男\n    女\n\n    用户名\n    \n    性别：\n    男\n    \n    女\n    \n123456789&lt;form&gt;    &lt;label for=\"usename\"&gt;用户名&lt;/label&gt;\t&lt;input type=\"text\" name=\"useman\" id=\"usename\" value=\"有lable\"/&gt;&lt;br&gt;    性别：\t&lt;label for=\"man\"&gt;男&lt;/label&gt;\t&lt;input type=\"radio\" name=\"sex\" id=\"man\" /&gt;\t&lt;label for=\"woman\"&gt;女&lt;/label&gt;\t&lt;input type=\"radio\" name=\"sex\" id=\"woman\" /&gt;&lt;/form&gt;select下拉列表籍贯：\n    \n        山东\n        天降\n        大撒\n        恶趣味\n        臭小子\n    \n123456789&lt;form&gt;籍贯：    &lt;select&gt;        &lt;option&gt;山东&lt;/option&gt;        &lt;option &gt;天降&lt;/option&gt;        &lt;option&gt;大撒&lt;/option&gt;        &lt;option selected=\"selected\"&gt;恶趣味&lt;/option&gt;        &lt;option&gt;臭小子&lt;/option&gt;    &lt;/select&gt;&lt;/form&gt;\n设置默认选项\n\n1&lt;option selected=\"selected\"&gt;恶趣味&lt;/option&gt;textarea表单\n与&lt;input type=&quot;text&quot;&gt;区别\n\ntext 单行的输入字段，输入文本，默认宽度20个字符\ntextarea 多行文本输入的控件。\n\n    今日反馈：文本内容\n123&lt;form&gt;\t今日反馈：&lt;br&gt;&lt;textarea rows=\"3\" cols=\"20\"&gt;文本内容&lt;/textarea&gt;&lt;/form&gt;cols:一行字数，尽量用CSS\nrows：行数，尽量用CSS\nCSS1234567&lt;style type=\"text/css\"&gt;\t选择器&#123;属性：\"属性值\"&#125;&lt;/style&gt;p &#123;    color=\"red\";&#125;选择器123456789101112131415161718头: header内容:content/container尾: footer导航:nav侧栏:sidebar栏: columnu页面外围控制整体布局宽度:wrapper左右中:left right center登录条:loginbar标志:logo广告:banner页面主体:main热点: hot新闻:news下载:download子导航:subnav菜单:menu子菜单:submenu基础选择器类选择器：可调用多次\nid选择器：只能调用一次\n标签选择器标签名作为选择器，不能差异化设置\n12345标签名 &#123;属性：属性值;&#125;p &#123;    color:pink;&#125;类选择器 .123456789.类名 &#123;    属性：属性值;&#125;.jianb &#123;\twidth: 200px;\theight: 80px;\tbackground-image: linear-gradient(to right, #f00, #00f);&#125;123//调用&lt;p class=\"类名\"&gt;&lt;/p&gt;&lt;p class=\"jianb\"&gt;&lt;/p&gt;多类名一个标签有多个名字\n1234567.red &#123;\tcolor=\"red\";&#125;.font35&#123;\tfont=\"35px\";&#125;&lt;div class=\"red font35\"&gt;亚瑟&lt;/div&gt;id选择器只能调用一次\n1234#类名 &#123;    属性：属性值;&#125;&lt;div id=\"red\"&gt;亚瑟&lt;/div&gt;\nid选择器和类选择器的区别\n\n类选择器( class )好比人的名字，一个人可以有多个名字，同时一个名字也可以被多个人使用。id选择器好比人的身份证号码，全中国是唯一的，不得重复。\nid选择器和类选择器最大的不同在于使用次数上。\n类选择器在修改样式中用的最多, id选择器一般用于页面唯一性的元素上，经常和JavaScript 搭配使用。\n通配符选择器应用于所有标签\n123* &#123;\tcolor=\"red\";&#125;复合选择器后代选择器（重要）又称包含选择器 ，最后改的是li的样式 \n123ol li &#123;\tcolor:pink;&#125;子选择器只选亲儿子元素\n1.nav&gt;a &#123;&#125;123456&lt;div class=\"nav\"&gt;\t&lt;a href=\"#\"&gt;我是儿子&lt;/a&gt;\t&lt;p&gt;\t\t&lt;a href=\"#\"&gt;我是孙子&lt;/a&gt;\t&lt;/p&gt;&lt;/div&gt;并集选择器(重点)div和p都改样式\n123div,p&#123;\tcolor: red;&#125;伪类选择器1234a:link\t\t//未被访问链接a:visited\t//被访问链接a:hover\t\t//a:active\t//活动链接 按下未弹起的链接按顺序声明    Love Hate\n:focus选择器123456intput:focus\t//选取获得焦点的表单元素input:focus&#123;\tbackground-color:yellow;&#125;&lt;input type=\"text\"&gt;字体\n属性表示注意点\n\nfont-size字号px\n\nfont-family字体\n\nfont-weight字体粗细加粗是700，不需要加单位\n\nfont-style字体样式倾斜italic 默认normal\n\nfont字体连写有顺序，字号和字体必须保留\n1234font-famlit: Arial,'Microsoft Yahei','微软雅黑';font-size: 20px;font-weight: bold; //字体粗细100~900 normal boldfont-style:italic; //倾斜 normal\n复合属性\n\n必须保留 font-size font-family\n12//复合属性font:font-style font-weight font-size/line-height font-family;文本属性\n属性表示注意点\n\ncolor文本颜色\n\ntext-align文本对齐文字水平对齐的方式\n\ntext-indent文本缩进2em\n\ntext-decoration文本修饰下划线underline\n\nline-height行高行与行之间距离，垂直居中：行高等于容器高度\n文本颜色\n1color:red;\n表示属性值\n\n预定义的颜色值red，green，blue，pink\n\n十六进制#FF0000\n\nRGB代码rgb(255,0,0)、rgb(100%,0%,0%)，rgba（255,255,255,0.5）\n\n对齐文本\n1text-align:center;\n属性值解释\n\nleft左对齐（默认值）\n\nright右对齐\n\ncenter居中对齐\n\n装饰文本\n1text-decoration:underline\n属性值描述\n\nnone默认\n\nunderline下划线\n\noverline上划线\n\nline-through删除线\n\n文本缩进\n12text-indent:2em\t\t//em相对单位，当前元素 一个文字大小text-indent:20px;\n行间距\n1line-height:26px;\n垂直居中原理 line-height=height\n\n\n引入方式\n样式表优点缺点使用情况控制范围\n\n行内样式表书写方便，权重高结构样式混乱较少控制一个标签\n\n内部样式表部分结构和样式相分离没有彻底分离较多控制一个页面\n\n外链式完全实现结构和样式分离需要引入最多控制多个页面\n内部样式表123456&lt;style&gt;\tdiv &#123;        color:red;        font-size:12px;\t&#125;&lt;/style&gt;行内样式表青春不常在，抓紧谈恋爱1&lt;div style=\"color:red;font-size:12px;\"&gt;青春不常在，抓紧谈恋爱&lt;/div&gt;外部样式表(外链式)1&lt;link rel=\"stylesheet\" href=\"css路径\"&gt;Emmet语法\nTab建\n\n123456789!\t\t\t\t//快速生成 html结构div或标签名\t\t //生成标签div*3\t\t   //快速生成3个divul&gt;li\t\t   //父子级关系标签div+p\t\t\t//兄弟标签.demo\t\t\t//生成div 类名为demo#demo\t\t\t//生成div id名为demo.demo$*5\t\t//生成div1 div2 div3 div4 div5div&#123;123&#125;\t\t//&lt;div&gt;123&lt;/div&gt;\nShift+alt 快速输入\n\n元素显示模式\n元素模式元素排列设置样式默认宽度包含\n\n块级元素一行只能放一个可设置宽高容器100%容器级可包含任何标签\n\n行内元素一行多个行内元素不可直接设置宽高本身内容宽度容纳文本、其他行内元素\n\n行内块元素一行多个行内块元素可设置宽高本身内容宽度\n块元素div比较霸道，自己独占一行。\n高度，宽度、外边距以及内边距都可以控制\n宽度默认是容器（父级宽度)的100%\n是一个容器及盒子，里面可以放行内或者块级元素。\n\n注意\n\n文字类的元素内不能使用块级元素\n&lt;p&gt;标签主要用于存放文字，因此&lt;p&gt;里面不能放块级元素，特别是不能放&lt;div&gt;\n同理，&lt;h1&gt;~&lt;h6&gt;等都是文字类块级标签，里面也不能放其他块级元素\n如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\n行内元素span&lt;a href=&quot;#&quot;&gt;&lt;/a&gt;\n相邻行内元素在一行上，一行可以显示多个\n高、宽直接设置是无效的\n默认宽度就是它本身内容的宽度\n行内元素只能容纳文本或其他行内元素。\n\n注意\n\n链接里面不能再放链接\n特殊情况链接&lt;a&gt;里面可以放块级元素，但是给&lt;a&gt;转换一下块级模式最安全\n行内块元素&lt;img /&gt; &lt;input /&gt; &lt;td&gt; 同时具有块元素和行内元素的特点\n和相邻行内元素(行内块)在一行上，但是他们之间会有空白缝隙。一行可以显示多个(行内元素特点）\n默认宽度就是它本身内容的宽度(行内元素特点)\n高度，行高、外边距以及内边距都可以控制（块级元素特点)。\n显示模式转换123456789a&#123;\tdisplay: block;\t//转换成块元素&#125;div&#123;\tdisplay: inline;\t//转换成行内元素&#125;span&#123;    display:inline-block;\t//转换成行内块元素&#125;背景\n属性作用值\n\nbackground-color背景颜色预定义的颜色值/十六进制/RGB代码\n\nbackground-image背景图片url（图片路径）\n\nbackground-repeat是否平铺repeat、no-repeart、repeat-x、repeat-y\n\nbackground-position背景位置length/position   x和y坐标\n\nbackground-attachment背景附着scroll(背景滚动)/fixed(背景固定)\n\n背景简写书写简单背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置\n\n背景色半透明rgba(0,0,0,0.3)\n12345678background:背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;background: transparent url(image.jpg) repeat-y fixed top ;background-color : #fff | transparent(透明) | rgba(0,0,0,0.3);background-image: none | url();background-repeat: repeat | no-repeart | repeat-x | repeat-y;background-position: left top;\t//两个值前后顺序无关background-position: 20px 20px;\t//x轴 y轴 一个值时 默认另一个是垂直居中background-attachment: scroll | fixed\t//背景图像随内容滚动 背景图像固定背景图片:实际开发常见于logo或者一些装饰性的小图片或者是超大的背景图片\n优点是非常便于控制位置.(精灵图也是一种运用场景)\ncss三大特性层叠性相同选择器给设置相同的样式，此时一个样式就会覆盖（层叠）另一个冲突的样式。层叠性主要解决样式冲突的问题层叠性原则︰样式冲突，遵循的原则是就近原则，哪个样式离结构近，就执行哪个样式·样式不冲突，不会层叠\n123456div&#123;    background: pink;&#125;div&#123;    background:purple;&#125;继承性CSS中的继承:子标签会继承父标签的某些样式，如文本颜色和字号。简单的理解就是∶子承父业。\n123div&#123;    font: pink;&#125;12345&lt;div&gt;    &lt;p&gt;        龙生龙，逢生凤\t//div的选择器对p进行了影响    &lt;/p&gt;&lt;/div&gt;优先级当同一个元素指定多个选择器，就会有优先级的产生\n\n选择器相同，则执行层叠性\n\n选择器不同，则根据选择器权重执行\n\n继承的权重是0\n\n复合选择器具有权重叠加\n​    div ul li —&gt; 0,0,0,3 (不需要进位)\n​    .nav ul li—-&gt;0,0,1,2\n\n    猪头肉\n    猪肉肉\n1234567ul li &#123;color: purple;&#125;\t//复合选择器 0,0,0,2li&#123;color: pink;&#125;&lt;ul&gt;    &lt;li&gt;猪头肉&lt;/li&gt;    &lt;li&gt;猪肉肉&lt;/li&gt;&lt;/ul&gt;\n\n选择器权重\n\n继承 或者 *0，0，0，0\n\n标签选择器0，0，0，1\n\n类选择器，伪类选择器0，0，1，0\n\nID选择器0，1，0，0\n\n行内样式style=””1，0，0，0\n\n！important重要的∞无穷大\n123div&#123;    font: pink!important;\t//权重高&#125;盒子模型边框 border\n属性作用\n\nborder-width定义边框粗细 px\n\nborder-style边框样式\n\nborder-color边框颜色\n12border: border-width border-style border-color;border : 1px solid red;\t//没有顺序表格边框————\n1border-collapse:collapse; //相邻边框合并在一起\n边框会额外增加盒子的实际大小。因此我们有两种方案解决:\n\n测量盒子大小的时候,不量边框.\n如果测量的时候包含了边框,则需要width/height减去边框宽度\n内边距 padding额外增加盒子的实际大小\n\n属性作用\n\npadding-left左内边距\n\npadding-right右\n\npadding-top上\n\npadding-bottom下\n123padding : 上 右 下 左;padding : 上 左右 下;padding : 上下 左右;外边距 margin\n属性作用\n\nmargin-left左外边距\n\nmargin-right右\n\nmargin-top上\n\nmargin-bottom下\n\n外边距可以让块级盒子水平居中，但是必须满足两个条件:\n\n盒子必须指定了宽度( width )\n盒子左右的外边距都设置为auto \n1.header&#123; width: 960px; margin: 0 auto; &#125;外边距合并\n嵌套块元素垂直外边距的塌陷问题\n\n对于两个嵌套关系(父子关系)的块元素，父元素有上外边距同时子元素也有上外边距，此时父元素会塌陷较大的外边距值。\n123456789101112#father&#123;    margin-top: 50px;\t//顶部50px    width: 190px;    height: 190px;    background: purple;&#125;#son&#123;    margin-top: 30px;\t//想要的效果：顶部距离father 30px 没有实现    width: 130px;    height: 130px;    background: rgb(88, 192, 105);&#125;123&lt;div id=\"father\"&gt;    &lt;div id=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;\n解决方案:\n\n可以为父元素定义上边框。border: 1px solid transparent;\n可以为父元素定义上内边距。padding-top:30px;\n可以为父元素添加overflow:hidden\n清除内外边距行内元素为了照顾兼容性，尽量只设置左右内外边距，不要设置上下内外边距。\n但是转换为块级和行内块元素就可以了心\n1234*&#123;    margin: 0;    padding: 0;&#125;圆角边框1234border-radius : 10px; //数值或%border-top-left-radiusborder-top-right-radiusborder-bottom-right-radius\n圆形\n\n半径是高度的一半\nborder-radius: 50%;\n盒子阴影影子不占用空间\n12box-shadow: x位置 y位置 模糊距离 阴影尺寸 颜色 inset(内阴影 可选);box-shadow: 10px 10px 10px -4px rgba(0,0,0,0.3);文字阴影1text-shadow : h-shadow v-shadow blur(模糊距离) color;浮动\n 布局方式\n\n标准流（普通流、文档流）：元素默认方式排列\n浮动布局\n层模型\n浮动最典型的应用:可以让多个块级元素一行内排列显示。\n123选择器 &#123;\tfloat: none | left | right;&#125;\n特性\n\n脱离标准普通流的控制，移动到指定位置(父盒子位置)，(俗称脱标)，浮动的盒子不再保留原先的位置\n浮动的元素会一行内显示，并且元素顶部对齐\n具有行内块元素的特性 如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定\n浮动的盒子中间是没有缝隙的，是紧挨着一起的\n\n中文属性值\n\n宽度width%，px,auto\n\n高度height%,px,auto\n\n定位:相对positionrelation\n\n文本装饰test-decorationnone\n\n背景颜色background-color十六进制，rgba(*,*,*,*)\n\n文本颜色color十六进制，rgba(*,*,*,*)\n\n行高line-heightpx,em\n\n边框border颜色 粗细 线型\n\n外边距margin行元素只有水平外边距，没有垂直外边距\n\n内边距padding导致元素与边框之间的距离增大\n\n字体font-family\n\n字号font-size\n\n边框-圆角半径border-radius\n\n盒子投影box-shadow水平便宜、垂直偏移、模糊半径 扩展半径 颜色\n\n文字投影text-shadow水平便宜、垂直偏移、模糊半径 扩展半径 颜色\n\n背景图像background-imageurl()\n\n背景重复background-repeatno-repeat\n\n背景尺寸background-sizepx %\n\n交换状态：hover\n\n强调状态:link\n\n活动中：active\n\n已访问：visited\n\n最后一个元素:last-child\n\n第一个元素:fist-child\n\n第几个元素:nth-of-type(n)\n\n\n12345678//控制div最后一个链接#nav06 a:last-child&#123;\tbackground-image: url(\"../images/1.png\");&#125;#nav06 a:last-child:hover&#123;\tbackground-image: url(\"../images/2.png\");\tcolor:#1476e6;&#125;","plink":"https://dxsummer.gitee.io/posts/99720b1c/"},{"title":"Js","date":"2021-12-31T12:35:52.000Z","date_formatted":{"ll":"2021年12月31日","L":"2021/12/31","MM-DD":"12-31"},"updated":"2022-01-13T11:51:44.857Z","content":"js基础JS脚本语言：一行一行执行\nJS组成ECMAScript\nECMAScript是由ECMA国际（原欧洲计算机制造商协会）进行标准化的一门编程语言，这种语言在万维网上应用广泛，它往往被称为JavaScript或JScript，但实际上后两者是ECMAScript语言的实现和扩展。\n\nDOM–文档对象模型\n文档对象模型(Document Object Model，简称DOM），是W3C组织推荐的处理可扩展标记语言的标准编程接口。通过DOM提供的接口可以对页面上的各种元素进行操作(大小、位置、颜色等)。\n\nBOM–浏览器对象模型BOM(Browser ObjectModel，简称BOM)是指浏览器对象模型，它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等。\n\n书写方式行内1234&lt;body&gt;    &lt;!-- 行内式的js 直接写到元素的内部 --&gt;    &lt;input type=\"button\" value=\"唐伯虎\" onclick=\"alert('秋香姐')\"&gt;&lt;/body&gt;可以将单行或少量JS代码写在HTML标签的事件属性中(以on开头的属性），如: onclick\n注意单双引号的使用:在HTML中我们推荐使用双引号,JS中我们推荐使用单引号\n可读性差，在html中编写JS大量代码时，不方便阅读;引号易错，引号多层嵌套匹配时，非常容易弄混;\n特殊情况下使用\n内嵌123456&lt;body&gt;    &lt;!-- 内嵌式 --&gt;    &lt;script&gt;        alert('沙漠骆驼');    &lt;/script&gt;&lt;/body&gt;外部12//my.jsalert('js vice!')1234&lt;body&gt;   &lt;!-- 外部js script 双标签 --&gt;    &lt;script src=\"my.js\"&gt;&lt;/script&gt;&lt;/body&gt;利于HTML页面代码结构化，把大段JS代码独立到HTML页面之外，既美观，也方便文件级别的复用\n\n引用外部JS文件的script标签中间不可以写代码\n\n适合于JS代码量比较大的情况\n\n注释单行注释 Ctrl+/\n\n多行注释 Shift+alt+A  \nVS Code 可修改成Shift+alt+/\n\n\n修改VS Code快捷键\n\n\n\n输入输出语句\n方法说明归属\n\nalert(msg)浏览器弹出警示框浏览器\n\nconsole.log(msg)浏览器控制台打印输出信息浏览器\n\nprompt(info)浏览器弹出输入框，用户可输入浏览器\n12345&lt;script&gt;    prompt('请输入您的年龄')    alert('计算结果是')    console('我是程序员能看到的')&lt;/script&gt;变量存放数据的容器 通常通过变量名获取数据，可修改\n变量就是一个装东西的盒子\n本质：变量是程序在内存中申请的一块用来存放数据的空间\n声明变量123456//声明变量var age; //声明一个名称为age的变量age = 10;var myname = 'autumndx';console.log(age);console.log(myname)123456// 3．声明变量的特殊情况// 3.1只声明不赋值结果是?程序也不知道里面存的是啥所以结果是undefined未定义的var sex;console.log(sex); l / undefined// 3.2 不声明不赋值直接使用某个变量会报错滴console.log(tel);// 3.3不声明直接赋值使用qq= 110;console.log(qq);变量的数据类型JavaScript是一种弱类型或者说动态语言\n12var age = 10;\t//这是一个数字型var areYouOk = '是的'; //这是一个字符串在代码运行时，变量的数据类型是由JS引擎 根据 = 右边变量值的数据类型来判断的，运行完毕之后，变量就确定了数据类型。\nJavaScript拥有动态类型，同时也意味着相同的变量可用作不同的类型︰\n12var x= 6;\t//x为数字x =\"Bi1l\";\t//x为字符串数据类型的分类\n简单数据类型说明默认值\n\nNumber数字型，包含整型值和浮点型值，如21、0.210\n\nBoolean布尔值类型，如true , false，等价于1和0false\n\nString字符串类型，如”张三” 注意咱们js里面，字符串都带引号“”\n\nUndefinedvar a;声明了变量a但是没有给值，此时a = undefinedundefined\n\nNullvar a = nul;声明了变量a 为空值null\n数字型八进制：010 （8）//数字前加0\n十六进制：0xa   (10)    //数字前加0x\n\n最大值\n\n1console.log(Number.MAX_VALUE);\n最小值\n\n1console.log(Number.MIN_VALUE);\n无穷\n\n12console.log(Number.MAX_VALUE*2);\t//Infinity 无穷大console.log(Number.MIN_VALUE*2);\t//Infinity 无穷小\n非数字 NaN\n\n1console.log('pink老师' - 100);\t//NaNisNaNisNaN()这个方法用来判断非数字―并且返回一个值如果是数字返回的是 false 如果不是数字返回的是true\n123456&lt;script&gt;    // isNaN(）这个方法用来判断非数字―并且返回一个值如果是数字返回的是 false 如果不是数字返回的是true    console.log(isNaN(12)); // false    console.log(isNaN(12));//false\tconsole.log(isNaN('pink老师'));//true&lt;/script&gt;字符串 StringJS可以用单引号嵌套双引号，或者用双引号嵌套单引号(外双内单，外单内双)\n12345678var str =‘我是一个\"高富帅\"的程序员';\tconsole.log(str);var str1 =\"我是一个'高富帅'的程序员\";console.log(str1);//字符串转义字符都是用\\开头但是这些转义字符写道引号里面var str2 =\"我是一个'高富帅'的\\n程序员\";console.log(str2);12345我是一个\"高富帅\"的程序员我是一个'高富帅'的程序员我是一个'高富帅'的程序员字符串转义符\n转义符解释说明\n\n\\n换行符，n是newline的意思\n\n\\\\斜杠 \\\n\n\\‘‘ 单引号\n\n\\““ 双引号\n\n\\ttab 缩进\n\n\\b空格 b是blank的意思\n字符串长度和拼接只要有字符串和其他类型相拼接最终的结果是字符串类型\n字符串＋任何类型=拼接之后的新字符串\n123456789101112&lt;script&gt;    // 检测获取字符串的长度length    var str = 'my name is andy';    console.log(str.length); //15    //字符串拼接    console.log('沙漠' + '骆驼'); //沙漠骆驼    console.log('pink老师' + '18'); //pink老师18    console.log('pink' + true);   //pinktrue    console.log('pink老师' + 18 + '岁'); //pink老师18岁    var age = 18;    console.log('pink老师' + age + '岁');&lt;/script&gt;28","plink":"https://dxsummer.gitee.io/posts/824395f6/"},{"title":"java","date":"2021-12-31T12:35:52.000Z","date_formatted":{"ll":"2021年12月31日","L":"2021/12/31","MM-DD":"12-31"},"updated":"2022-03-12T09:06:24.233Z","content":"理解面向对象JDKJDK安装目录bin：该路径下存放了JDK的各种工具命令，常用的javac、java等命令就放在该路径下。db：该路径是安装Java DB的路径。include：一些平台特定的头文件。jre：该路径下安装的就是运行Java程序所必须的JRE环境。lib：该路径下存放的是JDK工具命令的实际执行程序。src.zip：该压缩文件里存放的是Java所有核心类库的源代码。README和LICENSE等说明性文档。\n命令行WIN cmd命令123456789E:\t\t进入E盘dir \t查看目录cd XX \t进入XX文件夹cd.. \t退出到上一级cd\\\t\t多级回退cls\t\t清屏exit \t退出窗口↑↓\t\t上下命令切换Tab\t\t自动补齐文件名mac 命令行1234567891011121314151617181920212223242526272829303132cd\t进入指定文件夹路径\tcd ~&#x2F;Desktoppwd\t显示当前的目录路径\t&#x2F;Users&#x2F;xz&#x2F;Desktopls\t显示当前目录下的内容\tls -la\t显示当前目录下的详细内容\tls -A\t显示当前目录下的内容\t含点(.)开头的文件mkdir\t创建目录\tmkdir dir_nametouch file.format\t创建指定格式的文件\tmvdir\t移动目录\tmvdir dir1 dir2mv\t移动&#x2F;重命名---文件&#x2F;文件夹\tmv dir1 dir2MAC没有重命名的命令rm\t删除文件 或 空目录\trm -rf dir\t删除一个 非空 目录\trm -rf dirrmdir\t删除 空 目录\t平时用得少cp\t复制文件或目录\tcp file1 file2file\t显示文件类型\tfile file_namefind\t使用匹配表达式查找文件\tfind *.file_formatopen\t使用默认的程序打开文件\topen file_namecat\t显示或连接文件内容\tcat fileln\t为文件创建联接\tln -s file1 file2s 表示软联接head\t显示文件的最初几行\thead -20 file_nametail\t显示文件的最后几行\ttail -10 file_namepaste\t横向拼接文件内容\tpaste file1 file2diff\t比较并显示两个文件的内容差异\tdiff file1 file2wc\t统计文件的字符数、词数和行数\twc file_nameuniq\t去掉文件中的重复行\tuniq file_namegrep\t通过简单正则表达式搜索文件作者：惑也链接：https:&#x2F;&#x2F;www.jianshu.com&#x2F;p&#x2F;4f66b1468646来源：简书著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。编译\n一个class的名称为Simple，Java源文件名称可以不是Simple.java么？\n\n答案是可以的，但是前提是该类不是public修饰符。\n\n一个Java源文件中可以写多个类么？\n\n答案是可以的。如下图所示：\njavac1javac -d destdir srcFile-d destdir: 指定编译生成的字节码文件的存放路径，destdir是本地磁盘的一个有效地址\nsrcFile: Java源文件所在地址\n\n例\n\n\n可省略-d简写\n1E:\\&gt; javac helloworld.javajava1java Java类名\n例\n\n1java HelloWorld根据CLASSPATH环境变量定位类如果指定了环境变量，一定不要忘记在CLASSPATH中增加（.），代表当前路径，用以强制Java解释器在当前路径下搜索Java类\n\n 当使用java Java类名来运行java程序时，JRE到哪里搜索Java类？\n\n1.4以前版本需要在CLASSPATH环境变量中添加（.），用以告诉JRE需要在当前路径下搜索Java类\n还需要设置环境变量中的值，;%JAVA_HOME%\\lib\\dt.jar ;%JAVA_HOME%\\lib\\tools.jar\n\n1.5版本以后一旦设置了环境变量，JRE将会按照环境变量指定的路径来搜索Java类。意味着如果没有在CLASSPATH环境变量中添加（.），也就是没有包含当前路径，JRE不会搜索当前路径下的Java类\n也可不设置环境变量\n\n\n如果想在运行Java程序时临时指定JRE搜索Java类的路径，可使用 -classpath或者 -cp \n\n12java -classpath dir1;dir2;dir3...;dirN Java类java -classpath D:\\work\\java\\log4.jar HelloWorldWindows上用 ;隔开 ， Linux使用 ：隔开\n-classpath选项的值可以是一系列路径\n\n如果希望CLASSPATH环境变量指定搜索路径仍然有效\n\n1java -classpath %CLASSPATH%;.;dir1;dir2;dir3...;dirN Java类%CLASSPATH%:引用环境变量的值\n.：强制JRE在当前路径下搜索Java类\n源文件命名规则源文件扩展名必须是 .java\n\nJava程序源文件的主文件名可以是任意的。如果Java程序源代码里定义了一个public类，则该源文件的主文件名必须为public类的类名相同\n\n一个Java源文件最多只能定义一个public类\n\n定义3个独立的类，会生成3个 .class 文件，每个类对应一个 .class文件\n生成 Elephant.class Cat.class Dog.class 三个文件\n123456789public class Elephant&#123;\tpublic static void main(String[] args)&#123;\t\tSystem.out.println(\"Elephant\");\t&#125;&#125;class Cat&#123;&#125;class Dog&#123;&#125;\nJava源文件通常只定义一个类\n\n交互式工具 jshell执行Java语言的变量声明，语句和表达式，可立即看到执行结果\n测试Java的新API\n\n启动：在命令行中直接输入jshell\n\n/help: 查看帮助信息\n/exit : 退出jshell\n程序优化Java11改进的垃圾回收器为了更快的让垃圾回收器回收那些不再使用的对象，可以将该对象的引用变量设置为 null，来暗示垃圾回收器可以回收该对象\n对于不再需要的对象，不要引用他们\n基本结构-基本特征任何简单或复杂的算法都可以由顺序结构、选择结构、循环结构这三种基本类型组合而成。\n\n面向对象的三大特征\n\n封装：将对象的实现细节隐藏起来，然后通过一些公用的方法来暴露该对象的功能。\n继承：面向对象实现软件复用的重要手段，子类作为特殊的父类，将直接获得父类的属性和方法。Java不支持多继承\n多态：子类对象可以直接赋给父类变量，但运行时仍然表现出子类的行为特征。\nmain方法如果需要用Java命令直接运行一个Java类，这个Java类必须包含main方法，这个main方法必须使用public和static修饰，必须使用void声明该方法的返回值，而且该方法的参数类型只能是一个字符串数组\n\nJava程序必须以类Class的形式存在，类是java程序的最小程序单位。\n\n12345public class HelloWorld &#123;    public static void main(String[] args) &#123;        System.out.print(\"helloworld\");    &#125;&#125;数据类型和运算符注释1234567891011public class HelloWorld&#123;\t/*\t多行注释 java语言很有趣\t*/\tpublic static void main(String[] args)&#123;\t\t//这是单行注释\t\tSystem.out.println(\"hello\");\t\t//这行代码被注释了 所以不会执行 System.out.println(\"hello\");\t&#125;&#125;文档注释文档说明，用于说明每个类，每个方法的用途\n\n下载官方API文档\n\n￥点我进入！！！Oracle官方javaAPI\n\n文档注释\n\njavadoc工具默认只处理以public或protected修饰的类、接口、方法、成员变量、构造器和内部类之前的文档注释\nJava11 的API文档已经支持HTML 5 规范\n文档注释以 /**开始 */结束\n-d &lt;directory&gt; : 该选项指定一个路径，用于将生成的API文档放到指定目录下\n-windowtitle &lt;test&gt; : 该选项指定一个字符串，用于设置API文档的浏览器窗口标题\n-doctitle &lt;html-code&gt; : 该选项指定一个HTML格式的文本，用于指定概述页面的标题只有对处于多个包下的源文件来生成API文档时，才有概述页面\n\n-header &lt;html-code&gt; : 该选项指定一个HTML格式的文本，包含每个页面的页眉\n1javadoc -d apidoc -windowtitle 测试 -doctitle 学习javadoc工具的测试API文档 -header 我的类 *Test.java@author : 指定Java程序的作者\n@version : 指定源文件的版本\n@deprecated ： 不推荐使用的方法\n@param : 方法的参数说明信息\n@return ： 方法的返回值说明信息\n@see ： “参见” 用于指定交叉参考的内容\n@exception : 抛出异常的类型\n@throws : 抛出的异常，和@exception同意义 \n 重点  javadoc 工具默认不会提取 @author 和 @version 两个标记的信息，如果需要提取这两个标记的信息，应该在使用javadoc工具时指定 -author 和 -version 两个选项\n1javadoc -d apidoc -windowtitle 测试 -doctitle 学习javadoc工具的测试API文档 -header 我的类 -version -author *Test.java\n 例\n\ncodes/JavadocTest.java\n123456789101112131415161718192021222324/** * Description: * 网站: &lt;a href=\"https://www.baidu.com\"&gt;11&lt;/a&gt;&lt;br&gt; * Copyright (c),2021-2020,YE &lt;br&gt; * This program is protected by copyright laws. &lt;br&gt; * Program Name: &lt;br&gt; * Date: &lt;br&gt; * @author AutumnDx 2088809753@qq.com * @version 5.0 */public class JavadocTest &#123;\t/**\t * 简单测试成员变量\t */\tprotected String name;\t/**\t * 这是程序的入口函数\t * @param args 这是调用参数。。。。。。\t */\tpublic static void main(String[] args) &#123;\t\tSystem.out.print(\"Hello\");\t&#125;&#125;codes/Test.java\n12345678910111213141516171819202122/** * Description: * 网站: &lt;a href=\"https://www.baidu.com\"&gt;11&lt;/a&gt;&lt;br&gt; * Copyright (c),2021-2020,YE &lt;br&gt; * This program is protected by copyright laws. &lt;br&gt; * Program Name: &lt;br&gt; * Date: &lt;br&gt; * @author AutumnDx 2088809753@qq.com * @version 5.0 */public class Test &#123;    /**     * 简单测试成员变量     */    public int age;    /**     * Test类的测试构造器     */    public Test()&#123;            &#125;&#125;在命令行窗口执行命令，将JavadocTest.java 和 Test.java 程序生成API文档：\n1javadoc -d apidoc -windowtitle 测试 -doctitle 学习javadoc工具的测试API文档 -header 我的类 *Test.java关键字-标识符关键字（全部小写）：全部小写 idea有特殊颜色标记    public    class    static\n123456Java 语言目前定义了 51 个关键字，这些关键字不能作为变量名、类名和方法名来使用。以下对这些关键字进行了分类。数据类型：boolean、int、long、short、byte、float、double、char、class、interface。流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。保留字：true、false、null、goto、const。标识符：\n标识符由数字（09）和字母（AZ 和 a~z）、美元符号（$）、下划线（_）以及 Unicode 字符集中符号大于 0xC0 的所有符号组合构成（各符号之间没有空格）。\n标识符的第一个符号为字母、下划线和美元符号，后面可以是任何字母、数字、美元符号或下划线。\n12合法标识符：date、$2011、_date、D_$date 等。不合法的标识符：123.com、2com、for、if 等。命名法Java总体命名规范1、项目名全部小写.2、包名全部小写.3、类名首字母大写,其余组成词首字母依次大写.4、变量名,方法名首字母小写,如果名称由多个单词组成,除首字母外的每个单词的首字母都要大写.5、常量名全部大写.6、所有命名规则必须遵循以下规则 :\n名称只能由字母、数字、下划线、$符号组成.\n不能以数字开头.\n名称不能使用Java中的关键字.\n坚决不允许出现中文及拼音命名.\nJava包名命名规范  Java的包名由小写单词组成,包的路径符合所开发的系统模块的定义,以便通过包名可得知其属于哪个模块,从而方便到对应包里找相应的实现类.\n常规包名为了保障每个Java Package命名的唯一性,在Java编程规范中要求开发人员在自己定义的包名前加上唯一的前缀.由于互联网上的域名称是不会重复的,所以多数开发人员采用自己公司在互联网上的域名称作为自己程序包的唯一前缀.例如 : com.sun.swt…1.公司项目  com : 公司项目,copyright由项目发起的公司所有.\n1包名 : com.公司名.项目名.模块名..2.团队项目  team : 团队项目,指由团队发起,并由该团队开发的项目,copyright属于该团队所有.\n1包名 : team.团队名.项目名.模块名..自定义包名一般公司命名为com.公司名.项目名.模块名….那我们个人的项目又怎么命名呢?\n个人的英语单词有individual、personal、private、one-man,进一步对以上四个单词词意进行分析并在保证了唯一性,继而使用每个单词的前4个字母作为前缀,与com也做了区分.示例如下所示:\n1.indi : 个体项目,指个人发起,但非自己独自完成的项目,可公开或私有项目,copyright主要属于发起者.  \n包名 : indi.发起者名.项目名.模块名..\n2.pers : 个人项目,指个人发起,独自完成,可分享的项目,copyright主要属于个人.\n包名 : pers.个人名.项目名.模块名..\n3.priv : 私有项目,指个人发起,独自完成,非公开的私人使用的项目,copyright属于个人.\n包名 : priv.个人名.项目名.模块名..\n4.onem : 与indi相同，推荐使用indi.\n数据类型\n基本类型整型\n一般地整型变量默认为 int 类型；\n\nbyte：\nbyte 数据类型是8位、有符号的，以二进制补码表示的整数；\n最小值是 -128（-2^7）；\n最大值是 127（2^7-1）；\n默认值是 0；\nbyte 类型用在大型数组中节约空间，主要代替整数，因为 byte 变量占用的空间只有 int 类型的四分之一；\n例子：byte a = 100，byte b = -50。\nshort：\nshort 数据类型是 16 位、有符号的以二进制补码表示的整数\n最小值是 -32768（-2^15）；\n最大值是 32767（2^15 - 1）；\nShort 数据类型也可以像 byte 那样节省空间。一个short变量是int型变量所占空间的二分之一；\n默认值是 0；\n例子：short s = 1000，short r = -20000。\nint：\nint 数据类型是32位、有符号的以二进制补码表示的整数；\n最小值是 -2,147,483,648（-2^31）；\n最大值是 2,147,483,647（2^31 - 1）；\n一般地整型变量默认为 int 类型；\n默认值是 0 ；\n例子：int a = 100000, int b = -200000。\nlong：\nlong 数据类型是 64 位、有符号的以二进制补码表示的整数；\n最小值是 -9,223,372,036,854,775,808（-2^63）；\n最大值是 9,223,372,036,854,775,807（2^63 -1）；\n这种类型主要使用在需要比较大整数的系统上；\n默认值是 0L；\n例子： long a = 100000L，Long b = -200000L。“L”理论上不分大小写，但是若写成”l”容易与数字”1”混淆，不容易分辩。所以最好大写。\n12345678910111213public class Test &#123;    public static void main(String[] args)&#123;        //系统会自动把56当成byte类型处理        byte a = 56;        /*        下面代码是错误的，系统不会把99999999999999当成long类型处理        所以超出int的表数范围，从而引起错误        */        //long bigValue = 99999999999999;        //下面代码是正确的，在巨大的整数值后面使用L后缀，强制使用long类型        long bigValue2= 9223372036854775807L;    &#125;&#125;\n可以把一个较小的整数值（在int类型的表数范围以内）直接赋给一个long类型的变量，这并不是因为java会把这个较小的整数值当成long类型来处理，Java依然把这个整数值当成int类型来处理，只是因为int类型的值会自动类型转换到long类型\n\n二进制： 0b 0B\n八进制：0\n十六进制：0x 0X \n\n负数在计算机里是以补码的形式存在\n\n所有数字在计算机底层都是以二进制形式存在的，原码是直接将一个数值换算成二进制数。但计算机以补码的形式保存所有的整数。补码的计算规则：正数的补码和原码完全相同，负数的补码是其反码加1；反码是对原码按位取反，只是最高位（符号位）保持不变。\n12345678910111213public class Test&#123;    public static void main(String[] args)&#123;        //定义两个8位的二进制整数        int binVal1 = 0b11010100;        byte binVal2 = 0B01101001;        //定义一个32位的二进制整数，最高位是符号位        int binVal3 = 0B10000000000000000000000000000011;        System.out.println(binVal1); //输出212        System.out.println(binVal2); //输出105        System.out.println(binVal3); //输出-2147483645    &#125;&#125;\n字符型2字节 16位 \n三种表现形式\n直接通过单个字符来指定字符型值， &#39;A&#39;  &#39;0&#39; &#39;9&#39;\n通过转义字符表示特殊字符型值， \\n \\t\n直接使用 Unicode 值来表示字符型值， \\uXXXX XXXX代表一个十六进制的整数\nchar int 转换（1）int类型转char类型，将数字加一个‘0’，并强制类型转换为char即可。\n（2）char类型装int类型，将字符减一个‘0’即可。\n1234567891011public static void main(String[] args) &#123;    //int类型转char类型    int number = 9;    char cNumber= (char) (number+'0');    System.out.println(\"Number \"+number+\" to char is:\"+cNumber);    //char类型转int类型    char cNumber2='3';    int number2=cNumber2-'0';    System.out.println(\"Char \"+cNumber2+\" to number is:\"+number2);&#125;浮点型\n浮点数的默认类型为 double 类型；\n\n表示形式\n十进制数 ： 浮点数必须包含一个小数点，否则会被当成int类型处理\n科学计数法 ： 5.12e2（即5.12 x 10²）5.12E2\n\n 0.0除以0.0或对一个负数开方将得到一个非数 NaN 。 正无穷大数值都是相等的，负无穷大数值都是相等的，NaN不与任何数值相等，甚至和NaN都不相等\n只有浮点数除以0才可以得到正无穷大或负无穷大，因为Java语言会自动把和浮点数运算的0（整数）当成0.0（浮点数）处理。如果一个整数值除以0，则会抛出一个异常：ArithmeticException:/ by zero(除以零异常)\n\n123456789101112131415161718192021222324public class FloatTest&#123;\tpublic static void main(String[] args)\t&#123;\t\tfloat af = 5.2345556f;\t\t// 下面将看到af的值已经发生了改变\t\tSystem.out.println(af);\t\tdouble a = 0.0;\t\tdouble c = Double.NEGATIVE_INFINITY;\t\tfloat d = Float.NEGATIVE_INFINITY;\t\t// 看到float和double的负无穷大是相等的。\t\tSystem.out.println(c == d);\t\t// 0.0除以0.0将出现非数\t\tSystem.out.println(a / a);\t\t// 两个非数之间是不相等的\t\tSystem.out.println(a / a == Float.NaN);\t\t// 所有正无穷大都是相等的\t\tSystem.out.println(6.0 / 0 == 555.0/0);\t\t// 负数除以0.0得到负无穷大\t\tSystem.out.println(-8 / a);\t\t// 下面代码将抛出除以0的异常//\t\tSystem.out.println(0 / 0);\t&#125;&#125;float：\nfloat 数据类型是单精度、32位、符合IEEE 754标准的浮点数；\nfloat 在储存大型浮点数组的时候可节省内存空间；\n默认值是 0.0f；\n浮点数不能用来表示精确的值，如货币；\n例子：float f1 = 234.5f。\ndouble：\ndouble 数据类型是双精度、64 位、符合 IEEE 754 标准的浮点数；\n\n浮点数的默认类型为 double 类型；\n\ndouble类型同样不能表示精确的值，如货币；\n\n默认值是 0.0d；\n\n例子：\n12345double   d1  &#x3D; 7D ;double   d2  &#x3D; 7.; double   d3  &#x3D;  8.0; double   d4  &#x3D;  8.D; double   d5  &#x3D;  12.9867;7 是一个 int 字面量，而 7D，7. 和 8.0 是 double 字面量。\n\n布尔型boolean数据类型表示一位的信息；\n只有两个取值：true 和 false；\n这种类型只作为一种标志来记录 true/false 情况；\n默认值是 false；\n例子：boolean one = true。\n使用var定义变量使用var定义局部变量时，必须在定义局部变量的同时指定初始值\n12345678910111213class IntegerValTest &#123;    public static void main(String[] args) &#123;        var a = 20; // 被赋值20，因此a的类型是int        System.out.println(a);        // a = 1.6; 这行代码会报错，不兼容的类型        var b = 3.4; // 被赋值为3.4 类型是float        System.out.println(b);        var c = (byte) 13; //c的类型是byte        System.out.println(c);        // c=a ; // 这行会报错 不兼容的类型        // var d; //无法判断d的类型    &#125;&#125;引用类型空类型空引用 null 只能被转换成引用类型 ， 不能转换成基本类型，因此不要把一个 null 值赋给基本数据类型\nStringString类型的直接量不能赋给其他类型的变量，null类型的直接量可以直接赋给任何引用类型的变量\nJava通常使用常量池来缓存字符串直接量\n由于String类是一个典型的不可变类，因此String对象创建出来就不可能被改变，因此无需担心共享String对象对导致混乱\n常量池指的是在编译期被确定，并被保存在已编译的 .class 文件中的一些数据。它包括关于类、方法、接口中的常量，也包括字符串直接量\n数组数组也是一种引用类型。int是基本类型， int[] （一种定义数组的方式） 就是引用类型\n基本类型的类型转换自动类型转化12345678910111213141516171819public class AutoConversion&#123;\tpublic static void main(String[] args)\t&#123;\t\tint a  = 6;\t\t// int可以自动转换为float类型\t\tfloat f = a;\t\t// 下面将输出6.0\t\tSystem.out.println(f);\t\t// 定义一个byte类型的整数变量\t\tbyte b = 9;\t\t// 下面代码将出错，byte型不能自动类型转换为char型\t\t// char c = b;\t\t// 下面是byte型变量可以自动类型转换为double型\t\tdouble d = b;\t\t// 下面将输出9.0\t\tSystem.out.println(d);\t&#125;&#125;\n任何基本类型的值和字符串值进行连接运算时，基本类型的值都将自动转换为字符串类型，虽然字符串类型不是基本类型，而是引用类型\n\n1234567891011121314151617public class PrimitiveAndString&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 下面代码是错的，因为5是一个整数，不能直接赋给一个字符串\t\t// String str1 = 5;\t\t// 一个基本类型值和字符串进行连接运算时，基本类型值自动转换为字符串\t\tString str2 = 3.5f + \"\";\t\t// 下面输出3.5\t\tSystem.out.println(str2);\t\t// 下面语句输出7Hello!\t\tSystem.out.println(3 + 4 + \"Hello！\");\t\t// 下面语句输出Hello!34，因为Hello! + 3会把3当成字符串处理，\t\t// 而后再把4当成字符串处理\t\tSystem.out.println(\"Hello！\" + 3 + 4);\t&#125;&#125;强制类型转换(targetType)value\n12345678910111213141516public class NarrowConversion&#123;\tpublic static void main(String[] args)\t&#123;\t\tint iValue = 233;\t\t// 强制把一个int类型的值转换为byte类型的值\t\tbyte bValue = (byte)iValue;\t\t// 将输出-23\t\tSystem.out.println(bValue);\t\tdouble dValue = 3.98;\t\t// 强制把一个double类型的值转换为int\t\tint tol = (int)dValue;\t\t// 将输出3\t\tSystem.out.println(tol);\t&#125;&#125;\n临时生成的验证字符串 原理\n\n可以先随机生成一个在指定范围内的int数字（如果希望生成小写字母，就在97~122之间），然后将其强制类型转换成char类型，再将多次生成的字符串连缀起来即可\n123456789101112131415161718public class RandomStr&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 定义一个空字符串\t\tString result = \"\";\t\t// 进行6次循环\t\tfor(int i = 0 ; i &lt; 6 ; i ++)\t\t&#123;\t\t\t// 生成一个97～122的int型的整数\t\t\tint intVal = (int)(Math.random() * 26 + 97);\t\t\t// 将intValue强制转换为char后连接到result后面\t\t\tresult = result + (char)intVal;\t\t&#125;\t\t// 输出随机字符串\t\tSystem.out.println(result);\t&#125;&#125;123//直接把5.6赋值给float类型变量将出现错误，因为5.6默认是double类型float a = 5.6;float a = (float)5.6;\n通常情况下，字符串不能直接转换为基本类型，但通过基本类型对应的包装类则可以实现把字符串转换成基本类型\n\n1234String a = \"45\";//使用Integer的方法将一个字符串转换成int类型int iValue = Integer.parseInt(a);System.out.println(iValue);表达式类型的自动提升\n整个算术表达式的数据类型自动提升到与表达式中最高等级操作数相同的类型\n\n1234567891011121314151617181920212223242526272829public class AutoPromote&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 定义一个short类型变量\t\tshort sValue = 5;\t\t// 下面代码将出错：表达式中的sValue将自动提升到int类型，\t\t// 则右边的表达式类型为int，将一个int类型赋给short类型的变量将发生错误。\t\t// sValue = sValue - 2;\t\tbyte b = 40;\t\tchar c = 'a';\t\tint i = 23;\t\tdouble d = .314;\t\t// 右边表达式中在最高等级操作数为d（double型）\t\t// 则右边表达式的类型为double型,故赋给一个double型变量\t\tdouble result = b + c + i * d;\t\t// 将输出144.222\t\tSystem.out.println(result);\t\tint val = 3;\t\t// 右边表达式中2个操作数都是int，故右边表达式的类型为int\t\t// 因此，虽然23/3不能除尽，依然得到一个int整数\t\tint intResult = 23 / val;\t\tSystem.out.println(intResult); // 将输出7\t\t// 输出字符串Hello!a7\t\tSystem.out.println(\"Hello!\" + 'a' + 7);\t\t// 输出字符串104Hello!\t\tSystem.out.println('a' + 7 + \"Hello!\");\t&#125;&#125;运算符/123456789101112131415161718public class DivTest&#123;\tpublic static void main(String[] args)\t&#123;\t\tdouble a = 5.2;\t\tdouble b = 3.1;\t\tdouble div = a / b;\t\t// div的值将是1.6774193548387097\t\tSystem.out.println(div);\t\t// 输出正无穷大：Infinity\t\tSystem.out.println(\"5除以0.0的结果是:\" + 5 / 0.0);\t\t// 输出负无穷大：-Infinity\t\tSystem.out.println(\"-5除以0.0的结果是:\" + - 5 / 0.0);\t\t// 下面代码将出现异常\t\t// java.lang.ArithmeticException: / by zero\t\tSystem.out.println(\"-5除以0的结果是::\" + -5 / 0);\t&#125;&#125;%如果求余运算的两个操作数中有一个或者两个都是浮点数，则允许第二个操作数是0或0.0，求余运算的结果是非数:NaN 。\n0或0.0对零以外的任何数求余都将得到0或0.0。看如下程序。\n1234567891011121314151617public class ModTest&#123;\tpublic static void main(String[] args)\t&#123;\t\tdouble a = 5.2;\t\tdouble b = 3.1;\t\tdouble mod = a % b;\t\tSystem.out.println(mod); // mod的值为2.1\t\tSystem.out.println(\"5对0.0求余的结果是:\" + 5 % 0.0); // 输出非数:NaN\t\tSystem.out.println(\"-5.0对0求余的结果是:\" + -5.0 % 0); // 输出非数:NaN\t\tSystem.out.println(\"0对5.0求余的结果是:\" + 0 % 5.0); // 输出0.0\t\tSystem.out.println(\"0对0.0求余的结果是:\" + 0 % 0.0); // 输出非数:NaN\t\t// 下面代码将出现异常：java.lang.ArithmeticException: / by zero\t\tSystem.out.println(\"-5对0求余的结果是:\" + -5 % 0);\t&#125;&#125;\n提供其他更复杂的运算符，如果需要完成乘方、开方等运算，则可借助于java.lang.Math类\n\n12345678910111213141516171819public class MathTest&#123;\tpublic static void main(String[] args)\t&#123;\t\tdouble a = 3.2; // 定义变量a为3.2\t\t// 求a的5次方，并将计算结果赋为b。\t\tdouble b = Math.pow(a , 5);\t\tSystem.out.println(b); // 输出b的值。\t\t// 求a的平方根，并将结果赋给c\t\tdouble c = Math.sqrt(a);\t\tSystem.out.println(c); // 输出c的值。\t\t// 计算随机数,返回一个0～1之间的伪随机数。\t\tdouble d = Math.random();\t\tSystem.out.println(d); // 输出随机数d的值\t\t// 求1.57的sin函数值：1.57被当成弧度数\t\tdouble e = Math.sin(1.57);\t\tSystem.out.println(e); // 输出接近1\t&#125;&#125;位运算符&amp;: 按位与。当两位同时为1时才返回1。\n|: 按位或。只要有一位为1即可返回1。\n~: 按位非。单目运算符，将操作数的每个位（包括符号位）全部取反。\n^: 按位异或。当两位相同时返回0，不同时返回1。\n&lt;&lt;: 左移运算符。\n&gt;&gt;: 右移运算符。把第一个操作数的二进制码右移指定位数后，左边空出来的位以原来的符号位填充，即如果第一个操作数原来是正数，则左边补0; 如果第一个操作数是负数，则左边补1。\n\n&gt;&gt;&gt;: 无符号右移运算符 它把第一个操作数的二进制码右移指定位数后，左边空出来的位总是以0填充。\n\n进行移位运算时还要遵循如下规则。\n对于低于int类型（如 byte、short 和 char)的操作数总是先自动类型转换为int类型后再移位。\n对于int类型的整数移位a&gt;&gt;b，当b&gt;32时，系统先用b对32求余(因为int类型只有32位)，得到的结果才是真正移位的位数。例如，a&gt;&gt;33和 a&gt;&gt;1的结果完全一样，而a&gt;&gt;32的结果和a相同。\n对于long类型的整数移位 a&gt;&gt;b，当b&gt;64时，总是先用b对64求余(因为long类型是64位)，得到的结果才是真正移位的位数。\n123456789101112131415public class BitOperatorTest&#123;\tpublic static void main(String[] args)\t&#123;//\t\tSystem.out.println(2.5 &amp; 3.0);\t\tSystem.out.println(5 &amp; 9); // 将输出1\t\tSystem.out.println(5 | 9); // 将输出13\t\tSystem.out.println(~-5); // 将输出4\t\tSystem.out.println(5 ^ 9); // 将输出12\t\tSystem.out.println(5 &lt;&lt; 2); // 输出20\t\tSystem.out.println(-5 &lt;&lt; 2); // 输出-20\t\tSystem.out.println(-5 &gt;&gt; 2); // 输出-2\t\tSystem.out.println(-5 &gt;&gt;&gt; 2); // 输出1073741822\t&#125;&#125;扩展后的赋值运算符+-:对于x+=y，即对应于x=x+y。\n-=:对于x-=y，即对应于x=X-y。\n*=:对于x*=y，即对应于x=x * y。\n/=:对于x/=y，即对应于x=x / y。\n%=:对于x%=y，即对应于x=x % y\n&amp;=:对于x&amp;=y，即对应于x=x &amp; y。\n|=:对于x|=y，即对应于x=x | y。\n^=:对于x^=y，即对应于x=x^y。\n&lt;&lt;=:对于x&lt;&lt;=y，即对应于x=x &lt;&lt;y。\n&gt;&gt;=:对于x &gt;&gt;=y，即对应于x=x &gt;&gt;y。\n&gt;&gt;&gt;=:对于x &gt;&gt;&gt;=y，即对应于x=x &gt;&gt;&gt; y。\n\n只要能使用这种扩展后的赋值运算符,通常都推荐使用它们。因为这种运算符不仅具有更好的性能,而且程序会更加健壮。\n\n123456789101112131415public class EnhanceAssignTest&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 定义一个byte类型的变量\t\tbyte a = 5;\t\t// 下面语句出错，因为5默认是int类型，a + 5就是int类型。\t\t// 把int类型赋给byte类型的变量，所以出错\t\t// a = a + 5;\t\t// 定义一个byte类型的变量\t\tbyte b = 5;\t\t// 下面语句不会出现错误\t\tb += 5;\t&#125;&#125;比较运算符==： 只要他们的值相等，也都将返回true\n\n基本类型的变量、值不能和引用类型的变量、值使用==进行比较;\n boolean类型的变量、值不能与其他任意类型的变量、值使用==进行比较;\n如果两个引用类型之间没有父子继承关系，那么它们的变量也不能使用==进行比较。\n\n1234567891011121314151617181920public class ComparableOperatorTest&#123;\tpublic static void main(String[] args)\t&#123;\t\tSystem.out.println(\"5是否大于 4.0：\" + (5 &gt; 4.0)); // 输出true\t\tSystem.out.println(\"5和5.0是否相等：\" + (5 == 5.0)); // 输出true\t\tSystem.out.println(\"97和'a'是否相等：\" + (97 == 'a')); // 输出true\t\tSystem.out.println(\"true和false是否相等：\" + (true == false)); // 输出false\t\t// 创建2个ComparableOperatorTest对象，分别赋给t1和t2两个引用\t\tComparableOperatorTest t1 = new ComparableOperatorTest();\t\tComparableOperatorTest t2 = new ComparableOperatorTest();\t\t// t1和t2是同一个类的两个实例的引用，所以可以比较，\t\t// 但t1和t2引用不同的对象，所以返回false\t\tSystem.out.println(\"t1是否等于t2：\" + (t1 == t2));\t\t// 直接将t1的值赋给t3，即让t3指向t1指向的对象\t\tComparableOperatorTest t3 = t1;\t\t// t1和t3指向同一个对象，所以返回true\t\tSystem.out.println(\"t1是否等于t3：\" + (t1 == t3));\t&#125;&#125;逻辑运算符&amp;&amp;: 与，前后两个操作数必须都是true才返回true，否则返回 false.\n&amp;: 不短路与，作用与&amp;&amp;相同，但不会短路。\n||: 或，只要两个操作数中有一个是true，就可以返回true，否则返回 false。如果第一个操作数返回true，将不再对第二个操作数求值，直接返回true\n\n|: 不短路或，作用与||相同，但不会短路。\n!: 非，只需要一个操作数，如果操作数为true，则返回false;如果操作数为 false，则返回 true\n^: 异或，当两个操作数不同时才返回true，如果两个操作数相同则返回 false。\n1234567891011121314151617181920212223242526272829303132333435public class LogicOperatorTest&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 直接对false求非运算，将返回true\t\tSystem.out.println(!false);\t\t// 5&gt;3返回true，'6'转换为整数54，'6'&gt;10返回true，求与后返回true\t\tSystem.out.println(5 &gt; 3 &amp;&amp; '6' &gt; 10);\t\t// 4&gt;=5返回false，'c'&gt;'a'返回true。求或后返回true\t\tSystem.out.println(4 &gt;= 5 || 'c' &gt; 'a');\t\t// 4&gt;=5返回false，'c'&gt;'a'返回true。两个不同的操作数求异或返回true\t\tSystem.out.println(4 &gt;= 5 ^ 'c' &gt; 'a');\t\t// 定义变量a,b，并为两个变量赋值\t\tint a = 5;\t\tint b = 10;\t\t// 对a &gt; 4和b++ &gt; 10求或运算\t\tif (a &gt; 4 | b++ &gt; 10)\t\t&#123;\t\t\t// 输出a的值是5，b的值是11。\t\t\tSystem.out.println(\"a的值是:\" + a + \"，b的值是:\" + b);\t\t&#125;\t\t// 定义变量c,d，并为两个变量赋值\t\tint c = 5;\t\tint d = 10;\t\t// c &gt; 4 || d++ &gt; 10求或运算\t\tif (c &gt; 4 || d++ &gt; 10)\t\t&#123;\t\t\t// 输出c的值是5，d的值是10。\t\t\tSystem.out.println(\"c的值是:\" + c + \"，d的值是:\" + d);\t\t&#125;\t&#125;&#125;三目运算符三目运算符和 if else写法的区别在于: if后的代码块可以有多个语句，但三目运算符是不支持多个语句的。\n1(expression)? if-true-statement : if-false-statement;idea123456快速生成main()方法：psvm快速生成输出语句：sout内容提示 代码补全：Ctrl+Alt+Space格式化：Ctrl+Alt+L快速设置左侧变量：Ctrl+Alt+V生成代码：command + n流程控制与数组顺序控制if123456789if(布尔表达式 1)&#123;   //如果布尔表达式 1的值为true执行代码&#125;else if(布尔表达式 2)&#123;   //如果布尔表达式 2的值为true执行代码&#125;else if(布尔表达式 3)&#123;   //如果布尔表达式 3的值为true执行代码&#125;else &#123;   //如果以上布尔表达式都不为true执行代码&#125;switch\n使用switch语句时,有两个值得注意的地方:\n第一个地方是switch语句后的expression表达式的数据类型只能是byte、short、char、int 四种整数类型，String (从Java 7开始支持）和枚举类型;\n第二个地方是如果省略了case后代码块的break;，将引入一个陷阱。\n\n1234567891011121314switch (expression) &#123;    case value: &#123;        // 语句        break; // 可选    &#125;    case value: &#123;        // 语句        break; // 可选    &#125;    default: // 可选    &#123;        // 语句    &#125;&#125;\n 和if语句不同的是，switch语句中各case标签后代码块的开始点和结束点非常清晰，因此完全可以省略case后代码块的花括号\n\n1234567891011121314151617181920212223242526272829public class SwitchTest&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 声明变量score，并为其赋值为'C'\t\tchar score = 'C';\t\t// 执行swicth分支语句\t\tswitch (score)\t\t&#123;\t\t\tcase 'A':\t\t\t\tSystem.out.println(\"优秀\");\t\t\t\tbreak;\t\t\tcase 'B':\t\t\t\tSystem.out.println(\"良好\");\t\t\t\tbreak;\t\t\tcase 'C':\t\t\t\tSystem.out.println(\"中\");\t\t\t\tbreak;\t\t\tcase 'D':\t\t\t\tSystem.out.println(\"及格\");\t\t\t\tbreak;\t\t\tcase 'F':\t\t\t\tSystem.out.println(\"不及格\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tSystem.out.println(\"成绩输入错误\");\t\t&#125;\t&#125;&#125;Java 11编译器做了一些改进，如果开发者忘记了case块后面的 break语句，Java 11编译器会生成警告:“[falthrough]可能无法实现 case”。这个警告以前需要为javac指定-X:fallthrough选项才能显示出来。\n从Java 7开始增强了switch语句的功能，允许switch语句的控制表达式是java.lang.String类型的变量或表达式——只能是java.lang.String类型,不能是StringBuffer或StringBuilder这两种字符串类型。\n1234567891011121314151617181920212223242526public class StringSwitchTest&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 声明变量season\t\tString season = \"夏天\";\t\t// 执行swicth分支语句\t\tswitch (season)\t\t&#123;\t\t\tcase \"春天\":\t\t\t\tSystem.out.println(\"春暖花开.\");\t\t\t\tbreak;\t\t\tcase \"夏天\":\t\t\t\tSystem.out.println(\"夏日炎炎.\");\t\t\t\tbreak;\t\t\tcase \"秋天\":\t\t\t\tSystem.out.println(\"秋高气爽.\");\t\t\t\tbreak;\t\t\tcase \"冬天\":\t\t\t\tSystem.out.println(\"冬雪皑皑.\");\t\t\t\tbreak;\t\t\tdefault:\t\t\t\tSystem.out.println(\"季节输入错误\");\t\t&#125;\t&#125;&#125;while - do while\n如果省略了循环体的花括号，那么while循环条件仅控制到紧跟该循环条件的第一个分号处。\n\ndo while循环与while循环的区别在于: while循环是先判断循环条件,如果条件为真则执行循环体;而do while循环则先执行循环体，然后才判断循环条件，如果循环条件为真，则执行下一次循环，否则终止循环。\n123456789101112131415161718192021222324252627282930313233343536373839// 循环的初始化条件int count = 0;// 当count小于10时，执行循环体while (count &lt; 10) &#123;    System.out.println(count);    // 迭代语句    count++;&#125;System.out.println(\"循环结束!\");--------------------------------------------------------int count = 0;// while后紧跟一个分号，表明循环体是一个分号（空语句）while (count &lt; 10);// 下面的代码块与while循环已经没有任何关系&#123;    System.out.println(\"------\" + count);    count++;&#125;--------------------------------------------------------// 定义变量countint count = 1;// 执行do while循环do&#123;    System.out.println(count);    // 循环迭代语句    count++;    // 循环条件紧跟while关键字&#125;while (count &lt; 10);System.out.println(\"循环结束!\");// 定义变量count2int count2 = 20;// 执行do while循环do    // 这行代码把循环体和迭代部分合并成了一行代码    System.out.println(count2++);while (count2 &lt; 10);System.out.println(\"循环结束!\");forfor循环和while、do while循环不一样:由于while、do while循环的循环迭代语句紧跟着循环体，因此如果循环体不能完全执行，如使用continue语句来结束本次循环，则循环迭代语句不会被执行。但for 循环的循环迭代语句并没有与循环体放在一起，因此不管是否使用continue语句来结束本次循环，循环迭代语句一样会获得执行。\n123456// 循环的初始化条件,循环条件，循环迭代语句都在下面一行for (int count = 0 ; count &lt; 10 ; count++)&#123;    System.out.println(count);&#125;System.out.println(\"循环结束!\");\n建议不要在循环体内修改循环变量(也叫循环计数器)的值，否则会增加程序出错的可能性。万一程序真的需要访问、修改循环变量的值，建议重新定义一个临时变量，先将循环变量的值赋给临时变量，然后对临时变量的值进行修改。\n\nbreak - continuebreak语句不仅可以结束其所在的循环，还可以直接结束其外层循环。此时需要在 break后紧跟-个标签，这个标签用于标识一个外层循环。\n123456789101112131415161718192021222324public class BreakTest2&#123;\tpublic static void main(String[] args)\t&#123;\t\t// 外层循环，outer作为标识符\t\touter:\t\tfor (int i = 0 ; i &lt; 5 ; i++ )\t\t&#123;\t\t\t// 内层循环\t\t\tfor (int j = 0; j &lt; 3 ; j++ )\t\t\t&#123;\t\t\t\tSystem.out.println(\"i的值为:\" + i + \"  j的值为:\" + j);\t\t\t\tif (j == 1)\t\t\t\t&#123;\t\t\t\t\t// 跳出outer标签所标识的循环。\t\t\t\t\tbreak outer;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;\t&#125;&#125;---------------------- 结果 ----------------------------i的值为:0  j的值为: 0i的值为:0  j的值为: 1程序从外层循环进入内层循环后，当j等于1时，程序遇到一个break outer;语句，这行代码将会导致结束outer标签指定的循环，不是结束break所在的循环，而是结束break循环的外层循环。所以看到上面的运行结果。\n\n通常紧跟 break之后的标签，必须在 break所在循环的外层循环之前定义才有意义。\n\n与break类似的是，continue后也可以紧跟一个标签，用于直接跳过标签所标识循环的当次循环的剩下语句，重新开始下一次循环。例如下面代码。\n123456789101112131415// 外层循环outer:for (int i = 0 ; i &lt; 5 ; i++ )&#123;    // 内层循环    for (int j = 0; j &lt; 3 ; j++ )    &#123;        System.out.println(\"i的值为:\" + i + \"  j的值为:\" + j);        if (j == 1)        &#123;            // 忽略outer标签所指定的循环中本次循环所剩下语句。            continue outer;        &#125;    &#125;&#125;运行上面程序可以看到，循环变量j的值将无法超过1，因为每当j等于1时，continue outer;语句就结束了外层循环的当次循环，直接开始下一次循环，内层循环没有机会执行完成。\nreturn 关键字并不是专门用于结束循环的，return的功能是结束一个方法。当一个方法执行到一个return 语句时(return关键字后还可以跟变量、常量和表达式，这将在方法介绍中有更详细的解释)，这个方法将被结束。\nJava程序中大部分循环都被放在方法中执行，例如前面介绍的所有循环示范程序。一旦在循环体内执行到一个return语句，return 语句就会结束该方法，循环自然也随之结束。例如下面程序。\n12345678910// 一个简单的for循环for (int i = 0; i &lt; 3 ; i++ )&#123;    System.out.println(\"i的值是\" + i);    if (i == 1)    &#123;        return;    &#125;    System.out.println(\"return后的输出语句\");&#125;数组一个数组里只能存储一种数据类型的数据，而不能存储多种数据类型的数据。\n\n因为Java 语言是面向对象的语言，而类与类之间可以支持继承关系，这样可能产生一个数组里可以存放多种数据类型的假象。例如有一个水果数组，要求每个数组元素都是水果，实际上数组元素既可以是苹果，也可以是香蕉（苹果、香蕉都继承了水果，都是一种特殊的水果)，但这个数组的数组元素的类型还是唯一的，只能是水果类型。\n\n一旦数组的初始化完成，数组在内存中所占的空间将被固定下来，因此数组的长度将不可改变。即使把某个数组元素的数据清空，但它所占的空间依然被保留，依然属于该数组，数组的长度依然不变。\n12345数据类型[] 变量名;int[] arr;\t//定义了一个int类型数组，数组名是arr 推荐！！！！数据类型 变量名[];int arr[];\t//定义了一个int类型的变量，变量名是arr数组初始化一旦为数组的每个数组元素分配了内存空间，每个内存空间里存储的内容就是该数组元素的值，即使这个内存空间存储的内容是空，这个空也是一个值（ null )。不管以哪种方式来初始化数组，只要为数组元素分配了内存空间，数组元素就具有了初始值。\n静态初始化:初始化时由程序员显式指定每个数组元素的初始值，由系统决定数组长度。\n动态初始化:初始化时程序员只指定数组长度，由系统为数组元素分配初始值。\n\n基本类型初始值\n\nbyte  short  int  long0\n\nfloat double0.0\n\nchar\\u0000\n\nbooleanfalse\n\n引用类型（类、接口、数组）null\n\n不要同时使用静态初始化和动态初始化，也就是说，不要在进行数组初始化时，既指定数组的长度，也为每个数组元素分配初始值。\n\n123456789int[] arr = new int[]&#123;1,2,3&#125;; //静态初始化int[] arr = &#123;1,2,3&#125;; //静态初始化 简化写法----------------------------------------------int[] prices = new int[5];//动态初始化Object[] books = new String[4];----------------------------------------------使用静态初始化简化语法执行初始化 数组不能使用var定义数组变量var names = new String[]&#123;\"yeeku\",\"none\"&#125;;var weightArr = new double[4];获取数组长度12数组名.lengtharr.lengthforeach循环使用 foreach循环遍历数组和集合元素时，无须获得数组和集合长度，无须根据索引来访问数组元素和集合元素，foreach循环自动遍历数组和集合的每个元素。\n123456789101112131415String[] books = &#123;\"轻量级Java EE企业应用实战\" ,\t\t\"疯狂Java讲义\",\t\t\"疯狂Android讲义\"&#125;;\t\t// 使用foreach循环来遍历数组元素，其中book将会自动迭代每个数组元素\t\tfor (String book : books)\t\t&#123;\t\t\tbook = \"疯狂Ajax讲义\";\t\t\tSystem.out.println(book);\t\t&#125;\t\tSystem.out.println(books[0]);----------------------------------------------疯狂Ajax讲义疯狂Ajax讲义疯狂Ajax讲义轻量级Java EE企业应用实战在上面语法格式中，String是数组元素或集合元素的类型，或者直接使用var定义，book是一个形参名，foreach循环将自动将数组元素、集合元素依次赋给该变量。\n\n使用foreach循环迭代数组元素时，并不能改变数组元素的值，因此不要对foreach的循环变量进行赋值\n\n不难看出，当使用foreach来迭代访问数组元素时，foreach中的循环变量相当于一个临时变量，系统会把数组元素依次赋给这个临时变量，而这个临时变量并不是数组元素，它只是保存了数组元素的值。因此，如果希望改变数组元素的值，则不能使用这种foreach循环。\n多维数组1234567891011121314151617181920212223242526272829// 定义一个二维数组int[][] a;// 把a当成一维数组进行初始化，初始化a是一个长度为4的数组// a数组的数组元素又是引用类型a = new int[4][];// 把a数组当成一维数组，遍历a数组的每个数组元素for (int i = 0 , len = a.length; i &lt; len ; i++ )&#123;    System.out.println(a[i]);&#125;// 初始化a数组的第一个元素a[0] = new int[2];// 访问a数组的第一个元素所指数组的第二个元素a[0][1] = 6;// a数组的第一个元素是一个一维数组，遍历这个一维数组for (int i = 0 , len = a[0].length ; i &lt; len ; i ++ )&#123;    System.out.println(a[0][i]);&#125;------------------------------------------------------------------------------------// 同时初始化二维数组的2个维数int[][] b = new int[3][4];// 使用静态初始化的语法来初始化一个二维数组String[][] str1 = new String[][]&#123;new String[3], new String[]&#123;\"hello\"&#125;&#125;;// 使用简化的静态初始化语法来初始化二维数组String[][] str2 = &#123;new String[3], new String[]&#123;\"hello\"&#125;&#125;;System.out.println(str1[1][0]);System.out.println(str2[1][0]);操作数组的工具类：Arrays\nArrays类处于 java.util包下，为了在程序中使用 Arrays类，必须在程序中导入java.util.Arrays类。\n\nint binarySearch(type[] a, type key):使用二分法查询key元素值在a数组中出现的索引;如果a数组不包含 key元素值，则返回负数。调用该方法时要求数组中元素已经按升序排列，这样才能得到正确结果。\nint binarySearch(type[] a, int fromIndex, int toIndex, type key):这个方法与前一个方法类似，但它只搜索a数组中 fromIndex到 toIndex索引的元素。调用该方法时要求数组中元素已经按升序排列，这样才能得到正确结果。\ntype[]copyOf(type[] original, int length):这个方法将会把 original数组复制成一个新数组，其中length是新数组的长度。如果 length小于original数组的长度,则新数组就是原数组的前面length个元素;如果length大于original 数组的长度，则新数组的前面元素就是原数组的所有元素，后面补充0（数值类型)、false（布尔类型）或者null（引用类型)。\ntype[]copyOfRange(type[]original, int from, int to):这个方法与前面方法相似，但这个方法只复制original 数组的from索引到to索引的元素。\nboolean equals(type[] a, type]a2):如果a数组和a2数组的长度相等，而且 a数组和a2数组的数组元素也一一相同，该方法将返回true。比较相同\nvoid fill(type[] a, type val):该方法将会把a数组的所有元素都赋值为val。\nvoid fill(type[] a, int fromIndex, int toIndex, type val):该方法与前一个方法的作用相同，区别只是该方法仅仅将a数组的fromIndex到 toIndex索引的数组元素赋值为val。\nvoid sort(type[]a):该方法对a数组的数组元素进行排序。\nvoid sort(type[]a，int fromIndex，int toIndex):该方法与前一个方法相似，区别是该方法仅仅对fromIndex到toIndex索引的元素进行排序。\nString toString(type[] a):该方法将一个数组转换成一个字符串。该方法按顺序把多个数组元素连缀在一起,多个数组元素使用英文逗号(,）和空格隔开。\n\nJava8 增强了Arrays 类的功能\n\nvoid parallelPrefix(xxx[]array，XxxBinaryOperator op):该方法使用op参数指定的计算公式计算得到的结果作为新的数组元素。op计算公式包括left、right两个形参，其中 left 代表新数组中前一个索引处的元素, right代表array数组中当前索引处的元素。新数组的第一个元素无须计算，直接等于array数组的第一个元素。\nvoid parallelPrefix(xxx[] array, int fromIndex, int toIndex,XxxBinaryOperator op):该方法与上一个方法相似，区别是该方法仅重新计算fromIndex到 toIndex索引的元素。\nvoid setAll(xxx[]array, IntToXxxFunction generator):该方法使用指定的生成器( generator)为所有数组元素设置值，该生成器控制数组元素的值的生成算法。\nvoid parallelSetAll(xxx[ array, IntToXxxFunction generator):该方法的功能与上一个方法相同，只是该方法增加了并行能力，可以利用多CPU 并行来提高性能。\nvoid parallelSort(xxx[] a):该方法的功能与Arrays类以前就有的 sort()方法相似，只是该方法增加了并行能力,可以利用多 CPU 并行来提高性能。\nvoid parallelSort(xxx[] a, int fromIndex, int toIndex):该方法与上一个方法相似，区别是该方法仅对fromlndex到toIndex索引的元素进行排序。\nSpliterator.OfXxx spliterator(xxx[] array):将该数组的所有元素转换成对应的Spliterator对象。\nSpliterator.OfXxx spliterator(xxx[] array, int startInclusive, int endExclusive):该方法与上一个方法相似，区别是该方法仅转换startInclusive到 endExclusive索引的元素。\nXxxStream stream(xxx[]array):该方法将数组转换为Stream，Stream是Java 8新增的流式编程的API。\nXxxStream stream(xxx[] array, int startInclusive, int endExclusive):该方法与上一个方法相似，区别是该方法仅将fromIndex到tolndex索引的元素转换为Streamo\n12345678910111213141516171819// 定义一个a数组int[] a = new int[] &#123; 3, 4, 5, 6 &#125;;// 定义一个a2数组int[] a2 = new int[] &#123; 3, 4, 5, 6 &#125;;// a数组和a2数组的长度相等，每个元素依次相等，将输出trueSystem.out.println(\"a数组和a2数组是否相等：\"+ Arrays.equals(a, a2));// 通过复制a数组，生成一个新的b数组int[] b = Arrays.copyOf(a, 6);System.out.println(\"a数组和b数组是否相等：\" + Arrays.equals(a, b));// 输出b数组的元素，将输出[3, 4, 5, 6, 0, 0]System.out.println(\"b数组的元素为：\" + Arrays.toString(b));// 将b数组的第3个元素（包括）到第5个元素（不包括）赋为1Arrays.fill(b, 2, 4, 1);// 输出b数组的元素，将输出[3, 4, 1, 1, 0, 0]System.out.println(\"b数组的元素为：\" + Arrays.toString(b));// 对b数组进行排序Arrays.sort(b);// 输出b数组的元素，将输出[0, 0, 1, 1, 3, 4]System.out.println(\"b数组的元素为：\" + Arrays.toString(b));原理数组引用变量只是一个引用，这个引用变量可以指向任何有效的内存，只有当该引用指向有效内存后，才可通过该数组变量来访问数组元素。\n实际的数组对象被存储在堆( heap)内存中;如果引用该数组对象的数组引用变量是一个局部变量,那么它被存储在栈（ stack）内存中。\n\n 为什么会有栈内存和堆内存？\n\n答:当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁。因此，所有在方法中定义的局部变量都是放在栈内存中的;在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大)，这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(在方法的参数传递时很常见)，则这个对象依然不会被销毁。只有当一个对象没有任何引用变量引用它时，系统的垃圾回收器才会在合适的时候回收它。\n只要类型相互兼容，就可以让一个数组变量指向另一个实际的数组，这种操作会让人产生数组的长度可变的错觉。如下代码所示。\n123456789101112131415161718192021// 定义并初始化数组，使用静态初始化int[] a = &#123;5, 7 , 20&#125;;// 定义并初始化数组，使用动态初始化int[] b = new int[4];// 输出b数组的长度System.out.println(\"b数组的长度为：\" + b.length);// 循环输出a数组的元素for (int i = 0 ,len = a.length; i &lt; len ; i++ )&#123;    System.out.println(a[i]);&#125;// 循环输出b数组的元素for (int i = 0 , len = b.length; i &lt; len ; i++ )&#123;    System.out.println(b[i]);&#125;// 因为a是int[]类型，b也是int[]类型，所以可以将a的值赋给b。// 也就是让b引用指向a引用指向的数组b = a;// 再次输出b数组的长度System.out.println(\"b数组的长度为：\" + b.length);应用举例\n 将一个浮点数转换成人民币读法字符串\n\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import java.util.Arrays;/** * Description: * 网站: &lt;a href=\"http://www.crazyit.org\"&gt;疯狂Java联盟&lt;/a&gt;&lt;br&gt; * Copyright (C), 2001-2018, Yeeku.H.Lee&lt;br&gt; * This program is protected by copyright laws.&lt;br&gt; * Program Name:&lt;br&gt; * Date:&lt;br&gt; * @author Yeeku.H.Lee kongyeeku@163.com * @version 1.0 */public class Num2Rmb&#123;\tprivate String[] hanArr = &#123;\"零\" , \"壹\" , \"贰\" , \"叁\" , \"肆\" ,\t\t\"伍\" , \"陆\" , \"柒\" , \"捌\" , \"玖\"&#125;;\tprivate String[] unitArr = &#123;\"十\" , \"百\" , \"千\"&#125;;\t/**\t * 把一个浮点数分解成整数部分和小数部分字符串\t * @param num 需要被分解的浮点数\t * @return 分解出来的整数部分和小数部分。第一个数组元素是整数部分，第二个数组元素是小数部分。\t */\tprivate String[] divide(double num)\t&#123;\t\t// 将一个浮点数强制类型转换为long，即得到它的整数部分\t\tlong zheng = (long)num;\t\t// 浮点数减去整数部分，得到小数部分，小数部分乘以100后再取整得到2位小数\t\tlong xiao = Math.round((num - zheng) * 100);\t\t// 下面用了2种方法把整数转换为字符串\t\treturn new String[]&#123;zheng + \"\", String.valueOf(xiao)&#125;;\t&#125;\t/**\t * 把一个四位的数字字符串变成汉字字符串\t * @param numStr 需要被转换的四位的数字字符串\t * @return 四位的数字字符串被转换成的汉字字符串。\t */\tprivate String toHanStr(String numStr)\t&#123;\t\tString result = \"\";\t\tint numLen = numStr.length();\t\t// 依次遍历数字字符串的每一位数字\t\tfor (int i = 0 ; i &lt; numLen ; i++ )\t\t&#123;\t\t\t// 把char型数字转换成的int型数字，因为它们的ASCII码值恰好相差48\t\t\t// 因此把char型数字减去48得到int型数字，例如'4'被转换成4。\t\t\tint num = numStr.charAt(i) - 48;\t\t\t// 如果不是最后一位数字，而且数字不是零，则需要添加单位（千、百、十）\t\t\tif ( i != numLen - 1 &amp;&amp; num != 0)\t\t\t&#123;\t\t\t\tresult += hanArr[num] + unitArr[numLen - 2 - i];\t\t\t&#125;\t\t\t// 否则不要添加单位\t\t\telse\t\t\t&#123;\t\t\t\tresult += hanArr[num];\t\t\t&#125;\t\t&#125;\t\treturn result;\t&#125;    public static void main(String[] args)    &#123;\t\tNum2Rmb nr = new Num2Rmb();\t\t// 测试把一个浮点数分解成整数部分和小数部分\t\tSystem.out.println(Arrays.toString(nr.divide(236711125.123)));\t\t// 测试把一个四位的数字字符串变成汉字字符串\t\tSystem.out.println(nr.toHanStr(\"609\"));    &#125;&#125;面向对象类 class如果定义了一个public类，则该源文件的主文件名必须与该public类的类名相同\n类object是类层次结构的根。每个类都有objpct作为超类。所有对象 (包括数组)都实现了这个类的方法。\nobject要么是其他类的父类 ，要么是其他类（有继承关系的类）的超类\n标准类制作(构造器、成员变量、方法)\n成员变量 private修饰  用来封装\n构造方法 （有参、无参）\n成员方法 public修饰为成员变量提供 setXX() getXX() \n提供一个显示对象信息的show()\n\n类里各成员之间的定义顺序没有任何影响，各成员之间可以相互调用，但需要指出的是，static修饰的成员不能访问没有static修饰的成员。\nJava语言提供了一个功能:如果程序员没有为一个类编写构造器，则系统会为该类提供一个默认的构造器。一旦程序员为一个类提供了构造器，系统将不再为该类提供构造器。\n123456789修饰符 class 类名 &#123;\t//成员变量 （属性）    数据类型 变量1;    ····    //成员方法（行为）   \t方法1;    方法2;    ····&#125;变量成员变量：类中，方法外的变量\n局部变量：方法内 \n123456789101112public class Student&#123;    String name;    //成员变量    public void study()&#123;        int i=0;    //局部变量        System.out.println(\"好好学习\");    &#125;    public void doHomework()&#123;        System.out.println(\"多做练习\");        int j = 0;  //局部变量    &#125;    int age;    //成员变量&#125;成员变量1[修饰符] 类型 成员变量名 [= 默认值]修饰符:修饰符可以省略,也可以是public、 protected ,private 、static、 final,前三个最多只能出现其中之一，可以与static、final组合起来修饰成员变量。\n类型:类型可以是Java语言允许的任何数据类型，包括基本类型和现在介绍的引用类型。\n成员变量名:成员变量名只要是一个合法的标识符即可，第一个单词首字母小写，后面每个单词首字母大写\n默认值:定义成员变量还可以指定一个可选的默认值。\n\n 成员变量由英文单词field意译而来，早期有些书籍将成员变量称为属性。但实际上在Java世界里属性（由 property翻译而来）指的是一组setter方法和getter方法。\n比如说某个类有age属性，意味着该类包含setAge()和getAge()两个方法。另外，也有些资料、书籍将field翻译为字段、域。\n\n局部变量方法12345[修饰符] 方法返回值类型 方法名(类型列表)&#123;\t方法体;\treturn 数据;&#125;static修饰的成员表明它属于这个类本身,而不属于该类的单个实例,通常把 static修饰的成员变量和方法也称为类变量、类方法。\n不使用static修饰的普通方法,成员变量则属于该类的单个实例,而不属于该类。因为通常把不使用static修饰的成员变量和方法也称为实例变量、实例方法。有时也把 static修饰的成员变量和方法称为静态变量和静态方法，把不使用static修饰的成员变量和方法称为非静态变量和非静态方法。静态成员不能直接访问非静态成员。\n\n虽然绝大部分资料都喜欢把static称为静态，但实际上这种说法很模糊，完全无法说明static的真正作用。static的真正作用就是用于区分成员变量、方法、内部类、初始化块(本书后面会介绍后两种成员）这四种成员到底属于类本身还是属于实例。在类中定义的成员，static相当于一个标志，有static修饰的成员属于类本身，没有static修饰的成员属于该类的实例。\n\n形参：方法中定义的参数，int number\n实参：方法中调用的参数，10、number\n方法重载多个方法在同一个类中\n多个方法具有相同的方法名\n多个方法的参数不相同，类型不相或者数量不同\n1234567891011121314151617class MyClass &#123;    int height;    MyClass() &#123;        System.out.println(\"无参数构造函数\");        height = 4;    &#125;    MyClass(int i) &#123;        System.out.println(\"房子高度为 \" + i + \" 米\");        height = i;    &#125;    void info() &#123;        System.out.println(\"房子高度为 \" + height + \" 米\");    &#125;    void info(String s) &#123;        System.out.println(s + \": 房子高度为 \" + height + \" 米\");    &#125;&#125;形参的改变 不影响外部实参的值\n123456789101112public class HelloWorld &#123;    public static int number(int number) &#123;        number = 200; //形参的改变 不影响外部实参的值    &#125;    public static void main(String[] args) &#123;        int number = 100;        System.out.println(\"调用函数前\" + number);        number(number);        System.out.println(\"调用函数后\" + number);    &#125;&#125;123输出：100100构造方法(构造器)如果没有定义构造方法，系统默认给出构造方法\n如果定义了构造方法，系统不再提供无参构造方法\n12345public class 类名 &#123;    修饰符 类名() &#123;&#125;\t//无参构造方法    修饰符 类名(参数1) &#123;&#125;\t//有参构造方法    修饰符 类名(参数1,参数2) &#123;&#125;&#125;构造器1234[修饰符] 构造器名(形参列表)&#123;\t执行体&#125;修饰符：可省略，也可以是 public protected private \n构造器名：构造器名必须和类名相同\n构造器不能定义返回值类型，也不能使用void声明构造器没有返回值\n\n 不要在构造器里显式使用return来返回当前类的对象，因为构造器的返回值是隐式的。\n\n对象创建对象的根本途径是构造器，通过new关键字来调用某个类的构造器即可创建这个类的实例。\n12Person p = new Person();var p = new Person();123456789//使用Person类定义一个Person类型的变量Person p;//通过new关键字调用Person类的构造器，返回一个Person实例//将该Person实例赋给p变量p = new Person();//使用成员变量p.brand//使用成员方法p.call();static修饰的方法和成员变量，既可通过类来调用，也可通过实例来调用;\n没有使用static修饰的普通方法和成员变量，只可通过实例来调用。\n1234567// 访问p的name实例变量，直接为该变量赋值。p.name = \"李刚\";// 调用p的say方法，声明say()方法时定义了一个形参，// 调用该方法必须为形参指定一个值p.say(\"Java语言很简单，学习很容易！\");// 直接输出p的name实例变量，将输出 李刚System.out.println(p.name);System.out.print(s1)为001\n封装 private是一个权限修饰符\n可以修饰成员(成员变量和成员方法)\n作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问\n\n 封装通过setXXX()，getXXX() 调用\n\nStudent.java\n12345678910111213141516171819202122232425262728public class Student&#123;    //成员变量    private String name;    private int age;    //get/set方法    public void setName(String n)&#123;        name = n;    &#125;//    public String getName()&#123;//        return name;//    &#125;    public void setAge(int a)&#123;        age = a;    &#125;//    public int getAge()&#123;//        return age;//    &#125;    public  void show()&#123;        System.out.println(name+\" ，\"+age);    &#125;&#125;Student_test.java\n1234567891011121314public class Student_test &#123;    public static void main(String[] args) &#123;        //创建对象        Student s = new Student();        //使用set方法给成员变量赋值        s.setName(\"林青霞\");        s.setAge((22));        s.show();    &#125;&#125;------------------------------------------------------ 林青霞 ，22this修饰的变量代指成员变量\n1234private String name;\t//成员变量public void setName(String name)&#123;    this.name = name; //this.name 成员变量&#125;APIDash for Mac\n一款功能强大的API文档浏览器和代码片段管理器，内置了丰富的API文档，多达150多种，可以在线下载各种开发API和文档资料，可以让您集中管理API文档，包括离线下载、搜索、查阅，包括各种主流的编程语言和框架，如Cocos2D, Cocos3D, Corona, CSS, HTML, Java, Objective-C, JavaScript, jQuery, Vue,React等, 不需要在到处下载 API 文档，Dash 已经自动集成了，并支持集成到Webstrom、Xcode、Alfred等软件中，非常的强大！开发者必备的API文档参考工具。\n\n数据输入导包\n1import java.util.Scanner;\n创建对象\n1Scanner sc &#x3D; new Scanner(System.in);\n接受数据\n1int i &#x3D; sc.nextInt();1float i &#x3D; sc.nextFloat();1double x &#x3D; sc.nextDouble();1String i &#x3D; sc.nextLine();\nnext() 与 nextLine() 区别next():\n1、一定要读取到有效字符后才可以结束输入。\n2、对输入有效字符之前遇到的空白，next() 方法会自动将其去掉。\n3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。\nnext() 不能得到带有空格的字符串。\nnextLine()：\n1、以Enter为结束符,也就是说 nextLine()方法返回的是输入回车之前的所有字符。\n2、可以获得空白。\n输出12System.out.println();&#x2F;&#x2F;输出内容换行System.out.print(); &#x2F;&#x2F;输出内容不换行Random随机数导包\n1import java.util.Random\n创建对象\n1Random r &#x3D; new Random();\n获取随机数\n1int number &#x3D; r.nextInt(10); &#x2F;&#x2F;取数据范围[0，10）\n字符串String值创建后不能修改\n可被共享\n效果相当于字符数组char[]，底层原理是字节数组byte[]\n12345byte[] bys = &#123;97,98,99&#125;;String s3 = new String(bys);System.out.println(\"s3:\"+s3);//s3:abcString构造方法123456789101112char[] chs = &#123;'a','b','c'&#125;byte[] bys = &#123;97,98,99&#125;;public String();\t//创建一个空白字符串，不包含任何内容public String(char[] chs);\t//abc\t根据字符数组内容 创建对象 public String(byte[] bys);\t//abc\tString s = \"abc\";\t\t\t//abc\t直接赋值的方式创建字符串对象-------------------------------------------------------------String s = \"abc\";String n = new String();String n = new String(chs);String n = new String(bys);比较字符串比较地址是否相同\n1234char[] chs =&#123;'a','b','c'&#125;;String s1 = new String(chs);\t//new出来的都是不相同的 String s2 = new String(chs);System.out.println(s1==s2);\t//false\n比较内容是否相同 .equals\n123String s3 = \"abc\";String s4 = \"abc\";System.out.println(s3.equals(s4));\n实例：用户登录\n\n123456789101112131415161718public class StringTest01 &#123;    public static void main(String[] args) &#123;        String usename= \"itheima\";        String password = \"123\";        Scanner sc= new Scanner(System.in);        for(int i = 3;i&gt;0;i--) &#123;            System.out.println(\"请输入用户名:\");            String name = sc.nextLine();            System.out.println(\"请输入密码：\");            String pass = sc.nextLine();            if (usename.equals(name) &amp;&amp; password.equals(pass)) &#123;                System.out.println(\"登陆成功\");            &#125; else &#123;                System.out.println(\"您还有\"+i+\"次机会，密码错误\");            &#125;        &#125;    &#125;&#125;遍历字符串public char charAt(int index):返回索引处的char值，字符串的索引也从0开始\npublic int length():返回字符串的长度\n字符串长度：字符串对象.length() \n12345678910111213Scanner sc = new Scanner(System.in);System.out.print(\"亲输入一个字符串:\");String line = sc.nextLine();System.out.println(line.length());System.out.println(line.charAt(0));System.out.println(line.charAt(1));System.out.println(line.charAt(2));------------------------------------------------亲输入一个字符串:asd3asd统计字符出现次数12345678910111213141516171819Scanner sc = new Scanner(System.in);System.out.println(\"请输入一个字符串\");String line = sc.nextLine();int bigCount = 0;int smallCount = 0;int numberCount = 0;for (int i = 0; i &lt; line.length(); i++) &#123;    char ch = line.charAt(i);    if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123;        bigCount++;    &#125; else if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123;        smallCount++;    &#125; else if (ch &gt;= '0' &amp;&amp; ch &lt;= '9') &#123;        numberCount++;    &#125;&#125;System.out.println(\"大写字母\" + bigCount + '个');System.out.println(\"小写字母\" + smallCount + '个');System.out.println(\"数字\" + numberCount + '个');字符串拼接浪费空间\n时间效率低\n12345678910111213141516171819202122public class Student &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 2, 3&#125;;        String s = arryToString(arr);        System.out.println(\"s:\" + s);    &#125;        public static String arryToString(int[] arr) &#123;        String s = \"\";        s += \"[\";        for (int i = 0; i &lt; arr.length; i++) &#123;            if (i == arr.length - 1) &#123;                s += arr[i];            &#125; else &#123;                s += arr[i];                s += \",\";            &#125;        &#125;        s += \"]\";        return s;    &#125;&#125;翻转拼接12345678910111213141516171819import java.util.Scanner;public class reverse &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入一个字符串：\");        String line = sc.nextLine();        String s = reverse(line);        System.out.println(\"s:\" + s);    &#125;    public static String reverse(String s) &#123;        String ss = \"\";        for (int i = s.length() - 1; i &gt;= 0; i--) &#123;            ss += s.charAt(i);        &#125;        return ss;    &#125;&#125;StringBuilderString:内容是不可变的\nStringBuilder:内容是可变的\nStringBuilder构造方法12345public StringBuilder();\t//创建一个空白可变字符串对象，不含有任何内容public StringBuilder(String str);\t//根据字符串的内容，来创建可变字符串对象StringBuilder sb = new StringBuilder(); //创建空的StringBuilder sb = new StringBuilder(\"hello\");StringBuilder的添加和反转方法public StringBuilder append(任意类型): 添加数据，并返回对象本身public StringBuilder reverse(): 变成相反的字符序列，并返回\n123456789StringBuilder sb = new StringBuilder();StringBuilder sb2 = sb.append(\"hello\");System.out.println(\"sb:\"+sb);   //sb:helloSystem.out.println(\"sb2:\"+sb2); //sb：2helloSystem.out.println(sb==sb2);   //true-----------------------------------------StringBuilder sb = new StringBuilder(\"hello\");sb.reverse();System.out.println(\"sb:\"+sb);   //sb:olleh链式编程12sb.append(\"hello\"). append(\"world\"). append(\"java\").append(100);//helloworldjava100StringBuilder和String转化StringBuilder转化为String\n123456//通过 tostring()就可以实现把 String Builder转换为 Stringpublic String toString(); -------------------------------------------------------------StringBuilder sb = new StringBuilder(\"hello\");String s = sb.toString();System.out.println(s);\nString转化为StringBuilder\n123456//通过构造方法就可以实现把 String转换为 String Builderpublic StringBuilder(String str)----------------------------------------------------------------String s = \"hello\";StringBuilder sb = new StringBuilder(s);System.out.println(sb);\n字符串拼接【升级版】节省空间\n时间效率高\n123456789101112131415161718192021public class Student &#123;    public static void main(String[] args) &#123;        int[] arr = &#123;1, 2, 3&#125;;        String s = arrayToString(arr);        System.out.println(\"s:\" + s);    &#125;    public static String arrayToString(int[] arr) &#123;        StringBuilder sb = new StringBuilder();        sb.append(\"[\");        for (int i = 0; i &lt; arr.length; i++) &#123;            if (i == arr.length - 1) &#123;                sb.append(arr[i]);            &#125; else &#123;                sb.append(arr[i]).append(\",\");            &#125;        &#125;        sb.append(\"]\");        return sb.toString();    &#125;&#125;翻转【升级版】12345678910111213141516public class Student &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.print(\"请输入一个字符串：\");        String line = sc.nextLine();        String s = myreverse(line);        System.out.println(\"s:\" + s);    &#125;    public static String myreverse(String line) &#123;        StringBuilder sb = new StringBuilder(line);        sb.reverse();        return sb.toString();        //简写：return new StirngBuilder(line).reverse().toString();    &#125;&#125;集合集合类的特点:提供一种存储空间可变的存储模型，存储的数据容量可以发生改变\n\n🍰泛型概述泛型:是JDK5中引入的特性,它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型\n它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数\n一提到参数， 最熟悉的就是定义方法时有形参,然后调用此方法时传递实参。那么参数化类型怎么理解呢?\n顾名思义，就是将类型由原来的具体的类型参数化，然后在使用/调用时传入具体的类型\n这种参数类型可以用在类、方法和接口中,分别被称为泛型类、泛型方法、泛型接口\n泛型定义格式:\n&lt;类型&gt;:指定一种类型的格式。这里的类型可以看成是形参\n&lt;类型1,类型2…&gt;.:指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参\n将来具体调用时候给定的类型可以看成是实参, 且实参的类型只能是引用数据类型\n泛型的好处:\n把运行时期的问题提前到了编译期间\n避免了强制类型转换\n1234567891011public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        c.add(\"hello\");        c.add(\"java\");        System.out.println(c);    &#125;&#125;泛型类泛型类的定义格式:\n格式: 修饰符class 名&lt;类型&gt; { }\n\n范例: public class Generic&lt;T&gt; { }\n此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型\n\nGeneric.java\n123456789101112public class Generic&lt;T&gt; &#123;    private T t;    public T getT() &#123;        return t;    &#125;    public void setT(T t) &#123;        this.t = t;    &#125;&#125;GenericDemo.java\n123456789101112131415161718192021public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new Generic&lt;&gt;();        g1.setT(\"凌青霞\");        System.out.println(g1.getT());        Generic&lt;Integer&gt; g2 = new Generic&lt;&gt;();        g2.setT(30);        System.out.println(g2.getT());        Generic&lt;Boolean&gt; g3 = new Generic&lt;&gt;();        g3.setT(true);        System.out.println(g3.getT());    &#125;&#125;------------------凌青霞30true泛型方法泛型方法的定义格式: \n格式: 修饰符 &lt;类型&gt; 返回值类型方法名(类型变量名){ }\n范例: public &lt;T&gt; void show(T t){ }\nGeneric.java\n1234567public class Generic &#123;    // 泛型方法    public &lt;T&gt; void show(T t) &#123;        System.out.println(t);    &#125;&#125;GenericDemo.java\n12345678910111213141516171819public class GenericDemo &#123;    public static void main(String[] args) &#123;/*         Generic&lt;String&gt; g1 = new Generic&lt;&gt;();        g1.show(\"凌青霞\");        Generic&lt;Integer&gt; g2 = new Generic&lt;&gt;();        g2.show(20);        Generic&lt;Double&gt; g3 = new Generic&lt;&gt;();        g3.show(111.111); */        Generic g = new Generic();        g.show(\"林青霞\");        g.show(30);        g.show(true);    &#125;&#125;泛型接口泛型接口的定义格式:\n格式:修饰符 interface 接口名&lt;类型&gt; { }\n范例: public interface Generic&lt;T&gt;{}\nGeneric.java\n123public interface Generic&lt;T&gt; &#123;    public void show(T t);&#125;Genericlmpl.java\n123456public class Genericlmpl&lt;T&gt; implements Generic&lt;T&gt;&#123;    @Override    public void show(T t) &#123;        System.out.println(t);    &#125;&#125;GenericDemo.java\n123456789public class GenericDemo &#123;    public static void main(String[] args) &#123;        Generic&lt;String&gt; g1 = new Genericlmpl&lt;String&gt;();        g1.show(\"林青霞\");        Generic&lt;Integer&gt; g2 = new Genericlmpl&lt;Integer&gt;();        g2.show(30);    &#125;&#125;类型通配符为了表示各种泛型List的父类，可以使用类型通配符\n类型通配符: &lt;?&gt;\nList&lt;?&gt;: 表示元素类型未知的List,它的元素可以匹配任何的类型\n\n这种带通配符的List仅表示它是各种泛型List的父类，钚能把元素添加到其中\n\n如果说我们不希望List&lt;?&gt;是任何泛型List的父类,只希望它代表某一类泛型List的父类，可以使用类型通配符的上限\n类型通配符上限: &lt;? extends类型&gt;\nList &lt;? extends Number&gt;:它表示的类型是Number或者其子类型\n\n除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限\n类型通配符下限: &lt;?super类型&gt;\nList&lt;? super Number&gt;: 它表示的类型是Number或者其父类型\n\n\n12345678910111213141516171819202122import java.util.ArrayList;import java.util.List;public class GenericDemo &#123;    public static void main(String[] args) &#123;        // 类型通配符: &lt;?&gt;        List&lt;?&gt; list1 = new ArrayList&lt;Object&gt;();        List&lt;?&gt; list2 = new ArrayList&lt;Number&gt;();        List&lt;?&gt; list3 = new ArrayList&lt;Integer&gt;();        // 类型通配符上限: &lt;? extends类型&gt;        // List&lt;? extends Number&gt; list4 = new ArrayList&lt;Object&gt;();        List&lt;? extends Number&gt; list5 = new ArrayList&lt;Number&gt;();        List&lt;? extends Number&gt; list6 = new ArrayList&lt;Integer&gt;();        // 类型通配符下限: &lt;?super类型&gt;        List&lt;? super Number&gt; list7 = new ArrayList&lt;Object&gt;();        List&lt;? super Number&gt; list8 = new ArrayList&lt;Number&gt;();        // List&lt;? super Number&gt; list9 = new ArrayList&lt;Integer&gt;();    &#125;&#125;可变参数可变参数又称参数个数可变,用作方法的形参出现，那么仿法参数个数就是可变的了\n格式: 修饰符 返回值类型 方法名(数据类型…名){ }\n范例: public static int sum(int...a){ }\n可变参数注意事项\n这里的变量其实是一个数组\n如果一个方法有多个参数，包含可变参数，可变参数要放在最后\n123456789101112131415161718192021222324public class GenericDemo &#123;    public static void main(String[] args) &#123;        System.out.println(sum(1, 2, 3, 4, 5, 6));        System.out.println(sum(1, 2, 3, 4, 5));        System.out.println(sum(1, 2, 3, 4));        System.out.println(sum(1, 2, 3));        System.out.println(sum(1, 2));    &#125;    // 多个参数时，可变参数要放在后面    /*     * public static int sum(int b,int... a)&#123;     * return 0;     * &#125;     */    public static int sum(int... a) &#123;        int sum = 0;        for (int i : a) &#123;            sum += i;        &#125;        return sum;    &#125;&#125;可变参数的使用Arrays工具类中有一个静态方法:\npublic static &lt;T&gt; List&lt;T&gt; asList(T... a):返回由指定数组支持的固定大小的列表\n返回的集合不能做增删操作，可以做修改操作\nList接口中有-个静态方法:\npublic static &lt;E&gt; List&lt;E&gt; of(... elements): 返回包含任意数元素的不可变列表\n返回的集合不能做增删改操作\nSet接口中有一个静态方法:\npublic static &lt;E&gt; Set&lt;E&gt; of(... elements) :返回一个包含任意数量元素的不可变集合\n在给元素的时候，不能给重复的元素\n返回的集合不能做增删操作，没有修改的方法\n12345678910111213141516171819202122232425262728import java.util.Arrays;import java.util.List;import java.util.Set;public class GenericDemo &#123;    public static void main(String[] args) &#123;        // public static &lt;T&gt; List&lt;T&gt; asList(T... a)        List&lt;String&gt; list = Arrays.asList(\"hello\", \"world\", \"java\");        list.add(\"javaee\"); // UnsupportedOperationException        list.remove(\"world\"); // UnsupportedOperationException        list.set(1, \"javaee\");        System.out.println(list);        // public static &lt;E&gt; List&lt;E&gt; of(... elements)        List&lt;String&gt; list2 = List.of(\"hello\", \"world\", \"java\");        list2.add(\"javaee\"); // UnsupportedOperationException        list2.remove(\"world\"); // UnsupportedOperationException        list2.set(1, \"javaee\");// UnsupportedOperationException        System.out.println(list2);        // public static &lt;E&gt; Set&lt;E&gt; of(... elements)        Set&lt;String&gt; set = Set.of(\"hello\", \"world\", \"java\");        set.add(\"javaee\"); // UnsupportedOperationException        set.remove(\"world\"); // UnsupportedOperationException        System.out.println(set);    &#125;&#125;🍰Collections概述和使用Collections类的概述\n是针对集合操作的工具类\nCollections类的常用方法\npublic static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list): 将指定的列表按升序排序\n\n首先：public static void sort(List list)\n\n为了安全性加泛型：public static &lt;T&gt; void sort(List&lt;T&gt; list)\n\n想要排序先比较，要有可比较性,因此T必须是Comparable的子类：public static &lt;T extends Comparable&gt; void sort(List&lt;T&gt; list)\n\nComparable接口也有泛型：public static &lt;T extends Comparable&lt;T&gt;&gt; void sort(List&lt;T&gt; list)\n\nT的父类也行，&lt;? super T&gt;表示Comparable&lt;&gt;中的类型下限为T：public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort (List&lt;T&gt; list)\nList&lt;? extends T&gt;是规定了类型上界，即该数组元素的类型上限是T，后面定义装载的元素类型必须是T本身或者T的子类。\n\n\npublic static void reverse(List&lt;?&gt; list):反转指定列表中元素的顺序\n\npublic static void shuffle(List&lt;?&gt; list):使用默认的随机源随机排列指定的列表\n\n12345678910111213141516171819202122232425262728import java.util.ArrayList;import java.util.Collection;import java.util.Collections;import java.util.List;public class MapDemo &#123;    public static void main(String[] args) &#123;        List&lt;Integer&gt; list = new ArrayList&lt;&gt;();        list.add(30);        list.add(20);        list.add(50);        list.add(10);        list.add(40);        // 升序        // Collections.sort(list);        // 翻转        // Collections.reverse(list);        // 随机        Collections.shuffle(list);        System.out.println(list);    &#125;&#125;ArrayList存储学生对象并排序需求: ArrayList存储学生对象，使用Collections对ArrayList进行排序\n要求:按照年龄从小到大排序,年龄相同时，按照姓名的字母顺序排序\n思路:①定义学生类②创建ArrayList集合对象③创建学生对象④把学生添加到集合⑤使用Collections对ArrayList集合排序⑥遍历集合\n1234567891011121314151617181920212223242526272829303132import java.util.ArrayList;import java.util.Collections;import java.util.Comparator;public class MapDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();        Student s1 = new Student(\"linqiangxia\", 30);        Student s2 = new Student(\"zhangmanyu\", 35);        Student s3 = new Student(\"wangzuxian\", 33);        Student s4 = new Student(\"liuyan\", 33);        array.add(s1);        array.add(s2);        array.add(s3);        array.add(s4);        // public static &lt;T&gt; void sort​(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)        Collections.sort(array, new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                int num = s1.getAge() - s2.getAge();                int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;                return num2;            &#125;        &#125;);        for (Student s : array) &#123;            System.out.println(s.getName() + \",\" + s.getAge());        &#125;    &#125;&#125;模拟斗地主需求:通过程序实现斗地主过程中的洗牌，发牌和看牌\n思路:①创建一个牌盒,也就是定义一个集合对象，用ArrayList集合实现②往牌盒里面装牌③洗牌，也就是把牌打撒，用Collections的shuffle()方法实现④发牌，也就是遍历集合，给三个玩家发牌⑤看牌，也就是三个玩家分别遍历自己的牌\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import java.util.ArrayList;import java.util.Collections;public class MapDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        // 定义花色数组        String[] colors = &#123; \"♦️\", \"♠️\", \"♥️\", \"♣️\" &#125;;        // 定义点数        String[] numbers = &#123; \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\" &#125;;        for (String color : colors) &#123;            for (String number : numbers) &#123;                array.add(color + number);            &#125;        &#125;        array.add(\"小王\");        array.add(\"大王\");        // 洗牌        Collections.shuffle(array);        // 发牌        ArrayList&lt;String&gt; lqxArray = new ArrayList&lt;&gt;();        ArrayList&lt;String&gt; lyArray = new ArrayList&lt;&gt;();        ArrayList&lt;String&gt; fqyArray = new ArrayList&lt;&gt;();        ArrayList&lt;String&gt; dpArray = new ArrayList&lt;&gt;();        for (int i = 0; i &lt; array.size(); i++) &#123;            String poker = array.get(i);            if (i &gt;= array.size() - 3) &#123;                dpArray.add(poker);            &#125; else if (i % 3 == 0) &#123;                lqxArray.add(poker);            &#125; else if (i % 3 == 1) &#123;                lyArray.add(poker);            &#125; else if (i % 3 == 2) &#123;                fqyArray.add(poker);            &#125;        &#125;        // 看牌        lookPoker(\"林青霞\", lqxArray);        lookPoker(\"柳岩\", lyArray);        lookPoker(\"疯抢杨\", fqyArray);        lookPoker(\"底牌\", dpArray);    &#125;    public static void lookPoker(String name, ArrayList&lt;String&gt; array) &#123;        System.out.println(name + \"的牌是：\");        for (String poker : array) &#123;            System.out.print(poker + \" \");        &#125;        System.out.println();    &#125;&#125;模拟斗地主升级版需求:通过程序实现斗地主过程中的洗牌,发牌和看牌。要求:对牌进行排序\n\n思路:①创建HashMap,键是编号,值是牌②创建ArrayList, 存储编号③创建花色数组和点数数组④从0开始往HashMap里面存储编号,并存储对应的牌。同时往ArrayList里面存储编号⑤洗牌(洗的是编号)，用Collections的shuffle()方法实现⑥发牌(发的也是编号,为了保证编号是排序的,创建TreeSet集合接收)⑦方法看牌(遍历TreeSet集合,获取编号,到HashMap集合找对应的牌)⑧调用看牌方法\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374import java.util.ArrayList;import java.util.Collections;import java.util.HashMap;import java.util.TreeSet;public class MapDemo &#123;    public static void main(String[] args) &#123;        // 创建HashMap，键是编号，值是牌        HashMap&lt;Integer, String&gt; hm = new HashMap&lt;&gt;();        // 创建ArrayList,存储编号        ArrayList&lt;Integer&gt; array = new ArrayList&lt;&gt;();        // 定义花色数组        String[] colors = &#123; \"♦️\", \"♠️\", \"♥️\", \"♣️\" &#125;;        // 定义点数        String[] numbers = &#123; \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"J\", \"Q\", \"K\", \"A\", \"2\" &#125;;        // 从0开始往HashMap里面存储编号，并存储对应的牌，同时往ArrayList里面存储编号        int index = 0;        for (String number : numbers) &#123;            for (String color : colors) &#123;                hm.put(index, color + number);                array.add(index);                index++;            &#125;        &#125;        hm.put(index, \"小王\");        array.add(index);        index++;        hm.put(index, \"大王\");        array.add(index);        // 洗牌        Collections.shuffle(array);        // 发牌        TreeSet&lt;Integer&gt; lqxArray = new TreeSet&lt;&gt;();        TreeSet&lt;Integer&gt; lyArray = new TreeSet&lt;&gt;();        TreeSet&lt;Integer&gt; fqyArray = new TreeSet&lt;&gt;();        TreeSet&lt;Integer&gt; dpArray = new TreeSet&lt;&gt;();        for (int i = 0; i &lt; array.size(); i++) &#123;            int x = array.get(i);            if (i &gt;= array.size() - 3) &#123;                dpArray.add(x);            &#125; else if (i % 3 == 0) &#123;                lqxArray.add(x);            &#125; else if (i % 3 == 1) &#123;                lyArray.add(x);            &#125; else if (i % 3 == 2) &#123;                fqyArray.add(x);            &#125;        &#125;        // 看牌        lookPoker(\"林青霞\", lqxArray, hm);        lookPoker(\"柳岩\", lyArray, hm);        lookPoker(\"疯抢杨\", fqyArray, hm);        lookPoker(\"底牌\", dpArray, hm);    &#125;    public static void lookPoker(String name, TreeSet&lt;Integer&gt; ts, HashMap&lt;Integer, String&gt; hm) &#123;        System.out.println(name + \"的牌是：\");        for (Integer key : ts) &#123;            String poker = hm.get(key);            System.out.print(poker + \" \");        &#125;        System.out.println();    &#125;&#125;🌸CollectionCollection集合概述\n是单例集合的顶层接口， 它表示一组对象， 这些对象也称为Collection的元素\nJDK 不提供此接口的任何直接实现，它提供更具体的子接口(如Set和List) 实现\n创建Collection集合的对象\n多态的方式\n具体的实现类ArrayList\n12345678910111213public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        c.add(\"hello\");        c.add(\"java\");        System.out.println(c);    &#125;&#125;---------------------------------[hello, java]常用方法\n方法名说明\n\nboolean add(E e)添加元素\n\nboolean remove(Object o)从集合中移除指定的元素\n\nvoid clear()清空集合中的元素\n\nboolean contains(Object o)判断集合中是否存在指定的元素\n\nboolean isEmpty()判断集合是否为空\n\nint size()集合的长度，也就是集合中元素的个数\n12345678910111213141516171819202122public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        c.add(\"hello\");        c.add(\"java\");        c.add(\"world\");        System.out.println(c.contains(\"java\"));        System.out.println(c.isEmpty());        System.out.println(c.size());        System.out.println(c);    &#125;&#125;-------------------------------------------------------truefalse3[hello, java, world]集合的遍历\nIterator: 迭代器，集合的专用遍历方式\nIterator&lt;E&gt; iterator():  返回此集合中元素的迭代器，通过集合的iterator()方法得到\n迭代器是通过集合的iterator()方法得到的， 所以我们说它是依赖于集合而存在的\nIterator中的常用方法\nE next():返回迭代中的下一个元素\nboolean hasNext(): 如果迭代具有更多元素,则返回 true\n123456789101112131415161718192021222324252627282930import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();        c.add(\"Hello\");        c.add(\"World\");        c.add(\"Java_nice\");        Iterator&lt;String&gt; it = c.iterator();        // E next():返回迭代中的下一个元素        /*         * System.out.println(it.next());         * System.out.println(it.next());         * System.out.println(it.next());         * System.out.println(it.next()); //java.util.NoSuchElementException没有此类元素异常         */        // boolean hasNext():如果迭代具有更多元素，则返回 true        while (it.hasNext()) &#123;            System.out.println(it.next());        &#125;    &#125;&#125;Collection集合存储学生对象并遍历\n 需求:创建一个存储学生对象的集合,存储3个学生对象，使用程序实现在控制台遍历该集合\n\n思路:\n定义学生类\n创建Collection集合对象\n创建学生对象\n把学生添加到集合\n遍历集合(迭代器方式)\nStudent.java\n12345678910111213141516171819202122232425262728293031package test2;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;CollectionDemo.java\n123456789101112131415161718192021222324252627import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Collection&lt;Student&gt; c = new ArrayList&lt;Student&gt;();        // 创建学生对象        Student s1 = new Student(\"邪头\", 20);        Student s2 = new Student(\"初爱\", 22);        Student s3 = new Student(\"三上悠亚\", 29);        c.add(s1);        c.add(s2);        c.add(s3);        // 遍历集合 迭代器方式        Iterator&lt;Student&gt; it = c.iterator();        while (it.hasNext()) &#123;            Student s = it.next();            System.out.println(s.getName() + \",\" + s.getAge());        &#125;    &#125;&#125;🍄ListList集合概述\n有序集合(也称为序列)， 用户可以精确控制列表中每个元素的插入位置。用户可以通过整数索引访问元素,并搜索列表中的元素\n与Set集合不同， 列表通常允许重复的元素\nList集合特点\n有序:存储和取出的元素顺序一致\n可重复:存储的元素可以重复\n🍇Iterator&lt;E&gt; 迭代器\n123456789101112131415161718192021import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(\"hello\");        list.add(\"world\");        list.add(\"java\");        // 迭代器        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) &#123;            System.out.println(it.next());        &#125;    &#125;&#125;List特有方法\n方法名说明\n\nvoid add(int index,E element)在此集合中的指定位置插入指定的元素\n\nE remove(int index)删除指定索引处的元素，返回被删除的元素\n\nE set(int index,E element)修改指定索引处的元素，返回被修改的元素\n\nE get(int index)返回指定索引处的元素\n12345678910111213141516171819202122232425262728293031323334353637import java.util.ArrayList;import java.util.List;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(\"hello\");        list.add(\"world\");        list.add(\"java\");        // 添加元素        /*         * list.add(1,\"javaee\");         * list.add(11,\"php\"); //IndexOutOfBoundsException         */        // 删除元素        /*         * System.out.println(list.remove(1));         * System.out.println(list.remove(11)); //IndexOutOfBoundsException         */        // 修改元素 E set(int index,E element) 修改指定索引处的元素，返回被修改的元素        System.out.println(list.set(1, \"邪头王冰\"));        // 返回指定元素        for (int i = 0; i &lt; list.size(); i++) &#123;            String s = list.get(i);            System.out.println(s);        &#125;        // 最终元素        System.out.println(list);    &#125;&#125;存储学生对象并遍历123456789101112131415161718192021222324252627282930313233343536import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        // 创建学生对象        Student s1 = new Student(\"邪头\", 20);        Student s2 = new Student(\"初爱\", 22);        Student s3 = new Student(\"三上悠亚\", 29);        list.add(s1);        list.add(s2);        list.add(s3);        // 迭代器方式        Iterator&lt;Student&gt; it = list.iterator();        while (it.hasNext()) &#123;            Student s = it.next();            System.out.println(s.getName() + \",\" + s.getAge());        &#125;        System.out.println(\"------------\");        // for循环方式        for (int i = 0; i &lt; list.size(); i++) &#123;            Student s = list.get(i);            System.out.println(s.getName() + \"，\" + s.getAge());        &#125;    &#125;&#125;并行修改异常ConcurrentModificationException\n产生原因\n迭代器遍历的过程中,通过集合对象修改了集合中元素的长度,造成了迭代器获取元素中判断预期修改值和实际修改值不一致\n解决方案\n用for循环遍历，然后用集合对象做对应的操作即可\n12345678910111213141516171819202122232425262728293031323334import java.util.ArrayList;import java.util.Collection;import java.util.Iterator;import java.util.List;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(\"hello\");        list.add(\"world\");        list.add(\"java\");        // 错误方法        Iterator&lt;String&gt; it = list.iterator();        while (it.hasNext()) &#123;            // ConcurrentModificationException            // 原因modCount(实际修改集合的次数)!= expectedModCount(语气修改集合的次数)            String s = it.next();            if (s.equals(\"world\")) &#123;                list.add(\"javase\");            &#125;        &#125;        // 正确方法        for (int i = 0; i &lt; list.size(); i++) &#123;            String s = list.get(i);            if(s.equals(\"world\"))&#123;                list.add(\"javaee\");            &#125;        &#125;    &#125;&#125;\n错误原因 视频链接\n\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253// 并发修改异常的源码分析public interface List&lt;E&gt; extends Collection&lt;E&gt; &#123;    Iterator&lt;E&gt; iterator();    boolean add(E e);&#125;public abstract class AbstractList&lt;E&gt; &#123;    protected int modCount = 0;&#125;public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt; &#123;    public boolean add(E e) &#123;        modCount++; //问题出现的原因 add执行后 使得modCount数增加 导致hasNext执行错误        add(e, elementData, size);        return true;    &#125;    public Iterator&lt;E&gt; iterator() &#123;        return new Itr();    &#125;    // 内部类    private class Itr implements Iterator&lt;E&gt; &#123;        // 预期修改集合的次数 修改集合的次数        int expectedModCount = modCount;        public boolean hasNext() &#123;            return cursor != size;        &#125;        public E next() &#123;            checkForComodification();            int i = cursor;            if (i &gt;= size)                throw new NoSuchElementException();            Object[] elementData = ArrayList.this.elementData;            if (i &gt;= elementData.length)                throw new ConcurrentModificationException();            cursor = i + 1;            return (E) elementData[lastRet = i];        &#125;        final void checkForComodification() &#123;            if (modCount != expectedModCount) //报错处                throw new ConcurrentModificationException();        &#125;    &#125;&#125;🍇ListIterator&lt;E&gt; 列表迭代器ListIterator:列表迭代器\n通过List集合的listIterator()方法得到， 所以说它是List集合特有的迭代器\n用于允许程序员沿任一方向遍历列表的列表迭代器， 在迭代期间修改列表,并获取列表中迭代器的当前位置\nListlterator中的常用方法\nE next():返回迭代中的下一个元愫\nboolean hasNext(): 如果迭代具有更多元素, 则返回true\nE previous(): 返回列表中的上一个元素\nboolean hasPrevious(): 如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true\nvoid add(E e): 将指定的元素插入列表\n123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.List;import java.util.ListIterator;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        List&lt;String&gt; list = new ArrayList&lt;&gt;();        list.add(\"hello\");        list.add(\"world\");        list.add(\"java\");        // 通过List集合的listIterator() 方法得到        /*         * ListIterator&lt;String&gt; lit = list.listIterator();         * while (lit.hasNext()) &#123;         * String s = lit.next();         * System.out.println(s);         * &#125;         * System.out.println(\"--------\");         * while (lit.hasPrevious()) &#123;         * String s = lit.previous();         * System.out.println(s);         * &#125;         */        // 获取列表迭代器        ListIterator&lt;String&gt; lit = list.listIterator();        while (lit.hasNext()) &#123;            String s = lit.next();            if (s.equals(\"world\")) &#123;                lit.add(\"javaee\");            &#125;        &#125;        System.out.println(list);    &#125;&#125;[hello, world, javaee, java]增强for循环增强for:简化数组和Collection集合的遍历\n实现Iterable接口的类允许其对象成为增强型 for语句的目标\n它是JDK5之后出现的，其内部原理是一个Iterator迭代器\n增强for的格式\n格式:\n123for(元素数据类型 变量名:数组或者Collection集合) &#123;\t//在此处使用变量即可，该变量就是元素&#125;\n范例\n1234int[] arr = &#123;1,2,3,4,5&#125;;for(int i:arr)&#123;\tSystem.out.println(i);&#125;\nList集合存储学生对象用三种方式遍历需求:创建一个存储学生对象的集合，存储3个学生对象，使用程序实现在控制台遍历该集合\n思路:\n定义学生类\n创建List集合对象\n创建学生对象\n把学生添加到集合\n遍历集合\n迭代器:集合特有的遍历方式普通for:带有索引的遍历方式增强for:最方便的遍历方式\n123456789101112131415161718192021222324252627282930313233343536373839import java.util.ArrayList;import java.util.Iterator;import java.util.List;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        List&lt;Student&gt; list = new ArrayList&lt;Student&gt;();        // 创建学生对象        Student s1 = new Student(\"邪头\", 20);        Student s2 = new Student(\"初爱\", 22);        Student s3 = new Student(\"三上悠亚\", 29);        list.add(s1);        list.add(s2);        list.add(s3);        // 迭代器：集合特有的遍历方式        Iterator&lt;Student&gt; it = list.iterator();        while (it.hasNext()) &#123;            Student s = it.next();            System.out.println(s.getName() + \",\" + s.getAge());        &#125;        System.out.println(\"------------------\");      \t// 普通for:带有索引的遍历方式        for (int i = 0; i &lt; list.size(); i++) &#123;            Student s = list.get(i);            System.out.println(s.getName() + \",\" + s.getAge());        &#125;        System.out.println(\"------------------\");      \t// 增强for:最方便的遍历方式        for (Student s : list) &#123;            System.out.println(s.getName() + \",\" + s.getAge());        &#125;    &#125;&#125;List集合子类特点List集合常用子类: ArrayList, LinkedList\nArrayList: 底层数据结构是数组,查询快，增删慢\nLinkedList: 底层数据结构是链表，查询慢，增删快\n🍉ArrayList&lt;E&gt;可调整大小的数组实现\n&lt;E&gt; :是一种特殊的数据类型，泛型。\n构造方法\n方法名说明\n\npublic ArrayList()创建一个空的集合对象\n\npublic boolean add(E e)将指定的元素追加到此集合的末尾, 返回bool表示是否成功\n\npublic void add(int index,E element)在此集合中的指定位置插入指定的元素\n12345678ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();array.add(\"hello\");array.add(\"world\");array.add(\"java\");array.add(1, \"javase\");System.out.println(array);------------------------------------------------------[hello, javase, world, java]方法集合\n方法名说明\n\npublic boolean remove(Objecto)删除指定的元素，返回删除是否成功\n\npublic E remove(int index)删除指定索引处的元素，返回被删除的元素\n\npublic E set(int index,E element)修改指定索引处的元素，返回被修改的元素\n\npublic E get(int index)返回指定索引\n\npublic int size()返回集合中的元素的个数\n123456789ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();array.add(\"hello\");array.add(\"world\");array.add(\"java\");System.out.println(array.remove(\"world\"));System.out.println(array.remove(\"javaee\"));------------------------------------------------------------truefalse123456789ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();array.add(\"hello\");array.add(\"world\");array.add(\"java\");System.out.println(array.remove(1));System.out.println(array);------------------------------------------------------------world[hello, java]123456789ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();array.add(\"hello\");array.add(\"world\");array.add(\"java\");System.out.println(array.set(1, \"javaee\"));System.out.println(array);------------------------------------------------------------world[hello, javaee, java]123456789ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();array.add(\"hello\");array.add(\"world\");array.add(\"java\");System.out.println(array.get(1));System.out.println(array);------------------------------------------------------------world[hello, world, java]遍历集合1234567ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();array.add(\"三上\");array.add(\"悠亚\");array.add(\"初爱\");for (int i = 0; i &lt; array.size(); i++) &#123;    System.out.println(array.get(i));&#125;存储学生对象并遍历Student.java\n12345678910111213141516171819202122232425262728293031package test1;public class Student &#123;  //创建对象    private String name;    private int age;//定义构造方法    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;//定义方法    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public int getAge() &#123;        return age;    &#125;&#125;Student_test.java\n12345678910111213141516171819202122232425262728293031323334353637package test1;import java.util.ArrayList;public class Student_test &#123;    public static void main(String[] args) &#123;        // 创建集合对象        ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();        // 创建学生对象        Student s1 = new Student(\"三上悠亚\", 28);        Student s2 = new Student(\"初爱\", 22);        // 添加学生对象        array.add(s1);        array.add(s2);              // 遍历              // 普通for        for (int i = 0; i &lt; array.size(); i++) &#123;            Student s = array.get(i);            System.out.println(s.getName() + \"，\" + s.getAge());        &#125;        // 迭代器        Iterator&lt;Student&gt; it = array.iterator();        while (it.hasNext()) &#123;            Student s = it.next();            System.out.println(s.getName() + \"，\" + s.getAge());        &#125;        // 增强for        for (Student s : array) &#123;            System.out.println(s.getName() + \"，\" + s.getAge());        &#125;    &#125;&#125;存储学生对象并遍历【升级版】Student.java\n123456789101112131415161718192021222324252627282930package test1;public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getName() &#123;        return name;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public int getAge() &#123;        return age;    &#125;&#125;Student_test.java\n123456789101112131415161718192021222324252627282930package test1;import java.util.ArrayList;import java.util.Scanner;public class Student_test &#123;    public static void main(String[] args) &#123;        //创建集合对象        ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();        addStudent(array);        //遍历        for (int i = 0; i &lt; array.size(); i++) &#123;            Student s = array.get(i);            System.out.println(s.getName() + \"，\" + s.getAge());        &#125;    &#125;    public static void addStudent(ArrayList&lt;Student&gt; array) &#123;        //创建学生对象        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入姓名\");        String name = sc.nextLine();        System.out.println(\"请输入年龄\");        int age = sc.nextInt();        Student s = new Student(name, age);        //添加学生对象        array.add(s);    &#125;&#125;学生管理系统Student.java\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package test1;/*    学生类    Alt+Insert  根据自己的需要进行选择 */public class Student &#123;    //学号    private String sid;    //姓名    private String name;    //年龄    private String age;    //居住地    private String address;    public Student() &#123;    &#125;    public Student(String sid, String name, String age, String address) &#123;        this.sid = sid;        this.name = name;        this.age = age;        this.address = address;    &#125;    public String getSid() &#123;        return sid;    &#125;    public void setSid(String sid) &#123;        this.sid = sid;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public String getAge() &#123;        return age;    &#125;    public void setAge(String age) &#123;        this.age = age;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;StudentManager.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184package test1;import java.util.ArrayList;import java.util.Scanner;/*    学生管理系统 */public class StudentManager &#123;    /*        1:用输出语句完成主界面的编写        2:用Scanner实现键盘录入数据        3:用switch语句完成操作的选择        4:用循环完成再次回到主界面    */    public static void main(String[] args) &#123;        //创建集合对象，用于存储学生数据        ArrayList&lt;Student&gt; array = new ArrayList&lt;Student&gt;();        while (true) &#123;            System.out.println(\"--------欢迎来到学生管理系统--------\");            System.out.println(\"1.添加学生\");            System.out.println(\"2.删除学生\");            System.out.println(\"3.修改学生\");            System.out.println(\"4.查看所有学生\");            System.out.println(\"5.退出\");            System.out.println(\"请输入你的选择：\");            Scanner sc = new Scanner(System.in);            String line = sc.nextLine();            switch (line) &#123;                case \"1\"://                    System.out.println(\"添加学生\");                    addStudent(array);                    break;                case \"2\"://                    System.out.println(\"删除学生\");                    deleteStudent(array);                    break;                case \"3\"://                    System.out.println(\"修改学生\");                    updateStudent(array);                    break;                case \"4\"://                    System.out.println(\"查看所有学生\");                    findAllStudent(array);                    break;                case \"5\":                    System.out.println(\"谢谢使用\");                    System.exit(0);//JVM退出//                    break;            &#125;        &#125;    &#125;    //定义一个方法，用于添加学生信息    public static void addStudent(ArrayList&lt;Student&gt; array) &#123;        //键盘录入学生对象所需要的数据,显示提示信息，提示要输入何种信息        Scanner sc = new Scanner(System.in);        String sid;//定义学号        //循环实现        while (true) &#123;            System.out.println(\"请输入学生学号\");            sid = sc.nextLine();            //判断学号是否重复            boolean flag = isUsed(array, sid);            if (flag == true) &#123;                System.out.println(\"学号被使用\");            &#125; else &#123;                break;            &#125;        &#125;        System.out.println(\"请输入学生姓名：\");        String name = sc.nextLine();        System.out.println(\"请输入学生年龄：\");        String age = sc.nextLine();        System.out.println(\"请输入学生居住地：\");        String address = sc.nextLine();        //创建学生对象，把键盘录入的数据赋值给学生对象的成员变量        Student s = new Student();        s.setSid(sid);        s.setName(name);        s.setAge(age);        s.setAddress(address);        //将学生对象添加到集合中        array.add(s);        //给出添加成功提示        System.out.println(\"添加学生成功\");    &#125;    //判断学号是否被使用    public static boolean isUsed(ArrayList&lt;Student&gt; array, String sid) &#123;        boolean flag = false;        for (int i = 0; i &lt; array.size(); i++) &#123;            Student s = array.get(i);            if (s.getSid().equals(sid)) &#123;                flag = true;                break;            &#125;        &#125;        return flag;    &#125;    //定义一个方法，用于查看学生信息    public static void findAllStudent(ArrayList&lt;Student&gt; array) &#123;        //判断是否有信息        if (array.size() == 0) &#123;            System.out.println(\"无信息，请先添加信息\");            return;//程序结束        &#125;        //显示表头信息        System.out.println(\"学号\\t\\t\\t姓名\\t\\t年龄\\t\\t居住地\");        //将集合中数据取出按照对应格式显示学生信息，年龄显示补充“岁”        for (int i = 0; i &lt; array.size(); i++) &#123;            Student s = array.get(i);            System.out.println(s.getSid() + \"\\t\" + s.getName() + \"\\t\" + s.getAge() + \"岁\\t\" + s.getAddress());        &#125;    &#125;    //定义一个方法，用于删除学生信息    public static void deleteStudent(ArrayList&lt;Student&gt; array) &#123;        //键盘录入要删除的学生学号,显示提示信息        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入你要删除的学生的学号:\");        String sid = sc.nextLine();        //遍历集合将对应学生对象从集合中删除        int index = -1;        for (int i = 0; i &lt; array.size(); i++) &#123;            Student s = array.get(i);            if (s.getSid().equals(sid)) &#123;                index = i;                break;            &#125;        &#125;        if (index == -1) &#123;            System.out.println(\"信息不存在，请重新输入\");        &#125; else &#123;            //给出删除成功提示            System.out.println(\"删除成功\");            array.remove(index);        &#125;    &#125;    //定义一个方法，用于修改学生信息    public static void updateStudent(ArrayList&lt;Student&gt; array) &#123;        //键盘录入要修改的学生学号，显示提示信息        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入你要修改的学生的学号：\");        String sid = sc.nextLine();        //键盘录入要修改的学生信息        System.out.println(\"请输入学生姓名：\");        String name = sc.nextLine();        System.out.println(\"请输入学生年龄：\");        String age = sc.nextLine();        System.out.println(\"请输入学生居住地：\");        String address = sc.nextLine();        //创建学生对象        Student s = new Student();        s.setSid(sid);        s.setName(name);        s.setAge(age);        s.setAddress(address);        //遍历集合修改对应的学生信息        for (int i = 0; i &lt; array.size(); i++) &#123;            Student student = array.get(i);            if (student.getSid().equals(sid)) &#123;                array.set(i, s);                break;            &#125;        &#125;        //给出修改成功提示        System.out.println(\"修改学生成功\");    &#125;&#125;🍉LinkedListLinkedList: 底层数据结构是链表，查询慢，增删快\n\n方法名说明\n\npublic void addFirst(E e)在该列表开头插入指定的元素\n\npublic void addLast(E e)将指定的元素追加到此列表的末尾\n\npublic E getFirst()返回此列表中的第一个元素\n\npublic E getLast()返回此列表中的最后一个元素\n\npublic E removeFirst()从此列表中删除并返回第一个元素\n\npublic E removeLast()从此列表中删除并返回最后一个元素\n12345678910111213141516171819202122232425262728public class CollectionDemo &#123;    public static void main(String[] args) &#123;        LinkedList&lt;String&gt; linkedList = new LinkedList&lt;&gt;();        linkedList.add(\"hello\");        linkedList.add(\"world\");        linkedList.add(\"java\");        // 添加        linkedList.addFirst(\"javase\");        linkedList.addLast(\"javaee\");        // 获取        System.out.println(linkedList.getFirst());        System.out.println(linkedList.getLast());        // 删除        System.out.println(linkedList.removeFirst());        System.out.println(linkedList.removeLast());        // 遍历        for (String s : linkedList) &#123;            System.out.println(s);        &#125;        System.out.println(linkedList);    &#125;&#125;🍄SetSet集合特点\n不包含重复元素的集合\n没有带索引的方法，所以不能使用普通for循环遍历\n12345678910111213141516public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Set&lt;String&gt; set = new HashSet&lt;String&gt;();        set.add(\"hello\");        set.add(\"world\");        set.add(\"java\");        // 不包含重复元素的集合        set.add(\"java\");        // 遍历        for (String s : set) &#123;            System.out.println(s);        &#125;    &#125;&#125;哈希值哈希值:是 JDK 根据对象的地址或者字符串或者数字算出来的int类型的数值Object类中有一个方法可以获取对象的哈希值\npublic int hashCode():  返回对象的哈希码值\n对象的哈希值特点\n同一个对象多次调用hashCode() 方法返回的哈希值是相同的\n默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同\n1234567891011121314151617181920212223public class CollectionDemo &#123;    public static void main(String[] args) &#123;        Student s1 = new Student(\"林青霞\", 30);        System.out.println(s1.hashCode());// 405662939        System.out.println(\"-----------------\");        // 默认情况下，不同对象的哈希值是不相同的        // 通过方法重写，可以实现不同对象的哈希值相同        Student s2 = new Student(\"林青霞\", 30);        System.out.println(s2.hashCode());// 653305407        System.out.println(\"-----------------\");        System.out.println(\"hello\".hashCode());// 99162322        System.out.println(\"world\".hashCode());// 113318802        System.out.println(\"hello\".hashCode());// 99162322        System.out.println(\"-----------------\");        System.out.println(\"种地\".hashCode());// 988931        System.out.println(\"通话\".hashCode());// 1179395    &#125;&#125;🍑HashSetHashSet集合特点\n底层数据结构是哈希表\n对集合的迭代顺序不作任何保证，也就是说不保证存储和取出的元素顺序一致\n没有带索引的方法，所以不能使用普通for循环遍历\n由于是Set集合，所以是不包含重复元素的集合\n123456789101112131415161718public class CollectionDemo &#123;    public static void main(String[] args) &#123;        HashSet&lt;String&gt; hs = new HashSet&lt;&gt;();        hs.add(\"hello\");        hs.add(\"world\");        hs.add(\"java\");      \t// 不保证取出元素顺序一致        for (String s : hs) &#123;            System.out.println(s);        &#125;    &#125;&#125;------------------------worldjavahelloHashSet集合保证元素唯一性的源码分析HashSet集合存储元素:\n要保证元素唯一性，需要重写hashCode()和equals()\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// HashSet集合保证元素唯一性的源码分析public boolean add(E e) &#123;        return map.put(e, PRESENT)==null;&#125;static final int hash(Object key) &#123;    int h;    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125;public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;// hash值和元素的hashCode()方法相关final V putVal(int hash, K key, V value, boolean onlyIfAbsent,                   boolean evict) &#123;        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;        // 如果哈希表未初始化，就对其进行初始化        if ((tab = table) == null || (n = tab.length) == 0)            n = (tab = resize()).length;        // 根据对象的哈希值计算对象的存储位置，如果该位置没有元素，就存储元素        if ((p = tab[i = (n - 1) &amp; hash]) == null)            tab[i] = newNode(hash, key, value, null);        else &#123;            Node&lt;K,V&gt; e; K k;            /*            存入的元素和以前的元素比较哈希值                如果哈希值不同，会继续向下执行，把元素添加到集合                如果哈希值相同，会调用对象的equals()方法比较                    如果返回false，会继续向下执行，把元素添加到集合                    如果返回true，说明元素重复，不存储            */            if (p.hash == hash &amp;&amp;                ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))                e = p;            else if (p instanceof TreeNode)                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);            else &#123;                for (int binCount = 0; ; ++binCount) &#123;                    if ((e = p.next) == null) &#123;                        p.next = newNode(hash, key, value, null);                        if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st                            treeifyBin(tab, hash);                        break;                    &#125;                    if (e.hash == hash &amp;&amp;                        ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))                        break;                    p = e;                &#125;            &#125;            if (e != null) &#123; // existing mapping for key                V oldValue = e.value;                if (!onlyIfAbsent || oldValue == null)                    e.value = value;                afterNodeAccess(e);                return oldValue;            &#125;        &#125;        ++modCount;        if (++size &gt; threshold)            resize();        afterNodeInsertion(evict);        return null;&#125;哈希表存储流程\nHashSet集合存储学生对象并遍历需求: 创建一个存储学生对象的集合，存储多个学生对象,使用程序实现在控制台遍历该集合\n​        要求: 学生对象的成员变量值相同,我们就认为是同一个对象\n思路:\n定义学生类\n创建HashSet集合对象\n创建学生对象\n把学生添加到集合\n遍历集合(增强for)\n在学生类中重写两个方法hashCode()和equals() 自动生成即可\nHashSetDemo.java\n1234567891011121314151617181920212223import java.util.HashSet;public class HashSetDemo &#123;    public static void main(String[] args) &#123;        HashSet&lt;Student&gt; hs = new HashSet&lt;&gt;();        Student s1 = new Student(\"凌青霞\",30);        Student s2 = new Student(\"张曼玉\",20);        Student s3 = new Student(\"王祖贤\",10);        Student s4 = new Student(\"凌青霞\",30);        hs.add(s1);        hs.add(s2);        hs.add(s3);        hs.add(s4);        for (Student s : hs) &#123;            System.out.println(s.getName()+\",\"+s.getAge());        &#125;    &#125;&#125;Student.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public int hashCode() &#123;        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    &#125;    @Override    public boolean equals(Object obj) &#123;        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) &#123;            if (other.name != null)                return false;        &#125; else if (!name.equals(other.name))            return false;        return true;    &#125;&#125;🍑LinkedHashSetLinkedHashSet集合特点\n哈希表和链表实现的Set接口，具有可预测的迭代次序\n由链表保证元素有序，也就是说元素的存储和取出顺序是一致的\n由哈希表保证元素唯一， 也就是说没有重复的元素\n1234567891011121314151617public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // 创建集合对象        LinkedHashSet&lt;String&gt; linkedHashSet = new LinkedHashSet&lt;&gt;();                linkedHashSet.add(\"Heloo\");        linkedHashSet.add(\"World\");        linkedHashSet.add(\"Java\");        linkedHashSet.add(\"World\");        // 遍历集合        for(String s :linkedHashSet)&#123;            System.out.println(s);        &#125;    &#125;&#125;🍑 TreeSetTreeSet集合特点\n元素有序, 这里的顺序不是指存储和取出的顺序,而是按照一定的规则进行排序，具体排序方式取决于构造方法\nTreeSet():根据其元素的自然排序进行排序TreeSet(Comparator comparator): 根据指定的比较器进行排序\n\n没有带索引的方法，所以不能使用普通for循环遍历\n\n由于是Set集合,所以不包含重复元素的集合\n\n123456789101112131415161718192021222324public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // 创建集合对象        TreeSet&lt;Integer&gt; ts = new TreeSet&lt;&gt;();        // 添加元素        ts.add(10);        ts.add(40);        ts.add(20);        ts.add(30);        ts.add(50);        // 遍历集合        for (Integer s : ts) &#123;            System.out.println(s);        &#125;    &#125;&#125;---------------------------1020304050自然排序Comparable的使用存储学生对象并遍历，创建TreeSet集合使用无参构造方法\n要求:按照年龄从小到大排序，年龄相同时，按照姓名的字母顺序排序\n结论\n用TreeSet集合存储自定义对象， 无参构造方法使用的是自然排序对元素进行排序的\n自然排序，就是让元素所属的类实现Comparable接口， 重写compareTo(T o)方法\n重写方法时， 一定要注意排序规则必须按照要求的主要条件和次要条件来写\nStudent.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172public class Student implements Comparable&lt;Student&gt; &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    @Override    public int hashCode() &#123;        final int prime = 31;        int result = 1;        result = prime * result + age;        result = prime * result + ((name == null) ? 0 : name.hashCode());        return result;    &#125;    @Override    public boolean equals(Object obj) &#123;        if (this == obj)            return true;        if (obj == null)            return false;        if (getClass() != obj.getClass())            return false;        Student other = (Student) obj;        if (age != other.age)            return false;        if (name == null) &#123;            if (other.name != null)                return false;        &#125; else if (!name.equals(other.name))            return false;        return true;    &#125;    @Override    public int compareTo(Student o) &#123;        // return 0;        // return 1;        // return -1;        // 按照年龄从小到大输出        int num = this.age - o.age;        // 年龄相同时，按照姓名的字母顺序排序        int num2 = num == 0 ? this.name.compareTo(o.name) : num;        return num2;    &#125;&#125;CollectionDemo.java\n123456789101112131415161718192021222324252627import java.util.TreeSet;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // 创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;&gt;();        // 添加元素        Student s1 = new Student(\"西施\", 10);        Student s2 = new Student(\"猪八戒\", 40);        Student s3 = new Student(\"上合上\", 20);        Student s4 = new Student(\"唐僧\", 30);        Student s5 = new Student(\"林青霞\", 40);        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        // 遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + \",\" + s.getAge());        &#125;    &#125;&#125;比较器排序Comparator的使用存储学生对象并遍历，创建TreeSet集合使用带参构造方法\n要求:按照年龄从小到大排序，年龄相同时,按照姓名的字母顺序排序\n结论\n用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的\n比较器排序,就是让集合构造方法接收Comparator的实现类对象，重写compare(T o1,T o2)方法\n重写方法时， 一定要注意排序规则必须按照要求的主要条件和次要条件来写\nStudent.java\n1234567891011121314151617181920212223242526272829public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;&#125;CollectionDemo.java\n12345678910111213141516171819202122232425262728293031323334353637import java.util.Comparator;import java.util.TreeSet;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // 创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                int num = s1.getAge() - s2.getAge();                int num2 = num == 0 ? s1.getName().compareTo(s2.getName()) : num;                return num2;            &#125;        &#125;);        // 添加元素        Student s1 = new Student(\"西施\", 10);        Student s2 = new Student(\"猪八戒\", 40);        Student s3 = new Student(\"上合上\", 20);        Student s4 = new Student(\"唐僧\", 30);        Student s5 = new Student(\"林青霞\", 40);        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        // 遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + \",\" + s.getAge());        &#125;    &#125;&#125;案例:成绩排序;需求:用TreeSet集合存储多个学生信息(姓名,语文成绩，数学成绩，并遍历该集合\n要求:按照总分从高到低出现\n思路:\n①定义学生类②创建TreeSet集合对象， 通过比较器排序进行排序③创建学生对象④把学生对象添加到集合\nStudent.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243public class Student &#123;    private String name;    private int chinese;    private int math;    public Student() &#123;    &#125;    public Student(String name, int chinese, int math) &#123;        this.name = name;        this.chinese = chinese;        this.math = math;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getChinese() &#123;        return chinese;    &#125;    public void setChinese(int chinese) &#123;        this.chinese = chinese;    &#125;    public int getMath() &#123;        return math;    &#125;    public void setMath(int math) &#123;        this.math = math;    &#125;    public int getSum() &#123;        return this.chinese + this.math;    &#125;&#125;CollectionDemo.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243import java.util.Comparator;import java.util.TreeSet;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // 创建集合对象        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                // int num = s1.getSum()- s2.getSum();// 成绩升序排序                // 成绩升序排序 -(s1.gerSum()-s2.getSum());                // 主要条件                int num = s2.getSum() - s1.getSum();                // 次要条件                int num2 = num == 0 ? s1.getChinese() - s2.getChinese() : num;                int num3 = num2 == 0 ? s1.getName().compareTo(s2.getName()) : num2;                return num3;            &#125;        &#125;);        // 添加元素        Student s1 = new Student(\"西施\", 10, 55);        Student s2 = new Student(\"猪八戒\", 40, 66);        Student s3 = new Student(\"上合上\", 20, 77);        Student s4 = new Student(\"唐僧\", 30, 88);        Student s5 = new Student(\"林青霞\", 41, 65);        ts.add(s1);        ts.add(s2);        ts.add(s3);        ts.add(s4);        ts.add(s5);        // 遍历集合        for (Student s : ts) &#123;            System.out.println(s.getName() + \",\" + s.getChinese() + \"，\" + s.getMath() + \"，\" + s.getSum());        &#125;    &#125;&#125;案例:不重复的随机数需求:编写一个程序,获取10个1-20之间的随机数，要求随机数不能重复,并在控制台输出\n思路:①创建Set集合对象②创建随机数对象③判断集合的长度是不是小于10        是:产生一个随机数,添加到集合        回到3继续④遍历集合\n123456789101112131415161718192021import java.util.Random;import java.util.Set;import java.util.TreeSet;public class CollectionDemo &#123;    public static void main(String[] args) &#123;        // Set&lt;Integer&gt; set = new HashSet&lt;&gt;();        Set&lt;Integer&gt; set = new TreeSet&lt;&gt;();        Random r = new Random();        while (set.size() &lt; 10) &#123;            int t = r.nextInt(20) + 1;            set.add(t);        &#125;        for (Integer i : set) &#123;            System.out.println(i);        &#125;    &#125;&#125;🌸Map集合Map集合概述\nInterface Map&lt;K,V&gt;        K:键的类型; V:值的类型\n\n将键映射到值的对象; 不能包含重复的键;每个键可以映射到最多一个值\n\n举例: 学生的学号和姓名itheima001    林青霞itheima002    张曼玉itheima003    王祖贤\n\n12345678910111213141516171819import java.util.HashMap;import java.util.Map;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();        // 添加元素        map.put(\"1234\", \"张曼玉\");        map.put(\"2345\", \"阿西吧\");        map.put(\"3456\", \"萨迪吗\");        // 修改元素        map.put(\"3456\", \"三上悠亚\");        System.out.println(map);    &#125;&#125;基本功能\n方法名说明\n\nV put(K key,V value)添加元素\n\nV remove(Object key)根据键删除键值对元素\n\nvoid clear()移除所有的键值对元素\n\nboolean containsKey(Object key)判断集合是否包含指定的键\n\nboolean containsValue(Object value)判断集合是否包含指定的值\n\nboolean isEmpty()判断集合是否为空\n\nint size()集合的长度，也就是集合中键值对的个数\n12345678910111213141516171819202122232425262728293031323334353637383940import java.util.HashMap;import java.util.Map;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        // put        map.put(\"张无忌\", \"赵敏\");        map.put(\"郭靖\", \"黄蓉\");        map.put(\"杨哥\", \"小龙女\");        // remove        System.out.println(map.remove(\"张无忌\"));        System.out.println(map.remove(\"三上悠亚\"));        System.out.println(\"-------------\");        // clear        // map.clear();        // containsKey        System.out.println(\"包含指定的键 杨哥\" + map.containsKey(\"杨哥\"));        System.out.println(\"包含指定的键 三上悠亚\" + map.containsKey(\"三上悠亚\"));        System.out.println(\"-------------\");        // containsValue        System.out.println(\"包含指定的值 小龙女\" + map.containsValue(\"小龙女\"));        System.out.println(\"-------------\");        // isEmpty        System.out.println(\"是否为空\" + map.isEmpty());        System.out.println(\"-------------\");        // size        System.out.println(\"大小\" + map.size());        System.out.println(\"-------------\");        System.out.println(map);    &#125;&#125;获取功能\n方法名说明\n\nV get(Object key)根据键获取值\n\nSet&lt;K&gt; keySet()获取所有键的集合\n\nCollection&lt;V&gt; values()获取所有值的集合\n\nSet&lt; Map.Entry&lt;K,V&gt; &gt; entrySet()获取所有键值对对象的集合\n123456789101112131415161718192021222324252627282930313233343536import java.util.Collection;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        // put        map.put(\"张无忌\", \"赵敏\");        map.put(\"郭靖\", \"黄蓉\");        map.put(\"杨哥\", \"小龙女\");        // 获取value值        System.out.println(map.get(\"杨哥\"));        System.out.println(map.get(\"张三丰\"));        System.out.println(\"------------------\");        // HashMap 无需存放 所以输出无序！！！！！！！！        // 获取所有key的集合        Set&lt;String&gt; keySet = map.keySet();        for (String key : keySet) &#123;            System.out.println(key);        &#125;        System.out.println(\"------------------\");        // 获取所有value的集合        Collection&lt;String&gt; values = map.values();        for (String valus : values) &#123;            System.out.println(valus);        &#125;    &#125;&#125;遍历(方式1)我们刚才存储的元素都是成对出现的,所以我们把Map看成是一个夫妻对的集合\n遍历思路\n把所有的丈夫给集中起来\n遍历丈夫的集合，获取到每一个丈夫\n根据丈夫去找对应的妻子\n转换为Map集合中的操作:\n获取所有键的集合。 用keySet()方法实现遍历键的集合，获取到每一个键。 用增强for实现\n根据键去找值。 用get(Object key)方法实现\n123456789101112131415161718192021222324import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        // put        map.put(\"张无忌\", \"赵敏\");        map.put(\"郭靖\", \"黄蓉\");        map.put(\"杨哥\", \"小龙女\");        // 获取所有键的集合。用keySet()方法实现        Set&lt;String&gt; keySet = map.keySet();        // 遍历键的集合，获取到每个键。增强for实现        for (String key : keySet) &#123;            // 根据键去找值。用get方法实现            String value = map.get(key);            System.out.println(key + \",\" + value);        &#125;    &#125;&#125;(方式2)我们刚才存储的元素都是成对出现的，所以我们把Map看成是一个夫妻对的集合\n遍历思路\n获取所有结婚证的集合\n遍历结婚证的集合,得到每一个结婚证\n根据结婚证获取丈夫和妻子\n转换为Map集合中的操作:\n获取所有键值对对象的集合Set &lt;Map.Entry&lt;K,V&gt;&gt; entrySet():获取所有键值对对象的集合\n遍历键值对对象的集合, 得到每一个键值对对象用增强for实现，得到每一个Map.Entry\n根据键值对对象获取键和值用getKey()得到键用getValue()得到值\n12345678910111213141516171819202122import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        Map&lt;String, String&gt; map = new HashMap&lt;&gt;();        // put        map.put(\"张无忌\", \"赵敏\");        map.put(\"郭靖\", \"黄蓉\");        map.put(\"杨哥\", \"小龙女\");        // 获取所有 键值对对象的集合        Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();        for (Map.Entry&lt;String, String&gt; me : entrySet) &#123;            String key = me.getKey();            String value = me.getValue();            System.out.println(key + \",\" + value);        &#125;    &#125;&#125;1️⃣HashMap集合存储学生对象并遍历需求:创建一个HashMap集合,键是学号(String), 值是学生对象(Student)。存储三个键值对元素,并遍历\n思路:\n①定义学生类②创建HashMap集合对象③创建学生对象④把学生添加到集合⑤遍历集合        方式1:键找值        方式2:键值对对象找键和值\n1234567891011121314151617181920212223242526272829303132333435import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        HashMap&lt;String, Student&gt; hm = new HashMap&lt;&gt;();        Student s1 = new Student(\"林青霞\", 22);        Student s2 = new Student(\"张曼玉\", 34);        Student s3 = new Student(\"王祖贤\", 30);        hm.put(\"itheima001\", s1);        hm.put(\"itheima002\", s2);        hm.put(\"itheima003\", s3);        // 方式1遍历        Set&lt;String&gt; keySet = hm.keySet();        for (String key : keySet) &#123;            Student value = hm.get(key);            System.out.println(key + \",  \" + value.getName() + \",\" + value.getAge());        &#125;        System.out.println(\"--------------------\");        // 方式2遍历        Set&lt;Map.Entry&lt;String, Student&gt;&gt; entrySet = hm.entrySet();        for (Map.Entry&lt;String, Student&gt; me : entrySet) &#123;            String key = me.getKey();            Student value = hm.get(key);            System.out.println(key + \",  \" + value.getName() + \",\" + value.getAge());        &#125;    &#125;&#125;2️⃣HashMap集合存储学生对象并遍历需求:创建-个HashMap集合,键是学生对象(Student),值是居住地(String)。存储多个键值对元素,并遍历。\n​        要求保证键的唯一性: 如果学生对象的成员变量值相同，我们就认为是同一个对象\n思路:\n①定义学生类②创建HashMap集合对象③创建学生对象④把学生添加到集合⑤遍历集合⑥在学生类中重写两个方法    hashCode()    equals()\n12345678910111213141516171819202122232425262728import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        HashMap&lt;Student, String&gt; hm = new HashMap&lt;&gt;();        Student s1 = new Student(\"林青霞\", 22);        Student s2 = new Student(\"张曼玉\", 34);        Student s3 = new Student(\"王祖贤\", 30);        Student s4 = new Student(\"王祖贤\", 30);        hm.put(s1, \"西安\");        hm.put(s2, \"武汉\");        hm.put(s3, \"郑州\");        hm.put(s4, \"北京\");        // 方式1遍历        Set&lt;Student&gt; keySet = hm.keySet();        for (Student key : keySet) &#123;            String value = hm.get(key);            System.out.println(key.getName() + \", \" + key.getAge() + \",\" + value);        &#125;    &#125;&#125;🅰️ArrayList集合存储HashMap元素并遍历需求:创建一个ArrayList集合,存储三个元素,每一个元素都是HashMap,每一个HashMap的键和值都是String,并遍历\n思路:\n①创建ArrayList集合②创建HashMap集合, 并添加键值对元素③把HashMap作为元素添加到ArrayList集合④遍历ArrayList集合\n123456789101112131415161718192021222324252627282930313233import java.util.ArrayList;import java.util.HashMap;import java.util.Map;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        ArrayList&lt;HashMap&lt;String, String&gt;&gt; array = new ArrayList&lt;HashMap&lt;String, String&gt;&gt;();        HashMap&lt;String, String&gt; hm1 = new HashMap&lt;&gt;();        hm1.put(\"孙策\", \"大桥\");        hm1.put(\"周瑜\", \"小乔\");        array.add(hm1);        HashMap&lt;String, String&gt; hm2 = new HashMap&lt;&gt;();        hm2.put(\"郭靖\", \"黄蓉\");        hm2.put(\"杨哥\", \"小龙女\");        array.add(hm2);        HashMap&lt;String, String&gt; hm3 = new HashMap&lt;&gt;();        hm3.put(\"三上\", \"悠亚\");        hm3.put(\"初爱\", \"打脸\");        array.add(hm3);        for (HashMap&lt;String, String&gt; hm : array) &#123;            Set&lt;String&gt; keySet = hm.keySet();            for (String key : keySet) &#123;                String value = hm.get(key);                System.out.println(key + \",\" + value);            &#125;        &#125;    &#125;&#125;🅱️HashMap集合存储ArrayList元素并遍历需求:创建- -个HashMap集合,存储三个键值对元素，每-一个键值对元素的键是String,值是ArrayList,每一个ArrayList的元素是String，并遍历思路:①创建HashMap集合②创建ArrayList集合, 并添加元素③把ArrayList作为元素添加到HashMap集合④遍历HashMap集合\n1234567891011121314151617181920212223242526272829303132333435import java.util.ArrayList;import java.util.HashMap;import java.util.Set;public class MapDemo &#123;    public static void main(String[] args) &#123;        HashMap&lt;String, ArrayList&lt;String&gt;&gt; hm = new HashMap&lt;&gt;();        ArrayList&lt;String&gt; sgyy = new ArrayList&lt;&gt;();        sgyy.add(\"诸葛亮\");        sgyy.add(\"赵云\");        hm.put(\"三国演义\", sgyy);        ArrayList&lt;String&gt; xyj = new ArrayList&lt;&gt;();        xyj.add(\"孙悟空\");        xyj.add(\"猪八戒\");        hm.put(\"西游记\", xyj);        ArrayList&lt;String&gt; shz = new ArrayList&lt;&gt;();        shz.add(\"武松\");        shz.add(\"鲁智深\");        hm.put(\"水浒传\", shz);        Set&lt;String&gt; keySet = hm.keySet();        for (String key : keySet) &#123;            ArrayList&lt;String&gt; value = hm.get(key);            // System.out.println(key+\": \"+value);            System.out.println(key);            for (String s : value) &#123;                System.out.println(\"\\t\" + s);            &#125;        &#125;    &#125;&#125;统计字符串中每个字符出现的次数需求:键盘录入一个字符串，要求统计字符串中每个字符串出现的次数。\n举例: 键盘录入“aababcabcdabcde”        在控制台输出:” a(5)b(4)c(3)d(2)e(1)”\n分析:\n①我们可以把结果分成几个部分来看: a(5),b(),c(3),d(2),e(1)②每一个部分可以看成是:字符和字符对应的次数组成③这样的数据，我们可以通过HashMap集合来存储,键是字符,值是字符出现的次数    注意:键是字符,类型应该是Character;值是字符出现的次数,类型应该是Integer\n思路:\n①键盘录入一个字符串②创建HashMap集合， 键是Character,值是Integer③遍历字符串，得到每-一个字符④拿得到的每一 个字符作为键到HashMap集合中去找对应的值,看其返回值    如果返回值是null:说明该字符在HashMap集合中不存在,就把该字符作为键，1作为值存储    如果返回值不是null:说明该字符在HashMap集合中存在,把该值加1,然后重新存储该字符和对应的值⑤遍历HashMap集合,得到键和值,按照要求进行拼接⑥输出结果\n12345678910111213141516171819202122232425262728293031323334import java.util.Scanner;import java.util.Set;import java.util.TreeMap;public class MapDemo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入一个字符串：\");        String line = sc.nextLine();        // HashMap&lt;Character, Integer&gt; hm = new HashMap&lt;&gt;();        // 自然顺序排序        TreeMap&lt;Character, Integer&gt; hm = new TreeMap&lt;&gt;();        for (int i = 0; i &lt; line.length(); i++) &#123;            char key = line.charAt(i);            Integer value = hm.get(key);            if (value == null) &#123;                hm.put(key, 1);            &#125; else &#123;                value++;                hm.put(key, value);            &#125;        &#125;        StringBuilder sb = new StringBuilder();        Set&lt;Character&gt; keySet = hm.keySet();        for (Character key : keySet) &#123;            Integer value = hm.get(key);            sb.append(key).append(\"(\").append(value).append(\")\");        &#125;        String result = sb.toString();        System.out.println(result);    &#125;&#125;继承extends继承中子类的特点:\n子类可以有父类的内容\n子类还可以有自己特有的内容\n1public class 子类名 extends 父类名&#123;&#125;\n例\n\nfu.java\n123456public class fu &#123;    public void show()&#123;        System.out.println(\"show方法被调用\");    &#125;&#125;zi.java\n12345public class zi extends fu&#123;    public void method()&#123;        System.out.println(\"method方法被调用\");    &#125;&#125;Demo.java\n12345678910111213public class Demo &#123;    public static void main(String[] args) &#123;        fu f=new fu();        f.show();        zi z=new zi();        z.method();        z.show();    &#125;&#125;-----------------------------------------------------------------show方法被调用method方法被调用show方法被调用继承中变量的访问特点在子类方法中访问一个变量 \n子类局部范围找 \n子类成员范围找 \n父类成员范围找\n如果都没有就报错，不考虑父亲的父亲\n\n例\n\nfu.java\n123public class fu &#123;    public int age = 30;&#125;zi.java\n123456789public class zi extends fu &#123;    public int age = 20;    public String name = \"父亲\";    public void show() &#123;        int age = 10;        System.out.println(name + \",\" + age);    &#125;&#125;Demo.java\n12345678public class Demo &#123;    public static void main(String[] args) &#123;        zi z = new zi();        z.show();    &#125;&#125;------------------------------------------------------------------------父亲,10继承的注意事项Java中类只支持单继承，不支持多继承\nJava中类支持多层继承\ngrand.java\n12345public class grand &#123;    public void drink() &#123;        System.out.println(\"爷爷爱喝酒\");    &#125;&#125;father.java\n12345public class father extends grand &#123;    public void smoke() &#123;        System.out.println(\"爷爷爱抽烟\");    &#125;&#125;son.java\n123public class son extends father &#123;    son s = new son();&#125;访问父类 superthis：本类对象的引用\nsuper：父类存储空间的标识（父类对象引用）\n\n关键字访问成员变量访问构造方法访问成员方法\n\nthisthis.成员方法 访问本类成员变量this(...) 访问本类构造方法this.成员方法(...) 访问本类成员方法\n\nsupersuper.成员方法 访问父类成员变量super(...) 访问父类构造方法super.成员方法(...) 访问父类成员方法\n继承中构造方法的访问特点子类中所有的构造方法默认都会访问父类中无参的构造方法为什么呢?\n因为子类会继承父类中的数据,可能还会使用父类的数据。所以，子类初始化之前，一定要先完成父类数据的初始化\n每一个子类构造方法的第一条语句默认都是: super()\n如果父类中没有无参构造方法，只有带参构造方法，该怎么办呢?\n通过使用super关键字去显示的调用父类的带参构造方法\n在父类中自己提供一个无参构造方法推荐:自己给出无参构造方法\n\n例\n\nfu.java\n12345678910public class fu &#123;/*    public fu() &#123;        System.out.println(\"fu中无参构造方法被调用\");    &#125;*/  \t\t//带参构造方法    public fu(int age) &#123;        System.out.println(\"fu中带参构造方法被调用\");    &#125;&#125;zi.java\n12345678910111213public class zi extends fu &#123;  \t//无参构造方法    public zi() &#123;        super(20);//调用父类有参构造方法        System.out.println(\"zi中无参构造方法被调用\");    &#125;  \t\t//带参构造方法    public zi(int age) &#123;        super(20);//调用父类有参构造方法        System.out.println(\"zi中带参构造方法被调用\");    &#125;&#125;Demo.java\n1234567891011public class Demo &#123;    public static void main(String[] args) &#123;        zi z = new zi();        zi z2 = new zi(20);    &#125;&#125;------------------------------------------------------------------------fu中带参构造方法被调用zi中无参构造方法被调用fu中带参构造方法被调用zi中带参构造方法被调用继承中成员方法的访问特点通过子类对象访问一个方法\n子类成员范围找\n\n父类成员范围找\n\n如果都没有就报错(不考虑父亲的父亲..)\n\n\n例\n\nfu.java\n12345public class fu &#123;    public void show()&#123;        System.out.println(\"fu中show方法被调用\");    &#125;&#125;zi.java\n123456789public class zi extends fu &#123;    public void method()&#123;        System.out.println(\"zi中的method方法被调用\");    &#125;    public void show()&#123;        super.show();        System.out.println(\"zi中的show方法被调用\");    &#125;&#125;Demo.java\n123456789public class Demo &#123;    public static void main(String[] args) &#123;        zi z = new zi();        z.show();    &#125;&#125;------------------------------------------------------------------------zi中的show方法被调用fu中show方法被调用方法的重写子类中出现了和父类中一模一样的方法声明，重新定义父方法\n父类中的私有private 不可以被重写\n@Override \n是一个注解(注解后面会学习到）\n可以帮助我们检查重写方法的方法声明的正确性\n方法重写注意事项\n私有方法不能被重写 (父类私有成员子类是不能继承的)\n子类方法访问权限不能更低(public&gt;默认&gt;私有)\n\n例\n\nPhone.java\n12345public class Phone &#123;    public void call(String name) &#123;        System.out.println(\"给\" + name + \"打电话\");    &#125;&#125;NewPhone.java\n123456789public class NewPhone extends Phone &#123;    @Override   //方法重写    public void call(String name) &#123;        System.out.println(\"开视频\");//        System.out.println(\"给\"+name+\"打电话\");        super.call(name);    &#125;&#125;PhoneDemo.java\n12345678910public class PhoneDemo &#123;    public static void main(String[] args) &#123;        //创建对象，调用方法        Phone p = new Phone();        p.call(\"林青霞\");        NewPhone p1 = new NewPhone();        p1.call(\"林青霞\");    &#125;&#125;包package其实就是文件夹.\n作用:对类进行分类管理\n包的定义格式\n格式: package 包名; 多级包用 .  分开\n范例: package com.itheima;\n建包\n 手动建包\n\n按照以前的格式编译java文件    javac HelloWorld.java\n手动创建包                                    在E盘建立文件夹com ，然后在com下建文件夹itheima\n把class文件放到包的最里面        把HelloWorld.class文件放到com下的itheima这个文件夹下\n带包执行                                        java com.itheima.HelloWorld\n\n 自动建包    \n\njavac -d . HelloWorld.java\njava com.itherma.HelloWorld\n导包12import 包名；import test4.Person;\n例\n\ntest4 中的 Person.java\n1234567package test4;public class Person &#123;    public Person()&#123;        System.out.println(\"成功\");    &#125;&#125;test5 中的 Demo.java\n1234567891011package test5;import test4.Person;public class Demo &#123;    public static void main(String[] args) &#123;        //方法一 引用其他包中的类        test4.Person p = new test4.Person();        //方法二 import test4.Person;        Person p1 = new Person();    &#125;&#125;修饰符权限修饰符\n修饰符同一个类中同一个包中 子类、无关类不同包的子类不同包的无关类\n\nprivate✔️\n\n默认✔️✔️\n\nprotected✔️✔️✔️\n\npublic✔️✔️✔️✔️\n状态修饰符final最终\n修饰类:表明该类是最终类，不能被继承\n\n修饰方法:表明该方法是最终方法，不能被重写\n\n修饰变量:表明该变量是常量，不能再次被赋值\n\nfinal修饰局部变量\n变量是基本类型: final修饰指的是基本类型的数据值不能发生改变\n变量是引用类型: final修饰指的是引用类型的地址值不能发生改变,但是地址里面的内容是可以发生改变的\nStudent.java\n123456789//final修饰类不能被继承 表示最终类public final class Student &#123;    public int age = 10;    //final修饰方法不能被重写    public void setAge() &#123;        this.age = age;    &#125;&#125;Demo.java\n123456789101112public class Demo &#123;    public static void main(String[] args) &#123;        //final修饰变量不能被更改        final String name = \"三上悠亚\";              //final修饰引用变量，s不能更改指向的地址 但s的成员可被修改        final Student s = new Student();        s.age = 20;        System.out.println(s.age);    &#125;&#125;ststic表示静态，修饰成员方法 成员变量\nstatic修饰的特点\n被类的所有对象共享这也是我们判断是否使用静态关键字的条件\n可以通过类名调用当然，也可以通过对象名调用推荐使用类名调用\nstatic访问特点    总结成一句话就是:静态成员方法只能访问静态成员\n非静态的成员方法能访问静态的成员变量\n能访问非静态的成员变量\n能访问静态的成员方法\n能访问非静态的成员方法\n\n静态的成员方法能访问静态的成员变量\n能访问静态的成员方法\n\nStudent.java\n12345678910public final class Student &#123;    public String name;    public int age;  //static修饰成员变量    public static String university;    public void show() &#123;        System.out.println(name + \", \" + age + \", \" + university);    &#125;&#125;Demo.java\n123456789101112131415public class Demo &#123;    public static void main(String[] args) &#123;        //类名调用static变量        Student.university = \"清华\";        Student s1 = new Student();        s1.name = \"初爱\";        s1.age = 30;        //对象名调用static变量        s1.university = \"北大\";        s1.show();    &#125;&#125;------------------------------------------------------------------初爱, 30, 北大多态多态中成员访问特点\n成员变量: 编译看左边，执行看左边\n成员方法: 编译看左边(是否存在该方法) ，执行看右边(方法是否被重写)\n\n为什么成员变量和成员方法的访问不一样呢?\n\n​    因为成员方法有重写，而成员变量没有\n多态的好处: 提高了程序的扩展性具体体现: 定义方法的时候，使用父类型作为参数,将来在使用的时候，使用具体的子类型参与操作\n\n多态的弊端:不能使用子类的特有功能\nAnimal.java\n1234567public class Animal &#123;    public int age = 40;    public void eat() &#123;        System.out.println(\"动物吃东西\");    &#125;&#125;cat.java\n12345678910111213public class Cat extends Animal &#123;    public int age = 20;    public int weight = 10;    @Override    public void eat() &#123;        System.out.println(\"猫吃鱼\");    &#125;    public void playGame() &#123;        System.out.println(\"玩游戏\");    &#125;&#125;AnimalDemo.java\n123456789101112131415161718public class AnimalDemo &#123;    public static void main(String[] args) &#123;        //父类引用指向子类对象        Animal a = new Cat();        System.out.println(a.age); //40              //Animal类中没有weight成员变量//        System.out.println(a.weight);              a.eat();\t//猫吃鱼              //Animal类中没有playGame成员方法//        a.playGame();    &#125;&#125;----------------------------------------------------------------------40猫吃鱼多态的转型向上转型从子到父\n父类引用指向子类对象\n\n向下转型从父到子\n父类引用转为子类对象\n\nAnimal.java\n1234567public class Animal &#123;    public int age = 40;    public void eat() &#123;        System.out.println(\"动物吃东西\");    &#125;&#125;Cat.java\n12345678910111213public class Cat extends Animal &#123;    public int age = 20;    public int weight = 10;    @Override    public void eat() &#123;        System.out.println(\"猫吃鱼\");    &#125;    public void playGame() &#123;        System.out.println(\"玩游戏\");    &#125;&#125;AnimalDemo.java\n12345678910111213141516public class AnimalDemo &#123;    public static void main(String[] args) &#123;        //父类引用指向子类对象        Animal a = new Cat();   //向上转型        a.eat();        //向下转型        Cat c = (Cat) a;        c.eat();        c.playGame();    &#125;&#125;------------------------------猫吃鱼猫吃鱼玩游戏抽象类abstract在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法,该类必须定义为抽象类\n\n抽象类的特点\n\n抽象类和抽象方法必须使用abstract关键字修饰\n12public abstract class 类名&#123;&#125;public abstract void eat();抽象类中不一定有抽象方法,有抽象方法的类一定是抽象类\n\n抽象类不能实例化\n抽象类如何实例化呢?参照多态的方式，通过子类对象实例化，这叫抽象多态\n\n抽象类的子类\n要么重写抽象类中的所有抽象方法\n要么是抽象类\n\n\n抽象类的成员特点\n\n成员变量可以是变量\n也可以是常量\n\n构造方法有构造方法，但是不能实例化\n那么，构造方法的作用是什么呢? 用于子类访问父类数据的初始化\n\n成员方法可以有抽象方法: 限定子类必须完成某些动作\n也可以有非抽象方法: 提高代码复用性\n\nAnimal.java\n123456789//定义抽象类public abstract class Animal &#123;    //定义抽象方法    public abstract void eat();    public void sleep() &#123;        System.out.println(\"睡觉\");    &#125;&#125;Cat.java\n1234567public class Cat extends Animal &#123;  //抽象类的子类,要么重写抽象类中的所有抽象方法,要么是抽象类public abstract class Cat extends Animal    @Override    public void eat() &#123;        System.out.println(\"猫吃鱼\");    &#125;&#125;AnimalDemo.java\n1234567public class AnimalDemo &#123;    public static void main(String[] args) &#123;        Animal a = new Cat();        a.eat();        a.sleep();    &#125;&#125;接口接口的特点\n接口用关键字interface修饰\n12345public interface 接口名&#123;&#125;----------------------------------------------------------------public interface Jumpping &#123;    public abstract void jump();&#125;\n类实现接口用implements表示\n12345678public class 类名 implements 接口名&#123;&#125;----------------------------------------------------------------public class Cat implements Jumpping &#123;    @Override    public void jump() &#123;        System.out.println(\"猫可以跳高了\");    &#125;&#125;\n接口不能实例化\n接口如何实例化呢?参照多态的方式，通过实现类对象实例化，这叫接口多态。多态的形式:具体类多态,抽象类多态,接口多态。多态的前提:有继承或者实现关系;有方法重写;有父 (类/接口) 引用指向 (子实现) 类对象\n\n接口的实现类要么重写接口中的所有抽象方法要么是抽象类\n\n接口的成员特点\n成员变量只能是常量\n默认修饰符: public static final\n\n构造方法接口没有构造方法，因为接口主要是对行为进行抽象的,是没有具体存在\n一个类如果没有父类，默认继承自Object类\n\n成员方法只能是抽象方法\n默认修饰符: public abstract\n关于接口中的方法，JDK8和JDK9中有一些新特性，后面再讲解\n\nInterface.java\n123456789101112131415161718public interface Interface &#123;    // 成员变量默认带了 public static final    int num3 = 30;    public int num = 10;    public final int num2 = 20;    // 接口没有构造方法    // public Interface()&#123;&#125;;    // 接口里面没有成员方法    // public void show()&#123;&#125;;    // 接口可以有抽象方法    public abstract void method();    // 接口中的方法默认带了 public abstract 所以可以不写    void show();&#125;InterImple.java\n123456789101112public class InterImple implements Interface &#123;    @Override    public void method() &#123;        System.out.println(\"method\");    &#125;    @Override    public void show() &#123;        System.out.println(\"show\");    &#125;&#125;InterDemo.java\n1234567891011121314151617public class InterDemo &#123;    public static void main(String[] args) &#123;        Interface i = new InterImple();        // 接口的成员变量默认被public static final修饰 不能赋值        // i.num=10;        // i.num3 = 40;        System.out.println(i.num);        System.out.println(i.num2);        System.out.println(Interface.num);        System.out.println(i.num3);    &#125;&#125;----------------------------------------------------------------10201030猫和狗（接口类）Jumpping.java\n1234public interface Jumpping &#123;   //抽象方法   public abstract void jump();&#125;Animal.java\n12345678910111213141516171819202122232425262728293031public abstract class Animal &#123;    public String name;    public int age;    public Animal() &#123;    &#125;    public Animal(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public abstract void eat();&#125;Cat.java\n123456789101112131415161718192021package com.test1;public class Cat extends Animal implements Jumpping &#123;    public Cat() &#123;    &#125;    public Cat(String name, int age) &#123;        super(name, age);    &#125;    @Override    public void eat() &#123;        System.out.println(\"猫吃鱼\");    &#125;    @Override    public void jump() &#123;        System.out.println(\"猫跳高\");    &#125;&#125;AnimalDemo.java\n123456789101112131415161718192021222324public class AnimalDemo &#123;    public static void main(String[] args)&#123;        //创建对象 调用方法        Jumpping j = new Cat();        j.eat(); //接口中没有eat方法，所以不能调用        j.jump();        System.out.println(\"-------------------\");        Animal a = new Cat();        a.setName(\"加菲\");        a.setAge(10);        System.out.println(a.getName()+\", \"+a.getAge());        a.eat();        a.jump();//父类中没有jump方法，所以不能调用        System.out.println(\"-------------------\");        Cat c =new Cat();        c.setName(\"加菲\");        c.setAge(5);        System.out.println(c.getName()+\", \"+c.getAge());        c.eat();        c.jump();    &#125;&#125;类和接口的关系类和类的关系继承关系，只能单继承，但是可以多层继承\n\n类和接口的关系实现关系，可以单实现，也可以多实现，还可以在继承一个类的同时实现多个接口\n\n接口和接口的关系继承关系，可以单继承,也可以多继承\n\n123public interface Inter2 extends Inter1 &#123;&#125;public class InterImpl extends Object implements Inter1,Inter2,Inter3&#123;&#125;抽象类和接口的区别成员区别\n抽象类 ：变量,常量;有构造方法;有抽象方法,也有非抽象方法\n接口：常量;抽象方法\n\n关系区别\n类与类：继承，单继承\n类与接口：实现，可以单实现，也可以多实现\n接口与接口：继承，单继承，多继承\n\n设计理念区别\n抽象类：对类抽象，包括属性、行为\n接口： 对行为抽象，主要是行为\n\n抽象类是对事物的抽象,而接口是对行为的抽象\n123456789101112131415161718192021public interface Alram&#123;    void alarm();//报警功能&#125;public abstract class Door&#123;    public abstract void open();    public abstract void close();&#125;public class AlarmDoor extends Door implements Alram&#123;    @Override    public void open() &#123;        // TODO Auto-generated method stub    &#125;    @Override    public void close() &#123;        // TODO Auto-generated method stub    &#125;    @Override    public void alarm() &#123;        // TODO Auto-generated method stub    &#125;&#125;形参和返回值类名作为形参和返回值方法的形参是类名，其实需要的是该类的对象\n方法的返回值是类名， 其实返回的是该类的对象\nCat.java\n12345public class Cat &#123;    public void eat() &#123;        System.out.println(\"猫吃鱼\");    &#125;&#125;CatOperator.java\n1234567891011public class CatOperator &#123;    public void useCat(Cat c) &#123;        c.eat();    &#125;    public Cat getCat() &#123;        Cat c = new Cat();        return c;    &#125;&#125;CatDemo.java\n12345678910public class CatDemo &#123;    public static void main(String[] args) &#123;        CatOperator co = new CatOperator();        Cat c = new Cat();        co.useCat(c);        Cat c2 = co.getCat();        c2.eat();    &#125;&#125;抽象类名作为形参和返回值方法的形参是抽象类名，其实需要的是该抽象类的子类对象\n方法的返回值是抽象类名,实返回的是该抽象类的子类对象\nAnimal.java\n123public abstract class Animal &#123;    public abstract void eat();&#125;Cat.java\n12345678public class Cat extends Animal&#123;    @Override    public void eat() &#123;        System.out.println(\"猫吃鱼\");    &#125;    &#125;AnimalOperator.java\n1234567891011public class AnimalOperator &#123;    public void useAnimal(Animal a) &#123;//new Cat();        a.eat();    &#125;    public Animal getAnimal() &#123;        Animal a = new Cat();        return a;    &#125;&#125;AnimalDemo.java\n12345678910public class AnimalDemo &#123;    public static void main(String[] args) &#123;        AnimalOperator ao = new AnimalOperator();        Animal a = new Cat();        ao.useAnimal(a);        Animal a2 = ao.getAnimal();// Animal a2 = new Cat();        a2.eat();    &#125;&#125;接口名作为形参和返回值方法的形参是接口名,其实需要的是该接口的实现类对象\n方法的返回值是接口名，其实返回的是该接口的实现类对象\nJumpping.java\n12345public interface Jumpping &#123;    public abstract void jump();    &#125;Cat.java\n12345678public class Cat implements Jumpping&#123;    @Override    public void jump() &#123;        System.out.println(\"猫可以跳高\");    &#125;        &#125;JumppingOpetator.java\n12345678910public class JumppingOpetator &#123;    public void useJumpping(Jumpping j)&#123;//new Cat();        j.jump();    &#125;    public Jumpping getJumpping()&#123;        Jumpping j = new Cat();        return j;    &#125;    &#125;JumppingDemo.java\n123456789101112public class JumppingDemo &#123;    public static void main(String[] args) &#123;        JumppingOpetator jo = new JumppingOpetator();        Jumpping j = new Cat();        jo.useJumpping(j);        Jumpping j2 = jo.getJumpping();//new Cat();        j2.jump();    &#125;&#125;内部类就是在一个类中定义一个类。举例:在一个类A的内部定义一个类B类就被称为内部类\n123456789public class 类名&#123;    修饰符 class 类名&#123;      &#125;&#125;---------------------------------------------------------public class Outer&#123;    public class Inner&#123;     &#125;&#125;内部类的访问特点\n内部类可以直接访问外部类的成员，包括私有\n外部类要访问内部类的成员，必须创建对象\n1234567891011121314public class Outer &#123;    private int num = 10;    public class Inner &#123;        public void show() &#123;            System.out.println(num);        &#125;    &#125;    public void method() &#123;        Inner i = new Inner();        i.show();    &#125;&#125;成员内部类按照内部类在类中定义的位置不同，可以分为如下两种形式\n在类的成员位置: 成员内部类\n在类的局部位置: 局部内部类\n\n成员内部类，外界如何创建对象使用呢?\n\n格式:  外部类名.内部类名 对象名 = 外部类对象.内部类对象;\n范例: Oyter.Inner oi = new Outer().new Inner();\nOuter.java\n123456789101112131415161718192021public class Outer &#123;    private int num = 10;    public class Inner &#123;        public void show() &#123;            System.out.println(num);        &#125;    &#125;    private class Inner1 &#123;        public void show() &#123;            System.out.println(num);        &#125;    &#125;    public void method() &#123;        Outer.Inner1 i = new Outer().new Inner1();        i.show();    &#125;&#125;InnerOuter.java\n12345678public class InnerDemo &#123;    public static void main(String[] args) &#123;        Outer.Inner oi = new Outer().new Inner();        oi.show();        Outer o = new Outer();        o.method();    &#125;&#125;局部内部类局部内部类是在方法中定义的类，所以外界是无法直接使用，需要在方法内部创建对象并使用\n该类可以直接访问外部类的成员，也可以访问方法内的局部变量\nOuter.java\n123456789101112131415161718public class Outer &#123;    private int num = 10;    public void method() &#123;        int num2 = 20;        class Inner &#123;            public void show() &#123;                System.out.println(num);                System.out.println(num2);            &#125;        &#125;        Inner i = new Inner();        i.show();    &#125;&#125;InnerDemo.java\n123456public class InnerDemo &#123;    public static void main(String[] args) &#123;        Outer o = new Outer();        o.method();    &#125;&#125;匿名内部类是局部内部类的一种\n前提：存在一个类或接口，这里的类可以是具体类也可以是抽象类\n12345678new 类名或接口名()&#123;\t重新方法;&#125;;---------------------------------new Inter()&#123;\tpublic void show()&#123;\t&#125;&#125;;本质：是一个继承了该类或实现了该接口的子类匿名对象\nOuter.java\n12345678910111213141516171819202122232425262728293031323334353637public class Outer &#123;    private int num = 10;    public void method() &#123;        // 创建匿名内部类        /*         * new Inner()&#123;         *          * @Override         * public void show() &#123;         * System.out.println(\"匿名内部类\");         * &#125;         * &#125;;         */        // 调用匿名内部类的方法        new Inner() &#123;            @Override            public void show() &#123;                System.out.println(\"匿名内部类\");            &#125;        &#125;.show();        // 多次调用匿名内部类        Inner i = new Inner() &#123;            @Override            public void show() &#123;                System.out.println(\"匿名内部类\");            &#125;        &#125;;        i.show();// 可多次调用    &#125;&#125;Inner.java\n123public interface Inner &#123;    void show();&#125;InnerDemo.java\n123456public class InnerDemo &#123;    public static void main(String[] args) &#123;        Outer o = new Outer();        o.method();    &#125;&#125;工具类工具类的设计思想:\n构造方法用private修饰，（即不可构建实例对象）\n成员用public static修饰，（为了直接调用）\nMath\n方法名说明\n\npublic static int abs(int a)返回参数的绝对值\n\npublic static double ceil(double a)返回大于或等于参数的最小double值，等于一个整数\n\npublic static double floor(double a)返回小于或等于参数的最大double值，等于一个整数\n\npublic static int round(float a)按照四舍五入返回最接近参数的int\n\npublic static int max(int a,int b)返回两个int值中的较大值\n\npublic static int min(int a,int b)返回两个int值中的较小值\n\npublic static double pow(double a,double b)返回a的b次幂的值\n\npublic static double random()返回值为double的正值，[0.0 , 1.0)\n1234567891011121314151617181920public class MathDemo &#123;    public static void main(String[] args) &#123;        System.out.println(Math.abs(-88)); // 88        System.out.println(Math.ceil(12.34));// 13.0        System.out.println(Math.floor(12.34));// 12.0        System.out.println(Math.round(12.34F));// 12        System.out.println(Math.round(12.54));// 13        System.out.println(Math.max(66, 88));// 88        System.out.println(Math.pow(2.0, 3.0));// 8.0        System.out.println(Math.random());// 0.0到1.0的随机数 取不到1.0    &#125;&#125;System\n方法名说明\n\npublic static void exit(int status)终止当前运行的Java虚拟机，非零表示异常终止\n\npublic static long currentTimeMillis()返回当前时间(以毫秒为单位)\n1234567891011public class MathDemo &#123;    public static void main(String[] args) &#123;        long start = System.currentTimeMillis();        for (int i = 0; i &lt; 10000; i++) &#123;            System.out.println(i);        &#125;        long end = System.currentTimeMillis();        System.out.println(\"共耗时：\" + (end - start) + \"毫秒\");    &#125;&#125;ArraysArray类包含用于操作数组的各种方法\n\n方法名说明\n\npublic static String toString(int[] a)返回指定数组的内容的字符串表示形式 例[I@76ccd017\n\npublic static void sort(int[] a)按照数字顺序排列指定的数组\n12345678public static void main(String[] args) &#123;  // 定义一个数组  int[] arr = &#123; 24, 69, 80, 57 &#125;;  Arrays.sort(arr);  System.out.println(Arrays.toString(arr));&#125;----------------------------------------------[24, 57, 69, 80]冒泡排序冒泡排序（Bubble Sort），顾名思义，就是指越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法原理\n从左到右，依次比较相邻的元素大小，更大的元素交换到右边；\n从第一组相邻元素比较到最后一组相邻元素，这一步结束最后一个元素必然是参与比较的元素中最大的元素；\n按照大的居右原则，重新从左到后比较，前一轮中得到的最后一个元素不参与比较，得出新一轮的最大元素；\n按照上述规则，每一轮结束会减少一个元素参与比较，直到没有任何一组元素需要比较。\n动图演示\n\n代码实现\n12345678910111213141516171819202122public class ArryDemo &#123;    public static void main(String[] args) &#123;        // 定义一个数组        int[] arr = &#123; 24, 69, 80, 57 &#125;;        bubble_sort(arr);        System.out.println(Arrays.toString(arr));    &#125;    public static void bubble_sort(int arr[]) &#123;        int i, j;        for (i = 0; i &lt; arr.length - 1; i++) &#123;            for (j = 0; j &lt; arr.length - i - 1; j++) &#123;                if (arr[j] &gt; arr[j + 1]) &#123;                    int temp;                    temp = arr[j];                    arr[j] = arr[j + 1];                    arr[j + 1] = temp;                &#125;            &#125;        &#125;    &#125;&#125;算法分析\n冒泡排序属于交换排序，是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n但是我们常看到冒泡排序的最优时间复杂度是 O(n)，那要如何优化呢？\n我们可以用一个 flag 参数记录新一轮的排序中元素是否做过交换，如果没有，说明前面参与比较过的元素已经是正序，那就没必要再从头比较了。代码实现如下：\n1234567891011121314151617public static void bubble_sort(int arr[]) &#123;    int i, j, flag;    for (i = 0; i &lt; arr.length - 1; i++) &#123;        flag = 0;        for (j = 0; j &lt; arr.length - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                int temp;                temp = arr[j];                arr[j] = arr[j + 1];                arr[j + 1] = temp;                flag = 1;            &#125;        &#125;        if (flag == 0)            return;    &#125;&#125;日期类DateDate代表了一个特定的时间，精确到毫秒\n构造方法\n方法名说明\n\npublic Date()分配一个Date对象，并初始化，以便它代表它被分配的时间，精确到毫秒\n\npublic Date(long date)分配一个Date对象，并将其初始化为表示从标准基准时间起指定的毫秒数\n12345678910111213141516public class ArryDemo &#123;    public static void main(String[] args) &#123;        // public Date(): 分配一个Date对象, 并初始化，以便它代表它被分配的时间， 精确到毫秒        Date d1 = new Date();        System.out.println(d1);        // public Date(long date): 分配一个 Date 对象 ， 并将其初始化为表示从标准基准时间起指定的毫秒数        long date = 1000 * 60 * 60;        // January 1, 1970, 00:00:00 GMT.+ 往后一小时        Date d2 = new Date(date);        System.out.println(d2);    &#125;&#125;-------------------------------------------------------------Thu Jan 20 17:27:46 CST 2022Thu Jan 01 09:00:00 CST 1970常用方法\n方法名说明\n\npublic long getTime()获取的是日期对象从1970年1月1日00:00:00到现在的毫秒值\n\npublic void setTime(long time)设置时间，给的是毫秒值\n\n 实例对象.getTime 和 System.currentTimeMillis() 都能返回以毫秒为单位的当前时间\n\n123456789101112131415public class ArryDemo &#123;    public static void main(String[] args) &#123;        // 分配一个Date对象并对其进行初始化，使其表示分配该对象的时间，度量到最近的毫秒。        Date d = new Date();        // 返回以毫秒为单位的当前时间        // System.out.println(d.getTime());        System.out.println(d.getTime() * 1.0 / 1000 / 60 / 60 / 24 / 365 + \"年\");        // 返回以毫秒为单位的当前时间        long time = System.currentTimeMillis();        // System.out.println(time);        d.setTime(time);        System.out.println(d);    &#125;&#125;SimpleDateFormatSimpleDateFormat是一个具体的类，用于以区域设置敏感的方式格式化和解析日期。我们重点学习日期格式化和解析\n日期和时间格式由日期和时间模式字符串指定，在日期和时间模式字符串中，从’A’到’Z’ 以及从’a’到’z’ 引号的字母被解释为表示日期或时间字符串的组件的模式字母\n常用的模式字母及对应关系如下:\n\ny年\n\nM月\n\nd日\n\nH时\n\nm分\n\nS秒\n\n\nLetterDate or Time ComponentPresentationExamples\n\nGEra designatorTextAD\n\nyYearYear1996; 96\n\nYWeek yearYear2009; 09\n\nMMonth in year (context sensitive)MonthJuly; Jul; 07\n\nLMonth in year (standalone form)MonthJuly; Jul; 07\n\nwWeek in yearNumber27\n\nWWeek in monthNumber2\n\nDDay in yearNumber189\n\ndDay in monthNumber10\n\nFDay of week in monthNumber2\n\nEDay name in weekTextTuesday; Tue\n\nuDay number of week (1 = Monday, …, 7 = Sunday)Number1\n\naAm/pm markerTextPM\n\nHHour in day (0-23)Number0\n\nkHour in day (1-24)Number24\n\nKHour in am/pm (0-11)Number0\n\nhHour in am/pm (1-12)Number12\n\nmMinute in hourNumber30\n\nsSecond in minuteNumber55\n\nSMillisecondNumber978\n\nzTime zoneGeneral time zonePacific Standard Time; PST; GMT-08:00\n\nZTime zoneRFC 822 time zone-0800\n\nXTime zoneISO 8601 time zone-08; -0800; -08:00\n\n构造方法\n方法名说明\n\npublic SimpleDateFormat()构造一个SimpleDateFormat,使用默认模式和日期格式\n\npublic SimpleDateFormat(String attern)构造个SimpleDateFormat使用给定的模式和默认的日期格式\n格式化和解析日期格式化(从Date到String )\npublic final String format(Date date): 将日期格式化成日期/时间字符串\n\n解析(从String到Date )public Date parse(String source): 从给定字符串的开始解析文本以性成日期\n\n123456789101112131415161718192021public class ArryDemo &#123;    public static void main(String[] args) throws ParseException &#123;        // public final String format(Date date)        Date d1 = new Date();        SimpleDateFormat sdf = new SimpleDateFormat();        String s = sdf.format(d1);        System.out.println(s);        // public Date parse(String source)        String ss = \"2048-08-09 11:11:11\";      \t//new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\")必须和ss格式相同        SimpleDateFormat sdf2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\");        Date dd = sdf2.parse(ss);        System.out.println(dd);    &#125;&#125;-------------------------------------------------------------------------2022/1/20 下午8:10Sun Aug 09 11:11:11 CST 2048制作日期工具需求:定义一个日期工具类(DateUtils)，包含两个方法:把日期转换为指定格式的字符串;把字符串解析为指定格式的日期，然后定义一个测试类(DateDemo),测试日期工类的方法思路:\n义日期工具类(DateUtils)\n\n定义一个方法dateToString, 用于把日期转换为指定格式的字符串\n返回值类型: String\n参数: Date date, String format\n\n定义一个方法stringToDate, 用于字符串解析为指定格式的日期\n返回值类型: Date\n参数: String s, String format\n\n定义测试类DateDemo,调用日期工具类中的方法\n\nDateUtils.java\n123456789101112131415161718192021import java.util.Date;import java.text.ParseException;import java.text.SimpleDateFormat;public class DateUtils &#123;  //封装构造函数 禁止生成实例对象    private DateUtils() &#123;    &#125;    public static String dateToString(Date date, String format) &#123;        SimpleDateFormat sdf = new SimpleDateFormat(format);        String s = sdf.format(date);        return s;    &#125;    public static Date stringToDate(String s, String format) throws ParseException &#123;        SimpleDateFormat sdf = new SimpleDateFormat(format);        Date d = sdf.parse(s);        return d;    &#125;&#125;DateDemo.java\n123456789101112131415import java.text.ParseException;import java.util.Date;public class DateDemo &#123;    public static void main(String[] args) throws ParseException &#123;        Date date = new Date();        String s1 = DateUtils.dateToString(date, \"yyyy年MM月dd日 HH:mm:ss\");        System.out.println(s1);        String s = \"2022-11-11 11:11:11\";        Date dd = DateUtils.stringToDate(s, \"yyyy-MM-dd HH:mm:ss\");        System.out.println(dd);    &#125;&#125;Calendar日历类抽象类\n1public abstract class Calendar extends Object implements Serializable, Cloneable, Comparable&lt;Calendar&gt;Calendar为某一时刻和一组日历字段之间的转换提供了一方法,并为操作日历字段提供了一些方法\nCalendar提供了一个类方法getInstance用于获取Calendar对象，其日历字段已使用当前日期和时间初始化:Calendar rightNow = Calendar.getInstance() ;\n1234567891011121314151617import java.util.Calendar;public class CalendarDemo &#123;    public static void main(String[] args) &#123;        // 获取对象        Calendar c = Calendar.getInstance();        System.out.println(c);        // public int get​(int field)      \t// 输出年月日        int year = c.get(Calendar.YEAR);        int month = c.get(Calendar.MONTH) + 1;        int day = c.get(Calendar.DATE);        System.out.println(year + \"年\" + month + \"月\" + day + \"日\");    &#125;&#125;常用方法\n方法名说明\n\npublic int get(int field)返回给定日历字段的值\n\npublic abstract void add(int field, int amount)根据日历的规则，将指定的时间量添加或减去给定的日历字段\n\npublic final void set(int year,int month,int date)设置当前日历的年月日\n1234567891011121314151617181920212223242526272829import java.util.Calendar;public class CalendarDemo &#123;    public static void main(String[] args) &#123;        // 获取对象        Calendar c = Calendar.getInstance();        // 10年后的5天前        c.add(Calendar.YEAR, 10);        c.add(Calendar.DATE, -5);        // public int get​(int field)        int year = c.get(Calendar.YEAR);        int month = c.get(Calendar.MONTH) + 1;        int day = c.get(Calendar.DATE);        System.out.println(year + \"年\" + month + \"月\" + day + \"日\");        //设置2022,12,11        c.set(2022, 11, 11);        int year1 = c.get(Calendar.YEAR);        int month1 = c.get(Calendar.MONTH) + 1;        int day1 = c.get(Calendar.DATE);        System.out.println(year1 + \"年\" + month1 + \"月\" + day1 + \"日\");    &#125;&#125;-------------------------------------------------------------2032年1月16日2022年12月11日二月天数123456789101112131415161718import java.sql.Date;import java.time.Month;import java.util.Calendar;import java.util.Scanner;public class CalendarDemo &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入年份：\");        int year = sc.nextInt();        Calendar c = Calendar.getInstance();        c.set(year, 2, 1);        c.add(Calendar.DATE, -1);        System.out.println(year + \"年2月有\"+ c.get(Calendar.DATE) + \"天\");    &#125;&#125;Object\n方法名说明\n\npublic String toString()返回对象的字符串表示形式。建议所有子类重写该方法，自动生成\n\npublic boolean equals(Object obj)比较对象是否相等。默认比较地址，重写可以比较内容，自动生成\n\nVS CODE\n\n右键—源代码操作—Generate toString()\n右键—源代码操作—Generate equals()\n\nIDEA\n\n右键—生成—toString()\n右键—生成—equals()\ntoString()方法Student.java\n1234567891011121314151617181920212223242526272829303132333435public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    // 重写父类Object的toString方法 返回Student的内容    @Override    public String toString() &#123;        return \"Student [age=\" + age + \", name=\" + name + \"]\";    &#125;&#125;Object.java\n1234567891011121314151617181920212223242526272829303132public class ObjectDemo &#123;    public static void main(String[] args) &#123;        Student s = new Student(\"踹\", 22);        System.out.println(s);// test3.Student@182decdb        // println源代码 输出的是地址        /*         * public void println(Object x) &#123;           * String s = String.valueOf(x);           * synchronized (this) &#123;           * print(s);           * newLine();           * &#125;         * &#125;                  * public static String valueOf(Object obj) &#123;         * \t\treturn (obj == null) ? \"null\" : obj.toString();\t         * &#125;                  //toString源码         * public String toString() &#123;         * \t\treturn getClass().getName() + \"@\" + Integer.toHexString(hashCode());         * &#125;         */        System.out.println(s.toString());// 重写toString()方法    &#125;&#125;-------------------------------Student [age=22, name=踹]equals()方法Student.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566public class Student &#123;    private String name;    private int age;    public Student() &#123;    &#125;    public Student(String name, int age) &#123;        this.name = name;        this.age = age;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    // 重写父类Object的toString方法    @Override    public String toString() &#123;        return \"Student [age=\" + age + \", name=\" + name + \"]\";    &#125;    @Override    public boolean equals(Object obj) &#123;        /*        this --- s1         obj --- s2                 */        //比较地址是否相同        if (this == obj)            return true;        //判断参数是否为空        if (obj == null)            return false;        //判断是否是同一个类        if (getClass() != obj.getClass())            return false;                //多态向下转型        Student other = (Student) obj;        //比较年龄是否相同        if (age != other.age)            return false;        //比较name是否相同        if (name == null) &#123;            if (other.name != null)                return false;        &#125; else if (!name.equals(other.name))            return false;        return true;    &#125;&#125;ObjectDemo.java\n12345678910111213141516public class ObjectDemo &#123;    public static void main(String[] args) &#123;        Student s1 = new Student(\"踹\", 22);        Student s2 = new Student(\"踹\", 22);        System.out.println(s1.equals(s2));        /*父类Object实现 比较的是地址         * public boolean equals(Object obj) &#123;         *      return (this == obj);         * &#125;         */    &#125;&#125;----------------------------------------ture基本类型的包装类将基本数据类型封装成对象的好处在于可以在对象中定义更多的功能方法操作该数据\n常用的操作之一: 用于基本数据类型与字符串之间的转换\n\n基本数据类型包装类\n\nbyteByte\n\nshortShort\n\nintInteger\n\nlongLong\n\nfloatFloat\n\ndoubleDouble\n\ncharCharacter\n\nbooleanBoolean\nInteger\n方法名说明\n\npublic Integer(int value)根据int值创建Integer对象(过时)\n\npublic Integer(String s)根据String值创建Integer对象(过时)\n\npublic static Integer valueOf(int i)返回表示指定的int值的Integer实例\n\npublic static Integer valueOf(String s)返回一个保存指定值的Integer对象String\n12345678910111213141516171819202122public class ArryDemo &#123;    public static void main(String[] args) &#123;        Integer i1 = new Integer(100);        System.out.println(i1);        Integer i2 = new Integer(\"2030\");        // 字符串必须是数字类字符串        // Integer i3 = new Integer(\"abcc\");        System.out.println(i2);        Integer i3 = Integer.valueOf(199);        System.out.println(i3);        Integer i4 = Integer.valueOf(\"2020\");        System.out.println(i4);    &#125;&#125;------------------------------------------------------10020301992020int 和 String 类型相互转换基本类型包装类的最常见操作就是:用于基本类型和字符串之间的相互转换\nint转换为String\npublic static String valueOf(int i):返回int参数的字符串表示形式。该访法是String类中的方法\n\nString转换为int\npublic int intValue(): 以整数形式返回此Integer的值。该访法是Integer类中的方法\npublic static int parselnt(String s):将字符串解析为int类型。该访法是Integer类中的方法\n\n123456789101112131415161718192021222324252627282930public class ArryDemo &#123;    public static void main(String[] args) &#123;        // int转String        int number = 100;        // 方法1        String s1 = \"\" + number;        System.out.println(s1);        // 方法2        String s2 = String.valueOf(number);        System.out.println(s2);        System.out.println(\"--------\");        // String转int        String s = \"100\";        // 方法1        // String --- Integer --- int        Integer i = Integer.valueOf(s);        int x = i.intValue();        System.out.println(x);        // 方法2        int y = Integer.parseInt(s);        System.out.println(y);    &#125;&#125;------------------------------------------------------100100--------100100字符串中数据排序需求: 有一个字符串:“91 27 46 38 50”，请写程序实现最终输出结果是: “27 38 46 50 91”思路:\n定义一个字符串\n\n把字符串中的数字数据存储到一个int类型的数组中\n得到字符串中每一个数字数据?\n12//转成String数组public String[] split(String regex)定义一个int数组，把String[] 数组中的每一个元素存储到 int数组中\n1public static int parselnt(String s)\n对int数组进行排序\n\n把排序后的int数组中的元素进行拼接得到一个字符串，这里拼接采用StringBuilder来实现\n\n输出结果\n\n123456789101112131415161718192021public class ArryDemo &#123;    public static void main(String[] args) &#123;        String s = \"91 27 46 38 50\";        String[] strArray = s.split(\" \");        int[] arr = new int[strArray.length];        for (int i = 0; i &lt; arr.length; i++) &#123;            arr[i] = Integer.parseInt(strArray[i]);        &#125;        Arrays.sort(arr);        StringBuilder sb = new StringBuilder();        for (int i = 0; i &lt; arr.length; i++) &#123;            if (i == arr.length - 1) &#123;                sb.append(arr[i]);            &#125; else &#123;                sb.append(arr[i]).append(\" \");            &#125;        &#125;        String result = sb.toString();        System.out.println(result);    &#125;&#125;自动装箱和拆箱装箱:  把基本数据类型转换为对应的包装类类型拆箱:  把包装类类型转换为对应的基本数据类型\n注意:在使用包装类类型的时候，如果做操作,最好先判断是否为null\n我们推荐的是，只要是对象，在使用前就必须进行不为null的判断\n12345678910111213141516171819202122232425public class ArryDemo &#123;    public static void main(String[] args) &#123;        // 装箱        Integer i = Integer.valueOf(100);        // 自动装箱        Integer ii = 100; // Integer.valueOf(100);        // 拆箱：把包装类类型转换成对应的基本数据类型        ii = ii.intValue() + 200;        // 自动拆箱        ii += 200; // ii = ii + 200; ii+200 自动拆箱； ii=ii+200 自动装箱        System.out.println(ii);        Integer iii = null;        // 当iii为null时，iii+=300 就等于 iii.intValue(null)+300        if (iii != null) &#123;            // iii.intValue(iii)+300            iii += 300;        &#125; else &#123;            // 报错 iii.intValue(null)+300            iii += 300;        &#125;    &#125;&#125;异常异常: 就是程序出现了不正常的情况\nError: 严重问题，不需要处理\nException: 称为异常类，它表示程序本身可以处理的问题RuntimeException:在编译期是不检查的，出现问题后，需要我们回来修改代码\n非RuntimeException:编译期就必须处理的，否则程序不能通过编译,就更不能正常运行了\n\n编译时异常和运行时异常的区别Java中的异常被分为两大类:编译时异常和运行时异常，也被称为受检异常和非受检异常\n所有的RuntimeException及其子类被称为运行时异常,其他的异常都是编译时异常\n编译时异常: 必须显示处理，否则程序就会发生错误，无法通过编译\n运行时异常: 无需显示处理，也可以和编译时异常一样处理\n123456789101112131415161718public class CalendarDemo &#123;    public static void main(String[] args) &#123;        method();    &#125;    public static void method() &#123;        try &#123;            String s = \"2022-1-20\";            SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");            Date d = sdf.parse(s);            System.out.println(d);        &#125; catch (ParseException p) &#123;            p.printStackTrace();        &#125;          &#125;&#125;JVM的默认处理方案如果程序出现了问题，我们没有做任何处理，最终 JVM 会做默认的处理\n把异常的名称， 异常原因及异常出现的位置等信息输出在了控制台\n程序停止执行\ntry…catch…12345try &#123;    可能出现异常的代码;&#125; catch (异常类名 变量名) &#123;    异常的处理代码;&#125;执行流程:\n程序从try里面的代码开始执行\n出现异常,会自动生成一个异常类对象，该异常对象将被提交给Java运行时系统\n当Java运行时系统接收到异常对象时，会到catch中去找匹配的异常类，找到后进行异常的处理\n执行完毕之后，程序还可以继续往下执行\n12345678910111213141516171819202122232425public class CalendarDemo &#123;    public static void main(String[] args) &#123;        System.out.println(\"开始\");        method();        System.out.println(\"结束\");    &#125;    public static void method()&#123;        try &#123;            int[] arr =&#123;1,2,3&#125;;            System.out.println(arr[3]); // new ArrayIndexOutOfBoundsException        &#125; catch (ArrayIndexOutOfBoundsException e)&#123;           //e = new ArrayIndexOutOfBoundsException            System.out.println(\"你访问的数组不存在\");            e.printStackTrace();        &#125;    &#125;&#125;----------------------------------------------------------------------------开始你访问的数组不存在java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3        at test1.CalendarDemo.method(CalendarDemo.java:17)        at test1.CalendarDemo.main(CalendarDemo.java:10)结束Throwable\n方法名说明\n\npublic String getMessage()返回此throwable的详细消息字符串\n\npublic String toString()返回此可抛出的简短描述\n\npublic void printStackTrace()把异常的错误信息输出在控制台\n12345678910111213141516171819202122232425262728293031public class CalendarDemo &#123;    public static void main(String[] args) &#123;        System.out.println(\"开始\");        method();        System.out.println(\"结束\");    &#125;    public static void method() &#123;        try &#123;            int[] arr = &#123; 1, 2, 3 &#125;;            System.out.println(arr[3]);        &#125; catch (ArrayIndexOutOfBoundsException e) &#123;            // public String getMessage()            // Index 3 out of bounds for length 3            System.out.println(e.getMessage());            // public String toString()            // java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3            System.out.println(e.toString());            // public void printStackTrace()            /*             * java.lang.ArrayIndexOutOfBoundsException: Index 3 out of bounds for length 3             * at test1.CalendarDemo.method(CalendarDemo.java:13)             * at test1.CalendarDemo.main(CalendarDemo.java:6)             */            e.printStackTrace();        &#125;    &#125;&#125;throws虽然我们通过 try...catch... 可以对异常进行处理,但是并不是所有的情况我们都有权限进行异常的处理,  也就是说，有些时候可能出现的异常是我们处理不了的,这个时候该怎么办呢?\n针对这种情况，Java提供了throws的处理方案\n1throws 异常类名;编译时异常必须要进行处理，两种处理方案:  try...catch... 或者 throws ,如果采用 throws 这种方案，将来谁调用谁处理\n运行时异常可以不处理，出现问题后,需要我们回来修改代码\n12345678910111213141516171819202122232425public class CalendarDemo &#123;    public static void main(String[] args) &#123;        System.out.println(\"开始\");        try &#123;            method1();        &#125; catch (ParseException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 编译时异常    public static void method1() throws ParseException &#123;        String s = \"2022-1-20\";        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");        Date d = sdf.parse(s);        System.out.println(d);    &#125;    // 运行时异常 RuntimeException    public static void method() throws ArrayIndexOutOfBoundsException &#123;        int[] arr = &#123; 1, 2, 3 &#125;;        System.out.println(arr[3]);    &#125;&#125;自定义异常1234public class 异常类名 extends Exception &#123;\t\t无参构造\t\t无参构造&#125;12345678public class ScoreException extends Exception &#123;    public ScoreException() &#123;    &#125;    public ScoreException(String message) &#123;        super(message);    &#125;&#125;throws 和 throw 区别\nthrowsthrow\n\n用在方法声明后面，跟的是异常类名用在方法体内，跟的是异常对象名\n\n表示抛出异常，由该方法的调用者来处理表示抛出异常,由方法体内的语句处理\n\n表示出现异常的一种可能性,并不一定会发生这些异常执行throw一定抛出了某种异常\nScoreException.java\n12345678public class ScoreException extends Exception &#123;    public ScoreException() &#123;    &#125;    public ScoreException(String message) &#123;        super(message);    &#125;&#125;Teacher.java\n12345678910public class Teacher &#123;    public void checkScore(int score) throws ScoreException &#123;        if (score &lt; 0 || score &gt; 100) &#123;            // throw new ScoreException();            throw new ScoreException(\"你给的分数有误\");        &#125; else &#123;            System.out.println(\"分数正常\");        &#125;    &#125;&#125;TeacherTest.java\n123456789101112131415public class TeacherTest &#123;    public static void main(String[] args) &#123;        Scanner sc = new Scanner(System.in);        System.out.println(\"请输入分数\");        int score = sc.nextInt();        Teacher t = new Teacher();        try &#123;            t.checkScore(score);        &#125; catch (ScoreException e) &#123;            e.printStackTrace();        &#125;    &#125;&#125;FileFile类概述和构造方法File:它是文件和目录路径名的抽象表示\n文件和目录是可以通过File封装成对象的\n对于File而言，其封装的并不是一个真正存在的文件, 仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。\n将来是要通过具体的操作把这个路径的内容转换为具体存在的\n\n方法名说明\n\nFile(String pathname)通过将给定的路径名字符串转换为抽象路径名来创建新的File实例\n\nFile(String parent, String child)从父路径名字符串和子路径名字符串创建新的File实例\n\nFile(File parent, String child)从父抽象路径名和子路径名字符串创建新的File实例\n12345678910111213141516import java.io.File;public class FileDemo &#123;    public static void main(String[] args) &#123;        File f1 = new File(\"//Users//dx//Desktop//java.txt\");        System.out.println(f1);        File f2 = new File(\"//Users//dx//Desktop\", \"java.txt\");        System.out.println(f2);        File f3 = new File(\"//Users//dx//Desktop\");        File f4 = new File(f3, \"java.txt\");        System.out.println(f4);    &#125;&#125;File类创建功能\n方法名说明\n\npublic boolean createNewFile()当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件 创建文件\n\npublic boolean mkdir()创建由此抽象路径名命名的目录 创建文件夹\n\npublic boolean mkdirs()创建由此抽象路径名命名的目录，包括任何必需但不存在的父目录 创建路径\n\n如果文件不存在，就创建文件，并返true\n如果文件存在，就不创建文件，并返回false\n\n123456789101112131415161718192021import java.io.File;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        File f1 = new File(\"//Users//dx//Desktop//java.txt\");        // 创建java.txt文件        System.out.println(f1.createNewFile());        System.out.println(\"---------------------\");        // 创建Desktop下java文件夹        File f2 = new File(\"//Users//dx//Desktop//Java\");        System.out.println(f2.mkdir());        System.out.println(\"---------------------\");        // 自动补齐不存在的路径        File f3 = new File(\"//Users//dx//Desktop//Java//jjj\");        System.out.println(f3.mkdirs());    &#125;&#125;File类判断和获取功能\n方法名说明\n\npublic boolean isDirectory()测试此抽象路径名表示的File是否为目录\n\npublic boolean isFile()测试此抽象路径名表示的File是否为文件\n\npublic boolean exists()测试此抽象路径名表示的File是否存在\n\npublic String getAbsolutePath()返回此抽象路径名的绝对路径名字符串\n\npublic String getPath()将此抽象路径名转换为路径名字符串\n\npublic String getName()返回由此抽象路径名表示的文件或目录的名称\n\npublic String[] list()返回此抽象路径名表示的目录中的文件和目录的名称字符串数组\n\npublic File[] listFiles()返回此抽象路径名表示的目录中的文件和目录的File对象数组\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import java.io.File;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        File f1 = new File(\"java.txt\");        File f2 = new File(\"Java\");        // File是否为目录        System.out.println(f1.isDirectory());        System.out.println(f2.isDirectory());        System.out.println(\"----------------\");        // File是否为文件        System.out.println(f1.isFile());        System.out.println(f2.isFile());        System.out.println(\"----------------\");        // File是否存在        System.out.println(f1.exists());        System.out.println(f2.exists());        System.out.println(\"----------------\");        // 绝对路径名字符串        System.out.println(f1.getAbsolutePath());        System.out.println(f2.getAbsolutePath());        System.out.println(\"----------------\");        // 将此抽象路径名转换为路径名字符串        System.out.println(f1.getPath());        System.out.println(f2.getPath());        System.out.println(\"----------------\");        // 返回由此抽象路径名表示的文件或目录的名称        System.out.println(f1.getName());        System.out.println(f2.getName());        System.out.println(\"----------------\");        // 返回该目录下的文件和文件夹名字的字符串数组        File f3 = new File(\"//Users//dx/Documents//codes//java_code//src//test1\");        String[] strArray = f3.list();        for (String str : strArray) &#123;            System.out.println(str);        &#125;        System.out.println(\"----------------\");        // 返回该目录下的文件和文件夹路径的File数组        File[] fileArray = f3.listFiles();        for (File file : fileArray) &#123;            // System.out.println(file);            if (file.isFile()) &#123;                System.out.println(file.getName());            &#125;        &#125;    &#125;&#125;File类删除功能\n方法名说明\n\npublic boolean delete()删除由此抽象路径名表示的文件或目录\n绝对路径和相对路径的区别\n绝对路径:完整的路径名,不需要任何其他信息就可以定位它所表示的文件。例如: E:\\itcast\\Vjava.txt\n相对路径: 必须使用取自其他路径名的信息进行解释。例如: myFile\\Vjava.txt\n删除目录时的注意事项:\n如果一个目录中有内容(目录,文件)，不能直接删除。应该先删除目录中的内容，最后才能删除目录\n123456789101112131415161718192021222324252627282930313233import java.io.File;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // 在当前模块下创建java.txt        File f1 = new File(\"src//test1//java.txt\");        System.out.println(f1.createNewFile());        // 删除在当前模块下java.txt        System.out.println(f1.delete());        System.out.println(\"----------------\");        // 在当前模块下创建itcast目录        File f2 = new File(\"src//itcast\");        System.out.println(f2.mkdir());        // 删除在当前模块下itcast目录        System.out.println(f2.delete());        System.out.println(\"----------------\");        // 在当前模块下创建itcast 然后在该目录下创建一个文件java.txt        File f3 = new File(\"src//itcast\");        File f4 = new File(\"src//itcast//java.txt\");        System.out.println(f3.mkdir());        System.out.println(f4.createNewFile());        // 删除当前模块下的目录itcast        System.out.println(f4.delete());        System.out.println(f3.delete());    &#125;&#125;递归递归概述: 以编程的角度来看,递归指的是方法定义中调用方法本身的现象\n递归解决问题的思路:\n把一个复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解\n递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算\n递归解决问题要找到两个内容:\n递归出口:否则会出现内存溢出\n递归规则:与原问题相似的规模较小的问题\n递归求阶乘需求:用递归求5的阶乘，并把结果在控制台输出\n思路:\n①定义一个方法，用于递归求阶乘，参数为一个int类型的变量②在方法内部判断该变量的值是否是1    是:返回1    不是:返回n*(n-1)!③调用方法④输出结果\n\n1234567891011121314public class FileDemo &#123;    public static void main(String[] args) &#123;        int result = jc(5);        System.out.println(\"5的阶乘是\" + result);    &#125;    public static int jc(int n) &#123;        if (n == 1) &#123;            return 1;        &#125; else &#123;            return n * jc(n - 1);        &#125;    &#125;&#125;遍历目录需求:给定一个路径(E:\\itcast),请通过递归完成遍历该目录下的所有内容,并把所有文件的绝对路径输出在控制台\n思路:\n①根据给定的路径创建一个File对象②定义一个方法，用于获取给定目录下的所有内容,参数为第1步创建的File对象③获取给定的File目录下所有的文件或者目录的File数组④遍历该File数组，得到每一个File对象⑤判断该File对象是否是目录    是:递归调用    不是:获取绝对路径输出在控制台⑥调用方法\n12345678910111213141516171819202122232425import java.io.File;public class FileDemo &#123;    public static void main(String[] args) &#123;        File srcFile = new File(\"//Users//dx//Documents//codes//java_code\");        getAllFilePath(srcFile);    &#125;    public static void getAllFilePath(File srcFile) &#123;        // 获取给定的File目录下所有的文件或者目录的File数组        File[] fileArray = srcFile.listFiles();        // 遍历该File数组 得到每一个File对象        if (fileArray != null) &#123;            for (File file : fileArray) &#123;                // 判断File对象是否是目录                if (file.isDirectory()) &#123;                    getAllFilePath(file);                &#125; else &#123;                    System.out.println(file.getAbsolutePath());                &#125;            &#125;        &#125;    &#125;    &#125;字节流\nIO流概述和分类IO流分类:\n按照数据的流向输入流:读数据\n输出流:写数据\n\n按照数据类型来分字节流字节输入流; 字节输出流\n字符流字符输入流; 字符输出流\n\n一般来说，我们说IO流的分类是按照数据类型来分的\n\n那么这两种流都在什么情况下使用呢?\n\n如果数据通过Window自带的记事本软件开, 我们还可以读懂里面的内容,就使用字符流,否则使用字节流。如果你不知道该使用哪种类型的流，就使用字节流\n🍖字节流写数据字节流抽象基类\nInputStream: 这个抽象类是表示字节输入流的所有类的超类\nOutputStream: 这个抽象类是表示字节输出流的所有类的超类\n子类名特点: 子类名称都是以其父类名作为子类名的后缀\nFileOutputStream:文件输出流用于将数据写入File\nFileOutputStream(String name):创建文件输出流以指定的名称写入文件\n使用字节输出流写数据的步骤:\n创建字节输出流对象(调用系统功能创建 了文件,创建字节输出流对象,让字节输出流对象指向文件)\n调用字节输出流对象的写数据方法\n释放资源(关闭此文件输出流并释放与此流相关联的任何系统资源)\n12345678910111213141516171819import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // 调用系统功能创建文件 创建字节输出流对象 让字节输出流对象指向文件        FileOutputStream fos = new FileOutputStream(\"src//test1//fos.txt\");        // 写数据        fos.write(97); // a        fos.write(57); // 9        fos.write(55); // 7        // 最后释放资源        // 关闭此文件输出流并释放与此流相关联的任何系统资源        fos.close();    &#125;&#125;字节流写数据的3种方式\n方法名说明\n\nvoid write(int b)将指定的字节写入此文件输出流一次写一个字节数据\n\nvoid write(byte[] b)将b.length字节从指定的字节数组写入此文件输出流一次写一个字节数组数据\n\nvoid write(byte[] b, int off, int len)将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流一次写一个字节数组的部分数据\n123456789101112131415161718192021222324252627282930313233343536import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // FileOutputStream(String name):创建文件输出流以指定的名称写入文件        FileOutputStream fos = new FileOutputStream(\"src//test1//fos.txt\");        // FileOutputStream fos = new FileOutputStream(new File(\"src//test1//fos.txt\"));        // public FileOutputStream​(File file) 创建文件输出流 以写入由指定的File对象表示的文件        // File file = new File(\"src//test1//fos.txt\");        // FileOutputStream fos2 = new FileOutputStream(file);        // FileOutputStream fos2 = new FileOutputStream(new        // File(\"src//test1//fos.txt\"));        /*         * fos.write(97);         * fos.write(98);         * fos.write(99);         * fos.write(100);         */        // byte[] bys = &#123; 97, 98, 99, 100 &#125;;        // byte[] getBytes() 返回字符串对应的字节数组        byte[] bys = \"abcd\".getBytes();        // void write(byte[] b)        // fos.write(bys);        // void write(byte[] b, int off, int len)        fos.write(bys, 1, 3);        fos.close();    &#125;&#125;写数据的两个问题\n字节流写数据如何实现换行呢?\n\n​    window: \\r\\n\n​    Linux: \\n\n​    mac:\\r\n\n字节流写数据如何实现追加写入呢?\n\npublic FileOutputStream(File file, boolean append) \n\n创建文件输出流  以指定的名称写入文件 如果第二个append为ture 则写入文件末尾 而不是开头\n\n123456789101112131415161718192021import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // public FileOutputStream​(File file,boolean append) 如果第二个为ture 则写入文件末尾 而不是开头        FileOutputStream fos = new FileOutputStream(\"src//test1//fos.txt\", true);        for (int i = 0; i &lt; 10; i++) &#123;            fos.write(\"hello\".getBytes());            // window: \\r\\n            // Linux: \\n            // mac: \\r            fos.write(\"\\r\\n\".getBytes());        &#125;        fos.close();    &#125;&#125;字节流写数据加异常处理finally: 在异常处理时提供finally块来执行所有清除操作。比如说IO流中的释放资源\n特点: 被finally控制的语句一定会执行,除非JVM退出\n123456789try &#123;    // 可能出现异常的代码&#125; catch (异常类名 变量名) &#123;    // 异常的处理代码&#125; finally &#123;&#125;1234567891011121314151617181920212223242526import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) &#123;        FileOutputStream fos = null;        try &#123;            // 可能出现异常的代码            fos = new FileOutputStream(\"src//test1//fos.txt\");            fos.write(\"hello\".getBytes());        &#125; catch (IOException e) &#123;            // 异常的处理代码            e.printStackTrace();        &#125; finally &#123;            // 执行所有清除操作            if (fos != null) &#123;                try &#123;                    fos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;&#125;🍖字节流读数据字节流读数据(一次读一个字节数据)\n需求:把文件fos.txt中的内容读取出来在控制台输出\nFileInputStream:从文件系统中的文件获取输入字节\nFilelnputStream(String name):通过打开与实际文件的连接来创建一个FileInputStream,该文件由文件系统中的路径名name命名\n使用字节输入流读数据的步骤:\n①创建字节输入流对象②调用字节输入流对象的读数据方法③释放资源\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849import java.io.FileInputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileInputStream fis = new FileInputStream(\"src//test1//fos.txt\");        /*         * // 第一次读取数据         * int by = fis.read();         * System.out.println(by);         * System.out.println((char) by);         *          * // 第二次读取数据         * by = fis.read();         * System.out.println(by);         * System.out.println((char) by);         *          * // 再多读取两次         * by = fis.read();         * System.out.println(by);         * // 如果到达文件末尾，则为-1         * by = fis.read();         * System.out.println(by);         */        // 读取fos.txt        /*         * int by = fis.read();         * while (by != -1) &#123;         * System.out.print((char) by);         * by = fis.read();         * &#125;         */        // 优化读取        /*         * fis.read() ：读数据         * by = fis.read() ：把读取到的数据赋值给by         * by != -1 ：判断读取到的数据         */        int by;        while ((by = fis.read()) != -1) &#123;            System.out.print((char) by);        &#125;        fis.close();    &#125;&#125;复制文本文件需求:把 “E:\\itcast\\窗里窗外.txt“ 复制到模块目录下的 “窗里窗外.txt“\n\n分析:\n\n①复制文本文件，其实就把文本文件的内容从一个文件中读取出来(数据源)，然后写入到另一个文件中(目的地)②数据源:E:\\itcast\\窗里窗外.txt —读数据— InputStream — FilelnputStream③目的地:myByteStream)\\窗里窗外.txt —写数据— OutputStream — FileOutputStream\n\n思路:\n\n①根据数据源创建字节输入流对象②根据目的地创建字节输出流对象③读写数据,复制文本文件(一次读取一个字节，一次写入一个字节)④释放资源\n12345678910111213141516171819import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileInputStream fis = new FileInputStream(\"/Users/dx/Desktop/窗里窗外.txt\");        FileOutputStream fos = new FileOutputStream(\"src/test1/窗里窗外.txt\");        int by;        while ((by = fis.read()) != -1) &#123;            fos.write(by);        &#125;        fos.close();        fis.close();    &#125;&#125;一次读一个字节数组数据需求:把文件fos.txt中的内容读取出来在控制台输出\n\n使用字节输入流读数据的步骤:\n\n①创建字节输入流对象②调用字节输入流对象的读数据方法③释放资源\n123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.io.FileInputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileInputStream fis = new FileInputStream(\"src/test1/fos.txt\");        // byte[] bys = new byte[5];        /*         * // 第一次读取         * int len = fis.read(bys);         * System.out.println(\"一次读取长度为：\"+len);         * System.out.println(new String(bys,0,len));         *          * // 第二次读取         * len = fis.read(bys);         * System.out.println(\"一次读取长度为：\"+len);         * System.out.println(new String(bys,0,len));         *          * // 第三次读取         * len = fis.read(bys);         * System.out.println(\"一次读取长度为：\"+len);         * System.out.println(new String(bys,0,len));         *          * // 第三次读取         * len = fis.read(bys);         * System.out.println(\"一次读取长度为：\"+len);         * System.out.println(new String(bys,0,len));         *          * // 第四次读取         * // len = fis.read(bys);         * // System.out.println(\"一次读取长度为：\"+len);         * // System.out.println(new String(bys,0,len));         */        byte[] bys = new byte[1024];        int len;        while ((len = fis.read(bys)) != -1) &#123;            System.out.println(new String(bys, 0, len));        &#125;        fis.close();    &#125;&#125;复制图片需求:把“E:\\itcast\\mn.jpg”复制到模块目录下的”mnjpg”思路:①根据数据源创建字节输入流对象②根据目的地创建字节输出流对象③读写数据，复制图片(一次读取一个字节数组，一次写入一个字节数组④释放资源\n12345678910111213141516171819import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileInputStream fis = new FileInputStream(\"//Users//dx//Pictures//bg_001.png\");        FileOutputStream fos = new FileOutputStream(\"src//test1//bg_001.png\");        byte[] bys = new byte[1024];        int len;        while ((len = fis.read(bys)) != -1) &#123;            fos.write(bys, 0, len);        &#125;        fos.close();        fis.close();    &#125;&#125;🍖字节缓冲流字节缓冲流:\nBufferOutputStream: 该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节,而不必为写入的每个字节导致底层系统的调用\nBufferedInputStream: 创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时， 内部缓冲区将根据需要从所包含的输入流中重新填充，一次很多字节\n构造方法: \n字节缓冲输出流: BufferedOutputStream(OutputStream out)\n字节缓冲输入流: BufferedInputStream(InputStream in)\n为什么构造方法需要的是字节流，而不是具体的文件或者路径呢?\n字节缓冲流仅仅提供缓冲区， 而真正的读写数据还得依靠基本的字节流对象进行操作\n1234567891011121314151617181920212223242526272829303132333435363738import java.io.BufferedInputStream;import java.io.FileInputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        /*         * // 字符缓冲输出流         * // FileOutputStream fos = new FileOutputStream(\"src/test1/fos.txt\");         * // BufferedOutputStream bos = new BufferedOutputStream(fos);         * BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(\"src//test1//fos.txt\"));         *          * // 写数据         * bos.write(\"hello\\n\".getBytes());         * bos.write(\"hello\\n\".getBytes());         */        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(\"src//test1//fos.txt\"));        // 一次读取一个字节数据        /*         * int by;         * while ((by = bis.read()) != -1) &#123;         * System.out.print((char)by);         * &#125;         */        // 一次读取一个字节数组数据        byte[] bys = new byte[1024];        int len;        while ((len = bis.read(bys)) != -1) &#123;            System.out.println(new String(bys, 0, len));        &#125;        // bos.close();        bis.close();    &#125;&#125;复制视频需求:把  “E:\\itcastl\\字节流复制图片.avi&quot;复制到模块目录下的“字节流复制图片.avi“\n思路:①根据数据源创建字节输入流对象②根据目的地创建字节输出流对象③读写数据,复制视频.④释放资源\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // 开始记录时间        long startTime = System.currentTimeMillis();        // 复制视频        // method1(); // 共耗时：85327毫秒        // method2(); // 共耗时：104毫秒        // method3(); // 共耗时：393毫秒        method4(); // 共耗时：26毫秒        // 记录结束时间        long endTime = System.currentTimeMillis();        System.out.println(\"共耗时：\" + (endTime - startTime) + \"毫秒\");    &#125;    // 一次读取一个字节    public static void method1() throws IOException &#123;        FileInputStream fis = new FileInputStream(\"//Users//dx//Downloads//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\");        FileOutputStream fos = new FileOutputStream(\"src/test1/〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\");        int by;        while ((by = fis.read()) != -1) &#123;            fos.write(by);        &#125;        System.out.println(\"写入成功\");        fos.close();        fis.close();    &#125;    // 一次读取一个字节数组    public static void method2() throws IOException &#123;        FileInputStream fis = new FileInputStream(\"//Users//dx//Downloads//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\");        FileOutputStream fos = new FileOutputStream(\"src//test1//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\");        byte[] by = new byte[1024];        int len;        while ((len = fis.read(by)) != -1) &#123;            fos.write(by, 0, len);        &#125;        System.out.println(\"写入成功\");        fos.close();        fis.close();    &#125;    public static void method3() throws IOException &#123;        BufferedOutputStream bos = new BufferedOutputStream(                new FileOutputStream(\"//Users//dx//Downloads//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\"));        BufferedInputStream bis = new BufferedInputStream(                new FileInputStream(\"src//test1//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\"));        int by;        while ((by = bis.read()) != -1) &#123;            bos.write(by);        &#125;        bos.close();        bis.close();    &#125;    public static void method4() throws IOException &#123;        BufferedOutputStream bos = new BufferedOutputStream(                new FileOutputStream(\"//Users//dx//Downloads//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\"));        BufferedInputStream bis = new BufferedInputStream(                new FileInputStream(\"src//test1//〈JAVA〉自制实时聊天通信软件演示KaChat.mp4\"));        byte[] bys = new byte[1024];        int len;        while ((len = bis.read(bys)) != -1) &#123;            bos.write(bys, 0, len);        &#125;        bos.close();        bis.close();    &#125;&#125;字符流\n为什么会出现字符流由于字节流操作中文不是特别的方便，所以Java就提供字符流\n字符流=字节流+编码表\n\n用字节流复制文本文件时，本文件也会有中文，但是没有问题，原因是最终底层操作会自动进行字节拼接成中文，如何识别是中文的呢?\n\n汉字在存储的时候， 无论选择哪种编码存储，第一个字节都负数\n1234567891011121314151617181920212223import java.io.UnsupportedEncodingException;import java.util.Arrays;public class FileDemo &#123;    public static void main(String[] args) throws UnsupportedEncodingException &#123;        String s = \"abc\"; // [97, 98, 99]        byte[] bys = s.getBytes();        System.out.println(Arrays.toString(bys));        String s1 = \"中国\"; // [-28, -72, -83, -27, -101, -67]        byte[] bys1 = s1.getBytes();        System.out.println(Arrays.toString(bys1));        String s2 = \"中国\"; // [-28, -72, -83, -27, -101, -67]        byte[] bys2 = s2.getBytes(\"UTF-8\");        System.out.println(Arrays.toString(bys2));        String s3 = \"中国\"; // [-42, -48, -71, -6]        byte[] bys3 = s3.getBytes(\"GBK\");        System.out.println(Arrays.toString(bys3));    &#125;&#125;编码表基础知识:\n计算机中储存的信息都是用二 进制数表示的;我们在屏幕上看到的英文、汉字等字符是二进制数转换之后的结果\n按照某种规则，将字符存储到计算机中，称为编码。反之，将存储在计算机中的二进制数按照某种规则解析显示出来，称为解码。这里强调一下: 按照A编码存储，必须按照A编码解析,这样才能显示正确的文本符号。否则就会导致乱码现象\n字符编码:就是一套自然语言的字符与二进制数之间的对应规则(A,65)\nASCII字符集:\nASCII(American Standard Code for Information Interchange,美国信息交换标准代码):基于拉打字母的一套电脑编码系统, 于显示现代英语，主要包括控制字符(回车键、退格、换行键等)和可显字符(英文大小写字符、阿拉伯数字和文符号\n基本的ASCI字符集，使用7位表示一个字符, 共128字符。 ASCIl的扩展字符集使用8位表示一个字符,共256字符,方便支持欧洲常用字符。是一个系统支持的所有字符的集合,包括各国家文字、标点符号、图形符号、数字等\nGBXXX字符集:\nGB2312: 简体中文码表。一个小于127的字符的意义与原来相同，但两个大于127的字符连在一起时,就表示一一个汉字,这样大约可以组合了包含7000多个简体汉字,此外数学符号、罗马希腊的字母、暗的假名等都编进去了,连在ASCII里本来就有的数字、标点、字母都统统重新编了两个字节长的编码，这就是常说的”全角”字符,而原来在127号以下的那些就叫“半角”字符了\nGBK: 最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案,共收录了21003个汉字,完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等\nGB18030: 最新的中文码表。收录汉字70244个，采用多字节编码，每个字可以由1个、2个或4个字节组成。支持中国国内少数民族的文字,同时支持繁体汉字以及日韩汉字等\nUnicode字符集:\n为表达任意语言的任意字符而设计，是业界的一种标准,也称为统-码、标准万国码。它最多使用4个字节的数字来表达每个字母、符号，或者文字。有三种编码方案，UTF-8、 UTF-16和UTF32。 最为常用的UTF-8编码\nUTF-8编码:可以用来表示Unicode标准中任意字符，它是电子邮件、网页及其他存储或传送文字的应用中，优先采用的编码。互联网工程工作小组(IETF) 要求所有互联网协议都必须支持UTF -8编码。它使用一至四个字节为每个字符编码\n编码规则:128个US- ASCI字符，只需一个字节编码拉丁文等字符，需要二个字节编码大部分常用字(含中文)，使用三个字节编码其他极少使用的Unicode辅助字符，使用四字节编码\n小结:采用何种规则编码，就要采用对应规则解码，否则就会出现乱码\n字符串中的编码解码问题编码:\nbyte[] getBytes(): 使用平台的默认字符集将该String编码为一系列字节， 将结果存储到新的字节数组中\nbyte[] getBytes(String charsetName): 使用指定的字符集将该String编码为-系列字节, 将结果存储到新的字节数组中\n解码:\nString(byte[] bytes): 通过使用平台的默认字符集解码指定的字节数组来构造新的 String\nString(byte[] bytes, String charsetName):通过指定的字符集解码指定的字节数组来构造新的String\n123456789101112131415161718192021222324252627import java.io.UnsupportedEncodingException;import java.util.Arrays;public class FileDemo &#123;    public static void main(String[] args) throws UnsupportedEncodingException &#123;        String s = \"中国\"; // [-28, -72, -83, -27, -101, -67]        System.out.println(\"---------- 编码 -------------\");        // 平台默认的字符集        byte[] bys = s.getBytes();// [-28, -72, -83, -27, -101, -67]        System.out.println(Arrays.toString(bys));        // UTF-8        bys = s.getBytes(\"UTF-8\");// [-28, -72, -83, -27, -101, -67]        System.out.println(Arrays.toString(bys));        // GBK        bys = s.getBytes(\"GBK\");// [-42, -48, -71, -6]        System.out.println(Arrays.toString(bys));        System.out.println(\"---------- 解码 -------------\");        String ss = new String(bys, \"GBK\");        System.out.println(ss);    &#125;&#125;字符流中的编码解码问题字符流抽象基类\nReader:字符输入流的抽象类\n\nWriter:字符输出流的抽象类\n\n字符流中和编码解码问题相关的两个类:\nInputStreamReader ：字节流到字符流的桥梁，它读取字节，并使用指定的charset将其解码为字符\nOutputStreamWriter :  是从字符流到字节流的桥梁 , 使用指定的charset将写入的字符编码为字节。\n12345678910111213141516171819202122232425262728293031323334353637import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;      \t// 字节流中文乱码      \tFileInputStream fis = new FileInputStream(\"/Users/dx/Desktop/fos.txt\"); // 你好        FileOutputStream fos = new FileOutputStream(\"src/test1/fos.txt\");        int bys;        while ((bys = fis.read()) != -1) &#123;            fos.write((char) bys); // 浣犲ソ            System.out.print((char) bys);// ä½ å¥½%        &#125;        fis.close();        fos.close();              // FileOutputStream fos = new FileOutputStream(\"src/test1/fos.txt\");        // OutputStreamWriter osw = new OutputStreamWriter(fos);        // OutputStreamWriter osw = new OutputStreamWriter(new        // FileOutputStream(\"src/test1/fos.txt\"),\"UTF-8\");        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"src/test1/fos.txt\"), \"GBK\");        osw.write(\"中国\");        osw.close();        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"src/test1/fos.txt\"), \"GBK\");        int ch;        while ((ch = isr.read()) != -1) &#123;            System.out.print((char) ch);        &#125;        isr.close();    &#125;&#125;💦字符流写数据的5种方式\n方法名说明\n\nvoid write(int c)写一个字符\n\nvoid write(char[] cbuf)写入一个字符数组\n\nvoid write(char[] cbuf, int off, int len)写入字符数组的一部分\n\nvoid write(String str)写一个字符串\n\nvoid write(String str, int off, int len)写一个字符串的一部分\n\nflush()刷新流，还可以继续写数据\n\nclose()关闭流，释放资源，但是在关闭之前会先刷新流。一旦关闭，就不能再写数据\n💦字符流读数据的2种方式\n方法名说明\n\nint read()一次读一个字符数据\n\nint read(char[] cbuf)一次读一个字符数组数据\n12345678910111213141516171819202122232425import java.io.FileInputStream;import java.io.IOException;import java.io.InputStreamReader;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"src/test1/fos.txt\"));        /*         * int ch;         * while((ch=isr.read())!=-1)&#123;         * System.out.print((char)ch);         * &#125;         */        char[] chs = new char[1024];        int len;        while ((len = isr.read(chs)) != -1) &#123;            System.out.print(new String(chs, 0, len));        &#125;        isr.close();    &#125;&#125;复制Java文件需求:把模块目录下的”ConversionStreamDemo.java” 复制到模块目录下的”Copy.java”\n思路:①根据数据源创建字符输入流对象②根据目的地创建字符输出流对象③读写数据,复制文件④释放资源\n1234567891011121314151617181920212223242526272829import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.io.InputStreamReader;import java.io.OutputStreamWriter;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        InputStreamReader isr = new InputStreamReader(new FileInputStream(\"src/test1/FileDemo.java\"));        OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream(\"src/test1/copy.java\"));        /*         * int ch;         * while ((ch = isr.read()) != -1) &#123;         * osw.write(ch);         * &#125;         */        char[] chs = new char[1024];        int len;        while ((len = isr.read(chs)) != -1) &#123;            osw.write(chs, 0, len);        &#125;        osw.close();        isr.close();    &#125;&#125;复制Java文件(改进版)需求:把模块目录下的”ConversionStreamDemo.java” 复制到模块目录下的”Copy.java”\n分析:\n①转换流的名字比较长，而我们常见的操作都是按照本地默认编码实现的，所以，为了简化书写,转换流提供了对应的子类\n②FileReader: 用于读取字符文件的便捷类FileReader(String fileName)\n③FileWriter: 用于写入字符文件的便捷类FileWriter(String fileName)\n④数据源和目的地的分析\n数据源: myCharStream\\ConversionStreamDemo.java —读数据— Reader — InputStreamReader — FileReader\n目的地: myCharStreaml\\Copy.java —写数据— Writer — OutputStreamWriter — FileWriter\n123456789101112131415161718192021222324252627import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        FileReader fr = new FileReader(\"src/test1/fos.txt\");        FileWriter fw = new FileWriter(\"src/test1/1111111.txt\");        /*         * int ch;         * while((ch=fr.read())!=-1)&#123;         * fw.write(ch);         * &#125;         */        char[] chs = new char[1024];        int len;        while ((len = fr.read(chs)) != -1) &#123;            fw.write(chs, 0, len);        &#125;        fr.close();        fw.close();    &#125;&#125;💦字符缓冲流字符缓冲流:\nBufferedWriter:将文本写入字符输出流，缓冲字符,以提供单个字符,数组和字符串的效写入，可以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途\nBufferedReader:从字符输入流读取文本,缓冲字符，以提供字符,数组和行的高效读取，可以指定缓冲区大小，或者可以使用默认大小。默认值足够大，可用于大多数用途\n构造方法:\nBufferedWriter(Writer out)\nBufferedReader(Reader in)\n1234567891011121314151617181920212223242526272829303132333435import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // FileWriter fw = new FileWriter(\"src/test1/1111111.txt\");        // BufferedWriter bw = new BufferedWriter(fw);        /*         * BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/fos.txt\"));         * bw.write(\"hello\\n\");         * bw.write(\"world\");         * bw.close();         */        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        /*         * int ch;         * while ((ch = br.read()) != -1) &#123;         * System.out.print((char) ch);         * &#125;         */        char[] chs = new char[1024];        int len;        while ((len = br.read(chs)) != -1) &#123;            System.out.print(new String(chs, 0, len));        &#125;        br.close();    &#125;&#125;复制Java文件(字符缓冲流改进版)需求:把模块目录下的”ConversionStreamDemo.java” 复制到模块目录下的”Copy,java”\n思路:\n①根据数据源创建字符缓冲输入流对象②根据目的地创建字符缓冲输出流对象③读写数据,复制文件④释放资源\n12345678910111213141516171819202122232425262728import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/11111.txt\"));        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        int ch;        while ((ch = br.read()) != -1) &#123;            bw.write(ch);        &#125;        /*         * char[] chs = new char[1024];         * int len;         * while ((len = br.read(chs)) != -1) &#123;         * bw.write(chs, 0, len);         * &#125;         */        br.close();        bw.close();    &#125;&#125;🔥字符缓冲流特有功能BufferedWriter: \nvoid newLine():写一行行分隔符， 行分隔符字符串由系统属性定义\nBufferedReader:\npublic String readLine():读一行文字。结果包含行的内容的字符串，不包括任何行终止字符,如果流的结尾已经到达，则为null\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // 创建字符缓冲输出流        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/fos.txt\"));        for (int i = 0; i &lt; 10; i++) &#123;            bw.write(\"hello\" + i);            bw.newLine();            bw.flush();        &#125;        bw.close();        // 创建字符缓冲输入流        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        /*         * // 第一次读取         * String line = br.readLine();         * System.out.println(line);         *          * // 第二次读取         * line = br.readLine();         * System.out.println(line);         */        String line;        while ((line = br.readLine()) != null) &#123;            System.out.println(line);        &#125;        br.close();    &#125;&#125;-----------------------------hello0hello1hello2hello3hello4hello5hello6hello7hello8hello9复制Java文件(字符缓冲流特有功能改进版)需求:把模块目录下的”ConversionStreamDemo.java” 复制到模块目录下的”Copy.java”\n思路:①根据数据源创建字符缓冲输入流对象②根据目的地创建字符缓冲输出流对象③读写数据，复制文件使用字符缓冲流特有功能实现④释放资源.\n12345678910111213141516171819202122import java.io.BufferedReader;import java.io.BufferedWriter;import java.io.FileReader;import java.io.FileWriter;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/11111.txt\"));        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        String line;        while ((line = br.readLine()) != null) &#123;            bw.write(line);            bw.newLine();            bw.flush();        &#125;        br.close();        bw.close();    &#125;&#125;案例集合到文件需求:把ArrayList集合中的字符串数据写入到文本文件。\n要求:每一个字符串元素作为文件中的一行数据\n思路:①创建ArrayList集合②往集合中存储字符串元素③创建字符缓冲输出流对象④遍历集合,得到每一一个字符串数据⑤调用字符缓冲输出流对象的方法写数据⑥释放资源\n12345678910111213141516171819202122import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        array.add(\"hello\");        array.add(\"world\");        array.add(\"java\");        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/fos.txt\"));        for (String s : array) &#123;            bw.write(s);            bw.newLine();            bw.flush();        &#125;        bw.close();    &#125;&#125;文件到集合需求:把文本文件中的数据读取到集合中,并遍历集合。\n要求:文件中每一行数据是一个集合元素\n思路:\n①创建字符缓冲输入流对象②创建ArrayList集合对象③调用字符缓冲输入流对象的方法读数据④把读取到的字符串数据存储到集合中⑤释放资源⑥遍历集合\n1234567891011121314151617181920import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        String line;        while ((line = br.readLine()) != null) &#123;            array.add(line);        &#125;        br.close();        for (String a : array) &#123;            System.out.println(a);        &#125;    &#125;&#125;点名器需求:我有一个文件里面存储了班级同学的姓名,每一个姓名占- -行, 要求通过程序实现随机点名器\n思路:\n①创建字符缓冲输入流对象②创建ArrayList集合对象③调用字符缓冲输入流对象的方法读数据④把读取到的字符串数据存储到集合中⑤释放资源⑥使用Random产生一个随机数， 随机数的范围在: [0,集合的长度)⑦把第6步产生的随机数作为索引到ArrayList集合中获取值⑧把第7步得到的数据输出在控制台\n1234567891011121314151617181920212223import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;import java.util.Random;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        ArrayList&lt;String&gt; array = new ArrayList&lt;&gt;();        String line;        while ((line = br.readLine()) != null) &#123;            array.add(line);        &#125;        br.close();        Random r = new Random();        int index = r.nextInt(array.size());        String name = array.get(index);        System.out.println(\"幸运者是:\"+name);    &#125;&#125;集合到文件(改进版)需求:把ArrayList集合中的学生数据写入到文本文件。要求:每一个学生对象的数据作为文件中的一行数据格式:学号,姓名,年龄,居住地\n举例: itheima001,林青霞 30,西安\n思路:①定义学生类②创建ArrayList集合③创建学生对象④把学生对象添加到集合中⑤创建字符缓冲输出流对象⑥遍历集合，得到每一个学生对象⑦把学生对象的数据拼接成指定格式的字符串⑧调用字符缓冲输出流对象的方法写数据⑨释放资源.\nStudent.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class Student &#123;    private String sid;    private String name;    private int age;    private String address;    public Student() &#123;    &#125;    public Student(String sid, String name, int age, String address) &#123;        this.sid = sid;        this.name = name;        this.age = age;        this.address = address;    &#125;    public String getSid() &#123;        return sid;    &#125;    public void setSid(String sid) &#123;        this.sid = sid;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getAge() &#123;        return age;    &#125;    public void setAge(int age) &#123;        this.age = age;    &#125;    public String getAddress() &#123;        return address;    &#125;    public void setAddress(String address) &#123;        this.address = address;    &#125;&#125;FileDemo.java\n123456789101112131415161718192021222324252627282930import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.ArrayList;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();        Student s1 = new Student(\"itheima001\", \"林青霞\", 30, \"安\");        Student s2 = new Student(\"itheima002\", \"林青\", 20, \"西\");        Student s3 = new Student(\"itheima003\", \"林\", 10, \"西安\");        array.add(s1);        array.add(s2);        array.add(s3);        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/fos.txt\"));        for (Student s : array) &#123;            StringBuilder sb = new StringBuilder();            sb.append(s.getSid()).append(\",\").append(s.getName()).append(\",\").append(s.getAge()).append(\",\")                    .append(s.getAddress());            bw.write(sb.toString());            bw.newLine();            bw.flush();        &#125;        bw.close();    &#125;&#125;文件到集合(改进版)需求:把文本文件中的数据读取到集合中，并遍历集合。\n要求:文件中每一行数据是一个学生对象的成员变量值\n举例: itheima001,林青 霞30,西安\n思路:\n①定义学生类，②创建字符缓冲输入流对象③创建ArrayList集合对象④调用字符缓冲输入流对象的方法读数据⑤把读取到的字符串数据用split(进行分割,得到一个字符串数组⑥创建学生对象⑦把字符串数组中的每一个元素取出来对应的赋值给学生对象的成员变量值\n123456789101112131415161718192021222324252627import java.io.BufferedReader;import java.io.FileReader;import java.io.IOException;import java.util.ArrayList;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        BufferedReader br = new BufferedReader(new FileReader(\"src/test1/fos.txt\"));        ArrayList&lt;Student&gt; array = new ArrayList&lt;&gt;();        String line;        while ((line = br.readLine()) != null) &#123;            String[] strArray = line.split(\",\");            Student s = new Student();            s.setSid(strArray[0]);            s.setName(strArray[1]);            s.setAge(Integer.parseInt(strArray[2]));            s.setAddress(strArray[3]);            array.add(s);        &#125;        br.close();        for (Student s : array) &#123;            System.out.println(s.getSid() + \",\" + s.getName() + \",\" + s.getAge() + \",\" + s.getAddress());        &#125;    &#125;&#125;集合到文件(数据排序改进版)需求:键盘录入5个学生信息(姓名,语文成绩,数学成绩英语成绩。要求按照成绩总分从高到低写入文本文件\n格式:姓名，语文成绩，数学成绩，英语成绩举例:林青霞98,99,100\n思路:\n①定义学生类②创建TreeSet集合，通过比较器排序进行排序③键盘录入学生数据④创建学生对象,把键盘录入的数据对应赋值给学生对象的成员变量⑤把学生对象添加到TreeSet集合⑥创建字符缓冲输出流对象⑦遍历集合,得到每一个学生对象⑧把学生对象的数据拼接成指定格式的字符串⑨调用字符缓冲输出流对象的方法写数据⑩释放资源\nStudent.java\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class Student &#123;    private String name;    private int chinese;    private int math;    private int english;    public Student() &#123;    &#125;    public Student(String name, int chinese, int math, int english) &#123;        this.name = name;        this.chinese = chinese;        this.math = math;        this.english = english;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name = name;    &#125;    public int getChinese() &#123;        return chinese;    &#125;    public void setChinese(int chinese) &#123;        this.chinese = chinese;    &#125;    public int getMath() &#123;        return math;    &#125;    public void setMath(int math) &#123;        this.math = math;    &#125;    public int getEnglish() &#123;        return english;    &#125;    public void setEnglish(int english) &#123;        this.english = english;    &#125;    public int getsum() &#123;        return this.chinese + this.math + this.english;    &#125;&#125;FileDemo.java\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.io.BufferedWriter;import java.io.FileWriter;import java.io.IOException;import java.util.Comparator;import java.util.Scanner;import java.util.TreeSet;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        TreeSet&lt;Student&gt; ts = new TreeSet&lt;Student&gt;(new Comparator&lt;Student&gt;() &#123;            @Override            public int compare(Student s1, Student s2) &#123;                int num = s2.getsum() - s1.getsum();                int num2 = num == 0 ? s2.getChinese() - s1.getChinese() : num;                int num3 = num2 == 0 ? s2.getMath() - s1.getMath() : num2;                int num4 = num3 == 0 ? s1.getName().compareTo(s2.getName()) : num3;                return num4;            &#125;        &#125;);        for (int i = 0; i &lt; 5; i++) &#123;            Scanner sc = new Scanner(System.in);            System.out.println(\"请录入第\" + (i + 1) + \"个学生信息\");            System.out.println(\"姓名:\");            String name = sc.nextLine();            System.out.println(\"语文成绩：\");            int chinese = sc.nextInt();            System.out.println(\"数学成绩:\");            int math = sc.nextInt();            System.out.println(\"英语成绩:\");            int english = sc.nextInt();            Student s = new Student();            s.setName(name);            s.setChinese(chinese);            s.setMath(math);            s.setEnglish(english);            ts.add(s);        &#125;        BufferedWriter bw = new BufferedWriter(new FileWriter(\"src/test1/fos.txt\"));        for (Student s : ts) &#123;            StringBuilder sb = new StringBuilder();            sb.append(s.getName()).append(\",\").append(s.getChinese()).append(\",\").append(s.getMath()).append(\",\")                    .append(s.getEnglish()).append(\",\").append(s.getsum());            bw.write(sb.toString());            bw.newLine();            bw.flush();        &#125;        bw.close();    &#125;&#125;复制单级文件夹需求:把“:\\itcast”这个文件夹复制到模块目录下\n思路:\n①创建数据源目录File对象，路径是E:\\itcast②获取数据源目录File对象的名称(itcast)③创建目的地目录File对象，路径名是模块名+ itcast组成(myCharStream\\itcast)④判断目的地目录对应的File是否存在，如果不存在，就创建⑤获取数据源目录下所有文件的File数组⑥遍历File数组，得到每一个File对象, 该File对象,其实就是数据源文件数据源文件: E:\\itcast\\mn.jpg⑦获取数据源文件File对象的名称(mn.jpg)⑧创建目的地文件File对象，路径名是目的地目录+mn.jpg组成(myCharStream\\itcast\\mnjpg)⑨复制文件    由于文件不仅仅是文本文件，还有图片，视频等文件，所以采用字节流复制文件\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // 创建数据源目录File对象        File srcFolder = new File(\"/Users/dx/Documents/test\");        // 获取数据源目录File对象的名称        String srcFolderName = srcFolder.getName();        // 创建目的地目录File对象的名称        File destFolder = new File(\"src\", srcFolderName);        System.out.println(destFolder);        // 判断目的地目录对应的File是否存在        if (!destFolder.exists()) &#123;            destFolder.mkdir();        &#125;        // 获取数据源目录下所有文件的File数组        File[] listFiles = srcFolder.listFiles();        for (File srcFile : listFiles) &#123;            String srcFileName = srcFile.getName();            File destFile = new File(destFolder, srcFileName);            copyFile(srcFile, destFile);        &#125;    &#125;    private static void copyFile(File srcFile, File destFile) throws IOException &#123;        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));        byte[] bys = new byte[1024];        int len;        while ((len = bis.read(bys)) != -1) &#123;            bos.write(bys, 0, len);        &#125;        bos.close();        bis.close();    &#125;&#125;复制多级文件夹需求:把“E:\\itcast”复制到F盘目录下\n思路:\n①创建数据源File对象，路径是E:\\itcast②创建目的地File对象，路径是F:\\l③写方法实现文件夹的复制，参数为数据源File对象和目的地File对象④判断数据源File是否是目录    是:        A:在目的地下创建和数据源File名称-样的目录        B:获取数据源File下所有文件或者目录的File数组        C:遍历该File数组，得到每-个File对象        D:把该File作为数据源File对象，递归调用复制文件夹的方法    不是:说明是文件，直接复制，用字节流\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;        // 创建数据源目录File对象        File srcFile = new File(\"/Users/dx/Documents/test\");        // 创建目的地目录File对象的名称        File destFile = new File(\"src\");        copyFolder(srcFile, destFile);    &#125;    private static void copyFolder(File srcFile, File destFile) throws IOException &#123;        // 判断数据源File是否是目录        if (srcFile.isDirectory()) &#123;            // 在目的地下创建和数据源File名称-样的目录            String srcFileName = srcFile.getName();            File newFolder = new File(destFile, srcFileName);            if (!newFolder.exists()) &#123;                newFolder.mkdir();            &#125;            // 获取数据源File下所有文件或者目录的File数组            File[] fileArray = srcFile.listFiles();            // 遍历该File数组，得到每-个File对象            for (File file : fileArray) &#123;                // 把该File作为数据源File对象，递归调用复制文件夹的方法                copyFolder(file, newFolder);            &#125;        &#125; else &#123;            // 说明是文件，直接复制，用字节流            File newFile = new File(destFile, srcFile.getName());            copyFile(srcFile, newFile);        &#125;    &#125;    private static void copyFile(File srcFile, File destFile) throws IOException &#123;        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));        byte[] bys = new byte[1024];        int len;        while ((len = bis.read(bys)) != -1) &#123;            bos.write(bys, 0, len);        &#125;        bos.close();        bis.close();    &#125;&#125;复制文件的异常处理\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;public class FileDemo &#123;    public static void main(String[] args) throws IOException &#123;    &#125;    //// JDK9的改进方案    private static void copyFile4(File srcFile, File destFile) throws IOException &#123;        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));        try (bis; bos) &#123;            byte[] bys = new byte[1024];            int len;            while ((len = bis.read(bys)) != -1) &#123;                bos.write(bys, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // JDK7的改进方案    private static void copyFile3(File srcFile, File destFile) &#123;        try (BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));                BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));) &#123;            byte[] bys = new byte[1024];            int len;            while ((len = bis.read(bys)) != -1) &#123;                bos.write(bys, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125;    &#125;    // 取消throws IOException    private static void copyFile2(File srcFile, File destFile) &#123;        BufferedInputStream bis = null;        BufferedOutputStream bos = null;        try &#123;            bis = new BufferedInputStream(new FileInputStream(srcFile));            bos = new BufferedOutputStream(new FileOutputStream(destFile));            byte[] bys = new byte[1024];            int len;            while ((len = bis.read(bys)) != -1) &#123;                bos.write(bys, 0, len);            &#125;        &#125; catch (IOException e) &#123;            e.printStackTrace();        &#125; finally &#123;            if (bis != null) &#123;                try &#123;                    bis.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;            if (bos != null) &#123;                try &#123;                    bos.close();                &#125; catch (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    private static void copyFile(File srcFile, File destFile) throws IOException &#123;        BufferedInputStream bis = new BufferedInputStream(new FileInputStream(srcFile));        BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream(destFile));        byte[] bys = new byte[1024];        int len;        while ((len = bis.read(bys)) != -1) &#123;            bos.write(bys, 0, len);        &#125;        bos.close();        bis.close();    &#125;&#125;312占位符","plink":"https://dxsummer.gitee.io/posts/df2849ec/"},{"title":"python考试","date":"2021-05-31T11:54:43.000Z","date_formatted":{"ll":"2021年5月31日","L":"2021/05/31","MM-DD":"05-31"},"updated":"2021-05-31T11:55:22.000Z","content":"重复的字符\n给定一个字符串，找到它的第一个不重复的字符，并返回它的索引。如果不存在，则返回 -1。\n\n案例:\n12345s = \"leetcode\"返回 0.s = \"loveleetcode\",返回 2.123456789101112131415161718class Solution:\tdef firstUniqChar(self, s):\t\tcount = len(s)\t\tfor ch in range (0,len(s)):\t\t\tc=0\t\t\tfor a in range (0,len(s)):\t\t\t\tif a == ch:\t\t\t\t\tcontinue\t\t\t\telif s[ch] == s[a]:\t\t\t\t\tc=1\t\t\t\t\tbreak\t\t\tif c==0:\t\t\t\tprint(ch)\t\t\t\tbreak\t\tif c==1:\t\t\tprint(\"-1\")a=Solution()a.firstUniqChar(\"ddass\")合并两个有序数组\n给你两个有序整数数组 nums1 和 nums2，请你将 nums2 合并到 nums1 中，使 nums1 成为一个有序数组。\n\n\n初始化 nums1 和 nums2 的元素数量分别为 m 和 n 。你可以假设 nums1 的空间大小等于 m + n，这样它就有足够的空间保存来自 nums2 的元素。\n\n示例 1：\n12输入：nums1 &#x3D; [1,2,3,0,0,0], m &#x3D; 3, nums2 &#x3D; [2,5,6], n &#x3D; 3输出：[1,2,2,3,5,6]示例 2：\n12输入：nums1 &#x3D; [1], m &#x3D; 1, nums2 &#x3D; [], n &#x3D; 0输出：[1]1234567891011121314class Solution:\tdef merge(self, nums1: list[int], m: int, nums2: list[int], n: int) -&gt; None:\t\tnums1[m:n+m]=nums2[:n]\t\tfor i in range(len(nums1), 0, -1):\t\t\tflag = 0\t\t\tfor j in range(i - 1):\t\t\t\tif nums1[j] &gt; nums1[j + 1]:\t\t\t\t\tnums1[j], nums1[j + 1] = nums1[j + 1], nums1[j]\t\t\t\t\tflag = 1  # 标记存在元素交换\t\t\tif not flag:\t\t\t\tbreak  # 如果本趟遍历没有发生元素交换，直接跳出循环\t\tprint(nums1)a = Solution()a.merge(nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3)存在重复元素\n给定一个整数数组，判断是否存在重复元素,如果任何值在数组中出现至少两次，函数返回 true。如果数组中每个元素都不相同，则返回 false。\n\n示例 1:\n12345# 输入: [1,2,3,1]# 输出: True示例 2:\n12345# 输入: [1,2,3]# 输出: False1234567891011class Solution:    def containsDuplicate(self, nums: list[int]) -&gt; bool:        d = &#123;&#125;        for num in nums:            if num not in d:                d[num] = 0            else:                return True        return Falsea= Solution()print(a.containsDuplicate([1,2,3]))只出现一次的数字给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。\n思路：\n使用哈希表，第一次遍历记录元素出现的次数，第二次遍历查询只出现一次的元素。\n示例 1:\n12输入: [2,2,1]输出: 1示例 2:\n12输入: [4,1,2,1,2]输出: 4程序：\n123456789101112131415class Solution:    def singleNumber(self, nums: list[int]) -&gt; int:        length = len(nums)        if length &lt;= 0:            return \"error\"        if length == 1:            return nums[0]        myHashMap = &#123;&#125;        for num in nums:            myHashMap[num] = myHashMap.get(num, 0) + 1        for num in nums:            if myHashMap.get(num) == 1:                return numa=Solution()print(a.singleNumber([1,2,3,3]))最长公共前缀编写一个函数来查找字符串数组中的最长公共前缀。\n如果不存在公共前缀，返回空字符串 “ ”。\n示例 1:\n12输入: [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]输出: &quot;fl&quot;示例 2:\n123输入: [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]输出: &quot;&quot;解释: 输入不存在公共前缀。1234567891011121314151617181920212223class Solution:\tdef longestCommonPrefix(self, strs):\t\tif len(strs) == 0:\t\t\treturn ''\t\telif len(strs) == 1:\t\t\treturn strs[0]\t\telse:\t\t\tb = sorted(strs, key=lambda x:len(x))\t#按字符串的长度进行排序\t\t\t\t\t\ts = ''\t\t\ts1 = b[0]\t\t\tfor i, v in enumerate(s1):\t#对第一个字符串进行枚举，遍历其每一个字符\t\t\t\tl = []\t\t\t\tfor j in b[1:]:\t\t\t#从第二个字符串开始遍历之后的所有字符串\t\t\t\t\tl.append(v==j[i])\t#将字符比较的bool值添加到列表l中\t\t\t\t\t\t\t\tif all(l):\t\t\t\t#如果列表l中的所有值都为True\t\t\t\t\ts += v\t\t\t\telse:\t\t\t\t\tbreak\t\treturn sa = Solution()print(a.longestCommonPrefix([\"flower\", \"flow\", \"flight\"]))成绩统计【问题描述】 小蓝给学生们组织了一场考试，卷面总分为 100 分，每个学生的得分都是一个 0 到 100 的整数。 如果得分至少是 60 分，则称为及格。如果得分至少为 85 分，则称为优秀。 请计算及格率和优秀率，用百分数表示，百分号前的部分四舍五入保留整数。\n【输入格式】 输入的第一行包含一个整数 n，表示考试人数。 接下来 n 行，每行包含一个 0 至 100 的整数，表示一个学生的得分。\n【输出格式】 输出两行，每行一个百分数，分别表示及格率和优秀率。 百分号前的部分四舍五入保留整数。\n【样例输入】\n12345678780925674881000【样例输出】\n1271%43%123456789101112131415161718n = int(input())passed = []excellent = []for i in range(n):    a = int(input())    if a &gt;= 60:        passed.append(a)    if a &gt;= 85:        excellent.append(a)passed_0 = round(len(passed) / n * 100)excellent_0 = round(len(excellent) / n * 100)print(str(passed_0) + '%')print(str(excellent_0) + '%')单词分析题目描述 \n小蓝正在学习一门神奇的语言，这门语言中的单词都是由小写英文字母组成，有些单词很长，远远超过正常英文单词的长度。小蓝学了很长时间也记不住一些单词，他准备不再完全记忆这些单词，而是根据单词中哪个字母出现得最多来分辨单词。现在，请你帮助小蓝，给了一个单词后，帮助他找到出现最多的字母和这 个字母出现的次数。输入描述输入一行包含一个单词，单词只由小写英文字母组成。 对于所有的评测用例，输入的单词长度不超过 1000。输出描述输出两行，第一行包含一个英文字母，表示单词中出现得最多的字母是哪 个。如果有多个字母出现的次数相等，输出字典序最小的那个。\n第二行包含一个整数，表示出现得最多的那个字母在单词中出现的次数。\n示例 1\n输入\n1lanqiao输出\n12a2示例 2\n输入\n1longlonglongistoolong输出\n12o612345678910word = str(input())a = 0data = []for i in word:    cou = word.count(i)    if cou &gt; a:        data = [i]        a = couprint(data[0])print(a)","plink":"https://dxsummer.gitee.io/posts/aabdde41/"},{"title":"穿越机配置单","date":"2021-05-18T12:30:07.000Z","date_formatted":{"ll":"2021年5月18日","L":"2021/05/18","MM-DD":"05-18"},"updated":"2021-05-18T12:33:20.000Z","content":"\n电调曼巴F722 mini 30A 20*20 2-6S\n\n电机T-MOTOR 1507 2700KV\n\n图传rush tank mini800w 黑羊TBS UNIFY PRO32 HV 1W+ （高压版800mw也很好用）\n\n棒棒糖3代\n\n桨乾丰75mm涵道桨 HQ CINEWHOOP3 75mm\n\n摄像头foxeer 无牙仔 RUNCAM Nano2\n\n接收机Rxsr 黑羊TBS Crossfire Nano RX V2\n\n电池格氏Rline 1050mah 6S 放电倍率65c以上\n比如你打算组一台2寸机，那么电机就选11XX开头的，\n如果你想要一台3寸机，那么电机就选14XX-15XX开头的\n5寸机，那么电机就是主流 的22XX-23XX开头的了\n队长穿越之旅 篇二：带给你不一样的空中视角之穿越机动力篇_电机 (sohu.com)\n两组power(功率)，efficlency(效率)，我们要知道的是efficlency=Pull÷power，\n相同条件下，efficlency越小，越费电。\n最后一组是持续15秒的电机温度是59℃，这些参数了解就行，你就能大概知道这是一个什么样的电机了。是要拉力大的呢还是要飞行时长更长的呢？你想飞竞速就暴力一点的，你想要花飞呢就柔和一点的。\n电池\n一般个电芯的电压是3.7V-4.2V，S级越多，电压越高也就越暴力。但是S级越多，也就越重，酌情衡量。一般在说明上还会注4S1P，4S2P，这个1P中的P是Parallel的缩写（并联），4S1P就是1颗电芯串联的电池，而4S2P就是将两颗4S电池并联的电池，我们现在穿越机一般都是1P。\n这个很重要，C数就是电池的放电能力，C数越大，放电能力越强，一般老手都是100C以后，要知道以前我连40C的电池都飞过。。。\n放电倍率怎么算呢？如上图的1300mAh 120C电池，就是1.3X120=156A，而这些有什么用呢？只知道他暴不暴力？不是的，知道了这个，我们就可以同电机联系起来了，比如你选的电机最大支持电流40A，那么4个就是160A，而上图这块电池就可以用，但是你说100C的能不能用，当然也可以用，别说100C了，80C也能用，只是大油门不上。\n电压\n其实电压也是很重要的一个参数，如果你是土豪可以略过。一般个电芯的电压是3.7V-4.2V，我们在飞的时候OSD上有电压显示（没有的话最好调出来），一般遥控上都能设置低电压报警，一般不能低于3.6V，否则对电池不好。\n桨叶\n同转速下桨叶越多拉力越大，同拉力下桨叶越少效率越高，也就是越省电。\n1、尺寸\n尺寸的问题是一个老生常谈的问题，就是为了配套。桨叶上有一串的数字，比如5045、5055。这串数字的意思是什么呢？前面的50就是5寸桨，适合5寸机，如果是30开头的就是3寸桨。\n2、螺距（也叫桨距）\n同是这串数字，后面两位就是螺距，比如5045的桨，45就是螺距，螺距是指螺旋桨上每个叶片的角度。简而言之，螺旋桨的螺距是该螺旋桨在理想环境中每转一圈将前进多远的距离。螺距小了不出力，螺距大了又失速。低螺距的螺旋桨，能更加容易快速的改变方向，且响应更快。所以到后来，螺距精确到三位数了，比如50499。\n3、桨叶横切面（桨型）\n桨型好了效率高，桨型差了电机烫。\n电调A\n主要看电机搭配桨叶运行时候的电流，一般选择电机最大电流的1.5倍的电调较好。\n比如：电机的最大运行电流是40A，那么选择40*1.5=60A的电调比较合适。\n","plink":"https://dxsummer.gitee.io/posts/f65c706c/"},{"title":"穿越机详解","date":"2021-05-18T12:29:56.000Z","date_formatted":{"ll":"2021年5月18日","L":"2021/05/18","MM-DD":"05-18"},"updated":"2021-05-18T12:33:54.000Z","content":"机架篇创作立场声明：身临其境地飞行体验，太棒了。让我们从头开始，讲讲穿越机的组成\n前言\n穿越机，俗称FPV(First Person View)，也就是第一人称视角，从以前的遥不可及，到现在的平民化，连一向不屑进军穿越机的大疆都出了DJI FPV，不过较早进军穿越机的厂商应该是华科尔，但是现在华科尔的重心已经从穿越机转移到了工作机上面了。也有越来越多的人加入穿越机，成为一名飞手，体验第一视角飞行带来的身临其境。\n很多人玩腻了大疆等航拍无人机的视角，现在想体验新的航拍角度，穿越机是个不错的选择，不过从“驾驶”难度来说，这两个不是一个量级的，可能你飞DJI是个老手，却从没体验过穿越机，那么贸然上手就一定是“炸机”这一个结局。\n\n穿越机由多个部件组成，之前我也写过穿越机的组装，有兴趣的朋友可以翻回去看看。今天这篇我们从机架开始说起，这篇以传统的4轴机架来展开。\n一、尺寸先说穿越机机架的尺寸，可以先看作是机架的大小，那些老手说的“X寸机架”(这里的寸是英寸)，一般市面上能买到的是2-6寸的机架，2寸机架基本可以放在手里了，俗称“牙签机”，特点就是小，轻，家里都可以飞。\n但其实这个“寸”不是直接形容机架的，而是而是其匹配的螺旋桨的大小。一般几寸机就是配几寸桨。\n\n机架的尺寸就是两轴对角的距离，就是装电机的中心位置开始测量。一般常用的三寸机大概150mm，五寸机210mm。如果按寸来算的话，五寸机只有127mm，所以这样算是不对的。\n在你要入手之前你要选择好自己的机架，一般新手我建议从比较小的入手，比较耐炸，炸机的成本也低。\n二、材质\n穿越机机架的材质与民用航拍机有很大区，航拍无人机像大疆mavic这种，外表的覆盖件材质是PS/ABS，没有办法，需要塑造成不同好看的形状，只能这样。而穿越机炸机的概率要比民用航拍机高得多，ABS炸一下，不管是不是草地，基本就坏了，使用成本太高，得另辟蹊径，所以到目前为止，基本使用的是碳纤维复合材料为主， 碳纤维复合材料具有高强度、设计性好、结构尺寸稳定性好、抗疲劳断裂性好和可大面积整体成型，非常耐用，草地上炸一下，基本完好，最总要的是轻。炸机角度要是刁钻的话当我没说。\n\n当然， 使用碳纤维的缺点也是有的，就造型上没有航拍机那么漂亮，都是由直直的板一块一块拼装起来，由螺丝和铝柱连接，中间固定飞控的还需要安装减震，连装个电池都要用扎带，对不喜欢的人来说毫无美感。但是这样不是一体的的造型还有一个好处就是，换配件方便，经济，比如炸坏一根机臂就只换一根机臂，而不需要整体更换。\n\n但组完以后，还是很漂亮的，不是吗？机身基本属于敞篷的原因是为了更好的散热，图传的发热量是很大的。这个以后再说。\n三、机型机型就是机架的样子，先不去管机架是怎么设计的、他设计的样子和在轴对称上对 pitch/roll到底是什么关系，我们只要知道大概飞行感受就行，下面介绍的大致思路就是这样。\nQVA\n这可能是最经典的机架了， 经常被做为入门型的推荐，结构简单，便宜，空间巨大，什么都能塞，如果连QVA机架都装不好机的话，还是改行玩别的吧。\n因为他的存在时间太长，穿越机发展这么多年他依旧还在，所以都不是一点点的审美疲劳了，而且现在就算是刚入坑的粘伙伴也不差那点钱，为了颜值都会直接上主流机架，不过这穿越机界鼻祖级别的存在还是要提一下的，以示尊重。虽然看上去不太聪明的样子。\n1、竞速机架（Race）这类机架的设计之初就是速度是唯一的追求，是无人机界的F1。一般竞速机都是5寸机架，因为经过多次试验，5寸机刚刚好（废话，等于没说）。那么对于老手来说，飞行时机架的区别在飞行体验上还是挺明显的。\n\n竞速机架在设计上中心板会比较小，空间局促、紧凑，机臂会比较细，比较粗。因为竞速的炸机概率要比其他飞行大得多，首先在设计的时候得考虑他耐炸性。\n\n同时，由于中心板设计的关系，穿越机的重心基本都会在中心点，而前机臂的距离和侧机臂的距离也基本相同，这样的好处是pitch/roll的打杆力度/保持时间不会有太大的差异，在高速飞行的时候不用特意地去练习，做到上下和前后一样。竞速机架一般都是X形机架，多为正X（前轴距=侧轴距）。\n不过由于中心板空间过小，在装配的时候还是有一点难度的，走线什么的要提前规划好。\n2、花飞机架(Freestyle)花飞，就是飞手们说的Freestyle，你有Freestyle吗？相比竞速机架，花飞机架没有那么多的条条框框，但是进化到现在的，传统的宽机臂也已经变成了和竞速一样的窄机臂了，看上去更加美观。\n\n与竞速机架的区别一眼就能看出，是中心板的长度，过富裕的机身空间，有利于安放更多的硬件，毕竟，穿越机航拍就是这类机架为主体，所以他追求的并不是暴力和轻量化，有时候会往续航和距离倾斜。鉴于此，机身内安装的更大功率的图传，就像上图中的DJI天空端（很多正X机架也有此设计）已经被装在了机身后部。\n\n花飞机架大体结构都是类似的，有些4个机臂会交叉在一个点上，有些则不会，而有些前机臂和侧机臂的距离不同，有些则和竞速机一样相同。如果前机臂和侧机臂的距离不同，则是为了妥协一些不同的飞行体验，如前窄侧宽的设定会使横滚（roll）更加快速，反之则是俯仰(pitch)更加容易。花飞机架H形长X（前轴距＜侧轴距）或H形宽X（前轴距＞侧轴距）机架。一般的机架前后轴距是一样的。\n说完这两个最常作对比的类型，那么很多人会问，第一台机架到底是选哪种好？要我说，新手是飞不出来差别的，你的控制还达不到那么细腻的程度。所以看你个人喜好吧，还有就是动手能力，这两点才是你选择的重点。如果经济能力允许，我建议两台都装，哦不，还有下面这台，一起收了吧。\n3、涵道机架（Duct Propeller ）\n看图就能很好的明白了，所谓涵道机就是用圈圈把桨叶保护起来的机架，看上去中间就像是花飞机架，被称为最安全的穿越机，因为有桨叶保护圈，所以就算撞人也不怕。\n\n看机架配件图，就能看出其实他不是在花飞机架上装一个桨叶保护套那么简单，而是一体结构的。在机架上装了那么多东西，你要是做花飞动作，当然也不是不可以，只是你会觉得他比较费力，所以他的特点是稳定，安全，续航时间长还不挑场地，这点很重要，我们常常要为一次爽飞开好久的车（我知道你们想开什么车），而如果是涵道机，那你就幸福了。\n\n虽然是平稳飞行，那是相对于穿越机来说的，他的自由度比航拍无人机那是要多得多的，毕竟骨子里的硬件还是穿越机的。但如果你真要做些动作，只能提醒你先飞高一点再来做动作，你需要适应适应。\n4、异形机架这类机架，应该是表现个性的一种展示，传统机架用多了，或者看腻了，想换一种口味，当然不能被外表所欺骗，有此设计还是有道理的，只是我才疏学浅看不懂罢了。\n\n比如这款SINGLARITUM V5机架，中间类似竞速机架，不过机臂则是竖起来的，而且四周加了一圈碳板，也是竖的，咋眼一看就觉得是为了保护加强的。不过人家还杂糅了不少空气动力学在里面，这款是德国的机架，不过类似的机架国产的也很多。\n\n还有这款Super RC Range机架，前轴和后轴也不一样，闻上去有点仿生学的味道，不过人家说了适合远航。\n5、空心杯很多人说空心杯就是个玩具，不管是飞机还是遥控，都是玩具级别的。\n\n看样子还真的有点像，不过在文中我说过了很多遍，不要被他外表所欺骗，虽然和前面提到的涵道机差不多样子，但是他的材质是塑料的，非常轻，动力系统也和传统的穿越机不一样。但他的好处是显而易见的，小啊，还有桨叶保护套，哪里都能飞，不挑场地，撞到人也不怕。他还可以很暴力。\n\n如果你实在介意你的空心杯的样子和像小孩玩具一样的遥控器，那么，你选个2寸机架组一台加个桨叶保护罩子，就会比较合你意了。\n四、总结\n当初我就是被这款名叫armattam chameleon（变色龙）的机架迷得不要不要的，国内还买不到。不过我们现在看图就知道了，他的头部固定摄像头的是铝合金，很重，每次过弯就一定会推头，所以操作起来需要适应，幸好我没买（还不是因为穷）。\n穿越机发展到今天各方面都已经是非常成熟了，机架的选择余地也是较早前有着天差地别，不管是实用性，美观度都有不同的方向，还有一系列的3D打印件作为配套，来辅助更多的拓展。刚入坑的，不对，是刚入门的新手，可以向自己喜欢的方向做选择了。\n\n所谓炸机一时爽，一直炸机一直爽，不炸怎么有好的技术呢？\n动力篇2021-05-10 19:01:16 5点赞 14收藏 1评论\n创作立场声明：这篇说说穿越机动力的组成，也是核心部件。\n前言\n上一篇我介绍了穿越机机架，在选择完机架后，就可以选择电机了，这一是全循序渐进的过程，多大的机架配多大的电机。选择完电机后我们就可以选择桨叶，也是多大电机配多大桨叶。同时配合电动，我们可以选择多大的电池。这一篇我们来聊聊穿越机的动力组成以及怎么选择。\n很多朋友在选择穿越机组件的时候，多是按照自己的喜好去的，这无可厚非，但是你买的组件一定不会是同一品牌的同一系列的，就算是整机购买，也不是一个品牌的，只是商家会给你安排好套餐选择，这样的到手飞对新手来说是很友好的，但是没有经过自己动手组装，仿佛少了点灵魂和乐趣。\n一、电机\n电机的选择对你的飞行是有挺大的影响的，速度的快慢是一回事，机动性也是一个很重要的参数，好的电机能让你很跟手，做到人机合一，不过电机对飞行不是单一因素，还有电调，电池，桨叶。\n\n在你选择完机架的时候，电机的大小也就定了，比如你打算组一台2寸机，那么电机就选11XX开头的，如果你想要一台3寸机，那么电机就选14XX-15XX开头的，不过很多人第一台机会直接上5寸机，那么电机就是主流 的22XX-23XX开头的了。有些人会听得一头雾水，不要着急，这里说是11XX，15XX等是就是电机的参数。那么电机的参数有多个，我们一个个讲。\n1、尺寸\n电机的尺寸，就是我们上面说是11XX，15XX这组数字，电机用4个数字来表示。如上图电机中所标的2207，我们只要知道这是什么概念就可以了，2207，前两位表示宽度，也是电机定子的直径，后两位是电机定子的高度，这有什么用呢？ 定子越宽，扭力越大，定子越高，转速越快。\n2、KV值\nKV值指的是每增加1伏特电压,电机相应增加的转速，电机KV值：电机的转速（空载）=KV值X电压；例如KV1000的电机在10V电压下它的转速（空载）就是10000转/分钟。当然我们不用去记这个公式，我们只需要知道KV值越小，扭矩越大，转数越低，越省电。反之，KV值越大，扭矩越小，转数越高，越耗电。所以KV值与你选择桨叶有莫大的关系，小KV值电机选大桨叶，大KV值电机选电桨叶。\n3、力效表\n正规大厂生产的电机都会有力效表，不要求能全部看懂，我们主要去获取几个有用的信息就好，比如上图是你看中的电机，我们能从中获取除了尺寸以外的很多信息。如他支持的是5S-6S的电池，而你手里却只有4S的电池，那么就不能选这一款了。\n当然还有电机的孔距，上图电机是16mm，这要与你机架支持的孔距相符，不然装不上去。而不同的桨叶对电机有着不同的表现，如GF543的桨叶，在21V电池（就是5S电池）100%的油门力度下，电流是20.3A，拉力为1645G，后面两组power(功率)，efficlency(效率)，我们要知道的是efficlency=Pull÷power，相同条件下，efficlency越小，越费电。最后一组是持续15秒的电机温度是59℃，这些参数了解就行，你就能大概知道这是一个什么样的电机了。是要拉力大的呢还是要飞行时长更长的呢？你想飞竞速就暴力一点的，你想要花飞呢就柔和一点的。\n二、电池\n一般目前使用的电池都是锂电，也就是Lipo，从前几年的4S到目前的6S，穿越机的电池是越来越暴力了，快感真的是一波接着一波，就像手机一样，更新的太快。而我们从电池需要理解几个参数，这对穿越机的组装选择有着重大意义—配不配套。\n1、S数就是我们说的几S电池，穿越机电池是由几片独立的电芯串联在一起的，几片就是几S，这个很好理解，为什么要说这个呢？因为很多电调，飞控是有限制的，比如很多F4的飞控只支持4S电池，所以避免不配套，选购之前得看清楚。\n\n一般个电芯的电压是3.7V-4.2V，S级越多，电压越高也就越暴力。但是S级越多，也就越重，酌情衡量。一般在说明上还会注4S1P，4S2P，这个1P中的P是Parallel的缩写（并联），4S1P就是4颗电芯串联的电池，而4S2P就是将两颗4S电池并联的电池，我们现在穿越机一般都是1P。\n2、电池容量mAh这个很好理解了，正常来说容量越大飞得越久，当然，也越重。越重的电池飞机得克服多余的重量来做功，有时候4000mah的电池反而续航不如1800mah的。\n拿下图来说明，1300mah电池，ma是电流单位，H是时间单位，也就是说这个电池以1300ma电流可持续放电1小时；不过这个续航只能做为一个参考，因为你根本算不准，当然你飞机整机输出一定是大于这个1300ma的，\n再者你一架飞机算他300克-400克，飞机得抗飞，抗平衡等，4个电机加起来的推力得有600克吧。所生产的电流要绝对大于1300ma的，所以一般电池只能飞几分钟，暴力飞只有3-4分钟。\n3、C数\n这个很重要，C数就是电池的放电能力，C数越大，放电能力越强，一般老手都是100C以后，要知道以前我连40C的电池都飞过。。。\n放电倍率怎么算呢？如上图的1300mAh 120C电池，就是1.3X120=156A，而这些有什么用呢？只知道他暴不暴力？不是的，知道了这个，我们就可以同电机联系起来了，比如你选的电机最大支持电流40A，那么4个就是160A，而上图这块电池就可以用，但是你说100C的能不能用，当然也可以用，别说100C了，80C也能用，只是大油门跟不上。\n4、电压其实电压也是很重要的一个参数，如果你是土豪可以略过。一般个电芯的电压是3.7V-4.2V，我们在飞的时候OSD上有电压显示（没有的话最好调出来），一般遥控上都能设置低电压报警，一般不能低于3.6V，否则对电池不好。\n好的电池每一片电芯的都基本保持相等，不管充电和放电都一样，同样，电池的内阻也是越小越好，不过内阻得插上充电器才能看得出来。一分价钱一分货，不要贪便宜，选择大厂。\n三、电调\n电调就是在穿越机老手口中的ESC，他的工作内容就是响应来自飞控的命令来控制电动机的转速。这就很重要了，你遥控打杆后的回应当然是越快越好了，就是俗称的跟手，要是延迟大，这就很容易炸机了。\n\nESC由原来的分体式到现在的四合一，这个我简单说一下优缺点：\n四合一：优点：轻，装机简单，布线好看。缺点：坏就得全换，炸机成本高\n分体：优点：坏哪换哪，易维护。缺点：装机略复杂，布线不如一体好看，略重一点\n不过以现在的机架普遍窄机臂走向，是越来越容不得分体式电调了，以审美角度来说，窄机臂比宽机臂是要好看不少，同时也可以在机臂留出空间给LED。而不管分体还是四合一，我们都要从几个维度进行选择。\n1、尺寸\n没错，选电调也得考虑一下尺寸，正规厂家都会给出参数。如果你选择分体式的电调，一般宽度在10-14mm之间，就是说，你的机臂宽度得在这个区间，要不然，电调宽于机臂，不好看不说，炸的时候更容易坏。\n而如果选择四合一电调的话，我们还得注意他的孔距，这是第一步，不然你装不上，大体如下：\n30.5x30.5mm,M3 用于5-7寸飞机\n20x20mm,M2用于3-5寸飞机\n25.5x25.5mm,M2用于3寸以下飞机\n16x16mm,M2用于2寸以下飞机\n这里的M3/M2是螺丝规格。\n\n除些之外，我们还得注意他的三围尺寸，这也取决于你选购的机架，最好宽度不要超出机身。也是为了炸机的时候不会有太大的损失。\n2、电压、电流\n支持电压不用多说，取决于你选择的电机、飞控支持的电压，最好选择宽电压，如上图的3-6S。还有就是持续电流和瞬时电流这两个重要参数。选择上，电调的持续电流要大于电机的持续电流，我们要给给电调留余量。\n瞬时电流就比较重要了，它能确保电机堵转（可能炸机，可能故障）的时候，不致使电调烧毁，一般电机堵转瞬间的电流是电机最大电流的两倍。\n电调是个比较耐造的玩意儿，可以150%超负荷工作大约30秒钟而没有太大损伤，比如满油门45A，你选择个40A的电调完全可以满足新手，就连一般玩穿越机的就可以胜任。\n3、固件、协议\n其实这个已经比较有深度了，以前的协议有PWM，OneShot125,到现在的DShot300/600/1200，记住一点就可以了，越到后面操控越顺滑，越跟手。\n而固件取决于处理器，电调使用什么处理器相应的就是使用什么固件，如EFM8BB21F处理器使用BLHeli_S，STM32F0和STM32F3处理器使用BLHeli_32。不过一般现在的电调都使用后者。\n所以，仔细看文章的同学会发现，穿越机很多部件都是相互协调的，比如今天说的电机和电调，适配才最重要，要不然一个天花板一个地板，不但浪费还发挥不出性能。\n四、桨叶\n桨叶在穿越机中绝对是么一耗材，不过也是很便宜的，很多人一买就几十包，坏了就换，毫不心疼，但这也是一个高阶的选择，一般只要知道我们飞的是几寸选择几寸桨即可，但是一般穿越机都是用三叶桨，DJI航拍机用的是两叶桨，有何区别？同转速下桨叶越多拉力越大，同拉力下桨叶越少效率越高，也就是越省电。\n怎么选桨叶呢？新手一定一脸懵，只要尺寸对，样子颜色自己喜欢就可以了。那么我就简单说说吧，不同的桨叶萌新可能都飞不出有什么不同。\n1、尺寸尺寸的问题是一个老生常谈的问题，就是为了配套。桨叶上有一串的数字，比如5045、5055。这串数字的意思是什么呢？前面的50就是5寸桨，适合5寸机，如果是30开头的就是3寸桨。\n2、螺距（也叫桨距）同是这串数字，后面两位就是螺距，比如5045的桨，45就是螺距，螺距是指螺旋桨上每个叶片的角度。简而言之，螺旋桨的螺距是该螺旋桨在理想环境中每转一圈将前进多远的距离。螺距小了不出力，螺距大了又失速。低螺距的螺旋桨，能更加容易快速的改变方向，且响应更快。所以到后来，螺距精确到三位数了，比如50499。\n3、桨叶横切面（桨型）\n这个就玄学了， 桨叶横切面就像机翼一样，有着很讲究的空气动力学，要得到高性能的螺旋桨，必须优化设计高升阻比翼型，高升阻比意味着高拉力、低扭矩。俗话说：桨型好了效率高，桨型差了电机烫。\n还有就是他的设计，如上图翼尖那个小凸起，是不是在哪里见过，对DJI也有，号称静音。\n4、材料因为是高消耗品，又要考虑轻量化，又要刚度，以前由玻璃纤维增强塑料制成，不过太重了，一撞就坏。现在使用聚碳酸酯制成的一种塑料，有良好的刚度，碰到硬物不会破裂，只会弯曲，就这就还有机会救机，而不会直接炸机。所以现在不用你选择桨是由什么材料制成的，买就完了。\n以上，如有不对，敬请指教。\n","plink":"https://dxsummer.gitee.io/posts/f4c753e8/"},{"title":"选词填空","date":"2021-05-12T12:44:49.000Z","date_formatted":{"ll":"2021年5月12日","L":"2021/05/12","MM-DD":"05-12"},"updated":"2021-06-02T07:20:48.000Z","content":"1234【例六】2015 对于家长们来说，能够和孩子一起参与其中，亲身 到孩子的进步，是一次难得的亲子活动经历。同时，他们也可以在训练营中受到 ，得到一些教育的灵感。依次填入划横线部分最恰当的一项是（ ）A．感触 启示 \tB．感悟 启蒙C．感受 启发 \tD．感觉 启迪1234【例五】2017 物理学研究与艺术创作有异曲同工之妙，若是不能_______，就只能千锤百炼，通过成年累月的辛苦工作来解开暗物质的谜团了。填入画横线部分最恰当的一项是：（）A.妙手偶得 \tB.一蹴而就C.守株待兔 \tD.灵机一动1234【例四】2016 执行力的强弱已经成为影响企业成败的关键因素。世界级优秀企业总是能够让那些令人振奋的战略规划 地得到落实，达到甚至超出预期的目标。填入划横线部分最恰当的一项是（ ）A．一丝不苟 \tB．不遗余力C．分毫不差 \tD．滴水不漏123456【例三】2017 随着人工智能技术的不断发展，简单重复或危险的作业将由机器执行，低端蓝领、白领阶层可能会被人工智能 ，未来人工智能对职场很可能产生颠覆性影响。填入画横线部分最恰当的一项是：（ ）A.取而代之 \tB.越俎代庖C.鸠占鹊巢 \tD.更弦易辙词义轻重12345678【例一】2018 情绪并不是独立存在的，它常常伴随着信息而传播。作为一种态度，情绪不仅能够_________人们对所传播信息的认知，还会在一定程度上指导人们的行为。积极的情绪会促进人们积极地认识世界，消极的情绪则可能给他人甚至整个社会带来破坏性后果。人在情绪失控时，很容易不顾后果地做出_________的举动。依次填入画横线部分最恰当的一项是（ ）A．影响 危险 \tB．左右 出格C．干扰 反常 \tD．支配 冲动  B干扰：扰乱；打扰支配：安排，对人或事物起引导和控制的作用，语义过重1234567891011121314151617【例二】2018 秦岭阻挡了中国腹地南北气候的交互，却挡不住秦巴两地行者的脚步。无论是“明修栈道，暗度陈仓”，还是“一骑红尘妃子笑”，都与一条条秦岭古道_____。这些古道就如同一条条经线，沟通了关中和巴蜀，见证了中国历史的朝代兴替与政经融通，_____出不少故事与传说。填入画横线部分最恰当的一项是( )A.密不可分 演绎 \tB.交相辉映 衍生C.休戚与共 涌现 \tD.相伴相生 催生A明修栈道，暗度陈仓：将真实的意图隐藏在表面的行动背后，用明显的行动迷惑对方，使敌人产生错觉，并忽略自己的真实意图，从而出奇制胜。一骑红尘妃子笑：速度很快,只能看到滚滚烟尘却没有看到烈马掠过。密不可分：形容十分紧密，不可分割。交相辉映：各种光亮、色彩等互相映照。多用于形容美好的景象。休戚与共：有幸福共同享受，有祸患共同抵挡。形容关系紧密，利害相同相伴相生：互相转化，互相促进，依赖关系。演绎：展现，表现，推演，演绎传说。衍生：演变而产生，从母体物质得到的新物质涌现：在同一时期大量的出现。催生：因为某种原因，被迫生成当前状态，催促作品问世6-21234【例七】2018 在人类的脑海中，“科学”除了创造丰富的物质财富以外，往往纷演了“真实”与“客观”的化身。如果这一切被____，后果不堪设想。那么，我们需要_____的是，在刚刚过去的那个世纪里，是谁扣动了科学危机的扳机?依次填入划横线部分最恰当的一项是：A.颠覆 厘清 B.推倒 分清C.颠仆 辨清 D.推翻 厘正1234【例八】2017 晚清官员最害怕的就是和洋人直接打交道，他们中的绝大部分人不懂外语，不明世界大势，不知国际公法，在和洋人打交道时未免 ，进退失据。对于日渐增多的华洋纠纷，他们处理起来更是 ，稍有不慎，就会71招来严重的外交纷争。因此，他们便普遍形成了一种“畏洋如虎”的心态。依次填入画横线部分最恰当的一项是：A.如履薄冰 捉襟见肘 B.瞻前顾后 手足无措C.左支右绌 力不从心 D.妄自菲薄 眼花缭乱1234【例九】2016 改进作风涉及风俗、文化、制度、利益等方方面面，本身就是一场攻坚战。无论是克服 的形式主义、官僚主义，还是攻破思维定势、治疗沉疴顽疾（chén kē sù jì），都需要有坚忍不拔的毅力。只有这样，才能 ，积小胜为大胜，取得让广大干部群众满意的成效。依次填入划横线部分最恰当的一项是（ ）A．固步自封 渐入佳境 B．老调重弹 稳操胜券C．抱残守缺 循序渐进 D．根深蒂固 稳扎稳打1234【例十】2016 图书出版人首先应是一个文化人，然后才是一个生意人。只有在这两者之间求得一种 的平衡。才能在这个日益萎缩的图书市场中生存下去。用这个标准来衡量，有些出版人就不太合格：要么过于看重文化的附加值，对市场化的道路 ；要么把图书看作一单单生意，只顾着炮制各种 的畅销书。依次填入划横线部分最恰当的一项是（ ）A．微妙 不屑一顾 粗制滥造 B．精妙 置若罔闻 差强人意C．精确 嗤之以鼻 眼花缭乱 D．巧妙 退避三舍 名不副实123456【例十一】2016 很多时候，我们的问题在于不能正确地 个人和社会的界限。事实上，如果 了个人，就不可能加强集体；如果 了个人，集体也不可能获得自由。依次填入划横线部分最恰当的一项是（ ）A．区别 削减 约束B．分清 减弱 限制C．划清 削弱 束缚D．区分 降低 压制123456【例十二】2017 传统曲艺中一两个演员借助简单的手持道具，靠说唱完成一场表演，没有过硬的功夫不行，不会与观众 更不行。修养高深的曲艺表演者会使用各种手段拉近与观众的情感距离， 引领观众参与艺术创造。在基本没有舞台布景和“灯服道效”相配合的 表演环境中，曲艺演员要靠自身的表演征服观众，其难度远远大于其他舞台表演艺术。依次填入画横线部分最恰当的一项是：（）A.交流 主动 简约B.对话 巧妙 临时C.沟通 间接 单一D.互动 快速 虚拟123456【例十三】2017 未来将会怎样，不可准确预知，但格局和 总有踪迹可循。在信息技术、互联网发展所 的巨大变革面前，时代和社会呼唤产生一批真正的未来学家，能够站在历史和现实的关口，对信息社会的未来有所把握，为未来人们的生产和生活、选择和行为提供一些理论上的 。依次填入画横线部分最恰当的一项是：（）A.轨迹 带来 解释B.方向 造成 设想C.路径 导致 服务D.趋势 引发 指导1234【例十四】2018 黄河三角洲是中国大河三角洲中海陆变迁最_________的地区，特别是黄河口地区造陆速率之快、尾闾迁徙之频繁，更为世界罕见。黄河三角洲的_________受黄河水沙条件和海洋动力作用的制约，黄河来沙使海岸堆积向海洋推进，海洋动力作用又使海岸侵蚀向陆地推进。依次填入画横线部分最恰当的一项是（ ）A．壮观 形成 B．复杂 形态C．剧烈 演化 D．活跃 演变123456【例十五】2018 早在上世纪 70 年代末，钱学森就曾多次提出：国防科技的发展不能_________于“追尾巴”“照镜子”，而是要_________地开拓新领域和新方向。比如英国人针对重机枪机动性差的弱点，发明了坦克，一举撕裂了枪炮林立的僵持局面。这类非对称式的发展思路有助于打破先进国家的技术垄断，形成后发优势。依次填入画横线部分最恰当的一项是（ ）A．拘泥 与众不同B．满足 独辟蹊径C．沉迷 标新立异D．止步 别具匠心123456【例十六】2017 在长期积累中，传统媒体在新闻信息采集、加工和传播方面形成了一套比较 的方法、流程、标准和机制，虽然有单一乃至僵化的缺陷，但 ，对保证传统媒体的权威性发挥了重要作用。具有高度专业水平的内容对任何媒体都是的，这是媒体安身立命之本。依次填入画横线部分最恰当的一项是：（）A.系统 无独有偶 求之不得B.成熟 不可否认 不可或缺C.普遍 显而易见 独一无二D.先进 不言自明 至关重要1234【例十七】2015 我国高校每年有数万项科研成果通过验收，其中有 30%以上的成果被鉴定为“国际首创”、“国际领先”或者“填补了国内空白”。 的是，这些成果中只有极少一部分转化为实际生产力，大部分成果只能“沉睡”在实验室和书斋中，高校科技研究成果推广 。依次填入划横线部分最恰当的一项是（ ）A．可悲 难以为继 \tB．遗憾 步履维艰C．可惜 寸步难行 \tD．无奈 一筹莫展","plink":"https://dxsummer.gitee.io/posts/b1228ca7/"},{"title":"python数据结构","date":"2021-04-20T06:11:38.000Z","date_formatted":{"ll":"2021年4月20日","L":"2021/04/20","MM-DD":"04-20"},"updated":"2022-01-18T13:32:17.868Z","content":"常用算法时间和空间复杂度汇总：\n\n排序算法平均时间复杂度最优时间复杂度最差时间复杂度空间复杂度\n\n选择排序𝑂(𝑛2)𝑂(𝑛2)𝑂(𝑛2)𝑂(1)\n\n插入排序𝑂(𝑛2)𝑂(𝑛)𝑂(𝑛2)𝑂(1)\n\n冒泡排序𝑂(𝑛2)𝑂(𝑛2)𝑂(𝑛2)𝑂(1)\n\n快速排序𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛2)𝑂(𝑛𝑙𝑜𝑔𝑛)\n\n堆排序𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(1)\n\n归并排序𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛𝑙𝑜𝑔𝑛)𝑂(𝑛)\n排序插入排序插入排序的平均时间复杂度是O(n2)，最好情况下的时间复杂度是O(n), 最坏情况下的时间复杂度是O(n2)。它的空间复杂度是O(1)。\n\n排序开始时，我们对范例数组的每一个元素进行遍历。虚线的左侧表示已经有序的元素，右侧表示待排序的元素；递增排序。\n\n1234567891011nums = [5,3,6,4,1,2,8,7]for i in range(1,len(nums)):\t#遍历未排序的元素\tfor j in range(i):\t\t\t#遍历已有序的元素\t\tif(nums[j]&gt;nums[i]):\t\t\tins = nums[i]\t\t\tnums.pop(i)\t\t\tnums.insert(j,ins)\t\t\tbreakprint(nums)选择排序\n12345678nums = [5,3,6,4,1,2,8,7]for i in range(len(nums)-1): #更新有序数组的末尾位置\t\t\tminInd = i\t\t\tfor j in range(i,len(nums)): #找出未排序数组中最小值的下标\t\t\t\t\t if nums[j] &lt; nums[minInd]:\t\t\t\t\t\t\t\tminInd = j\t\t\tnums[i],nums[minInd] = nums[minInd],nums[i] #把最小值加到有序数组末尾print(nums)冒泡排序冒泡排序采用来重复遍历数组并比较相邻两个元素的方法来排序。\n由于使用冒泡排序算法进行排序的过程中，最大数/最小数会慢慢“浮”到数组的末尾，所以算法由此得名。\n冒泡排序的平均时间复杂度是O(n2)，最好情况下的时间复杂度是O(n), 最坏情况下的时间复杂度是O(n2)。它的空间复杂度是O(1)。它也是一个稳定的排序算法。\n\n12345678910nums = [5,3,6,4,1,2,8,7]for i in range(len(nums),0,-1): #更新本趟遍历确定的元素位置\t  flag = 0 \t\t#flag用于标记是否有元素交换发生\t  for j in range(i-1): #遍历未排序的数组\t\t\t if nums[j]&gt;nums[j+1]:\t\t\t\t\tnums[j],nums[j+1] = nums[j+1],nums[j]\t\t\t\t\tflag = 1 #标记存在元素交换\t  if not flag: \t\t\t break #如果本趟遍历没有发生元素交换，直接跳出循环         print(nums)归并排序归并排序算法就是一个先把数列拆分为子数列，对子数列进行排序后，再把有序的子数列合并为完整的有序数列的算法。它实际上采用了分治的思想。\n归并排序的平均时间复杂度是O(nlogn)，最好情况下的时间复杂度是O(nlogn), 最坏情况下的时间复杂度也是O(nlogn)。它的空间复杂度是O(1)，同时也是一个稳定的排序算法。\n\n12345678910111213141516171819#归并排序nums = [5,3,6,4,1,2,8,7]def MergeSort(num): \tif(len(num)&lt;=1): \t\t\t\t#递归边界条件\t\treturn num \t\t\t\t\t#到达边界时返回当前的子数组\tmid = int(len(num)/2) \t\t\t#求出数组的中位数\tllist,rlist = MergeSort(num[:mid]),MergeSort(num[mid:])#调用函数分别为左右数组排序\tresult = []\ti,j = 0,0\twhile i &lt; len(llist) and j &lt; len(rlist): #while循环用于合并两个有序数组\t\tif rlist[j]&lt;llist[i]:\t\t\tresult.append(rlist[j])\t\t\tj += 1\t\telse:\t\t\tresult.append(llist[i])\t\t\ti += 1\tresult += llist[i:]+rlist[j:] \t#把数组未添加的部分加到结果数组末尾\treturn result \t\t\t\t\t#返回已排序的数组print(MergeSort(nums))快速排序快速排序（Quick Sort），是冒泡排序的改进版，之所以“快速”，是因为使用了分治法。它也属于交换排序，通过元素之间的位置交换来达到排序的目的。\n基本思想\n在序列中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。\n\n\n基础版\n\n123456789101112131415nums = [5,3,6,4,1,2,8,7]def QuickSort(num):\tif len(num) &lt;= 1: #边界条件\t\treturn num\tkey = num[0] #取数组的第一个数为基准数\tllist,rlist,mlist = [],[],[key] #定义空列表，分别存储小于/大于/等于基准数的元素\tfor i in range(1,len(num)): #遍历数组，把元素归类到3个列表中\t\tif num[i] &gt; key:\t\t\trlist.append(num[i])\t\telif num[i] &lt; key:\t\t\tllist.append(num[i])\t\telse:\t\t\tmlist.append(num[i])\treturn QuickSort(llist)+mlist+QuickSort(rlist) #对左右子列表快排，拼接3个列表并返回print(QuickSort(nums))\n原版\n\n1234567891011121314151617nums = [5,3,6,4,1,2,8,7]def QSort(left,right): #子数组第一个元素和最后一个元素在原数组中的位置\tif(left &gt;= right): #边界条件\t\treturn\tl,r,key = left,right,nums[left] #初始化左指针，右指针和基准值\twhile(l &lt; r): #调整元素位置\t\twhile l &lt; r and nums[r] &gt;= key:\t\t\tr -= 1\t\tnums[l] = nums[r]\t\twhile l &lt; r and nums[l] &lt; key:\t\t\tl += 1\t\tnums[r] = nums[l]\tnums[l] = key #把基准值赋给左指针和右指针共同指向的位置\tQSort(left,l-1) #左侧数组排序\tQSort(l+1,right) #右侧数组排序QSort(0,len(nums)-1)print(nums)希尔排序希尔排序，又叫“缩小增量排序”，是对插入排序进行优化后产生的一种排序算法。它的执行思路是：把数组内的元素按下标增量分组，对每一组元素进行插入排序后，缩小增量并重复之前的步骤，直到增量到达1。\n一般来说，希尔排序的时间复杂度在O(n1.3)到O(n2)之间，这视增量大小而定。希尔排序的空间复杂度是O(1)，它是一个不稳定的排序算法。进行希尔排序时，元素一次移动可能跨越多个元素，从而可能抵消多次移动，提高了效率。\n123456789101112nums = [5,3,6,4,1,2,8,7]def ShellSort(nums):\tstep = len(nums)//2 \t#初始化增量为数组长度的一半\twhile step &gt; 0: \t#增量必须是大于0的整数\t\tfor i in range(step,len(nums)): #遍历需要进行插入排序的数\t\t\tind = i\t\t\twhile ind &gt;= step and nums[ind] &lt; nums[ind-step]: #对每组进行插入排序\t\t\t\tnums[ind],nums[ind-step] = nums[ind-step],nums[ind]\t\t\t\tind -= step\t\tstep //= 2 \t\t#增量缩小一半\tprint(nums)ShellSort(nums)堆排序堆是一种数据结构。它是一种特殊的完全二叉树。堆排序就是根据堆的特性设计的排序算法。\n如果这个堆是一个大顶堆（最大的元素在堆顶），那么每个节点上的元素都应该比它的孩子节点上的元素要大，最大的元素在根节点上。\n如果是小顶堆，那么每个节点上的元素都应该比它的孩子节点小，最小的元素在根节点上。\n1234567891011121314151617181920212223242526nums = [4,2,61,8,953,1,3,72,310,113,93,112,32,43,15,5,20,999,678,34,3,2]def Heapify(start,end): #向下调整的函数，传入数据为堆顶节点的编号和堆末尾的界限值\tfather = start\tson = father * 2 #son存储较大的子节点的编号，初始化为左子节点\twhile son &lt;= end: #当目前数据所处的节点还有子节点时，继续循环调整\t\tif son+1 &lt;= end and nums[son+1] &gt; nums[son]: \t\t\t#如果存在右节点且其值大于左子节点的值，son存储右子节点的编号\t\t\tson += 1\t\tif nums[father] &lt; nums[son]:#如果父亲节点的值小于子节点\t\t\tnums[father],nums[son] = nums[son],nums[father] #交换父亲和子节点\t\t\tfather = son\t\t\tson = father * 2 #进入下一层继续调整\t\telse: #如果父亲节点大于等于子节点，调整完成\t\t\treturndef HeapInit(): #初始化大顶堆的函数\tnums.insert(0,0) \t#堆顶编号从开始，在位置0插入一个数使得堆中元素的编号与在数组中的下标一样\tfor i in range((len(nums)-1)//2,0,-1): #从最底层最右侧的的非叶子节点开始调整\t\tHeapify(i,len(nums)-1)def HeapSort(): #堆排序函数\tfor i in range(len(nums)-1,0,-1): #从堆末尾开始进行元素交换\t\tnums[1],nums[i] = nums[i],nums[1]\t\tHeapify(1,i-1)HeapInit()HeapSort()print(nums)桶排序桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（也有可能是使用别的排序算法或是以递归方式继续用桶排序进行排序）。\n12345678countn = [0]*51 #建立足够的桶nums,result = [1,1,3,19,35,49,50,5,10,16],[]for i in nums:\tcountn[i] += 1 #统计每个元素出现的次数for i in range(1,len(countn)):\tif countn[i]: #如果桶内有元素\t\tresult += [i]*countn[i] #往结果数组中加上相应数量的元素。print(result)查找静态查找：程序只对查找表进行查询并返回信息动态查找：在静态查找的基础上，还增加了增删查找表中数据元素的操作。\n顺序查找12345678arr = [1,2,3,5,4,2,4,6,1]key = int(input())\t#输入关键字for i in range (len(arr)):  #顺序遍历列表    if arr[i] == key:        print(i)        break   #保证只输出第一个位置就跳出遍历循环    #关键字不存在于列表中    print(-1)二分查找二分查找，也叫折半查找，是一种适用于顺序存储结构的查找方法。它是一种效率较高的查找方法，时间复杂度为O(log n)，但它仅能用于有序表中——也就是说，表中的元素需按关键字大小有序排列。\n二分查找用左右两个指针来标注查找范围。程序开始时，查找范围是整个线性表，左指针指向第一个元素，右指针指向最后一个元素；每一次循环过后，查找范围都缩小为原先的一半，直到左右指针重叠。\n1234567891011121314l = [2,3,5,10,15,16,18,22,26,30]l,r = 0, len(arr)-1     #初始化左右指针n = int (input())       #输入关键字while l &lt;= r:       #判断是否存在合理的查找范围    mid = (l+r)//2  #求出左右指针的平均数    if arr[mid] &lt; n:    #折半缩小查找范围        l = mid + 1    elif arr[mid] &gt; n:        r= mid -1    else:   #如果mid指向的元素与关键字相等，直接输出下标并跳出循环        print(mid)        break    #while循环自然结束，说明没有查找到与关键字相等的元素print(-1)树树是一种由n个元素组成的集合。当n=0时，树被称作空树。当n&gt;0时，树被称作非空树。\n对于非空树，最基本的概念有三：\n树中的每个元素被称为节点\n\n树最顶层的节点称作根节点；每棵树只有一个特定的根节点，它没有直接前驱。\n\n当n&gt;1时，根节点及其之下的所有节点构成原树，而根节点之外的节点可以被划分为m个互不相交的有限集T1, T2, …Tm。每个集合Ti本身也是一棵树，被称作根的子树。\n\n由若干棵互不重合的树构成的集合称作森林。\n对于树中的每个节点而言，其所有子树的集合就为森林。\n而树还分为两种，有序树和无序树。有序树中的节点有顺序关系，不能轻易改变其中的排列；而无序树中的节点没有顺序关系，又被称作自由树。\n二叉树树和二叉树 - Dx (gitee.io)\n类的定义\n12345class TreeNode:\t#二叉树节点的定义\tdef __init__(self, val):\t\tself.val = val\t#二叉树的值\t\tself.left = None\t#左孩子的节点\t\tself.right= None\t#右孩子的节点创建树\n12345678910111213141516Input=[0]\t#Input列表用于存储输入tree=[0]\t#tree列表用于存储节点Input=Input+input().split()\t\t#a1,a2,…,an = input().split()用在接收多个用户输入的时候。（空格分开）cnt=1for item in Input:\t#将所有节点转换为treenode类型    tmp=TreeNode(item)    tree.append(tmp)for item in tree:\tif item.val==\"null\":\t#若节点为“null”，则不加入tree中\t\tcontinue\tif 2*cnt &lt;= len(Input) and tree[2*cnt].val != \"null\":#找到每个节点的左子节点\t\titem.left = tree[2*cnt]\tif 2*cnt + 1 &lt;= len(Input) and tree[2*cnt + 1].val != \"null\":#找到每个节点的右子节点\t\titem.right = tree[2 * cnt + 1]\tcnt += 1遍历二叉树\n列表下标表示二叉树遍历\n1234567891011121314151617181920def preorder(i): #先序遍历\tif tree[i]==0:        return\tprint(tree[i])\tpreorder(2*i)\tpreorder(2*i+1)def inorder(i):\t#中序遍历\tif tree[i] == 0:\t\treturn \tinorder(2*i)\tprint(tree[i])\tinorder(2*i+1)def postorder(i):\t#后序遍历\tif tree[i] == 0\t\treturn \tpostorder(2*i)\tpostorder(2*i+1)\tprint(tree[i])以存储的左右孩子地址表示二叉树 遍历函数写在类的内部\n12345678910111213141516171819202122232425262728293031class TreeNode:\tdef __init__(self,x):\t\tself.val = x\t\tself.left = None\t\tself.right = Noneclass BST:\tdef __init__(self, tlist):\t\tself.root = TreeNode(tlist[0])\t\tfor i in tlist[1:]:\t\t\tself.insert(i)\tdef preorder(self,node):\t#先序遍历\t\tif node is None:\t\t\treturn\t\tprint(node.val)\t\tself.preorder(node.left)\t\tself.preorder(node.right)\tdef inorder(self,node): #中序遍历\t\tif node is None:\t\t\treturn\t\tself.inorder(node.left)\t\tprint(node.val)\t\tself.inorder(node.right)\tdef postorder(self,node):  #后序遍历\t\tif node is None:\t\t\treturn\t\tself.postorder(node.left)\t\tself.postorder(node.right)\t\tprint(node.val)二叉搜索树二叉树(Binary Search Tree)是一种特殊的二叉树，树中的元素排列符合二叉搜索树性质。二叉搜索树中，每一个节点存储的元素称作该节点的键值\n二叉搜索树可以是一棵空树，也可以是具有如下几条性质的一棵二叉树：\n若任意一个节点的左子树非空，那么左子树中所有的元素都小于当前节点存储的元素。\n\n若任意一个节点的右子树非空，那么右子树中所有的元素都大于当前节点存储的元素。\n\n任意一个节点的左右子树也为二叉搜索树。\n\n二叉搜索树中没有两个节点有相同的键值。\n\n根据这些性质可以推出, 插入, 删除和查找操作的时间复杂度都是O(log n)。\n\n二叉搜索树支持的操作有：\n\n(1)建立二叉搜索树(2)插入键值为x的节点(3)查询键值为x的节点在二叉搜索树中的排名(4)删除键值为x的节点(5)求键值为x的节点的前驱与后继\n平衡二叉树平衡二叉树是一种特别形式的二叉搜索树，它采用平衡化旋转来避免二叉搜索树出现退化的情况\nAVL树平衡二叉树，又称AVL树。它维持二叉搜索树平衡的根本在于持续维护这样一个性质：二叉搜索树中，每一个节点的左右子树深度差的绝对值不大于1。\n\n如何判断一棵树是否符合AVL树的性质？答案就是维护每个节点的平衡因子。\n\n每个节点的平衡因子即为节点左子树的深度减去右子树的深度得到的差。在符合AVL性质的情况下，平衡因子只能取-1, 0, 1。\n正因这样，在插入或删除一个节点之后，在它们路径上的节点的平衡因子都需要被更新。\n双指针问题指针的概念指针存储着计算机中一个内存空间的地址，是编程语言中的一个对象。通过它存储的地址，计算机可以找到存储在计算机存储器中另一个地方的变量单元。一个特定的地址指针指向一个特定的变量单元。在重复读取数据的情况下，使用指针可以改善程序性能。同时，指针还可以有效利用存储器中非连续的内存。\n链表的概念链表是用指针连接的用于存储数据的数组。在很多编程语言中，定义数组的大小后不能随便更改，而且数组中只能存储同一类型的变量。为解决这个问题，程序员使用链表来达到随时向数组中添加各种数据的目的。\n在Python中，并不存在实际意义上的指针，所以也不存在实际意义上的链表。即便如此，Python中列表的工作原理就是链表。所以，我们用模拟指针的方法来实现链表，以表现链表连接各个元素的逻辑思维。\n单链表链表的每个元素不仅仅存储这个元素的值，还要存储与它相连的元素的地址，起到连接元素的效果。这个存储在元素中的地址就是指向下一个元素的指针。\n单链表的每个元素包含本身的值和一个指向下一个元素的指针。因为链表的最后一个数没有下一个数，所以它的指针为空指针。\n遍历单链表1234567ListValue = [1,5,6,2,4,3]ListPointer = [3,2,-1,5,1,4]head = 0                    \t\t#head是指向链表第一个元素的指针，需要自己定义next = head    \t\t\t\t#给next赋初始值while next != -1:            \t#next是指向下一个元素的指针，不等于-1代表后面还有元素\tprint(ListValue[next])   \t#输出下一个元素中存储的值\tnext = ListPointer[next] \t#把指针变为下一个元素中存储的指针插入元素1234567891011121314151617181920212223ListValue = [1, 4, 5, 2]ListRight = [3, 2, -1, 1]head = 0                              #初始化头指针num = 3                               #num为要插入的元素    next,last = head,head              #初始化表示插入位置的下一个元素和上一个元素的指针def Output():                    #定义一个函数用于输出链表   next = head   while next != -1:      print(ListValue[next])      next = ListRight[next]Output()                              #输出列表查看插入前的顺序while ListValue[next] &lt;= num and next != -1:      #找到适合插入元素的位置   last = next   next = ListRight[next]ListValue.append(num)                    #向数组末尾加上新元素的值ListRight.append(ListRight[last])           #加上新元素指针指向的位置（下一个元素）ListRight[last] = len(ListValue)-1          #上一个元素的指针指向新元素Output()                              #输出列表查看结果删除单链表第n个数12345ListValue = [1, 5, 6, 2, 7, 3]                        #建立单链表ListRight = [3, 2, 4, 5, -1, 1]head = 0                                                #确定头指针prepos = 5                                          #确定要删除的元素的前一个数的位置ListRight[prepos] = ListRight[ListRight[prepos]]      #删除元素双指针的应用在算法中，指针的概念常常被应用。比如说二分查找中存储查找范围最左和最右元素的两个变量，就可以理解为左指针和右指针，因为它们起到了“存储数据储存位置”的作用。\n在Python中，标准意义上的指针并不存在。不过，Python语言的许多内置函数和功能都使用了指针来编写——比如说列表，实际上是以链表的形式存在的。不过，程序员无法在用Python编写程序的时候直接使用真正意义上的指针；所以，本书会以模拟指针的形式在Python中传达指针的概念。\n数组合并问题\n\n\n\n\n1234567891011121314151617arr1 = [3,6,9,12,15]             #初始化两个数组arr2 = [2,4,7,13,14]i,j = 0,0                    #指针初始化，指向列表第一个数ans = []                     #ans初始化为空while i &lt; len(arr1) and j &lt; len(arr2): #当有一个指针不再指向元素时停止循环   if arr1[i] &lt;= arr2[j]:           #判断大小，把元素加入结果列表，挪动指针      ans.append(arr1[i])      i += 1   else:      ans.append(arr2[j])      j += 1if i == len(arr1):                 #把还有剩余长度的列表中的元素加入结果列表   ans += arr2[j:]else:   ans += arr1[i:]print(ans)删除单链表倒数第n个数12345678910111213141516171819#节点定义class ListNode:\tdef __init__(self, v):\t\t self.val = v\t\t self.next = None#删除倒数第n个数据def removeLastNth(head, n):\ttemp = ListNode(0)\ttemp.next = head\tfast = slow = temp\tc = 0\twhile c &lt; n:\t\t\t\t#fast先走n步\t\tfast = fast.next\t\tc += 1\twhile fast.next:\t\tfast = fast.next\t\tslow = slow.next\tslow.next = slow.next.next\treturn temp.next哈希算法Hash解决冲突两个数的和问题\n给定5个数字: 3，4，5，7，10，从中选择两个数使它们的和为someValue(例如someValue=11)\n\n123#两个数的和def twoSums ( mynum, target ):    mydict = &#123;&#125; #建立一个字典，存储数据和下标的对应关系1234567#核心思想i = #someValue  #i为给定的某个值m = mynum[i]    #定义m为当前待查询的数字if target-m in mydict:  #判断target-m是否已经在字典中    return (mydict[target-m],i) #如果已经存在，则返回这两个数的下标else:    mydict[m]=i #如果不存在则记录键值对12345678def twoSums(mynum, target):    mydict = &#123;&#125;    for i in range(len(mynum)):        m= mynum[i]              #定义m为当前待查询的数字        if target-m in mydict:            #判定target-m是否已经在字典中            return (mydict[target-m], i)   #如果已经存在，则返回这两个数的下标        else:     mydict[m] = i            #如果不存在则记录键值对团体赛问题\n判断派出的选手是否合规\n\n123456789101112131415161718#团体赛问题def pingpong(games, players):    game = games.split(',')    player = players.split(',')        if len(player) != len(game):   #如果两个字符串的长度不一样，则肯定不匹配        return False        mydict = &#123;&#125;              #记录模式字符串和目标字符串的对应关系    used= &#123;&#125;                 #记录目前已经使用过的字符串都有哪些    for i in range(len(game)):        if game[i] in mydict:               if mydict [game[i]] != player[i]:  #不是第一次出现，则检查映射关系是否一致                return False        else:            if player[i] in used:         #检查这个选手是否已经出现过，出现过则返回不成立               return False            mydict [game[i]] = player[i]      #第一次出现，则加入哈希表            used[player[i]] = True        #在used中保存哪些单词已经使用过    return True                 #没有任何问题则返回成立猜数字游戏12345678910111213141516171819202122#猜数字游戏def guessGame(secret, guess):    secret_dict = &#123;&#125;    guess_dict = &#123;&#125;    count1 = 0    count2 = 0    for i in range(len(secret)):        if secret[i] == guess[i]:            count1 += 1        else:            if secret[i] in secret_dict:                secret_dict[secret[i]] = secret_dict[secret[i]] + 1            else:                secret_dict[secret[i]]=1                if guess[i] in guess_dict:                    guess_dict[guess[i]] = guess_dict[guess[i]] + 1                else:                    guess_dict[guess[i]]=1    for digit in secret_dict:        if digit in guess_dict:            count2 += min(secret_dict[digit], guess_dict[digit])    return str(count1)+\",\"+str(count2)深度优先搜索算法理解什么是搜索\n掌握图在算法中的基本应用\n掌握用深度优先搜索算法解题需要解决的问题\n掌握深度优先搜索算法的步骤\n理解常见问题如最大油田问题、职员派对问题、和城市危机问题\n图上的深度优先搜索图是一种计算机科学中的模型，往往可以作为生活中复杂联系的简化结构图的使用，往往能解决“最近”，“最远”，“能否到达”，“不能到达”，“能到达哪”等问题。 \n无向图准确定义：由一组顶点和一组能够将两个顶点相连而没有方向的边组成的图     \n注：绘图时，往往用圆圈表示顶点，用线段表示连接两个顶点的边 \n相邻&amp;邻接点：当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，也可以说这两个的顶点互为邻接点，并称这条边依附于这两个顶点，与这两个顶点相关联 \n度\n    \n子图：子图是指在一幅图中所有边的一个子集以及它们所依附的所有顶点组成的图，如下右图所示（左图的一个子图）。    \n路径：接续的边构成的顶点序列。\n路径长度：其所包含的边数的长度。\n回路(环)：第一个顶点和最后一个顶点相同的路径。\n简单路径：一条没有重复顶点的路径\n简单回路(简单环)：一个没有重复顶点和边的环(除了起点和终点重复之外)\n最大油田问题政府现勘探到一片油田，在这一片油田中有很多散落的石油资源。因为经费原因，政府只能开采一处油田，所以需找到最大的油田进行施工。油田的地理情况被简化成了一个矩阵，其中每一个方格代表一块土地，0代表陆地，1代表石油资源。如果一处石油资源和另一处石油相连接，则其算一块油田。现要找到最大的相互连接的石油资源，并输出它的面积。\n上图为示例，其中灰色的区域都是不同大小的油田。那么对于这个例子来说，左上角的五块石油连在一起的区域就是最大的油田，其面积为5，如上右图阴影部分所示。\n深度遍历策略：\n为了知道一块油田有多大，我们可能需遍历每一个图中的方格。\n因为在一块油田中，石油资源一定是相邻的，因此只有四中情况：上，下，左，右。所以结合深度优先遍历算法，我们可以对每一个方格进行搜索来寻找该方格相邻处是否还有石油资源，从而快速得到每一块隔离的油田的面积\n我们可以用循环依此以每一块土地为起点进行搜索。如果该块土地含有石油资源，则继续搜索这个由石油资源土地的上下左右相邻的土地，反之则继续循环遍历其他土地。\n如此反复，将整幅图搜索完，即可求解出答案\n123456789101112131415161718192021#最大的油田代码def MaxAreaOfIsland(grid):    \t#grid为题目给的二维数组，其中存储着地理信息    row = len(grid)             \t#row记录二维数组的行数，也是地图的y轴长度    col = len(grid[0])\t\t    \t#col记录二维数组的列数，也是地图的x轴长度    arrived = [[False for j in range(col)] for i in range(row)]    \t\t\t\t\t\t\t#arrived为一个二维数组，存储一块土地是否被访问过    ans = 0                       \t#记录油田的最大面积    def DFS(x, y):        if x &gt;= 0 and x &lt; row and y &gt;= 0 and y &lt; col and not arrived[x][y] and grid[x][y] == 1:                   #判断现在搜索的土地是否出界，是否已经访问过，以及是否含有石油资源            arrived[x][y] = True\t#标记该块土地已经被搜索过            return 1 + DFS(x - 1, y) + DFS(x + 1, y) + DFS(x, y - 1) + DFS(x, y + 1)    \t\t\t\t\t\t\t#搜索其相邻的土地并将答案加上1        else:            return 0    for i in range(row):        for j in range(col):            area = DFS(i, j)   \t#遍历搜索每一块土地            if area &gt; ans:                ans = areareturn ans二叉树上的遍历\n二叉树的术语相关解释\n\n度节点的子树个数\n\n根二叉树的源头节点\n\n深度二叉树的层数\n\n叶子节点度为零的节点\n\n分支节点度不为零的节点\n\n孩子节点节点下一层的两个子节点\n\n双亲节点节点上一层的源头节点\n\n兄弟节点继承于同一个双亲节点的节点\n策略：\n二叉树属于一种无环连通图。所以深度搜索也可以在二叉树中进行。进行的方式反而更加好理解——从根节点开始，以树的深度为标准向叶子节点搜索。\n深度搜索往往从一个树的根节点开始进行。算法中，会遍历父节点的每一个边。值得注意的是，深度优先搜索算法在找到第一条父节点通往子节点的边时，不会直接继续寻找通往其他子节点的边，而是直接以找到的子节点为起点，继续遍历已知子节点的子节点（或者不严谨的说，“孙节点”），从而做到“深度优先”。\n如此反复，直到当前子节点已经没有子节点（也可以被称为叶子节点）。待遍历到叶子节点后，深度优先搜索算法会在回溯到叶子节点的父节点，继续遍历其没有遍历过的子节点，直到该父节点的所有子节点均被遍历完，再回溯到当前父节点的父节点，遍历没有其没有遍历过的子节点……直到回到根节点，并把所有的节点遍历完。\n职员派对问题描述：\n公司要举办一个职员派对，而公司里所有的员工都有资格来参加。如图6.16所示，该公司的职员组织结构是一个二叉树结构。如果一个节点A有双亲节点B，则代表B是A的上司。实际上，每一个员工为派对所能带来的贡献不一样，有的人幽默，就能使派对更加有趣，而有的人恰恰相反。树上每一个节点圆圈里的数字便代表每一个员工为派对所能带来的贡献值。然而，该公司里的所有员工都对自己的上司不满意（如果其有上司的话），所以如果一个员工来到派对，其上司就不能来到派对，反之亦然。但员工和员工上司的上司是可以一起参加派对的因为他们互相不熟悉。如果你是董事长的秘书，并且在已知公司职员组织结构的情况下，应该怎么邀请员工，使得任何一组员工和上司不会同时出现在派对中，并且使得邀请的所有员工的贡献值之和最大？\n城市危机问题已知某个国家中的城市呈二叉树形状分布。这时城市突然出现了断电危机。现在政府要求电力修理部队可以从任意一个城市出发来修理各个城市的电力。每个城市有不同的紧急程度,所以以不同的路径来修理电力会得到不同的收益，如图，二叉树节点上的数字代表修理电力的收益（可以为负）。不幸的是，修理部队应为种种原因不能掉头，这就意味着其不能来到同一个城市两次，城市与城市之间的边也只能走一回。在这种情况下，我们需求解出一条路径，使修理的收益最大，路径上的和最大。\n广度优先搜索队列这种数据结构是广度优先遍历算法优先选择的数据结构\n1，因为队列的存储机制为先进先出，而广度优先遍历算法恰好需要保证优先访问已访问顶点的未访问邻接点。因此队列最适合广度优先算法的存储法则。\n2，队列这个数据结构只支持两个基本操作：将新元素从队尾加入队列，和将队首元素移出队列。相比于其他数据结构如数组等，队列因为操作简单因此效率高。\n艰难旅行现已知一个大小为𝑛×𝑚格的地图，地图中只有可能出现两个数字：0或1，现规定如果位于数字为0的格子上，下一步只能往相邻四个格子中数字为1的格子走，如果位于数字为1的格子上，则下一步只能往相邻四个格子中数字为0的格子走。如果给定你的起点格子，且只能向上下左右四个方向移动，求你能在这个𝑛×𝑚的格的图中到达多少格子(包含自身)？\n12345678910111213141516171819202122232425262728293031323334# 艰难旅行from queue import QueueQ = Queue()                #建立队列class grid:                        #定义grid类，其中每一个方格(grid)都含有行(row)和列(col)属性    def __init__(self, row, col):        self.row = row        self.col = col    def bfs(self,val,startrow,startcol):        row = len(val)             #val是存储地图的二位列表，row变量为其行数        col = len(val[0])     #col变量为地图的列数        arrived = [[False for j in range(int(col))] for i in range(int(row))]         #arrived二维列表存储地图上每个方格是否已经到达过(已经进入过队列)        moverow = [0, 1, 0, -1]            #moverow数组存储向相邻方格移动时行的变化情况分别为增加1(1)，减少1(-1)，和不变(0)        movecol = [1, 0, -1, 0]               #moverow数组存储向相邻方格移动时列的变化情况，与moverow原理相同        ans = 1        Q.put(grid(int(startrow), int(startcol)))           #将起点加入队列        arrived[int(startrow) - 1][int(startcol) - 1] = True   #将起点设为已到达过        while not Q.empty():         #判断队列是否为空            cur = Q.get()           #取出队列首位的元素            for i in range(4):             #遍历moverow和movecol，其实就是向现所位于的方格的四个方向的移动                newrow = cur.row + moverow[i]                newcol = cur.col + movecol[i]                if newrow &gt; row or newrow &lt;= 0 or newcol &gt; col or newcol &lt;= 0:             #判断移动后是否超界                    continue                if not arrived[newrow - 1][newcol - 1] and val[newrow - 1][newcol - 1] != val[cur.row - 1][cur.col - 1]:                 #判断是否已经到达过，是否与起始点的数值不同                    Q.put(grid(newrow, newcol))    #将发现可以到达的新方格放入队列中                    arrived[newrow - 1][newcol - 1] = True  #将可到达的新方格设为已到达过                    ans += 1                        #求得答案        return ans","plink":"https://dxsummer.gitee.io/posts/7f8e2ad4/"},{"title":"Java基础","date":"2021-04-12T00:15:27.000Z","date_formatted":{"ll":"2021年4月12日","L":"2021/04/12","MM-DD":"04-12"},"updated":"2022-01-13T11:51:26.894Z","content":"JDK/JREJRE\n是Java程序的运行时环境，包含JVM和运行时所需要的核心类库。\nJVM\njava虚拟机 跨平台win mac Linux\nJDK\n是Java程序开发工具包，包含JRE和开发人员使用的工具。\n其中的开发工具:编译工具(javac.exe)和运行工具(java.exe)。\n我们想要开发一个全新的Java程序，那么必须安装JDK。\nJDK安装目录\n\n目录名称说明\n\nbin该路径下存放了JDK的各种工具命令。javac和java就放在这个目录。\n\nconf该路径下存放了JDK的相关配置文件。\n\ninclude该路径下存放了一些平台特定的头文件。\n\njmods该路径下存放了JDK的各种模块。\n\nlegal该路径下存放了JDK各模块的授权文档。\n\nlib该路径下存放了JDK工具的一些补充JAR包。\nDos常用命令\n操作说明\n\n盘符名称:盘符切换。E:回车，表示切换到E盘。\n\ndir查看当前路径下的内容。\n\ncd目录进入单级目录。cd itheima\n\ncd..回退到上—级目录。\n\ncd 目录1\\目录2\\…进入多级目录。cd itheima\\JavaSE\n\ncd \\回退到盘符目录。\n\ncls清屏。\n\nexit退出命令提示符窗口。\nJava程序基本结构我们先剖析一个完整的Java程序，它的基本结构是什么：\n123456789101112/** * 可以用来自动创建文档的注释 */public class Hello &#123;    public static void main(String[] args) &#123;        // 向屏幕输出文本:        System.out.println(\"Hello, world!\");        /* 多行注释开始        注释内容        注释结束 */    &#125;&#125; // class定义结束因为Java是面向对象的语言，一个程序的基本单位就是class，class是关键字，这里定义的class名字就是Hello：\n123public class Hello &#123; // 类名是Hello    // ...&#125; // class定义结束类名要求：\n类名必须以英文字母开头，后接字母，数字和下划线的组合\n习惯以大写字母开头\n要注意遵守命名习惯，好的类命名：\nHello\nNoteBook\nVRPlayer\n不好的类命名：\nhello\nGood123\nNote_Book\n_World\n注意到public是访问修饰符，表示该class是公开的。\n不写public，也能正确编译，但是这个类将无法从命令行执行。\n在class内部，可以定义若干方法（method）：\n12345public class Hello &#123;    public static void main(String[] args) &#123; // 方法名是main        // 方法代码...    &#125; // 方法定义结束&#125;方法定义了一组执行语句，方法内部的代码将会被依次顺序执行。\n这里的方法名是main，返回值是void，表示没有任何返回值。\n我们注意到public除了可以修饰class外，也可以修饰方法。而关键字static是另一个修饰符，它表示静态方法，后面我们会讲解方法的类型，目前，我们只需要知道，Java入口程序规定的方法必须是静态方法，方法名必须为main，括号内的参数必须是String数组。\n方法名也有命名规则，命名和class一样，但是首字母小写：\n好的方法命名：\nmain\ngoodMorning\nplayVR\n不好的方法命名：\nMain\ngood123\ngood_morning\n_playVR\n在方法内部，语句才是真正的执行代码。Java的每一行语句必须以分号结束：\n12345public class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(\"Hello, world!\"); // 语句    &#125;&#125;在Java程序中，注释是一种给人阅读的文本，不是程序的一部分，所以编译器会自动忽略注释。\n注释Java有3种注释，第一种是单行注释，以双斜线开头，直到这一行的结尾结束：\n1// 这是注释...而多行注释以/*星号开头，以*/结束，可以有多行：\n12345/*这是注释blablabla...这也是注释*/还有一种特殊的多行注释，以/**开头，以*/结束，如果有多行，每行通常以星号开头：\n12345678910/** * 可以用来自动创建文档的注释 *  * @auther liaoxuefeng */public class Hello &#123;    public static void main(String[] args) &#123;        System.out.println(\"Hello, world!\");    &#125;&#125;这种特殊的多行注释需要写在类和方法的定义处，可以用于自动创建文档。\nJava程序对格式没有明确的要求，多几个空格或者回车不影响程序的正确性，但是我们要养成良好的编程习惯，注意遵守Java社区约定的编码格式。\n那约定的编码格式有哪些要求呢？其实我们在前面介绍的Eclipse IDE提供了快捷键Ctrl+Shift+F（macOS是⌘+⇧+F）帮助我们快速格式化代码的功能，Eclipse就是按照约定的编码格式对代码进行格式化的，所以只需要看看格式化后的代码长啥样就行了。具体的代码格式要求可以在Eclipse的设置中Java-Code Style查看。\n运行和编译编译: javac 文件名.java——————生成.class文件\n范例: javac HelloWorld.java\n\n执行: java 类名\n范例: java HelloWorld\n\n变量和数据类型变量什么是变量？\n变量就是初中数学的代数的概念，例如一个简单的方程，x，y都是变量：\ny=x2+1\n在Java中，变量分为两种：基本类型的变量和引用类型的变量。\n我们先讨论基本类型的变量。\n在Java中，变量必须先定义后使用，在定义变量的时候，可以给它一个初始值。例如：\n1int x = 1;上述语句定义了一个整型int类型的变量，名称为x，初始值为1。\n不写初始值，就相当于给它指定了默认值。默认值总是0。\n来看一个完整的定义变量，然后打印变量值的例子：\n123456public class Main &#123;    public static void main(String[] args) &#123;        int x = 100; // 定义int类型变量x，并赋予初始值100        System.out.println(x); // 打印该变量的值    &#125;&#125;变量的一个重要特点是可以重新赋值。例如，对变量x，先赋值100，再赋值200，观察两次打印的结果：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        int x = 100; // 定义int类型变量x，并赋予初始值100        System.out.println(x); // 打印该变量的值，观察是否为100        x = 200; // 重新赋值为200        System.out.println(x); // 打印该变量的值，观察是否为200    &#125;&#125;注意到第一次定义变量x的时候，需要指定变量类型int，因此使用语句int x = 100;。而第二次重新赋值的时候，变量x已经存在了，不能再重复定义，因此不能指定变量类型int，必须使用语句x = 200;。\n变量不但可以重新赋值，还可以赋值给其他变量。让我们来看一个例子：\n12345678910111213141516public class Main &#123;    public static void main(String[] args) &#123;        int n = 100; // 定义变量n，同时赋值为100        System.out.println(\"n = \" + n); // 打印n的值        n = 200; // 变量n赋值为200        System.out.println(\"n = \" + n); // 打印n的值        int x = n; // 变量x赋值为n（n的值为200，因此赋值后x的值也是200）        System.out.println(\"x = \" + x); // 打印x的值        x = x + 100; // 变量x赋值为x+100（x的值为200，因此赋值后x的值是200+100=300）        System.out.println(\"x = \" + x); // 打印x的值        System.out.println(\"n = \" + n); // 再次打印n的值，n应该是200还是300？   &#125;&#125;我们一行一行地分析代码执行流程：\n执行int n = 100;，该语句定义了变量n，同时赋值为100，因此，JVM在内存中为变量n分配一个“存储单元”，填入值100：\n123456      n      │      ▼┌───┬───┬───┬───┬───┬───┬───┐│   │100│   │   │   │   │   │└───┴───┴───┴───┴───┴───┴───┘执行n = 200;时，JVM把200写入变量n的存储单元，因此，原有的值被覆盖，现在n的值为200：\n123456      n      │      ▼┌───┬───┬───┬───┬───┬───┬───┐│   │200│   │   │   │   │   │└───┴───┴───┴───┴───┴───┴───┘执行int x = n;时，定义了一个新的变量x，同时对x赋值，因此，JVM需要新分配一个存储单元给变量x，并写入和变量n一样的值，结果是变量x的值也变为200：\n123456      n           x      │           │      ▼           ▼┌───┬───┬───┬───┬───┬───┬───┐│   │200│   │   │200│   │   │└───┴───┴───┴───┴───┴───┴───┘执行x = x + 100;时，JVM首先计算等式右边的值x + 100，结果为300（因为此刻x的值为200），然后，将结果300写入x的存储单元，因此，变量x最终的值变为300：\n123456      n           x      │           │      ▼           ▼┌───┬───┬───┬───┬───┬───┬───┐│   │200│   │   │300│   │   │└───┴───┴───┴───┴───┴───┴───┘可见，变量可以反复赋值。注意，等号=是赋值语句，不是数学意义上的相等，否则无法解释x = x + 100。\n常量\n常量类型说明举例\n\n字符串常量用双引号括起来的内容“HelloWorld”,“黑马程序员”\n\n整数常量不带小数的数字666，-88\n\n小数常量带小数的数字13.14，-5.21\n\n字符常量用单引号括起来的内容‘A’ , ‘o’ ，‘我’\n\n布尔常量布尔值，表示真假只有两个值: true,false\n\n空常量一个特殊的值，空值值是: null\n空常量不能直接输出  System.out.println(null)\n定义变量的时候，如果加上final修饰符，这个变量就变成了常量：\n1234final double PI = 3.14; // PI是一个常量double r = 5.0;double area = PI * r * r;PI = 300; // compile error!常量在定义时进行初始化后就不可再次赋值，再次赋值会导致编译错误。\n常量的作用是用有意义的变量名来避免魔术数字（Magic number），例如，不要在代码中到处写3.14，而是定义一个常量。如果将来需要提高计算精度，我们只需要在常量的定义处修改，例如，改成3.1416，而不必在所有地方替换3.14。\n根据习惯，常量名通常全部大写。\n标识符定义规则数字、字母、下划线_ 、$组成\n不能数字开头\n不能是关键字\n区分大小写\n标识符命名规则方法、变量（小驼峰命名法）\n一个单词时，首字母小写    name\n多个单词，第一个首字母小写，其他首字母大写firstName\n类（大驼峰命名法）\n一个单词时，首字母大写    Student\n多个单词，每个首字母大写firstName\n基本数据类型基本数据类型是CPU可以直接进行运算的类型。Java定义了以下几种基本数据类型：\n整数类型：byte，short，int，long\n浮点数类型：float，double\n字符类型：char\n布尔类型：boolean\nJava定义的这些基本数据类型有什么区别呢？要了解这些区别，我们就必须简单了解一下计算机内存的基本结构。\n计算机内存的最小存储单元是字节（byte），一个字节就是一个8位二进制数，即8个bit。它的二进制表示范围从00000000—11111111，换算成十进制是0—255，换算成十六进制是00~ff。\n内存单元从0开始编号，称为内存地址。每个内存单元可以看作一间房间，内存地址就是门牌号。\n一个字节是1byte，1024字节是1K，1024K是1M，1024M是1G，1024G是1T。一个拥有4T内存的计算机的字节数量就是：\n123454T &#x3D; 4 x 1024G   &#x3D; 4 x 1024 x 1024M   &#x3D; 4 x 1024 x 1024 x 1024K   &#x3D; 4 x 1024 x 1024 x 1024 x 1024   &#x3D; 4398046511104不同的数据类型占用的字节数不一样。我们看一下Java基本数据类型占用的字节数：\nbyte恰好就是一个字节，而long和double需要8个字节。\n整型对于整型类型，Java只定义了带符号的整型，因此，最高位的bit表示符号位（0表示正数，1表示负数）。各种整型能表示的最大范围如下：\nbyte：-128 ~ 127\nshort: -32768 ~ 32767\nint: -2147483648 ~ 2147483647\nlong: -9223372036854775808 ~ 9223372036854775807\n我们来看定义整型的例子：\n12345678910public class Main &#123;    public static void main(String[] args) &#123;        int i = 2147483647;        int i2 = -2147483648;        int i3 = 2_000_000_000; // 加下划线更容易识别        int i4 = 0xff0000; // 十六进制表示的16711680        int i5 = 0b1000000000; // 二进制表示的512        long l = 9000000000000000000L; // long型的结尾需要加L    &#125;&#125;特别注意：同一个数的不同进制的表示是完全相同的，例如15=0xf＝0b1111。\nLong类型1long l=100000000L不加L默认为int类型 ，为了防止整数过大，后面加L\n浮点型浮点类型的数就是小数，因为小数用科学计数法表示的时候，小数点是可以“浮动”的，如1234.5可以表示成12.345x102，也可以表示成1.2345x103，所以称为浮点数。\n下面是定义浮点数的例子：\n12345float f1 = 3.14f;float f2 = 3.14e38f; // 科学计数法表示的3.14x10^38double d = 1.79e308;double d2 = -1.79e308;double d3 = 4.9e-324; // 科学计数法表示的4.9x10^-324对于float类型，需要加上f后缀。\n浮点数可表示的范围非常大，float类型可最大表示3.4x1038，而double类型可最大表示1.79x10308。\n布尔类型布尔类型boolean只有true和false两个值，布尔类型总是关系运算的计算结果：\n12345boolean b1 = true;boolean b2 = false;boolean isGreater = 5 &gt; 3; // 计算结果为trueint age = 12;boolean isAdult = age &gt;= 18; // 计算结果为falseJava语言对布尔类型的存储并没有做规定，因为理论上存储布尔类型只需要1 bit，但是通常JVM内部会把boolean表示为4字节整数。\n字符类型字符类型char表示一个字符。Java的char类型除了可表示标准的ASCII外，还可以表示一个Unicode字符：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        char a = 'A';        char zh = '中';        System.out.println(a);        System.out.println(zh);    &#125;&#125;注意char类型使用单引号&#39;，且仅有一个字符，要和双引号&quot;的字符串类型区分开。\na 97\nA 65\n0 48\n引用类型除了上述基本类型的变量，剩下的都是引用类型。例如，引用类型最常用的就是String字符串：\n1String s = \"hello\";引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置，后续我们介绍类的概念时会详细讨论。\nvar关键字有些时候，类型的名字太长，写起来比较麻烦。例如：\n1StringBuilder sb = new StringBuilder();这个时候，如果想省略变量类型，可以使用var关键字：\n1var sb = new StringBuilder();编译器会根据赋值语句自动推断出变量sb的类型是StringBuilder。对编译器来说，语句：\n1var sb = new StringBuilder();实际上会自动变成：\n1StringBuilder sb = new StringBuilder();因此，使用var定义变量，仅仅是少写了变量类型而已。\n整数运算Java的整数运算遵循四则运算规则，可以使用任意嵌套的小括号。四则运算规则和初等数学一致。例如：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        int i = (100 + 200) * (99 - 88); // 3300        int n = 7 * (5 + (i - 9)); // 23072        System.out.println(i);        System.out.println(n);    &#125;&#125;整数的数值表示不但是精确的，而且整数运算永远是精确的，即使是除法也是精确的，因为两个整数相除只能得到结果的整数部分：\n1int x = 12345 / 67; // 184求余运算使用%：\n1int y = 12345 % 67; // 12345÷67的余数是17特别注意：整数的除法对于除数为0时运行时将报错，但编译不会报错。\n溢出要特别注意，整数由于存在范围限制，如果计算结果超出了范围，就会产生溢出，而溢出不会出错，却会得到一个奇怪的结果：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        int x = 2147483640;        int y = 15;        int sum = x + y;        System.out.println(sum); // -2147483641    &#125;&#125;要解释上述结果，我们把整数2147483640和15换成二进制做加法：\n1234  0111 1111 1111 1111 1111 1111 1111 1000+ 0000 0000 0000 0000 0000 0000 0000 1111-----------------------------------------  1000 0000 0000 0000 0000 0000 0000 0111由于最高位计算结果为1，因此，加法结果变成了一个负数。\n要解决上面的问题，可以把int换成long类型，由于long可表示的整型范围更大，所以结果就不会溢出：\n1234long x = 2147483640;long y = 15;long sum = x + y;System.out.println(sum); // 2147483655还有一种简写的运算符，即+=，-=，*=，/=，它们的使用方法如下：\n12n += 100; // 3409, 相当于 n = n + 100;n -= 100; // 3309, 相当于 n = n - 100;自增/自减-=、+=等扩展运算符包含强制类型转换\nJava还提供了++运算和--运算，它们可以对一个整数进行加1和减1的操作：\n123456789public class Main &#123;    public static void main(String[] args) &#123;        int n = 3300;        n++; // 3301, 相当于 n = n + 1;        n--; // 3300, 相当于 n = n - 1;        int y = 100 + (++n); // 不要这么写        System.out.println(y);    &#125;&#125;注意++写在前面和后面计算结果是不同的，++n表示先加1再引用n，n++表示先引用n再加1。不建议把++运算混入到常规运算中，容易自己把自己搞懵了。\n移位运算在计算机中，整数总是以二进制的形式表示。例如，int类型的整数7使用4字节表示的二进制如下：\n100000000 0000000 0000000 00000111可以对整数进行移位运算。对整数7左移1位将得到整数14，左移两位将得到整数28：\n12345int n = 7;       // 00000000 00000000 00000000 00000111 = 7int a = n &lt;&lt; 1;  // 00000000 00000000 00000000 00001110 = 14int b = n &lt;&lt; 2;  // 00000000 00000000 00000000 00011100 = 28int c = n &lt;&lt; 28; // 01110000 00000000 00000000 00000000 = 1879048192int d = n &lt;&lt; 29; // 11100000 00000000 00000000 00000000 = -536870912左移29位时，由于最高位变成1，因此结果变成了负数。\n类似的，对整数28进行右移，结果如下：\n1234int n = 7;       // 00000000 00000000 00000000 00000111 = 7int a = n &gt;&gt; 1;  // 00000000 00000000 00000000 00000011 = 3int b = n &gt;&gt; 2;  // 00000000 00000000 00000000 00000001 = 1int c = n &gt;&gt; 3;  // 00000000 00000000 00000000 00000000 = 0如果对一个负数进行右移，最高位的1不动，结果仍然是一个负数：\n12345int n = -536870912;int a = n &gt;&gt; 1;  // 11110000 00000000 00000000 00000000 = -268435456int b = n &gt;&gt; 2;  // 11111000 00000000 00000000 00000000 = -134217728int c = n &gt;&gt; 28; // 11111111 11111111 11111111 11111110 = -2int d = n &gt;&gt; 29; // 11111111 11111111 11111111 11111111 = -1还有一种无符号的右移运算，使用&gt;&gt;&gt;，它的特点是不管符号位，右移后高位总是补0，因此，对一个负数进行&gt;&gt;&gt;右移，它会变成正数，原因是最高位的1变成了0：\n12345int n = -536870912;int a = n &gt;&gt;&gt; 1;  // 01110000 00000000 00000000 00000000 = 1879048192int b = n &gt;&gt;&gt; 2;  // 00111000 00000000 00000000 00000000 = 939524096int c = n &gt;&gt;&gt; 29; // 00000000 00000000 00000000 00000111 = 7int d = n &gt;&gt;&gt; 31; // 00000000 00000000 00000000 00000001 = 1对byte和short类型进行移位时，会首先转换为int再进行位移。\n仔细观察可发现，左移实际上就是不断地×2，右移实际上就是不断地÷2。\n位运算位运算是按位进行与、或、非和异或的运算。\n与运算的规则是，必须两个数同时为1，结果才为1：\n1234n = 0 &amp; 0; // 0n = 0 &amp; 1; // 0n = 1 &amp; 0; // 0n = 1 &amp; 1; // 1或运算的规则是，只要任意一个为1，结果就为1：\n1234n = 0 | 0; // 0n = 0 | 1; // 1n = 1 | 0; // 1n = 1 | 1; // 1非运算的规则是，0和1互换：\n12n = ~0; // 1n = ~1; // 0异或运算的规则是，如果两个数不同，结果为1，否则为0：\n1234n = 0 ^ 0; // 0n = 0 ^ 1; // 1n = 1 ^ 0; // 1n = 1 ^ 1; // 0对两个整数进行位运算，实际上就是按位对齐，然后依次对每一位进行运算。例如：\n1234567public class Main &#123;    public static void main(String[] args) &#123;        int i = 167776589; // 00001010 00000000 00010001 01001101        int n = 167776512; // 00001010 00000000 00010001 00000000        System.out.println(i &amp; n); // 167776512    &#125;&#125;上述按位与运算实际上可以看作两个整数表示的IP地址10.0.17.77和10.0.17.0，通过与运算，可以快速判断一个IP是否在给定的网段内。\n运算优先级在Java的计算表达式中，运算优先级从高到低依次是：\n()\n! ~ ++ --\n* / %\n+ -\n&lt;&lt; &gt;&gt; &gt;&gt;&gt;\n&amp;\n|\n+= -= *= /=\n记不住也没关系，只需要加括号就可以保证运算的优先级正确。\n类型自动提升与强制转型在运算过程中，如果参与运算的两个数类型不一致，那么计算结果为较大类型的整型。例如，short和int计算，结果总是int，原因是short首先自动被转型为int：\n12345678public class Main &#123;    public static void main(String[] args) &#123;        short s = 1234;        int i = 123456;        int x = s + i; // s自动转型为int        short y = s + i; // 编译错误!    &#125;&#125;也可以将结果强制转型，即将大范围的整数转型为小范围的整数。强制转型使用(类型)，例如，将int强制转型为short：\n12int i &#x3D; 12345;short s &#x3D; (short) i; &#x2F;&#x2F; 12345要注意，超出范围的强制转型会得到错误的结果，原因是转型时，int的两个高位字节直接被扔掉，仅保留了低位的两个字节：\n12345678910public class Main &#123;    public static void main(String[] args) &#123;        int i1 = 1234567;        short s1 = (short) i1; // -10617        System.out.println(s1);        int i2 = 12345678;        short s2 = (short) i2; // 24910        System.out.println(s2);    &#125;&#125;因此，强制转型的结果很可能是错的。\n字符串+操作123456789public class Main&#123;    public static void main(String[] args)&#123;        System.out.println(\"it\"+\"heima\");\t//itheima        System.out.println(\"itheima\"+666);\t//itheima666        System.out.println(\"itheima\"+6+66);\t//itheima666        System.out.println(1+99+\"黑马\");\t//100黑马         \t\t\t\t\t\t\t\t//先进行`1+99`，在进行`100+\"黑马    &#125;&#125;逻辑运算符\n前后都执行\n\n&amp;：有false则false\n|：有true则true\n^：相同为false，不同为true\n12345int i=10;int j=20;System.out.println((i++&gt;100)&amp;(j++&gt;100));System.out.println(\"i:\"+i);\t//i 11System.out.println(\"j:\"+j);\t//j 21\n短路与、或\n\n&amp;&amp;：左边为假，右边不执行\n||：左边为真，右边不执行\n12345int i=10;int j=20;System.out.println((i++&gt;100)&amp;&amp;(j++&gt;100));System.out.println(\"i:\"+i);\t//11System.out.println(\"j:\"+j);\t//20三元运算符12关系表达式？表达式1：表达式2;a&gt;b?a:b;首先计算关系表达式的值\n如果值为true，表达式1的值\n如果值为false，表达式2的值\n数据输入导包\n12import java.util.Scanner;导包的动作必须出现在类定义的上面\n创建对象\n12Sanner sc = new Scanner(System.in);上面这个格式里面，只有sc是变量名，可以变，其他的都不允许变\n接收数据\n12int i = sc.nextInt();上面这个格式里面，只有i是变量名，可以变，其他的都不允许变\n\n案例 身高比较\n\n123456789101112import java.util.Scanner;public class Scanner&#123;\tpublic static void main(String[] args)&#123;\t\tScanner sc = new Scanner(System.in);\t\tint height1 = sc.nextInt();\t\tint height2 = sc.nextInt();\t\tint height3 = sc.nextInt();\t\tint tempHeight = height1 &gt; height2 ? height1 : height2;        int maxHeight = tempHeight &gt; height3 ? tempHeight : height3;\t\tSystem.out.println(\"maxHeight:\"+maxHeight);\t&#125;&#125;流程控制switch语句1234567891011switch(表达式)&#123;\tcase 值1:\t\t语句体1;\t\tbreak;\tcase 值2:\t\t语句体2;\t\tbreak;\tdefault:\t\t语句体n+1;\t\t[break;]&#125;\n格式说明:\n\n表达式:取值为byte、short、int、char，JDK5以后可以是枚举，JDK7以后可以是Stringcase:后面跟的是要和表达式进行比较的值。break:表示中断，结束的意思，用来结束switch语句。default:表示所有情况都不匹配的时候，就执行该处的内容，和if语句的else相似。\n\n月份问题\n\n123456789101112131415161718192021222324switch (month)&#123;\tcase 1:\tcase 2:\tcase 12:\t\tSystem.out.println (\"冬季\");        break;\tcase 3:\tcase 4:\tcase 5:\t\tSystem.out.println (\"春季\") ;        break;\tcase 6:\tcase 7:\tcase 8:\t\tSystem.out.println (\"夏季\") ;        break;\tcase 9:\tcase 10:\tcase 11:\t\tSystem.out.println (\"秋季\");        break;\tdefault:\t\tSystem.out-println (\"你输入的月份有误\");&#125;Case 穿透12345678910switch(mouth)&#123;\tcase 1:\t\tSystem.out.println(\"冬季\");\t\t//break;\tcase 2:\t\tSystem.out.println(\"春季\");\t\tbreak;\tdefault:\tSystem.out.println(\"输入错误\");&#125;1冬季春季for循环123for(int i=1;i&lt;=5;i++)&#123;\tSystem.out.println(\"Hello\");&#125;","plink":"https://dxsummer.gitee.io/posts/b6543913/"},{"title":"数据库系统概论（第五版）课后答案","date":"2021-04-08T12:14:29.000Z","date_formatted":{"ll":"2021年4月8日","L":"2021/04/08","MM-DD":"04-08"},"updated":"2021-04-08T12:16:30.000Z","content":"\nP71 第六题 P130 第五题 \n\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101CREATE TABLE S  (SNO CHAR(2)PRIMARY KEY,  SNAME CHAR(6),  STATUS SMALLINT,  CITY CHAR(4),  );    CREATE TABLE P  (PNO CHAR(2)PRIMARY KEY,  PNAME CHAR(10),  COLOR CHAR(2),  WEIGHT SMALLINT,  );    CREATE TABLE J  (JNO CHAR(2)PRIMARY KEY,  JNAME CHAR(10),  CITY  CHAR(4),  );CREATE TABLE SPJ  (SNO CHAR(2),  PNO CHAR(2),  JNO CHAR(2),  QTY SMALLINT,  PRIMARY KEY(SNO,PNO,JNO),  FOREIGN KEY(SNO)REFERENCES S(SNO),  FOREIGN KEY(PNO)REFERENCES P(PNO),  FOREIGN KEY(JNO)REFERENCES J(JNO))  INSERT INTO S  VALUES('S1','精益',20,'天津');  INSERT INTO S  VALUES('S2','盛锡',10,'北京');  INSERT INTO S  VALUES('S3','东方红',30,'北京');  INSERT INTO S  VALUES('S4','丰盛泰',20,'天津');  INSERT INTO S  VALUES('S5','为民',30,'上海');  INSERT INTO P  VALUES('P1','螺母','红',12);  INSERT INTO P  VALUES('P2','螺栓','绿',17);  INSERT INTO P  VALUES('P3','螺丝刀','蓝',14);  INSERT INTO P   VALUES('P4','螺丝刀','红',14);  INSERT INTO P  VALUES('P5','凸轮','蓝',40);  INSERT INTO P  VALUES('P6','齿轮','红',30);  INSERT INTO SPJ   VALUES('S1','P1','J1',200);  INSERT INTO SPJ   VALUES('S1','P1','J3',100);  INSERT INTO SPJ   VALUES('S1','P1','J4',700);  INSERT INTO SPJ   VALUES('S1','P2','J2',100);  INSERT INTO SPJ   VALUES('S2','P3','J1',400);  INSERT INTO SPJ   VALUES('S2','P3','J2',200);  INSERT INTO SPJ   VALUES('S2','P3','J4',500);  INSERT INTO SPJ   VALUES('S2','P3','J5',400);  INSERT INTO SPJ   VALUES('S2','P5','J1',400);  INSERT INTO SPJ   VALUES('S2','P5','J2',100);  INSERT INTO SPJ   VALUES('S3','P1','J1',200);  INSERT INTO SPJ   VALUES('S3','P3','J1',200);  INSERT INTO SPJ  VALUES('S4','P5','J1',100);  INSERT INTO SPJ  VALUES('S4','P6','J3',300);  INSERT INTO SPJ  VALUES('S4','P6','J4',200);  INSERT INTO SPJ  VALUES('S5','P2','J4',100);  INSERT INTO SPJ  VALUES('S5','P3','J1',200);  INSERT INTO SPJ  VALUES('S5','P6','J2',200);  INSERT INTO SPJ  VALUES('S5','P6','J4',500);  SELECT JNAME, CITY FROM J;  SELECT PNAME, COLOR, WEIGHT FROM P;  SELECT JNO FROM SPJ WHERE SNO='S1';  SELECT P.PNAME,SPJ.QTY FROM SPJ,P WHERE  P.PNO = SPJ.PNO AND SPJ.JNO = 'J2' ;  SELECT DISTINCT PNO FROM SPJ,S WHERE S.CITY = '上海' AND SPJ.SNO = S.SNO;","plink":"https://dxsummer.gitee.io/posts/d47736e1/"},{"title":"SQL Sever笔记","date":"2021-04-05T11:02:51.000Z","date_formatted":{"ll":"2021年4月5日","L":"2021/04/05","MM-DD":"04-05"},"updated":"2021-05-24T12:32:28.000Z","content":"第二章 关系数据库1. 关系数据结构及形式化定义1.1 关系1.1.1 域域是一组具有相同数据类型的值的集合。 例:\n整数\n实数\n介于某个取值范围的整数\n指定长度的字符串集合\n{‘男’ ， ‘女’ }\n1.1.2 笛卡尔积给定一组域D1， D2， …， Dn， 允许其中某些域是相同的。D1， D2， …， Dn的笛卡尔积为：D1× D2× …× Dn ＝｛（d1， d2， …， dn） ｜ di∈Di， i＝1， 2， …， n｝\n所有域的所有取值的一个组合\n不能重复 \n元组（Tuple）笛卡尔积中每一个元素（d1， d2， …， dn）叫作一个n元组（n-tuple）或简称元组\n(张清玫，计算机专业，李勇)\n\n(张清玫，计算机专业，刘晨) 等 都是元组  \n\n分量（Component）笛卡尔积元素（d1， d2， …， dn）中的每一个值di 叫作一个分量\n张清玫、计算机专业、李勇、刘晨等都是分量 \n基数（Cardinal number）若Di（i＝1， 2， …， n）为有限集，其基数为mi（i＝1，2， …， n） ， 则D1× D2× …× Dn的基数M为：\n\n笛卡尔积的表示方法笛卡尔积可表示为一张二维表\n表中的每行对应一个元组， 表中的每列对应一个域\n\n例\n\n例如， 给出3个域：D1=导师集合SUPERVISOR=｛ 张清玫， 刘逸｝D2=专业集合SPECIALITY=｛ 计算机专业， 信息专业｝D3=研究生集合POSTGRADUATE=｛ 李勇， 刘晨， 王敏｝D1， D2， D3的笛卡尔积为  \n1234567D1× D2× D3＝｛(张清玫，计算机专业，李勇)， (张清玫，计算机专业，刘晨)，(张清玫，计算机专业，王敏)， (张清玫，信息专业，李勇)，(张清玫，信息专业，刘晨)， (张清玫，信息专业，王敏)，(刘逸，计算机专业，李勇)， (刘逸，计算机专业，刘晨)，(刘逸，计算机专业，王敏)， (刘逸，信息专业，李勇)，(刘逸，信息专业，刘晨)， (刘逸，信息专业，王敏) ｝基数为2× 2× 3＝12  \n1.1.3 关系关系D1× D2× …× Dn的子集叫作在域D1， D2， …， Dn上的关系， 表示为R（D1， D2， …， Dn）\nR： 关系名\n\nn： 关系的目或度（Degree）  \n\n\n元组关系中的每个元素是关系中的元组， 通常用t表示。\n\n单元关系与二元关系当n=1时， 称该关系为单元关系（Unary relation）或一元关系当n=2时， 称该关系为二元关系（Binary relation）  \n\n关系的表示关系也是一个二维表， 表的每行对应一个元组， 表的每列对应一个域  \n\n属性\n关系中不同列可以对应相同的域\n为了加以区分， 必须对每列起一个名字， 称为属性（Attribute）\nn目关系必有n个属性  \n\n码\n候选码（Candidate key）若关系中的某一属性组的值能唯一地标识一个元组，则称该属性组为候选码简单的情况：候选码只包含一个属性\n全码（All-key）最极端的情况：关系模式的所有属性组是这个关系模式的候选码，称为全码（All-key）\n主码若一个关系有多个候选码，则选定其中一个为主码（Primary key）\n主属性候选码的诸属性称为主属性（Prime attribute）不包含在任何侯选码中的属性称为非主属性（Non-Primeattribute）或非码属性（Non-key attribute）    \n\n三类关系基本关系（基本表或基表）\n实际存在的表，是实际存储数据的逻辑表示查询表\n查询结果对应的表视图表\n由基本表或其他视图表导出的表， 是虚表， 不对应实际存储的数据  \n基本关系的性质① 列是同质的（Homogeneous）② 不同的列可出自同一个域\n其中的每一列称为一个属性\n不同的属性要给予不同的属性名\n③ 列的顺序无所谓, 列的次序可以任意交换④ 任意两个元组的候选码不能相同⑤ 行的顺序无所谓， 行的次序可以任意交换  \n\n1.2 关系模式1.2.1 什么是关系模式关系模式（ Relation Schema） 是型\n\n关系是值\n\n关系模式是对关系的描述\n元组集合的结构属性构成\n属性来自的域\n属性与域之间的映象关系\n\n完整性约束条件  \n\n1.2.2 定义关系模式关系模式可以形式化地表示为：R（ U， D， DOM， F）\n\nR关系名\n\nU组成该关系的属性名集合\n\nDU中属性所来自的域\n\nDOM属性向域的映象集合（说明它们分别出自哪个域)\n\nF属性间数据的依赖关系的集合\n\n例:\n\n导师和研究生出自同一个域——人，取不同的属性名，并在模式中定义属性向域的映象，即说明它们分别出自哪个域：DOM（SUPERVISOR-PERSON）= DOM（POSTGRADUATE-PERSON）= PERSON  \n关系模式通常可以简记为R (U) 或 R (A1， A2， …， An)\nR: 关系名\nA1， A2， …， An : 属性名\n注：域名及属性向域的映象常常直接说明为属性的类型、长度  \n1.2.3 关系模式与关系关系模式\n对关系的描述\n静态的、 稳定的\n关系\n关系模式在某一时刻的状态或内容\n动态的、 随时间不断变化的\n关系模式和关系往往笼统称为关系\n通过上下文加以区别  \n1.3 关系数据库关系数据库在一个给定的应用领域中， 所有关系的集合构成一个关系数据库\n\n关系数据库的型与值关系数据库的型: 关系数据库模式， 是对关系数据库的描述\n关系数据库的值: 关系模式在某一时刻对应的关系的集合， 通常称为关系数据库    \n\n1.4 关系模型的存储结构关系数据库的物理组织有的关系数据库管理系统中一个表对应一个操作系统文件，将物理数据组织交给操作系统完成\n有的关系数据库管理系统从操作系统那里申请若干个大的文件，自己划分文件空间，组织表、索引等存储结构，并进行存储管理  \n\n2. 关系操作常用的关系操作\n查询操作：选择、 投影、 连接、 除、 并、 差、 交、 笛卡尔积\n\n选择、 投影、 并、 差、 笛卡尔基是5种基本操作\n\n数据更新：插入、 删除、 修改\n\n关系操作的特点\n集合操作方式：操作的对象和结果都是集合， 一次一集合的方式  \n2.1 关系数据库语言的分类关系代数语言\n用对关系的运算来表达查询要求\n代表： ISBL\n关系演算语言：用谓词来表达查询要求\n元组关系演算语言谓词变元的基本对象是元组变量\n代表： APLHA, QUEL\n\n域关系演算语言谓词变元的基本对象是域变量\n代表： QBE\n\n具有关系代数和关系演算双重特点的语言\n代表： SQL（Structured Query Language）  \n3. 关系的完整性实体完整性和参照完整性\n关系模型必须满足的完整性约束条件称为关系的两个不变性， 应该由关系系统自动支持\n用户定义的完整性\n应用领域需要遵循的约束条件， 体现了具体领域中的语义约束  \n3.1 实体完整性实体完整性规则（Entity Integrity）\n若属性A是基本关系R的主属性， 则属性A不能取空值\n空值就是“不知道” 或“不存在” 或“无意义” 的值\n\n 例：\n\n​    选修（学号， 课程号， 成绩）​    “学号、 课程号” 为主码​    “学号” 和“课程号” 两个属性都不能取空值  \n3.2 参照完整性3.2.1 关系间的引用在关系模型中实体及实体间的联系都是用关系来描述的， 自然存在着关系与关系间的引用  \n学生关系引用了专业关系的主码“专业号”。 \n学生关系中的“专业号”值必须是确实存在的专业的专业号   \n\n例[2.2]     学生、 课程、 学生与课程之间的多对多联系\n\n学生（学号， 姓名， 性别， 专业号， 年龄）课程（课程号， 课程名， 学分）选修（学号， 课程号， 成绩）  \n\n 例[2.3]     学生实体及其内部的一对多联系\n\n学生（学号， 姓名， 性别， 专业号， 年龄， 班长）\n\n学号姓名性别专业号年龄班长\n\n801张三女0119802\n\n802李四男0120\n\n803王五男0120802\n\n804赵六女0220806\n\n805钱七男0219\n“学号”是主码，“班长”是外码，它引用了本关系的“学号”\n“班长” 必须是确实存在的学生的学号  \n3.2.2 外码\n[例2.1]    学生关系的“专业号”与专业关系的主码“专业号”相对应\n\n“专业号”属性是学生关系的外码\n专业关系是被参照关系，学生关系为参照关系\n\n[例2.2]中\n\n选修关系的“学号” 与学生关系的主码“学号”相对应选修关系的“课程号”与课程关系的主码“课程号”相对应\n“学号”和“课程号”是选修关系的外码\n学生关系和课程关系均为被参照关系\n选修关系为参照关系\n\n[例2.3]中“班长”与本身的主码“学号”相对应\n\n“班长”是外码\n学生关系既是参照关系也是被参照关系  \n3.2.3 参照完整性规则\n[例2.1]    学生关系中每个元组的“专业号” 属性只取两类值：\n\n（1） 空值， 表示尚未给该学生分配专业（ 2） 非空值， 这时该值必须是专业关系中某个元组的“专业号” 值， 表示该学生不可能分配一个不存在的专业  \n\n[例2.2] 选修（学号， 课程号，成绩）\n\n“学号”和“课程号”可能的取值 ：（1）选修关系中的主属性，不能取空值（2）只能取相应被参照关系中已经存在的主码值  \n\n[例2.3]     学生（学号，姓名，性别，专业号，年龄， 班长）\n\n“班长”属性值可以取两类值：（1）空值，表示该学生所在班级尚未选出班长（2）非空值，该值必须是本关系中某个元组的学号值  \n3.3 用户定义的完整性\n例:    课程（课程号， 课程名， 学分）\n\n“课程号” 属性必须取唯一值\n非主属性“课程名” 也不能取空值\n“学分” 属性只能取值{1， 2， 3， 4}  \n4. 关系代数关系代数是一种抽象的查询语言，它用对关系的运算来表达查询\n关系代数\n运算对象是关系\n运算结果亦为关系\n关系代数的运算符有两类：集合运算符和专门的关系运算符\n传统的集合运算是从关系的“水平”方向即行的角度进行专门的关系运算不仅涉及行而且涉及列  \n并（Union）R和S\n具有相同的目n（ 即两个关系都有n个属性）\n相应的属性取自同一个域\nR∪ S\n仍为n目关系， 由属于R或属于S的元组组成R∪ S = { t|t∈R∨t ∈S }  \n差 （Difference）R和S\n具有相同的目n\n\n相应的属性取自同一个域\n\nR - S\n仍为n目关系， 由属于R而不属于S的所有元组组成R -S = { t|t∈R∧t ∉ S }  \n交（ Intersection）R和S\n具有相同的目n\n相应的属性取自同一个域\nR∩S\n仍为n目关系， 由既属于R又属于S的元组组成R∩S = { t|t ∈ R∧t ∈S }R∩S = R –(R-S）  \n笛卡尔积（ Cartesian Product）严 格 地 讲 应 该 是 广 义 的 笛 卡 尔 积 （ ExtendedCartesian Product）\nR: n目关系， k1个元组S: m目关系， k2个元组R × S\n列：（ n+m） 列元组的集合元组的前n列是关系R的一个元组\n后m列是关系S的一个元组\n\n行： k1× k2个元组\n\n\n符号\n\nR， t∈R， t[Ai]设关系模式为R(A1，A2， …，An)它的一个关系设为Rt∈R表示t是R的一个元组t[Ai]则表示元组t中相应于属性Ai的一个分量  \n选择（Selection）\n\n选择又称为限制（Restriction）\n选择运算符的含义\n在关系R中选择满足给定条件的诸元组\n​    σF(R) = {t|t∈R∧F(t)= ‘真’}\n\nF：选择条件， 是一个逻辑表达式， 取值为“ 真”或“假”\n基本形式为： X1θ Y1\nθ表示比较运算符， 它可以是＞， ≥， ＜， ≤， ＝或&lt;&gt;  \n\n选择运算是从关系R中选取使逻辑表达式F为真的元组， 是从行的角度进行的运算  \n\n[例2.4] 查询信息系（IS系） 全体学生。\n\nσSdept= ‘IS’ (Student)\n结果：\n\nSnoSnameSsexSageSdept\n\n201215125张立男19IS\n\n[例2.5] 查询年龄小于20岁的学生。\n\nσSage &lt; 20(Student)\n结果：\n\nSnoSnameSsexSageSdept\n\n201215122刘晨女19IS\n\n201215123王敏女18MA\n\n201215125张立男19IS\n投影（Projection）从R中选择出若干属性列组成新的关系\nπ&lt;sub&gt;A&lt;/sub&gt;(R) = { t[A] | t ∈R }\nA： R中的属性列\n投影操作主要是从列的角度进行运算  \n\n投影之后不仅取消了原关系中的某些列， 而且还可能取消某些元组（避免重复行）  \n\n[例2.6] 查询学生的姓名和所在系。\n\n即求Student关系上学生姓名和所在系两个属性上的投影\nπSname,Sdept(Student)\n结果：\n\nSnameSdept\n\n李勇CS\n\n刘晨CS\n\n王敏MA\n\n张立IS\n\n [例2.7] 查询学生关系Student中都有哪些系。\n\nπSdept(Student)\n结果：\n\nSdept\n\nCS\n\nIS\n\nMA\n连接（Join）连接也称为θ连接\n连接运算的含义\n​    从两个关系的笛卡尔积中选取属性间满足一定条件的元组​    \nA和B：分别为R和S上度数相等且可比的属性组\n\nθ：比较运算符\n\n连接运算从R和S的广义笛卡尔积R× S中选取R关系在A属性组上的值与S关系在B属性组上的值满足比较关系θ的元组  \n\n等值连接（equijoin）\nθ为“＝” 的连接运算称为等值连接\n从关系R与S的广义笛卡尔积中选取A、 B属性值相等的那些元组， 即等值连接为：\n自然连接（Natural join）\n自然连接是一种特殊的等值连接两个关系中进行比较的分量必须是相同的属性组\n在结果中把重复的属性列去掉\n\n自然连接的含义\nR和S具有相同的属性组B\n从行的角度进行运算  \n自然连接还需要取消重复列，所以是同时从行和列的角度进行运算。  \n\n[例2.8]关系R和关系S 如下所示：  \n\n\n外连接除运算（Division）R与S的除运算得到一个新的关系P(X)，P是R中满足下列条件的元组在 X 属性列上的投影：元组在X上分量值x的象集Yx包含S在Y上投影的集合， 记作：    \n除操作是同时从行和列角度进行运算  \n\n [例2.9]设关系R、 S分别为下图的(a)和(b)， RS的结果为图(c)  \n\n在关系R中， A可以取四个值{a1， a2， a3， a4}a1的象集为 {(b1， c2)， (b2， c3)， (b2， c1)}a2的象集为 {(b3， c7)， (b2， c3)}a3的象集为 {(b4， c6)}a4的象集为 {(b6， c6)}\nS在(B，C)上的投影为{(b1， c2)， (b2， c1)， (b2， c3) }\n只有a1的象集包含了S在(B， C)属性组上的投影所以 R÷S ={a1}  \n第三章 关系数据库标准语言SQL数据定义\n数据类型含义\n\nCHAR(n),CHARACTER(n)长度为n的定长字符串\n\nVARCHAR(n), CHARACTERVARYING(n)最大长度为n的变长字符串\n\nCLOB字符串大对象\n\nBLOB二进制大对象\n\nINT， INTEGER长整数（4字节）\n\nSMALLINT短整数（2字节）\n\nBIGINT大整数（8字节）\n\nNUMERIC(p， d)定点数，由p位数字（不包括符号、小数点）组成，小数后面有d位数字\n\nDECIMAL(p, d), DEC(p, d)同NUMERIC\n\nREAL取决于机器精度的单精度浮点数\n\nDOUBLE PRECISION取决于机器精度的双精度浮点数\n\nFLOAT(n)可选精度的浮点数，精度至少为n位数字\n\nBOOLEAN逻辑布尔量\n\nDATE日期，包含年、月、日，格式为YYYY-MM-DD\n\nTIME时间，包含一日的时、分、秒，格式为HH:MM:SS\n\nTIMESTAMP时间戳类型\n\nINTERVAL时间间隔类型\n模式定义模式1CREATE SCHEMA &lt;模式名&gt; AUTHORIZATION &lt;用户名&gt;[&lt;表定义子句&gt;|&lt;视图定义子句&gt;|&lt;授权定义子句&gt;]\n[例3.1] 为用户WANG定义一个学生-课程模式S-T\n\n1CREATE SCHEMA “S-T” AUTHORIZATION WANG;\n[例3.2] CREATE SCHEMA AUTHORIZATION WANG;\n\n该语句没有指定&lt;模式名&gt;， &lt;模式名&gt;隐含为&lt;用户名&gt;  \n\n[例3.3]为用户ZHANG创建了一个模式TEST，并且在其中定义一个表TAB1\n\n1234567CREATE SCHEMA TEST AUTHORIZATION ZHANGCREATE TABLE TAB1 (COL1 SMALLINT,                   COL2 INT,                   COL3 CHAR(20),                   COL4 NUMERIC(10,3),                   COL5 DECIMAL(5,2)                  );删除模式1DROP SCHEMA &lt;模式名&gt; &lt;CASCADE|RESTRICT&gt;CASCADE（cascade级联）\n删除模式的同时把该模式中所有的数据库对象全部删除\nRESTRICT（restrict限制）\n如果该模式中定义了下属的数据库对象（如表、视图等），则拒绝该删除语句的执行。\n仅当该模式中没有任何下属的对象时才能执行。  \n\n[例3.4]     DROP SCHEMA ZHANG CASCADE;\n\n删除模式ZHANG同时该模式中定义的表TAB1也被删除  \n基本表定义12345CREATE TABLE &lt;表名&gt;(&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt; ] [,&lt;列名&gt; &lt;数据类型&gt;[ &lt;列级完整性约束条件&gt;] ]…  [,&lt;表级完整性约束条件&gt; ] );&lt;表名&gt;：所要定义的基本表的名字\n&lt;列名&gt;：组成该表的各个属性（列）\n&lt;列级完整性约束条件&gt;：涉及相应属性列的完整性约束条件\n&lt;表级完整性约束条件&gt;：涉及一个或多个属性列的完整性约束条件\n如果完整性约束条件涉及到该表的多个属性列，则必须定义在表级上，否则既可以定义在列级也可以定义在表级。  \n\n[例3.5] 建立“学生” 表Student。 学号是主码， 姓名取值唯一。\n\n12345678CREATE TABLE Student    (Sno CHAR(9) PRIMARY KEY,                                /* 列级完整性约束条件,Sno是主码*/    Sname CHAR(20) UNIQUE, \t\t/* Sname取唯一值*/    Ssex CHAR(2),    Sage SMALLINT,    Sdept CHAR(20)    );\n[例3.6 ] 建立一个“课程”表Course\n\n12345678CREATE TABLE Course    (Cno CHAR(4) PRIMARY KEY,    Cname CHAR(40),    Cpno CHAR(4),    Ccredit SMALLINT，    FOREIGN KEY (Cpno) REFERENCES Course(Cno)     \t\t\t\t\t/*Cpno是外码被参照表是Course被参照列是Cno*/    );\n[例3.7] 建立一个学生选课表SC\n\n1234567891011CREATE TABLE SC    (Sno CHAR(9),    Cno CHAR(4),    Grade SMALLINT，    PRIMARY KEY (Sno,Cno),    \t/* 主码由两个属性构成，必须作为表级完整性进行定义*/    FOREIGN KEY (Sno) REFERENCES Student(Sno),    \t/* 表级完整性约束条件， Sno是外码，被参照表是Student */    FOREIGN KEY (Cno)REFERENCES Course(Cno)    \t/* 表级完整性约束条件， Cno是外码，被参照表是Course*/    );插入基本表12345678910INSERT INTO S  VALUES('S1','精益',20,'天津');  INSERT INTO S  VALUES('S2','盛锡',10,'北京');  INSERT INTO S  VALUES('S3','东方红',30,'北京');  INSERT INTO S  VALUES('S4','丰盛泰',20,'天津');  INSERT INTO S  VALUES('S5','为民',30,'上海');修改基本表123456ALTER TABLE &lt;表名&gt;    [ ADD[COLUMN] &lt;新列名&gt; &lt;数据类型&gt; [ 完整性约束 ] ]    [ ADD &lt;表级完整性约束&gt;]    [ DROP [ COLUMN ] &lt;列名&gt; [CASCADE| RESTRICT] ]    [ DROP CONSTRAINT&lt;完整性约束名&gt;[ RESTRICT | CASCADE ] ]    [ALTER COLUMN &lt;列名&gt;&lt;数据类型&gt; ] ;&lt;表名&gt;是要修改的基本表\nADD子句用于增加新列、新的列级完整性约束条件和新的表级完整性约束条件\nDROP COLUMN子句用于删除表中的列\n如果指定了CASCADE短语，则自动删除引用了该列的其他对象\n如果指定了RESTRICT短语，则如果该列被其他对象引用，关系数据库管理系统将拒绝删除该列\nDROP CONSTRAINT子句用于删除指定的完整性约束条件\nALTER COLUMN子句用于修改原有的列定义，包括修改列名和数据类型  \n\n[例3.8] 向Student表增加“入学时间” 列， 其数据类型为日期型\n\n1ALTER TABLE Student ADD S_entrance DATE;不管基本表中原来是否已有数据，新增加的列一律为空值  \n\n[例3.9] 将年龄的数据类型由字符型（假设原来的数据类型是字符型）改为整数。\n\n1ALTER TABLE Student ALTER COLUMN Sage INT;\n[例3.10] 增加课程名称必须取唯一值的约束条件。\n\n1ALTER TABLE Course ADD UNIQUE(Cname);删除基本表1DROP TABLE &lt;表名&gt;［RESTRICT| CASCADE］ ;RESTRICT：删除表是有限制的。\n欲删除的基本表不能被其他表的约束所引用\n\n如果存在依赖该表的对象，则此表不能被删除\n\nCASCADE：删除该表没有限制。\n在删除基本表的同时，相关的依赖对象一起删除  \n\n[例3.11]     删除Student表\n\n1DROP TABLE Student CASCADE;基本表定义被删除，数据被删除\n表上建立的索引、视图、触发器等一般也将被删除  \n\n[例3.12 ]若表上建有视图，选择RESTRICT时表不能删除;选择CASCADE时可以删除表，视图也自动删除。\n\n12345678CREATE VIEW IS_StudentAS    SELECT Sno,Sname,Sage    FROM Student    WHERE Sdept='IS';    \tDROP TABLE Student RESTRICT;--ERROR: cannot drop table Student because other objects depend on it\n[例3.12续]如果选择CASCADE时可以删除表，视图也自动被删除\n\n1234DROP TABLE Student CASCADE;--NOTICE: drop cascades to view IS_StudentSELECT * FROM IS_Student;--ERROR: relation \" IS_Student \" does not exist模式与表每一个基本表都属于某一个模式\n一个模式包含多个基本表\n定义基本表所属模式\n方法一：在表名中明显地给出模式名\n123Create table\"S-T\".Student(......); /*模式名为 S-T*/Create table \"S-T\".Cource(......);Create table \"S-T\".SC(......);\n方法二：在创建模式语句中同时创建表\n\n方法三：设置所属的模式  \n\n关系数据库管理系统会使用模式列表中第一个存在的模式作为数据库对象的模式名  \n创建基本表（其他数据库对象也一样）时，若没有指定模式，系统根据搜索路径来确定该对象所属的模式  \n索引建立索引建立索引的目的：加快查询速度\n关系数据库管理系统中常见索引：\n顺序文件上的索引\nB+树索引（参见爱课程网3.2节动画《B +树的增删改》 ）\n散列（hash）索引\n位图索引\n特点：\nB+树索引具有动态平衡的优点\nHASH索引具有查找速度快的特点  \n语句格式\n1CREATE [UNIQUE] [CLUSTER] INDEX &lt;索引名&gt; ON &lt;表名&gt;(&lt;列名&gt;[&lt;次序&gt;][,&lt;列名&gt;[&lt;次序&gt;] ]…);&lt;表名&gt;： 要建索引的基本表的名字\n索引：可以建立在该表的一列或多列上， 各列名之间用逗号分隔\n&lt;次序&gt;： 指定索引值的排列次序， 升序： ASC， 降序：DESC。 缺省值： ASC\nUNIQUE： 此索引的每一个索引值只对应唯一的数据记录\nCLUSTER： 表示要建立的索引是聚簇索引  \n\n[例3.13] 为学生-课程数据库中的Student， Course， SC三个表建立索引。 Student表按学号升序建唯一索引， Course表按课程号升序建唯一索引， SC表按学号升序和课程号降序建唯一索引\n\n123CREATE UNIQUE INDEX Stusno ON Student(Sno);CREATE UNIQUE INDEX Coucno ON Course(Cno);CREATE UNIQUE INDEX SCno ON SC(Sno ASC,Cno DESC);修改索引1ALTER INDEX &lt;旧索引名&gt; RENAME TO &lt;新索引名&gt;\n[例3.14] 将SC表的SCno索引名改为SCSno\n\n1ALTER INDEX SCno RENAME TO SCSno;删除索引1DROP INDEX &lt;索引名&gt;;删除索引时，系统会从数据字典中删去有关该索引的描述。\n\n[例3.15] 删除Student表的Stusname索引\n\n1DROP INDEX Stusname;数据字典数据字典是关系数据库管理系统内部的一组系统表，它记录了数据库中所有定义信息：\n关系模式定义\n视图定义\n索引定义\n完整性约束定义\n各类用户对数据库的操作权限\n统计信息等\n关系数据库管理系统在执行SQL的数据定义语句时，实际上就是在更新数据字典表中的相应信息。  \n数据查询语句格式\n1234SELECT [ALL|DISTINCT] &lt;目标列表达式&gt;[,&lt;目标列表达式&gt;] …FROM &lt;表名或视图名&gt;[,&lt;表名或视图名&gt; ]…|(SELECT 语句)[AS]&lt;别名&gt;[ WHERE &lt;条件表达式&gt; ][ GROUP BY &lt;列名1&gt; [ HAVING &lt;条件表达式&gt; ] ][ ORDER BY &lt;列名2&gt; [ ASC|DESC ] ];SELECT子句：指定要显示的属性列\nDISTINCT：去掉重复行\nFROM子句：指定查询对象（基本表或视图）\nWHERE子句：指定查询条件\nGROUP BY子句：对查询结果按指定列的值分组， 该属性列值相等的元组为一个组。 通常会在每组中作用聚集函数。\nHAVING短语：只有满足指定条件的组才予以输出\nORDER BY子句：对查询结果表按指定列值的升序或降序排序  \n查询指定列\n\n [例3.16] 查询全体学生的学号与姓名。\n\n1SELECT Sno,Sname FROM Student;\n [例3.17] 查询全体学生的姓名、 学号、 所在系。\n\n1SELECT Sname,Sno,Sdept FROM Student;查询全部列\n\n[例3.18] 查询全体学生的详细记录\n\n1SELECT Sno,Sname,Ssex,Sage,Sdept FROM Student;或\n1SELECT * FROM Student;查询经过计算的值\n\n[例3.19] 查全体学生的姓名及其出生年份。\n\n12SELECT Sname,2014-Sage /*假设当时为2014年*/FROM Student;输出结果：\n\nSname2014-Sage\n\n李勇1994\n\n刘晨1995\n\n王敏1996\n\n张立1995\n\n[例3.20] 查询全体学生的姓名、 出生年份和所在的院系， 要求用小写字母表示系名。\n\n1SELECT Sname,'Year of Birth: ',2014-Sage,LOWER(Sdept) FROM Student;输出结果：\n12345Sname 'Year of Birth:' 2014-Sage LOWER(Sdept)李勇 \t Year of Birth: \t\t1994 cs刘晨 \t Year of Birth: \t\t1995 cs王敏 \t Year of Birth: \t\t1996 ma张立 \t Year of Birth: \t\t1995 is 使用列别名改变查询结果的列标题:\nSELECT Sname NAME,’Year of Birth:’ BIRTH,2014-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENT FROM Student;\n1SELECT Sname NAME,'Year of Birth:' BIRTH,2014-Sage BIRTHDAY,LOWER(Sdept) DEPARTMENT FROM Student;输出结果：\n12345NAME BIRTH BIRTHDAY DEPARTMENT李勇  Year of Birth:  1994 cs刘晨  Year of Birth:  1995 cs王敏  Year of Birth:  1996 ma张立  Year of Birth:  1995 is消除取值重复的行如果没有指定DISTINCT关键词，则缺省为ALL\n\n[例3.21] 查询选修了课程的学生学号。\n\n1SELECT Sno FROM SC;等价于：\n1SELECT ALL Sno FROM SC;执行上面的SELECT语句后，结果为：  \n 指定DISTINCT关键词，去掉表中重复的行\n1SELECT DISTINCT Sno FROM SC;执行结果：\n常用的查询条件\n查 询 条 件谓 词\n\n比 较=, &gt;, &lt;, &gt;=, &lt;=, !=, &lt;&gt;, !&gt;, !&lt;; NOT+上述比较运算符\n\n确定范围BETWEEN AND, NOT BETWEEN AND\n\n确定集合IN, NOT IN\n\n字符匹配LIKE, NOT LIKE\n\n空 值IS NULL, IS NOT NULL\n\n多重条件（逻辑运算）AND, OR, NOT\n比较大小\n[例3.22] 查询计算机科学系全体学生的名单。\n\n1SELECT Sname FROM Student WHERE Sdept=‘CS’;\n[例3.23]查询所有年龄在20岁以下的学生姓名及其年龄。\n\n1SELECT Sname,Sage FROM Student WHERE Sage &lt; 20;\n[例3.24]查询考试成绩有不及格的学生的学号。\n\n1SELECT DISTINCT Sn FROM SC WHERE Grade&lt;60;确定范围谓词: \n1BETWEEN … AND … NOT BETWEEN … AND …\n[例3.25] 查询年龄在20~23岁（包括20岁和23岁）之间的学生的姓名、系别和年龄\n\n1SELECT Sname, Sdept, Sage FROM Student WHERE Sage BETWEEN 20 AND 23;\n[例3.26] 查询年龄不在20~23岁之间的学生姓名、 系别和年龄\n\n1SELECT Sname, Sdept, Sage FROM Student WHERE Sage NOT BETWEEN 20 AND 23;确定集合\n[例3.27]查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。\n\n1SELECT Sname, Ssex FROM Student WHERE Sdept IN ('CS','MA’,'IS' );\n[例3.28]查询既不是计算机科学系、 数学系， 也不是信息系的学生的姓名和性别。\n\n1SELECT Sname, Ssex FROM Student WHERE Sdept NOT IN ('IS','MA’,'CS' );字符匹配% （百分号） 代表任意长度（长度可以为0） 的字符串\n例如 a%b 表示以a开头， 以b结尾的任意长度的字符串\n\n_ （下横线） 代表任意单个字符。\n例如a_b表示以a开头， 以b结尾的长度为3的任意字符串  \n\n匹配串为固定字符串  \n\n[例3.29] 查询学号为201215121的学生的详细情况。\n\n1SELECT * FROM Student WHERE Sno LIKE ‘201215121';等价于：\n1SELECT * FROM Student WHERE Sno = ' 201215121 ';匹配串为含通配符的字符串  \n\n[例3.30] 查询所有姓刘学生的姓名、学号和性别。\n\n1SELECT Sname, Sno, Ssex FROM Student WHERE Sname LIKE '刘%';\n[例3.31] 查询姓”欧阳”且全名为三个汉字的学生的姓名。\n\n1SELECT Sname FROM Student WHERE Sname LIKE '欧阳__';\n[例3.32] 查询名字中第2个字为”阳”字的学生的姓名和学号。\n\n1SELECT Sname， Sno FROM Student WHERE Sname LIKE '__阳%';\n[例3.33] 查询所有不姓刘的学生姓名、学号和性别。\n\n1SELECT Sname, Sno, Ssex FROM Student WHERE Sname NOT LIKE '刘%';使用换码字符将通配符转义为普通字符  \n\n[例3.34] 查询DB_Design课程的课程号和学分。\n\n1SELECT Cno，Ccredit FROM Course WHERE Cname LIKE 'DB\\_Design' ESCAPE '\\ ' ;\n[例3.35] 查询以”DB_”开头，且倒数第3个字符为 i的课程的详细情况。\n\n123SELECT *FROM CourseWHERE Cname LIKE 'DB\\_%i_ _' ESCAPE '\\ ' ;ESCAPE &#39;＼ &#39; 表示“ ＼” 为换码字符  \n涉及空值的查询\n[例3.36] 某些学生选修课程后没有参加考试，所以有选课记录，但没 有考试成绩。查询缺少成绩的学生的学号和相应的课程号。\n\n1SELECT Sno, Cno FROM SC WHERE Grade IS NULL\n[例3.37] 查所有有成绩的学生学号和课程号。\n\n1SELECT Sno， Cno FROM SC WHERE Grade IS NOT NULL;多重条件查询[例3.38] 查询计算机系年龄在20岁以下的学生姓名。\n1SELECT Sname FROM Student WHERE Sdept= 'CS' AND Sage&lt;20;\n改写[例3.27][例3.27] 查询计算机科学系（CS）、数学系（MA）和信息系（IS）学生的姓名和性别。\n\n123SELECT Sname, SsexFROM StudentWHERE Sdept IN ('CS ','MA ','IS')可改写为：\n123SELECT Sname, SsexFROM StudentWHERE Sdept= ' CS' OR Sdept= ' MA' OR Sdept= 'IS ';ORDER BY升序： ASC;\n降序： DESC;    缺省值为升序  \n\n[例3.39]查询选修了3号课程的学生的学号及其成绩， 查询结果按分数降序排列。\n\n1234SELECT Sno, GradeFROM SCWHERE Cno= ' 3 'ORDER BY Grade DESC;\n[例3.40]查询全体学生情况，查询结果按所在系的系号升序排列，同一系中的学生按年龄降序排列。\n\n123SELECT *FROM StudentORDER BY Sdept, Sage DESC;聚集函数统计元组个数\n1COUNT(*)\n统计一列中值的个数\n\n1COUNT([DISTINCT|ALL] &lt;列名&gt;)计算一列值的总和（此列必须为数值型）\n1SUM([DISTINCT|ALL] &lt;列名&gt;)计算一列值的平均值（此列必须为数值型）\n1AVG([DISTINCT|ALL] &lt;列名&gt;)求一列中的最大值和最小值\n12MAX([DISTINCT|ALL] &lt;列名&gt;)MIN([DISTINCT|ALL] &lt;列名&gt;)\n[例3.41] 查询学生总人数。\n\n12SELECT COUNT(*)FROM Student;\n[例3.42] 查询选修了课程的学生人数。\n\n12SELECT COUNT(DISTINCT Sno)FROM SC;\n[例3.43] 计算1号课程的学生平均成绩。\n\n123SELECT AVG(Grade)FROM SCWHERE Cno= ' 1 ';\n[例3.44] 查询选修1号课程的学生最高分数。\n\n123SELECT MAX(Grade)FROM SCWHERE Cno='1';\n[例3.45 ] 查询学生201215012选修课程的总学分数。\n\n123SELECT SUM(Ccredit)FROM SC,CourseWHERE Sno='201215012' AND SC.Cno=Course.Cno;GROUP BY对查询结果分组后，聚集函数将分别作用于每个组  \n按指定的一列或多列值分组，值相等的为一组  \n\n[例3.46] 求各个课程号及相应的选课人数。\n\n123SELECT Cno, COUNT(Sno)FROM SCGROUP BY Cno;查询结果可能为：   \n\n[例3.47] 查询选修了3门以上课程的学生学号。\n\n1234SELECT SnoFROM SCGROUP BY SnoHAVING COUNT(*) &gt;3;\n[例3.48 ]查询平均成绩大于等于90分的学生学号和平均成绩\n\n下面的语句是不对的：\n1234SELECT Sno, AVG(Grade)FROM SCWHERE AVG(Grade)&gt;=90GROUP BY Sno;因为WHERE子句中是不能用聚集函数作为条件表达式\n正确的查询语句应该是：\n1234SELECT Sno, AVG(Grade)FROM SCGROUP BY SnoHAVING AVG(Grade)&gt;=90;HAVING短语与WHERE子句的区别：\n作用对象不同\nWHERE子句作用于基表或视图， 从中选择满足条件的元组\nHAVING短语作用于组， 从中选择满足条件的组  \n连接查询等值与非等值连接查询\n[例 3.49] 查询每个学生及其选修课程的情况\n\n123SELECT Student.*, SC.*FROM Student, SCWHERE Student.Sno = SC.Sno;\n[例 3.50] 对[例 3.49]用自然连接完成。\n\n123SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,GradeFROM Student,SCWHERE Student.Sno = SC.Sno;\n[例 3.51 ]查询选修2号课程且成绩在90分以上的所有学生的学号和姓名。\n\n1234SELECT Student.Sno, SnameFROM Student, SCWHERE Student.Sno=SC.Sno ANDSC.Cno=' 2 ' AND SC.Grade&gt;90;自身连接自身连接： 一个表与其自己进行连接\n需要给表起别名以示区别\n由于所有属性名都是同名属性，因此必须使用别名前缀  \n\n[例 3.52]查询每一门课的间接先修课（即先修课的先修课）\n\n123SELECT FIRST.Cno, SECOND.CpnoFROM Course FIRST, Course SECONDWHERE FIRST.Cpno = SECOND.Cno;外连接外连接与普通连接的区别\n普通连接操作只输出满足连接条件的元组\n外连接操作以指定表为连接主体，将主体表中不满足连接条件的元组一并输出\n左外连接列出左边关系中所有的元组\n\n右外连接列出右边关系中所有的元组  \n\n\n[例 3. 53] 改写[例 3.49]     查询每个学生及其选修课程的情况\n\n123SELECT Student.Sno,Sname,Ssex,Sage,Sdept,Cno,GradeFROM Student LEFT OUT JOIN SC ON(Student.Sno=SC.Sno);多表连接多表连接：两个以上的表进行连接\n\n [例3.54]查询每个学生的学号、 姓名、 选修的课程名及成绩\n\n1234SELECT Student.Sno, Sname, Cname, GradeFROM Student, SC, Course /*多表连接*/WHERE Student.Sno = SC.SnoAND SC.Cno = Course.Cno;嵌套查询一个SELECT-FROM-WHERE语句称为一个查询块\n将一个查询块嵌套在另一个查询块的WHERE子句或HAVING短语的条件中的查询称为嵌套查询\n123456SELECT Sname \t/*外层查询/父查询*/FROM StudentWHERE Sno IN            ( SELECT Sno \t/*内层查询/子查询*/            \tFROM SC            \tWHERE Cno= ' 2 ');上层的查询块称为外层查询或父查询\n下层查询块称为内层查询或子查询\nSQL语言允许多层嵌套查询即一个子查询中还可以嵌套其他子查询\n\n子查询的限制不能使用ORDER BY子句  \n\n带有IN谓词的子查询\n[例 3.55] 查询与“刘晨”在同一个系学习的学生。此查询要求可以分步来完成\n\n① 确定“刘晨”所在系名\n123SELECT SdeptFROM StudentWHERE Sname= ' 刘晨 ';​    结果为： CS  \n② 查找所有在CS系学习的学生。\n123SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept= ' CS ';​    结果为：  \n将第一步查询嵌入到第二步查询的条件中\n123456SELECT Sno, Sname, SdeptFROM StudentWHERE Sdept IN            (SELECT Sdept           \t\t FROM Student           \t\t WHERE Sname= ' 刘晨 ');此查询为不相关子查询。  \n\n用自身连接完成[例 3.55]查询要求\n\n123SELECT S1.Sno, S1.Sname,S1.SdeptFROM Student S1,Student S2WHERE S1.Sdept = S2.Sdept AND S2.Sname = '刘晨';\n[例 3.56]查询选修了课程名为“信息系统”的学生学号和姓名  \n\n12345678910SELECT Sno,Sname \t\t③ 最后在Student关系中取出Sno和SnameFROM Student WHERE Sno IN(SELECT Sno \t\t\t② 然后在SC关系中找出选修了3号课程的学生学号\tFROM SC \tWHERE Cno IN    (SELECT Cno \t\t① 首先在Course关系中找出“信息系统”的课程号，为3号    \tFROM Course    \t\tWHERE Cname= '信息系统'));\n用连接查询实现[例 3.56] ：\n\n12345SELECT Sno,SnameFROM Student,SC,CourseWHERE Student.Sno = SC.Sno ANDSC.Cno = Course.Cno ANDCourse.Cname='信息系统';带有比较运算符的子查询\n在[例 3.55]中，由于一个学生只可能在一个系学习，则可以用 = 代替IN ：\n\n123456SELECT Sno,Sname,SdeptFROM StudentWHERE Sdept =(SELECT Sdept\tFROM Student\tWHERE Sname= '刘晨');\n[例 3.57 ]找出每个学生超过他选修课程平均成绩的课程号。\n\n123456SELECT Sno, Cno FROM SC xWHERE Grade &gt;=(SELECT AVG（Grade）\tFROM SC y\tWHERE y.Sno=x.Sno);带有ANY（SOME）或ALL谓词的子查询123456789101112&gt; ANY 大于子查询结果中的某个值&gt; ALL 大于子查询结果中的所有值&lt; ANY 小于子查询结果中的某个值&lt; ALL 小于子查询结果中的所有值&gt;= ANY 大于等于子查询结果中的某个值&gt;= ALL 大于等于子查询结果中的所有值&lt;= ANY 小于等于子查询结果中的某个值&lt;= ALL 小于等于子查询结果中的所有值= ANY 等于子查询结果中的某个值=ALL 等于子查询结果中的所有值（通常没有实际意义）!=（或&lt;&gt;） ANY 不等于子查询结果中的某个值!=（或&lt;&gt;） ALL 不等于子查询结果中的任何一个值\n[例 3.58] 查询非计算机科学系中比计算机科学系任意一个学生年龄小的学生姓名和年龄\n\n12345SELECT Sname,SageFROM StudentWHERE Sage &lt; ANY \t(SELECT Sage FROM Student WHERE Sdept= ' CS ')AND Sdept &lt;&gt; 'CS ' ; /*父查询块中的条件 */结果：\n执行过程：（1） 首先处理子查询，找出CS系中所有学生的年龄，构成一个集合（20,19）（2） 处理父查询，找所有不是CS系且年龄小于20 或 19的学生  \n\n用聚集函数实现[例 3.58]\n\n1234SELECT Sname,SageFROM StudentWHERE Sage &lt; (SELECT MAX（Sage）FROM Student WHERE Sdept= 'CS ')AND Sdept &lt;&gt; ' CS ';\n[例 3.59] 查询非计算机科学系中比计算机科学系所有学生年龄都小的学生姓名及年龄。\n\n方法一：用ALL谓词\n1234SELECT Sname,SageFROM StudentWHERE Sage &lt; ALL (SELECT Sage FROM Student WHERE Sdept= ' CS ')AND Sdept &lt;&gt; ' CS ’;方法二：用聚集函数\n1234SELECT Sname,SageFROM StudentWHERE Sage &lt; (SELECT MIN(Sage) FROM Student WHERE Sdept= ' CS ')AND Sdept &lt;&gt;' CS ';表3.7 ANY（或SOME）， ALL谓词与聚集函数、 IN谓词的等价转换关系\n\n=&lt;&gt;或!=&lt;&lt;=&gt;&gt;=\n\nANYIN–&lt;MAX&lt;=MAX&gt;MIN&gt;= MIN\n\nALL–NOT IN&lt;MIN&lt;= MIN&gt;MAX&gt;= MAX\n带有EXISTS谓词的子查询EXISTS谓词  \n存在量词\n带有EXISTS谓词的子查询不返回任何数据，只产生逻辑真值“true”或逻辑假值“false”。若内层查询结果非空，则外层的WHERE子句返回真值\n若内层查询结果为空，则外层的WHERE子句返回假值\n\n由EXISTS引出的子查询，其目标列表达式通常都用 * ，因为带EXISTS的子查询只返回真值或假值，给出列名无实际意义  \nNOT EXISTS谓词\n若内层查询结果非空，则外层的WHERE子句返回假值\n若内层查询结果为空，则外层的WHERE子句返回真值  \n\n[例 3.60] 查询所有选修了1号课程的学生姓名。\n\n思路分析：\n本查询涉及Student和SC关系\n在Student中依次取每个元组的Sno值，用此值去检查SC表\n若SC中存在这样的元组，其Sno值等于此Student.Sno值，并且其Cno= ‘1’，则取此Student.Sname送入结果表\n1234SELECT SnameFROM StudentWHERE EXISTS(SELECT * FROM SC WHERE Sno=Student.Sno AND Cno= ' 1 ');第四章  数据库安全性TCSEC/TDI安全级别划分\n安 全 级 别定 义\n\nA1验证设计（Verified Design）\n\nB3安全域（Security Domains）\n\nB2结构化保护（Structural Protection）\n\nB1标记安全保护（Labeled Security Protection）\n\nC2受控的存取保护（Controlled Access Protection）Windows 2000Oracle 7\n\nC1自主安全保护（Discretionary Security Protection现有的商业系统稍作改进即可满足\n\nD最小保护（Minimal Protection）将一切不符合更高标准的系统均归于D组典型例子： DOS是安全标准为D的操作系统DOS在安全性方面几乎没有什么专门的机制来保障\n按系统可靠或可信程度逐渐增高\n各安全级别之间具有一种偏序向下兼容的关系，即较高安全性级别提供的安全保护要包含较低级别的所有保护要求，同时提供更多或更完善的保护能力  \n系统根据用户标识鉴定用户身份，合法用户才准许进入计算机系统\n数据库管理系统还要进行存取控制，只允许用户执行合法操作\n操作系统有自己的保护措施\n数据以密码形式存储到数据库中 \n自主存取控制方法通过 SQL 的GRANT 语句和REVOKE 语句实现\n用户权限组成数据对象\n操作类型\n\n定义用户存取权限：定义用户可以在哪些数据库对象上进行哪些类型的操作\n定义存取权限称为授权  \nGRANTGRANT语句的一般格式：\n1234GRANT &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt; &lt;对象名&gt;]…TO &lt;用户&gt;[,&lt;用户&gt;]...[WITH GRANT OPTION];语义：将对指定操作对象的指定操作权限授予指定的用户  \n发出GRANT：\n数据库管理员\n\n数据库对象创建者（即属主Owner）\n\n拥有该权限的用户\n\n按受权限的用户\n一个或多个具体用户\nPUBLIC（即全体用户）  \nWITH GRANT OPTION子句:\n指定：可以再授予\n没有指定： 不能传播\n不允许循环授权  \n\n[例4.1] 把查询Student表权限授给用户U1\n\n123GRANT SELECTON TABLE StudentTO U1;\n[例4.2] 把对Student表和Course表的全部权限授予用户U2和U3\n\n123GRANT ALL PRIVILIGESON TABLE Student,CourseTO U2,U3;\n[例4.3] 把对表SC的查询权限授予所有用户\n\n123GRANT SELECTON TABLE SCTO PUBLIC;\n[例4.4] 把查询Student表和修改学生学号的权限授给用户U4\n\n123GRANT UPDATE(Sno), SELECTON TABLE StudentTO U4;对属性列的授权时必须明确指出相应属性列名  \n\n[例4.5] 把对表SC的INSERT权限授予U5用户，并允许他再将此权限授予其他用户\n\n1234GRANT INSERTON TABLE SCTO U5WITH GRANT OPTION;执行例4.5后， U5不仅拥有了对表SC的INSERT权限，还可以传播此权限：\n\n[例4.6] \n\n1234GRANT INSERTON TABLE SCTO U6WITH GRANT OPTION;同样， U6还可以将此权限授予U7：\n\n[例4.7] \n\n123GRANT INSERTON TABLE SCTO U7;但U7不能再传播此权限。  \nREVOKE授予的权限可以由数据库管理员或其他授权者用REVOKE语句收回\n\nREVOKE语句的一般格式为：\n123REVOKE &lt;权限&gt;[,&lt;权限&gt;]...ON &lt;对象类型&gt; &lt;对象名&gt;[,&lt;对象类型&gt;&lt;对象名&gt;]…FROM &lt;用户&gt;[,&lt;用户&gt;]...[CASCADE | RESTRICT];\n\n[例4.8] 把用户U4修改学生学号的权限收回\n\n123REVOKE UPDATE(Sno)ON TABLE StudentFROM U4;\n[例4.9] 收回所有用户对表SC的查询权限\n\n123REVOKE SELECTON TABLE SCFROM PUBLIC;\n[例4.10] 把用户U5对SC表的INSERT权限收回\n\n123REVOKE INSERTON TABLE SCFROM U5 CASCADE ;将用户U5的INSERT权限收回的时候应该使用CASCADE，否则拒绝执行该语句\n\n如果U6或U7还从其他用户处获得对SC表的INSERT权限，则他们仍具有此权限，系统只收回直接或间接从U5处获得的权限  \n\n创建数据库模式的权限数据库管理员在创建用户时实现\n123CREATE USER语句格式CREATE USER &lt;username&gt;[WITH][DBA|RESOURCE|CONNECT];注：CREATE USER不是SQL标准，各个系统的实现相差甚远  \nCREATE USER语句格式说明\n只有系统的超级用户才有权创建一个新的数据库用户\n新创建的数据库用户有三种权限： CONNECT、RESOURCE和DBA\n如没有指定创建的新用户的权限，默认该用户拥有CONNECT权限。拥有CONNECT权限的用户不能创建新用户，不能创建模式，也不能创建基本表，只能登录数据库  \nCREATE USER语句格式说明（续）\n拥有RESOURCE权限的用户能创建基本表和视图，成为所创建对象的属主。但不能创建模式，不能创建新的用户\n拥有DBA权限的用户是系统中的超级用户，可以创建新的用户、创建模式、创建基本表和视图等； DBA拥有对所有数据库对象的存取权限，还可以把这些权限授予一般用户  \n\n可否执行的操作\n\n拥有的权限CREATE USERCREATE SCHEMACREATE TABLE登录数据库，执行数据查询和操纵\n\nDBA可以可以可以可以\n\nRESOURCE不可以不可以不可以不可以\n\nCONNECT不可以不可以不可以可以，但必须拥有相应权限\n角色的创建\n1CREATE ROLE &lt;角色名&gt;给角色授权\n123GRANT &lt;权限&gt;[,&lt;权限&gt;]…ON &lt;对象类型&gt;对象名TO &lt;角色&gt;[,&lt;角色&gt;]…将一个角色授予其他的角色或用户\n123GRANT &lt;角色1&gt;[,&lt;角色2&gt;]…TO &lt;角色3&gt;[,&lt;用户1&gt;]…[WITH ADMIN OPTION]该语句把角色授予某用户，或授予另一个角色\n授予者是角色的创建者或拥有在这个角色上的ADMIN OPTION\n指定了WITH ADMIN OPTION则获得某种权限的角色或用户还可以把这种权限授予其他角色\n一个角色的权限：直接授予这个角色的全部权限加上其他角色授予这个角色的全部权限  \n角色权限的收回\n123REVOKE &lt;权限&gt;[,&lt;权限&gt;]…ON &lt;对象类型&gt; &lt;对象名&gt;FROM &lt;角色&gt;[,&lt;角色&gt;]…用户可以回收角色的权限，从而修改角色拥有的权限\nREVOKE执行者是角色的创建者\n拥有在这个（些）角色上的ADMIN OPTION  \n\n\n[例4.11] 通过角色来实现将一组权限授予一个用户。步骤如下：\n\n（1）首先创建一个角色 R1\n1CREATE ROLE R1;（2）然后使用GRANT语句，使角色R1拥有Student表的\n1234SELECT、 UPDATE、 INSERT权限GRANT SELECT, UPDATE, INSERTON TABLE StudentTO R1;3）将这个角色授予王平，张明，赵玲。使他们具有角色R1所包含的全部权限\n12GRANT R1TO 王平,张明,赵玲;（4） 可以一次性通过R1来回收王平的这3个权限\n12REVOKE R1FROM 王平;\n[例4.12] 角色的权限修改 使角色R1在原来的基础上增加了Student表的DELETE 权限  \n\n123GRANT DELETEON TABLE StudentTO R1;\n[例4.13] 使R1减少了SELECT权限  \n\n123REVOKE SELECTON TABLE StudentFROM R1；强制存取控制方法敏感度标记（Label）\n对于主体和客体， DBMS为它们每个实例（值）指派一个敏感度标记（Label）\n敏感度标记分成若干级别绝密（Top Secret， TS）\n机密（Secret， S）\n可信（Confidential， C）\n公开（Public， P）\nTS&gt;=S&gt;=C&gt;=P\n\n主体的敏感度标记称为许可证级别（Clearance Level）\n客体的敏感度标记称为密级（Classification Level）  \n\n[例4.14] 建立计算机系学生的视图，把对该视图的SELECT权限授于王平，把该视图上的所有操作权限授于张明\n\n先建立计算机系学生的视图CS_Student\n12345CREATE VIEW CS_StudentASSELECT *FROM StudentWHERE Sdept='CS';在视图上进一步定义存取权限\n123456GRANT SELECTON CS_StudentTO 王平;GRANT ALL PRIVILIGESON CS_StudentTO 张明;审计审计功能\n基本功能提供多种审计查阅方式提供多种审计查阅方式\n多套审计规则：一般在初始化设定\n提供审计分析和报表功能\n\n审计日志管理功能防止审计员误删审计记录，审计日志必须先转储后删除\n对转储的审计记录文件提供完整性和保密性保护\n只允许审计员查阅和转储审计记录， 不允许任何用户新增和修改审计记录等\n\n提供查询审计设置及审计记录信息的专门视图  \nAUDIT语句和NOAUDIT语句\nAUDIT语句：设置审计功能\nNOAUDIT语句：取消审计功能  \n\n[例4.15] 对修改SC表结构或修改SC表数据的操作进行审计\n\n12AUDIT ALTER,UPDATEON SC;\n[例4.16] 取消对SC表的一切审计\n\n12NOAUDIT ALTER,UPDATEON SC;数据加密数据加密\n防止数据库中数据在存储和传输中失密的有效手段\n加密的基本思想\n根据一定的算法将原始数据—明文（Plain text）变换为不可直接识别的格式-—密文（Cipher text）\n加密方法\n存储加密\n传输加密  \n存储加密\n透明存储加密\n内核级加密保护方式，对用户完全透明\n将数据在写到磁盘时对数据进行加密， 授权用户读取数据时再对其进行解密\n数据库的应用程序不需要做任何修改，只需在创建表语句中说明需加密的字段即可\n内核级加密方法: 性能较好，安全完备性较高\n\n非透明存储加密\n通过多个加密函数实现  \n\n传输加密\n链路加密在链路层进行加密\n传输信息由报头和报文两部分组成\n报文和报头均加密\n\n端到端加密在发送端加密，接收端解密\n只加密报文不加密报头\n所需密码设备数量相对较少， 容易被非法监听者发现并从中获取敏感信息  \n\n第五章 数据库完整性提供完整性检查的方法\n数据库管理系统中检查数据是否满足完整性约束条件的机制称为完整性检查。\n一般在INSERT、 UPDATE、 DELETE语句执行后开始检查，也可以在事务提交时检查  \n实体完整性关系模型的实体完整性\nCREATE TABLE中用PRIMARY KEY定义\n单属性构成的码有两种说明方法\n定义为列级约束条件\n定义为表级约束条件\n对多个属性构成的码只有一种说明方法\n定义为表级约束条件  \n\n[例5.1] 将Student表中的Sno属性定义为码\n\n（1） 在列级定义主码\n1234567CREATE TABLE Student( Sno CHAR(9) PRIMARY KEY,Sname CHAR(20) NOT NULL,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20));（2） 在表级定义主码\n12345678CREATE TABLE Student( Sno CHAR(9),Sname CHAR(20) NOT NULL,Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20),PRIMARY KEY (Sno));\n[例5.2] 将SC表中的Sno， Cno属性组定义为码\n\n123456CREATE TABLE SC( Sno CHAR(9) NOT NULL,Cno CHAR(4) NOT NULL,Grade SMALLINT,PRIMARY KEY (Sno,Cno) /*只能在表级定义主码*/);参照完整性关系模型的参照完整性定义\n在CREATE TABLE中用FOREIGN KEY短语定义哪些列为外码\n用REFERENCES短语指明这些外码参照哪些表的主码  \n例如，关系SC中（Sno， Cno）是主码。 Sno， Cno分别参照Student表的主码和Course表的主码\n\n[例5.3]定义SC中的参照完整性\n\n12345678910CREATE TABLE SC( Sno CHAR(9) NOT NULL,Cno CHAR(4) NOT NULL,Grade SMALLINT,PRIMARY KEY (Sno, Cno), /*在表级定义实体完整性*/FOREIGN KEY (Sno) REFERENCES Student(Sno),/*在表级定义参照完整性*/FOREIGN KEY (Cno) REFERENCES Course(Cno)/*在表级定义参照完整性*/);例如，对表SC和Student有四种可能破坏参照完整性的情况 :\nSC表中增加一个元组，该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n修改SC表中的一个元组，修改后该元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n从Student表中删除一个元组，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等。\n\n修改Student表中一个元组的Sno属性，造成SC表中某些元组的Sno属性的值在表Student中找不到一个元组，其Sno属性的值与之相等 。  \n\n参照完整性违约处理\n（1） 拒绝（NO ACTION） 执行\n不允许该操作执行。该策略一般设置为默认策略\n（2） 级联（CASCADE） 操作\n当删除或修改被参照表（Student） 的一个元组造成了与参照表（SC） 的不一致，则删除或修改参照表中的所有造成不一致的元组\n（3）设置为空值（SET-NULL）\n当删除或修改被参照表的一个元组时造成了不一致，则将参照表中的所有造成不一致的元组的对应属性设置为空值  \n\n例如，有下面2个关系\n\n学生（学号，姓名，性别，专业号，年龄）专业（专业号，专业名）\n假设专业表中某个元组被删除，专业号为12\n按照设置为空值的策略，就要把学生表中专业号=12的所有元组的专业号设置为空值\n对应语义：某个专业删除了，该专业的所有学生专业未定，等待重新分配专业  \n\n[例5.4] 显式说明参照完整性的违约处理示例\n\n123456789101112CREATE TABLE SC( Sno CHAR(9) NOT NULL，Cno CHAR(4) NOT NULL，Grade SMALLINT,PRIMARY KEY(Sno,Cno)，FOREIGN KEY (Sno) REFERENCES Student(Sno)ON DELETE CASCADE /*级联删除SC表中相应的元组*/ON UPDATE CASCADE, /*级联更新SC表中相应的元组*/FOREIGN KEY (Cno) REFERENCES Course(Cno)ON DELETE NO ACTION /*当删除course 表中的元组造成了与SC表不一致时拒绝删除*/ON UPDATE CASCADE /*当更新course表中的cno时，级联更新SC表中相应的元组*/);属性上的约束CREATE TABLE时定义属性上的约束条件\n列值非空（NOT NULL）\n列值唯一（UNIQUE）\n检查列值是否满足一个条件表达式（CHECK）  \n不允许取空值\n\n[例5.5] 在定义SC表时，说明Sno、 Cno、 Grade属性不允许取空值。\n\n12345678CREATE TABLE SC( Sno CHAR(9) NOT NULL,Cno CHAR(4) NOT NULL,Grade SMALLINT NOT NULL,PRIMARY KEY (Sno, Cno),…/* 如果在表级定义实体完整性，隐含了Sno， Cno不允许取空值，则在列级不允许取空值的定义 可以不写 * /);列值唯一\n\n[例5.6]建立部门表DEPT，要求部门名称Dname列取值唯一，部门编号Deptno列为主码\n\n123456CREATE TABLE DEPT( Deptno NUMERIC(2),Dname CHAR(9) UNIQUE NOT NULL，/*要求Dname列值唯一, 并且不能取空值*/Location CHAR(10),PRIMARY KEY (Deptno));用CHECK短语指定列值应该满足的条件\n\n[例5.7] Student表的Ssex只允许取“男”或“女”。\n\n1234567CREATE TABLE Student( Sno CHAR(9) PRIMARY KEY,Sname CHAR(8) NOT NULL,Ssex CHAR(2) CHECK （Ssex IN （‘男’,’女’）） ，/*性别属性Ssex只允许取'男'或'女' */Sage SMALLINT,Sdept CHAR(20));\n[例5.8] SC表的Grade的值应该在0和100之间。\n\n12345678CREATE TABLE SC( Sno CHAR(9) ,Cno CHAR(4),Grade SMALLINT CHECK (Grade&gt;=0 AND Grade &lt;=100)，/*Grade取值范围是0到100*/PRIMARY KEY (Sno,Cno),FOREIGN KEY (Sno) REFERENCES Student(Sno),FOREIGN KEY (Cno) REFERENCES Course(Cno));在CREATE TABLE时可以用CHECK短语定义元组上的约束条件，即元组级的限制\n同属性值限制相比，元组级的限制可以设置不同属性之间的取值的相互约束条件  \n\n[例5.9]当学生的性别是男时，其名字不能以Ms.打头。\n\n12345678910CREATE TABLE Student( Sno CHAR(9),Sname CHAR(8) NOT NULL，Ssex CHAR(2),Sage SMALLINT,Sdept CHAR(20),PRIMARY KEY (Sno),CHECK (Ssex='女' OR Sname NOT LIKE 'Ms.%')/*定义了元组中Sname和 Ssex两个属性值之间的约束条件*/);性别是女性的元组都能通过该项检查，因为Ssex=‘女’成立;\n当性别是男性时，要通过检查则名字一定不能以Ms.打头  \n完整性约束命名子句1CONSTRAINT &lt;完整性约束条件名&gt;&lt;完整性约束条件&gt;&lt;完整性约束条件&gt;包括NOT NULL、 UNIQUE、PRIMARY KEY短语、 FOREIGN KEY短语、 CHECK短语等  \n\n[例5.10]建立学生登记表Student，要求学号在90000~99999之间，姓名不能取空值，年龄小于30，性别只能是“男”或“女”。\n\n1234567891011CREATE TABLE Student( Sno NUMERIC(6)CONSTRAINT C1 CHECK (Sno BETWEEN 90000 AND 99999),Sname CHAR(20)CONSTRAINT C2 NOT NULL,Sage NUMERIC(3)CONSTRAINT C3 CHECK (Sage &lt; 30),Ssex CHAR(2)CONSTRAINT C4 CHECK (Ssex IN ( ‘男’,'女')),CONSTRAINT StudentKey PRIMARY KEY(Sno));在Student表上建立了5个约束条件，包括主码约束（命名为StudentKey）以及C1、 C2、 C3、 C4四个列级约束。  \n\n[例5.11]建立教师表TEACHER，要求每个教师的应发工资不低于3000元。\n\n应发工资是工资列Sal与扣除项Deduct之和。\n12345678910CREATE TABLE TEACHER( Eno NUMERIC(4) PRIMARY KEY /*在列级定义主码*/Ename CHAR(10),Job CHAR(8),Sal NUMERIC(7,2),Deduct NUMERIC(7,2),Deptno NUMERIC(2),CONSTRAINT TEACHERFKey FOREIGN KEY (Deptno) REFERENCES DEPT(Deptno),CONSTRAINT C1 CHECK (Sal + Deduct &gt;= 3000));修改表中的完整性限制\n使用ALTER TABLE语句修改表中的完整性限制\n\n[例5.12]去掉例5.10 Student表中对性别的限制。\n\n1ALTER TABLE Student DROP CONSTRAINT C4;\n[例5.13] 修改表Student中的约束条件，要求学号改为在900000~999999之间，年龄由小于30改为小于40\n\n可以先删除原来的约束条件，再增加新的约束条件\n1234ALTER TABLE Student DROP CONSTRAINT C1;ALTER TABLE Student ADD CONSTRAINT C1 CHECK (Sno BETWEEN 900000 AND 999999),ALTER TABLE Student DROP CONSTRAINT C3;ALTER TABLE Student ADD CONSTRAINT C3 CHECK(Sage &lt; 40);断言SQL中，可以使用 CREATE ASSERTION语句，通过声明性断言来指定更具一般性的约束。\n\n可以定义涉及多个表的或聚集操作的比较复杂的完整性约束。\n\n断言创建以后，任何对断言中所涉及的关系的操作都会触发关系数据库管理系统对断言的检查，任何使断言不为真值的操作都会被拒绝执行  \n\n创建断言的语句格式\nCREATE ASSERTION&lt;断言名&gt;&lt;CHECK 子句&gt;\n&lt;!--￼138--&gt;\n\n\n\n[例5.19]限制每一门课程最多60名学生选修\n\n123456CREATE ASSERTION ASSE_SC_CNUM1CHECK(60 &gt;= ALL (SELECT count(*)FROM SCGROUP by cno));/*此断言的谓词，涉及聚集操作count 和分组函数group by的SQL语句*/\n[例5.20] 限制每个学期每一门课程最多60名学生选修\n\n首先需要修改SC表的模式，增加一个“学期（TERM）”属性\n1ALTER TABLE SC ADD TERM DATE;然后，定义断言：\n123CREATE ASSERTION ASSE_SC_CNUM2CHECK(60 &gt;= ALL (SELECT count(*) FROM SC GROUP by cno,TERM));删除断言的语句格式为\n1DROP ASSERTION &lt;断言名&gt;;如果断言很复杂，则系统在检测和维护断言的开销较高，这是在使用断言时应该注意的  \n触发器触发器（Trigger）是用户定义在关系表上的一类由事件驱动的特殊过程\n触发器保存在数据库服务器中\n任何用户对表的增、删、改操作均由服务器自动激活相应的触发器\n触发器可以实施更为复杂的检查和操作，具有更精细和更强大的数据控制能力  \n定义触发器CREATE TRIGGER语法格式\n12345CREATE TRIGGER &lt;触发器名&gt;&#123;BEFORE | AFTER&#125; &lt;触发事件&gt; ON &lt;表名&gt;REFERENCING NEW|OLD ROW AS&lt;变量&gt; /*引用 old表示插入之前的值，new表示新插入的值；*/FOR EACH &#123;ROW | STATEMENT&#125;  /*行 语句*/[WHEN &lt;触发条件&gt;]&lt;触发动作体&gt;触发器又叫做事件-条件-动作（event-condition-action）规则。当特定的系统事件发生时，对规则的条件进行检查，如果条件成立则执行规则中的动作，否则不执行该动作。规则中的动作体可以很复杂，通常是一段SQL存储过程  \n定义触发器的语法说明\n（1）表的拥有者才可以在表上创建触发器\n（2）触发器名\n触发器名可以包含模式名，也可以不包含模式名\n同一模式下，触发器名必须是唯一的\n触发器名和表名必须在同一模式下\n（3）表名\n触发器只能定义在基本表上，不能定义在视图上\n当基本表的数据发生变化时，将激活定义在该表上相应触发事件的触发器  \n（4）触发事件\n触发事件可以是INSERT、 DELETE或UPDATE也可以是这几个事件的组合\n还可以UPDATE OF&lt;触发列， ...&gt;，即进一步指明修改哪些列时激活触发器\nAFTER/BEFORE是触发的时机\nAFTER表示在触发事件的操作执行之后激活触发器\nBEFORE表示在触发事件的操作执行之前激活触发器  \n(5）触发器类型\n行级触发器（FOR EACH ROW）\n语句级触发器（FOR EACH STATEMENT）\n\n例如,在例5.11的TEACHER表上创建一个AFTER UPDATE触发器，触发事件是UPDATE语句：\n\n1UPDATE TEACHER SET Deptno=5;假设表TEACHER有1000行\n如果是语句级触发器，那么执行完该语句后，触发动作只发生一次\n如果是行级触发器，触发动作将执行1000次  \n（6）触发条件\n触发器被激活时，只有当触发条件为真时触发动作体才执行;  否则触发动作体不执行。\n如果省略WHEN触发条件，则触发动作体在触发器激活后立即执行  \n(7）触发动作体\n触发动作体可以是一个匿名PL/SQL过程块也可以是对已创建存储过程的调用\n如果是行级触发器，用户都可以在过程体中使用NEW和OLD引用事件之后的新值和事件之前的旧值\n如果是语句级触发器，则不能在触发动作体中使用NEW或OLD进行引用\n如果触发动作体执行失败，激活触发器的事件就会终止执行，触发器的目标表或触发器可能影响的其他对象不发生任何变化\n注意：不同的RDBMS产品触发器语法各部相同  \n\n[例5.21]当对表SC的Grade属性进行修改时，若分数增加了10%则将此次操作记录到下面表中：\n\n1SC_U（Sno,Cno,Oldgrade,Newgrade）其中Oldgrade是修改前的分数， Newgrade是修改后的分数。\n12345678910CREATE TRIGGER SC_TAFTER UPDATE OF Grade ON SCREFERENCINGOLD row AS OldTuple,NEW row AS NewTupleFOR EACH ROWWHEN (NewTuple.Grade &gt;= 1.1*OldTuple.Grade)INSERT INTO SC_U(Sno,Cno,OldGrade,NewGrade)VALUES(OldTuple.Sno,OldTuple.Cno,OldTuple.Grade,NewTuple.Grade)\n[例5.22] 将每次对表Student的插入操作所增加的学生个数记录到表StudentInsertLog中。\n\n123456789CREATE TRIGGER Student_CountAFTER INSERT ON Student/*指明触发器激活的时间是在执行INSERT后*/REFERENCINGNEW TABLE AS DELTAFOR EACH STATEMENT/*语句级触发器, 即执行完INSERT语句后下面的触发动作体才执行一次*/INSERT INTO StudentInsertLog (Numbers)SELECT COUNT(*) FROM DELTA\n[例5.23] 定义一个BEFORE行级触发器，为教师表Teacher定义完整性规则“教授的工资不得低于4000元，如果低于4000元，自动改为4000元”。\n\n12345678CREATE TRIGGER Insert_Or_Update_SalBEFORE INSERT OR UPDATE ON Teacher\t/*触发事件是插入或更新操作*/FOR EACH ROW \t/*行级触发器*/BEGIN \t\t\t/*定义触发动作体，是PL/SQL过程块*/    IF (new.Job='教授') AND (new.Sal &lt; 4000)    THEN new.Sal :=4000;    END IF;END;激活触发器触发器的执行，是由触发事件激活的，并由数据库服务器自动执行\n\n一个数据表上可能定义了多个触发器，遵循如下的执行顺序:\n\n（1） 执行该表上的BEFORE触发器;\n（2） 激活触发器的SQL语句;\n（3） 执行该表上的AFTER触发器。  \n删除触发器删除触发器的SQL语法：\n1DROP TRIGGER &lt;触发器名&gt; ON &lt;表名&gt;;触发器必须是一个已经创建的触发器，并且只能由具有相应权限的用户删除  \n第六章 关系数据理论问题的提出关系模式由五部分组成，是一个五元组：\nR(U, D, DOM, F)        R&lt;U,F&gt;\n关系名R是符号化的元组语义\nU为一组属性\nD为属性组U中的属性所来自的域\nDOM为属性到域的映射\nF为属性组U上的一组数据依赖  \n描述一个学生关系，可以有学号、姓名、系名等属性。\n一个学号只对应一个学生，一个学生只在一个系中学习\n“学号” 值确定后，学生的姓名及所在系的值就被唯一确定。\nSname=f(Sno)， Sdept=f(Sno)\n即Sno函数决定Sname\nSno函数决定Sdept\n记作Sno→Sname， Sno→Sdept  \n\n [例6.1] 建立一个描述学校教务的数据库。涉及的对象包括：\n\n学生的学号（Sno）\n所在系（Sdept）\n系主任姓名（Mname）\n课程号（Cno）\n成绩（Grade）  \n假设学校教务的数据库模式用一个单一的关系模式Student来表示，则该关系模式的属性集合为：U ＝{Sno, Sdept, Mname, Cno, Grade}  \n现实世界的已知事实（语义）：\n一个系有若干学生， 但一个学生只属于一个系；\n一个系只有一名（正职）负责人；\n一个学生可以选修多门课程，每门课程有若干学生选修；\n每个学生学习每一门课程有一个成绩。  \n由此可得到属性组U上的一组函数依赖F：F={Sno→Sdept, Sdept→ Mname, (Sno, Cno)→ Grade}  \n关系模式Student&lt;U, F&gt;中存在的问题：\n（1）数据冗余\n浪费大量的存储空间\n每一个系主任的姓名重复出现，重复次数与该系所有学生的所有课程成绩出现次数相同  \n(2）更新异常（Update Anomalies）\n数据冗余 ， 更新数据时，维护数据完整性代价大。\n某系更换系主任后，必须修改与该系学生有关的每一个元组。  \n(3）插入异常（Insertion Anomalies）\n如果一个系刚成立，尚无学生，则无法把这个系及其系主任的信息存入数据库。  \n(4）删除异常（Deletion Anomalies）\n如果某个系的学生全部毕业了， 则在删除该系学生信息的同时，把这个系及其系主任的信息也丢掉了。  \n结论\nStudent关系模式不是一个好的模式。\n\n一个“好” 的模式应当不会发生插入异常、删除异常和更新异常，数据冗余应尽可能少。\n\n原因\n由存在于模式中的某些数据依赖引起的。\n解决方法\n用规范化理论改造关系模式来消除其中不合适的数据依赖  \n把这个单一的模式分成三个关系模式：\nS(Sno,Sdept,Sno → Sdept);\n\nSC(Sno,Cno,Grade,(Sno,Cno) → Grade);\n\nDEPT(Sdept,Mname,Sdept → Mname);\n\n这三个模式都不会发生插入异常、删除异常的问题，数据的冗余也得到了控制  \n\n规范化函数依赖设R(U)是一个属性集U上的关系模式， X和Y是U的子集。若对于R(U)的任意一个可能的关系r， r 中不可能存在两个元组在X上的属性值相等， 而在Y上的属性值不等， 则称“X函数确定Y”或“Y函数依赖于X”，记作X→Y\n\n[例] Student(Sno, Sname, Ssex, Sage, Sdept),假设不允许重名，则有:\n\n1234Sno → Ssex， Sno → SageSno → Sdept， Sno ←→ SnameSname → Ssex， Sname → SageSname → Sdept若X→Y，并且Y→X, 则记为X←→Y。若Y不函数依赖于X, 则记为X→Y。  \n平凡函数依赖与非平凡函数依赖  \n对于任一关系模式，平凡函数依赖都是必然成立的，它不反映新的语义。\n\n若不特别声明， 我们总是讨论非平凡函数依赖  \n\n若X→Y，则X称为这个函数依赖的决定因素（Determinant）。\n\n若X→Y， Y→X，则记作X←→Y。\n\n若Y不函数依赖于X，则记作X ↛  Y。  \n\n完全函数依赖  与  部分函数依赖  \n定义6.2 \n在R(U)中，如果X→Y，并且对于X的任何一个真子集X’, 都有 X’ ↛ Y, 则称Y对X完全函数依赖，记作。\n\n若X→Y，但Y不完全函数依赖于X，则称Y对X部分函数依赖，记作\n\n传递函数依赖  \n码主属性与非主属性\n包含在任何一个候选码中的属性 ，称为主属性（Prime attribute）\n不包含在任何码中的属性称为非主属性（Nonprimeattribute）或非码属性（Non-key attribute）\n全码：整个属性组是码，称为全码（All-key）  \n\n[例6.2]\n\nS(Sno, Sdept, Sage)，单个属性Sno是码\nSC(Sno, Cno, Grade)中， (Sno, Cno)是码\n\n[例6.3] \n\nR(P,W,A)P：演奏者     W：作品     A：听众\n一个演奏者可以演奏多个作品\n某一作品可被多个演奏者演奏\n听众可以欣赏不同演奏者的不同作品\n码为(P,W,A)，即All-Key  \n定义6.5 \n关系模式 R中属性或属性组X 并非 R的码，但 X 是另一个关系模式的码，则称 X 是R 的外部码（Foreign key）也称外码。\nSC(Sno,Cno,Grade)中， Sno不是码\nSno是 S(Sno,Sdept,Sage)的码，则Sno是SC的外码\n主码与外部码一起提供了表示关系间联系的手段\n范式范式是符合某一种级别的关系模式的集合。\n关系数据库中的关系必须满足一定的要求。满足不同程度要求的为不同范式。\n范式的种类：\n第一范式(1NF)\n第二范式(2NF)\n第三范式(3NF)\nBC范式(BCNF)\n第四范式(4NF)\n第五范式(5NF)  \n各种范式之间存在联系：\n 某一关系模式R为第n范式，可简记为R∈ nNF。\n一个低一级范式的关系模式，通过模式分解（schemadecomposition）可以转换为若干个高一级范式的\n关系模式的集合，这种过程就叫规范化                              \n2NF定义6.6 \n若关系模式R∈ 1NF，并且每一个非主属性都完全函数依赖于任何一个候选码，则R∈ 2NF\n\n[例6.4] \n\nS-L-C(Sno,Sdept,Sloc,Cno,Grade)，Sloc为学生的住处，并且每个系的学生住在同一个地方。 S-L-C的码为(Sno,Cno)。\n函数依赖有  \n                                \n非主属性Sdept、 Sloc并不完全依赖于码  \n关系模式S-L-C不属于2NF  \n一个关系模式不属于2NF，会产生以下问题：\n插入异常\n如果插入一个新学生，但该生未选课，即该生无Cno，由于插入元组时，必须给定码值，因此插入失败。\n\n删除异常\n如果S4只选了一门课C3，现在他不再选这门课，则删除C3后，整个元组的其他信息也被删除了。\n\n修改复杂\n如果一个学生选了多门课，则Sdept， Sloc被存储了多次。如果该生转系，则需要修改所有相关的Sdept和Sloc，造成修改的复杂化\n\n出现这种问题的原因\n例子中有两类非主属性：\n一类如Grade，它对码完全函数依赖\n另一类如Sdept、 Sloc，它们对码不是完全函数依赖\n解决方法：\n用投影分解把关系模式S-L-C分解成两个关系模式\nSC(Sno,Cno,Grade)                                    \nS-L(Sno,Sdept,Sloc)  \n3NF","plink":"https://dxsummer.gitee.io/posts/ab4279d1/"},{"title":"SQL Sever安装教程","date":"2021-04-02T02:46:56.000Z","date_formatted":{"ll":"2021年4月2日","L":"2021/04/02","MM-DD":"04-02"},"updated":"2021-04-02T02:56:12.000Z","content":"SQL Server 是Microsoft 公司推出的关系型数据库管理系统。网络上可以找到微软官方下载的两个页面，一个是中文内容，一个是英文内容\n\n第一阶段：安装SQL Server向导以下以中文版为例：中文版官网：https://www.microsoft.com/zh-cn/sql-server/sql-server-downloads打开链接，进入下载页面，莫着急，注意查看是免费试用版(180天免费)，还是免费版：\n\n将网页下滑，可以看到“还可以下载免费的专用版本”字样，点击下方“Developer”版本的“立即下载”按钮进行下载\n\n备注：以上操作是基于Windows系统，若是其他系统可在页面下方自选对应的系统版本\n\n下载完成后双击SQLServer2017-SSEI-Expr.exe程序进行安装，在“选择安装类型”选择中“基本(B)”比较简单，但不推荐（有点计算机知识的都懂安装软件时默认安装一般都会将软件安装在系统盘(常说的C盘)，平时运行电脑会拖慢电脑运行速度，故一般采用自定义安装），这里也一样，选择“自定义©”安装\n更改安装路径，然后安装：\n等待安装完成：到此算是完成了第一阶段的安装，此刻推荐打开管理策略查询一下安装效果：快捷键：Win+R打开命令行，输入services.msc\n打开管理策略，下拉查找SQL Server是否已安装，若已安装，直接跳过第二阶段开始第三阶段的安装，否则继续第二阶段的安装\n第二阶段：安装SQL Server打开上述安装好的文件位置，找到SETUP.EXE程序并双击运行出现SQL Server安装中心向导，点击“全新SQL Server独立安装或向现有安装添加功能”安装SQL Server\n接下来的安装过程时间有点长，依此要安装下图左边栏目的内容，基本上都按默认，直接点击下一步即可，但有些要注意一下小细节：“许可条款”要先勾选“我接受许可条款”才能继续下一步“功能选择”处更改一下文件存储目录即可：\n“数据库引擎设置”处一般有默认指定SQL Server管理员为当前用户，若没有，则点击“添加当前用户”，接着就是一直的下一步下一步等待他安装好\n第三阶段：安装SQL Server管理工具细心的你可能发现了，在第一阶段安装的向导里可以找到SQL Server管理工具，第二阶段的图中也有标记出来，SQL Server安装中心向导，点击“全安装SQL Server管理工具”跳转下载网页，即下方给的网址：\nSQL Server管理工具网址： https://docs.microsoft.com/zh-cn/sql/ssms/download-sql-server-management-studio-ssms?redirectedfrom=MSDN&amp;view=sql-server-ver15进入网站，下载SSMS（SSMS即SQL Server Management Studio 是用于管理SQL Server基础架构的集成环境）：\n双击运行下载好的SSMS-Setup-CHS.exe程序，更改安装路径，然后点击安装按钮：\n安装好后会提示要求重启电脑：\n至此，全部安装已完成，以下查看基本运行进行验证\n运行SSM重启后即可搜索sql找到管理工具SSM(Microsoft SQL Server Management Studio 18)：运行SSM并点击下图的连接(信息默认即可)，若能成功连接即可：\n成功连接后的操作界面：若点击连接后无法连接，出现如下报错，则检查一下SQL Services 是否启动（若按照上述流程来操作是默认开机自动启动的）\n\n","plink":"https://dxsummer.gitee.io/posts/d6a1283f/"},{"title":"python主要函数","date":"2021-03-31T12:35:52.000Z","date_formatted":{"ll":"2021年3月31日","L":"2021/03/31","MM-DD":"03-31"},"updated":"2021-06-02T01:07:30.000Z","content":"字符函数新旧字符替换replace()12345&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a.replace('a', 'A')\t//把字符串中的 old（旧字符串） 替换成new(新字符串)'Abc'&gt;&gt;&gt; a'abc'虽然字符串有个replace()方法，也确实变出了&#39;Abc&#39;，但变量a最后仍是&#39;abc&#39;，应该怎么理解呢？\n我们先把代码改成下面这样：\n123456&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; b = a.replace('a', 'A')&gt;&gt;&gt; b'Abc'&gt;&gt;&gt; a'abc'要始终牢记的是，a是变量，而&#39;abc&#39;才是字符串对象！有些时候，我们经常说，对象a的内容是&#39;abc&#39;，但其实是指，a本身是一个变量，它指向的对象的内容才是&#39;abc&#39;：\n123┌───┐                  ┌───────┐│ a │─────────────────&gt;│ &#39;abc&#39; │└───┘                  └───────┘当我们调用a.replace(&#39;a&#39;, &#39;A&#39;)时，实际上调用方法replace是作用在字符串对象&#39;abc&#39;上的，而这个方法虽然名字叫replace，但却没有改变字符串&#39;abc&#39;的内容。相反，replace方法创建了一个新字符串&#39;Abc&#39;并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串&#39;abc&#39;，但变量b却指向新字符串&#39;Abc&#39;了：\n123456┌───┐                  ┌───────┐│ a │─────────────────&gt;│ &#39;abc&#39; │└───┘                  └───────┘┌───┐                  ┌───────┐│ b │─────────────────&gt;│ &#39;Abc&#39; │└───┘                  └───────┘所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。\n转整数（转字符）ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：\n12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文'如果知道字符的整数编码，还可以用十六进制这么写str：\n12&gt;&gt;&gt; '\\u4e2d\\u6587''中文'转字节(ascii、utf-8)\n字符ASCIIUnicodeUTF-8\n\nA0100000100000000 0100000101000001\n\n中x01001110 0010110111100100 10111000 10101101\n对bytes类型的数据用带b前缀的单引号或双引号表示：\n1x = b'ABC'要注意区分&#39;ABC&#39;和b&#39;ABC&#39;，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。\n以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：\n12345678&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; '中文'.encode('ascii')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。\n在bytes中，无法显示为ASCII字符的字节，用\\x##显示。\n反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：\n1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文'如果bytes中包含无法解码的字节，decode()方法会报错：\n1234&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8')Traceback (most recent call last):  ...UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte如果bytes中只有一小部分无效的字节，可以传入errors=&#39;ignore&#39;忽略错误的字节：\n12&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中'计算字符数要计算str包含多少个字符，可以用len()函数：\n1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len('中文')2len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：\n123456&gt;&gt;&gt; len(b'ABC')3&gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6列表list双冒号的作用[::]Python序列切片地址可以写为[开始：结束：步长]，其中的开始和结束可以省略\nrange(n)生成[0,n)区间整数\n12range(10)[0,1,2,3,4,5,6,7,8,9]开始start省略时，默认从第0项开始\n12range(10)[:10:2][0,2,4,6,8]结尾省略的时候，默认到数组最后。\n12range(10)[1::2][1,3,5,7,9]开始和结尾不省略的时候\n12345range(10)[2:6:]#step省略默认为1[2,3,4,5]range(10)[2:6:1][2,3,4,5]步长step=n;代表从start开始（start也算）每隔step间隔，取一个数，一直到结尾end\n12range(20)[::3][0,3,6,9,12,15,18]当step等于负数的时候，从右向左取数。\n12345range(10)[::-1][9,8,7,6,5,4,3,2,1,0]range(10)[::-2][9,7,5,3,1]单引号的作用[:]a[start:end]：取得范围为[start,end)\n123a&#x3D;[[1,2,3],[4,5,6],[7,8,9]]b&#x3D;a[1:2][[4, 5, 6]]a[:end]：取得范围为[0,end)\n123a&#x3D;[[1,2,3],[4,5,6],[7,8,9]]b&#x3D;a[:1][[1, 2, 3]]a[start:]：取得范围为从start到最后（包括最后）\n123a&#x3D;[[1,2,3],[4,5,6],[7,8,9]]b&#x3D;a[1:][[4, 5, 6], [7, 8, 9]]列表元素个数用len()函数可以获得list元素的个数：\n123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3索引元素如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：\n12&gt;&gt;&gt; classmates[-1]'Tracy'以此类推，可以获取倒数第2个、倒数第3个：\n12345678&gt;&gt;&gt; classmates[-2]&#39;Bob&#39;&gt;&gt;&gt; classmates[-3]&#39;Michael&#39;&gt;&gt;&gt; classmates[-4]Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range当然，倒数第4个就越界了。\n追加元素追加元素到末尾\n123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam']把元素插入到指定的位置\n比如索引号为1的位置：\n123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']删除元素删除list末尾的元素，用pop()方法：\n1234&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']要删除指定位置的元素，用pop(i)方法，其中i是索引位置：\n1234&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']元素替换要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\n123&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy']list里面的元素的数据类型也可以不同，比如：\n1&gt;&gt;&gt; L = ['Apple', 123, True]list元素也可以是另一个list，比如：\n123&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：\n12&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme']要拿到&#39;php&#39;可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0：\n123&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0排序sort()描述\nsort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。\n1234&gt;&gt;&gt; a = ['c', 'b', 'a']&gt;&gt;&gt; a.sort()\t//对原列表进行排序&gt;&gt;&gt; a['a', 'b', 'c']语法\nsort()方法语法：\n1list.sort(cmp=None, key=None, reverse=False)参数\ncmp – 可选参数, 如果指定了该参数会使用该参数的方法进行排序。\nkey – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。\nreverse – 排序规则，reverse = True 降序， reverse = False 升序（默认）。\n字典 dict {}判断key的存在如果key不存在，dict就会报错：\n123456&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Thomas']Traceback (most recent call last):\tFile \"&lt;stdin&gt;\", line 1, in &lt;module&gt;\tKeyError: 'Thomas'in要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：\n1234&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; 'Thomas' in dFalseget()实例\n获取 “model” 项的值：\n123456789car = &#123;  \"brand\": \"Porsche\",  \"model\": \"911\",  \"year\": 1963&#125;x = car.get(\"model\")print(x)&gt;&gt; 911语法\n1dictionary.get(keyname, value)参数值\n\n参数描述\n\nkeyname必需。您要从中返回值的项目的键名。\n\nvalue可选。如果指定的键不存在，则返回一个值。默认值 None。\n实例\n尝试返回不存在的项目的值：\n123456789car = &#123;  \"brand\": \"Porsche\",  \"model\": \"911\",  \"year\": 1963&#125;x = car.get(\"price\", 15000)print(x)&gt;&gt; 15000删除key要删除一个key，用pop(key)方法，对应的value也会从dict中删除：\n12345&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d.pop('Bob')75&gt;&gt;&gt; d&#123;'Michael': 95, 'Tracy': 85&#125;请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n和list比较，dict有以下几个特点：\n查找和插入的速度极快，不会随着key的增加而变慢；\n需要占用大量的内存，内存浪费多。\n而list相反：\n查找和插入的时间随着元素的增加而增加；\n占用空间小，浪费内存很少。\n所以，dict是用空间来换取时间的一种方法。\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\n12345&gt;&gt;&gt; key = [1, 2, 3]&gt;&gt;&gt; d[key] = 'a list'Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unhashable type: 'list'setadd(key)通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：\n123456789&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;remove(key)通过remove(key)方法可以删除元素：\n123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125;set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125;set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n函数maxmax函数max()可以接收任意多个参数，并返回最大的那个：\n1234&gt;&gt;&gt; max(1, 2)2&gt;&gt;&gt; max(2, 3, 1, -5)3数据类型检查 isinstance()让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\n1234567def my_abs(x):    if not isinstance(x, (int, float)):        raise TypeError('bad operand type')    if x &gt;= 0:        return x    else:        return -x添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n12345&gt;&gt;&gt; my_abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 3, in my_absTypeError: bad operand type错误和异常处理将在后续讲到。\nenumerate()    列出数据和数据下标遍历的数据对象(如列表、元组或字符串)组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。\n语法\n1enumerate(sequence, [start=0])参数\nsequence – 一个[]序列、迭代器或其他支持迭代对象。\nstart – 下标起始位置。\n返回值\n返回 enumerate(枚举) 对象。列出数据和数据下标\n\n实例\n以下展示了使用 enumerate() 方法的实例：\n123456&gt;&gt;&gt;seasons = ['Spring', 'Summer', 'Fall', 'Winter']&gt;&gt;&gt; list(enumerate(seasons))[(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]&gt;&gt;&gt; list(enumerate(seasons, start=1))       # 下标从 1 开始[(1, 'Spring'), (2, 'Summer'), (3, 'Fall'), (4, 'Winter')]普通的 for 循环\n123456789&gt;&gt;&gt;i = 0&gt;&gt;&gt; seq = ['one', 'two', 'three']&gt;&gt;&gt; for element in seq:\t\tprint i, seq[i]        i +=10 one1 two2 threefor 循环使用 enumerate\n1234567&gt;&gt;&gt;seq = ['one', 'two', 'three']&gt;&gt;&gt; for i, element in enumerate(seq):\t\tprint i, element0 one1 two2 threesorted()    排序操作sorted() 函数对所有可迭代的对象进行排序操作。\n\nsort 与 sorted 区别：\nsort 是应用在 list 上的方法，sorted 可以对所有可迭代的对象进行排序操作。\nlist 的 sort 方法返回的是对已经存在的列表进行操作，而内建函数 sorted 方法返回的是一个新的 list，而不是在原来的基础上进行的操作。\n\n语法\nsorted 语法：\n1sorted(iterable, key=None, reverse=False)参数说明：\niterable – 可迭代对象。\nkey – 主要是用来进行比较的元素，只有一个参数，具体的函数的参数就是取自于可迭代对象中，指定可迭代对象中的一个元素来进行排序。\nreverse – 排序规则，reverse = True 降序 ， reverse = False 升序（默认）。\n返回值\n返回重新排序的列表。\n实例\n12345&gt;&gt; b = sorted(strs)['flight', 'flow', 'flower']&gt;&gt; b = sorted(strs, key=lambda x:len(x))\t#按字符串的长度进行排序['flow', 'flower', 'flight']以下实例展示了 sorted 的最简单的使用方法：\n12&gt;&gt;&gt;sorted([5, 2, 3, 1, 4])[1, 2, 3, 4, 5]                      # 默认为升序你也可以使用 list 的 list.sort() 方法。这个方法会修改原始的 list（返回值为None）。通常这个方法不如sorted()方便-如果你不需要原始的 list，list.sort()方法效率会稍微高一些。\n1234&gt;&gt;&gt;a&#x3D;[5,2,3,1,4]&gt;&gt;&gt; a.sort()&gt;&gt;&gt; a[1,2,3,4,5]另一个区别在于list.sort() 方法只为 list 定义。而 sorted() 函数可以接收任何的 iterable。\n12&gt;&gt;&gt;sorted(&#123;1: 'D', 2: 'B', 3: 'B', 4: 'E', 5: 'A'&#125;)[1, 2, 3, 4, 5]利用key进行倒序排序\n12345&gt;&gt;&gt;example_list = [5, 0, 6, 1, 2, 7, 3, 4]&gt;&gt;&gt; result_list = sorted(example_list, key=lambda x: x*-1)&gt;&gt;&gt; print(result_list)[7, 6, 5, 4, 3, 2, 1, 0]&gt;&gt;&gt;要进行反向排序，也通过传入第三个参数 reverse=True：\n123&gt;&gt;&gt;example_list = [5, 0, 6, 1, 2, 7, 3, 4]&gt;&gt;&gt; sorted(example_list, reverse=True)[7, 6, 5, 4, 3, 2, 1, 0]lambda  匿名函数python 使用 lambda 来创建匿名函数。\nlambda只是一个表达式，函数体比def简单很多。\nlambda的主体是一个表达式，而不是一个代码块。仅仅能在lambda表达式中封装有限的逻辑进去。\nlambda函数拥有自己的命名空间，且不能访问自有参数列表之外或全局命名空间里的参数。\n虽然lambda函数看起来只能写一行，却不等同于C或C++的内联函数，后者的目的是调用小函数时不占用栈内存从而增加运行效率。\n语法\nlambda函数的语法只包含一个语句，如下：\n1lambda [arg1 [,arg2,.....argn]]:expression实例(Python 2.0+)\n12345&gt;&gt; b = sorted(strs)['flight', 'flow', 'flower']&gt;&gt; b = sorted(strs, key=lambda x:len(x))\t#按字符串的长度进行排序['flow', 'flower', 'flight']123456789#!/usr/bin/python# -*- coding: UTF-8 -*- # 可写函数说明sum = lambda arg1, arg2: arg1 + arg2 # 调用sum函数print \"相加后的值为 : \", sum( 10, 20 )print \"相加后的值为 : \", sum( 20, 20 )以上实例输出结果：\n12相加后的值为 :  30相加后的值为 :  40大小写转换12345678# Filename : test.py# author by : www.runoob.comstr = \"www.runoob.com\"print(str.upper())          # 把所有字符中的小写字母转换成大写字母print(str.lower())          # 把所有字符中的大写字母转换成小写字母print(str.capitalize())     # 把第一个字母转化为大写字母，其余小写print(str.title())          # 把每个单词的第一个字母转化为大写，其余小写","plink":"https://dxsummer.gitee.io/posts/d8c26074/"},{"title":"Python基础","date":"2021-03-20T07:13:14.000Z","date_formatted":{"ll":"2021年3月20日","L":"2021/03/20","MM-DD":"03-20"},"updated":"2021-04-17T08:50:04.000Z","content":"第一个Python程序输入、输出输出用print()在括号中加上字符串，就可以向屏幕上输出指定的文字。比如输出&#39;hello, world&#39;，用代码实现如下：\n1&gt;&gt;&gt; print('hello, world')print()函数也可以接受多个字符串，用逗号“,”隔开，就可以连成一串输出：\n12&gt;&gt;&gt; print('The quick brown fox', 'jumps over', 'the lazy dog')The quick brown fox jumps over the lazy dogprint()会依次打印每个字符串，遇到逗号“,”会输出一个空格，因此，输出的字符串是这样拼起来的：\n\nprint()也可以打印整数，或者计算结果：\n1234&gt;&gt;&gt; print(300)300&gt;&gt;&gt; print(100 + 200)300因此，我们可以把计算100 + 200的结果打印得更漂亮一点：\n12&gt;&gt;&gt; print('100 + 200 =', 100 + 200)100 + 200 = 300注意，对于100 + 200，Python解释器自动计算出结果300，但是，&#39;100 + 200 =&#39;是字符串而非数学公式，Python把它视为字符串，请自行解释上述打印结果。\n输入现在，你已经可以用print()输出你想要的结果了。但是，如果要让用户从电脑输入一些字符怎么办？Python提供了一个input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字：\n12&gt;&gt;&gt; name = input()Michael当你输入name = input()并按下回车后，Python交互式命令行就在等待你的输入了。这时，你可以输入任意字符，然后按回车后完成输入。\n输入完成后，不会有任何提示，Python交互式命令行又回到&gt;&gt;&gt;状态了。那我们刚才输入的内容到哪去了？答案是存放到name变量里了。可以直接输入name查看变量内容：\n12&gt;&gt;&gt; name'Michael'什么是变量？请回忆初中数学所学的代数基础知识：\n设正方形的边长为a，则正方形的面积为a x a。把边长a看做一个变量，我们就可以根据a的值计算正方形的面积，比如：\n若a=2，则面积为a x a = 2 x 2 = 4；\n若a=3.5，则面积为a x a = 3.5 x 3.5 = 12.25。\n在计算机程序中，变量不仅可以为整数或浮点数，还可以是字符串，因此，name作为一个变量就是一个字符串。\n要打印出name变量的内容，除了直接写name然后按回车外，还可以用print()函数：\n12&gt;&gt;&gt; print(name)Michael有了输入和输出，我们就可以把上次打印&#39;hello, world&#39;的程序改成有点意义的程序了：\n12name = input()print('hello,', name)运行上面的程序，第一行代码会让用户输入任意字符作为自己的名字，然后存入name变量中；第二行代码会根据用户的名字向用户说hello，比如输入Michael：\n123C:\\Workspace&gt; python hello.pyMichaelhello, Michael但是程序运行的时候，没有任何提示信息告诉用户：“嘿，赶紧输入你的名字”，这样显得很不友好。幸好，input()可以让你显示一个字符串来提示用户，于是我们把代码改成：\n12name = input('please enter your name: ')print('hello,', name)再次运行这个程序，你会发现，程序一运行，会首先打印出please enter your name:，这样，用户就可以根据提示，输入名字后，得到hello, xxx的输出：\n123C:\\Workspace&gt; python hello.pyplease enter your name: Michaelhello, Michael每次运行该程序，根据用户输入的不同，输出结果也会不同。\n在命令行下，输入和输出就是这么简单。\nPython基础数据类型和变量以#开头的语句是注释\n1# print absolute value of an integer:Python程序是大小写敏感的\n计算机顾名思义就是可以做数学计算的机器，因此，计算机程序理所当然地可以处理各种数值。但是，计算机能处理的远不止数值，还可以处理文本、图形、音频、视频、网页等各种各样的数据，不同的数据，需要定义不同的数据类型。在Python中，能够直接处理的数据类型有以下几种：\n整数Python可以处理任意大小的整数，当然包括负整数，在程序中的表示方法和数学上的写法一模一样，例如：1，100，-8080，0，等等。\n计算机由于使用二进制，所以，有时候用十六进制表示整数比较方便，十六进制用0x前缀和0-9，a-f表示，例如：0xff00，0xa5b4c3d2，等等。\n对于很大的数，例如10000000000，很难数清楚0的个数。Python允许在数字中间以_分隔，因此，写成10_000_000_000和10000000000是完全一样的。十六进制数也可以写成0xa1b2_c3d4。\n浮点数浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如，1.23x109和12.3x108是完全相等的。浮点数可以用数学写法，如1.23，3.14，-9.01，等等。但是对于很大或很小的浮点数，就必须用科学计数法表示，把10用e替代，1.23x109就是1.23e9，或者12.3e8，0.000012可以写成1.2e-5，等等。\n整数和浮点数在计算机内部存储的方式是不同的，整数运算永远是精确的（除法难道也是精确的？是的！），而浮点数运算则可能会有四舍五入的误差。\n字符串字符串是以单引号&#39;或双引号&quot;括起来的任意文本，比如&#39;abc&#39;，&quot;xyz&quot;等等。请注意，&#39;&#39;或&quot;&quot;本身只是一种表示方式，不是字符串的一部分，因此，字符串&#39;abc&#39;只有a，b，c这3个字符。如果&#39;本身也是一个字符，那就可以用&quot;&quot;括起来，比如&quot;I&#39;m OK&quot;包含的字符是I，&#39;，m，空格，O，K这6个字符。\n如果字符串内部既包含&#39;又包含&quot;怎么办？可以用转义字符\\来标识，比如：\n1'I\\'m \\\"OK\\\"!'表示的字符串内容是：\n1I'm \"OK\"!转义字符\\可以转义很多字符，比如\\n表示换行，\\t表示制表符，字符\\本身也要转义，所以\\\\表示的字符就是\\，可以在Python的交互式命令行用print()打印字符串看看：\n12345678&gt;&gt;&gt; print('I\\'m ok.')I'm ok.&gt;&gt;&gt; print('I\\'m learning\\nPython.')I'm learningPython.&gt;&gt;&gt; print('\\\\\\n\\\\')\\\\如果字符串里面有很多字符都需要转义，就需要加很多\\，为了简化，Python还允许用r&#39;&#39;表示&#39;&#39;内部的字符串默认不转义，可以自己试试：\n1234&gt;&gt;&gt; print('\\\\\\t\\\\')\\       \\&gt;&gt;&gt; print(r'\\\\\\t\\\\')\\\\\\t\\\\如果字符串内部有很多换行，用\\n写在一行里不好阅读，为了简化，Python允许用&#39;&#39;&#39;...&#39;&#39;&#39;的格式表示多行内容，可以自己试试：\n123456&gt;&gt;&gt; print('''line1... line2... line3''')line1line2line3上面是在交互式命令行内输入，注意在输入多行内容时，提示符由&gt;&gt;&gt;变为...，提示你可以接着上一行输入，注意...是提示符，不是代码的一部分：\n123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - python                           _ □ x │├────────────────────────────────────────────────────────┤│&gt;&gt;&gt; print(&#39;&#39;&#39;line1                                      ││... line2                                               ││... line3&#39;&#39;&#39;)                                           ││line1                                                   ││line2                                                   ││line3                                                   ││                                                        ││&gt;&gt;&gt; _                                                   ││                                                        ││                                                        ││                                                        │└────────────────────────────────────────────────────────┘当输入完结束符```和括号)后，执行该语句并打印结果。\n如果写成程序并存为.py文件，就是：\n123print(&#39;&#39;&#39;line1line2line3&#39;&#39;&#39;)多行字符串&#39;&#39;&#39;...&#39;&#39;&#39;还可以在前面加上r使用，请自行测试：\n12print(r'''hello,\\nworld''')布尔值布尔值和布尔代数的表示完全一致，一个布尔值只有True、False两种值，要么是True，要么是False，在Python中，可以直接用True、False表示布尔值（请注意大小写），也可以通过布尔运算计算出来：\n12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False布尔值可以用and、or和not运算。\nand运算是与运算，只有所有都为True，and运算结果才是True：\n12345678&gt;&gt;&gt; True and TrueTrue&gt;&gt;&gt; True and FalseFalse&gt;&gt;&gt; False and FalseFalse&gt;&gt;&gt; 5 &gt; 3 and 3 &gt; 1Trueor运算是或运算，只要其中有一个为True，or运算结果就是True：\n12345678&gt;&gt;&gt; True or TrueTrue&gt;&gt;&gt; True or FalseTrue&gt;&gt;&gt; False or FalseFalse&gt;&gt;&gt; 5 &gt; 3 or 1 &gt; 3Truenot运算是非运算，它是一个单目运算符，把True变成False，False变成True：\n123456&gt;&gt;&gt; not TrueFalse&gt;&gt;&gt; not FalseTrue&gt;&gt;&gt; not 1 &gt; 2True布尔值经常用在条件判断中，比如：\n1234if age &gt;= 18:    print('adult')else:    print('teenager')空值空值是Python里一个特殊的值，用None表示。None不能理解为0，因为0是有意义的，而None是一个特殊的空值。\n此外，Python还提供了列表、字典等多种数据类型，还允许创建自定义数据类型，我们后面会继续讲到。\n变量变量的概念基本上和初中代数的方程变量是一致的，只是在计算机程序中，变量不仅可以是数字，还可以是任意数据类型。\n变量在程序中就是用一个变量名表示了，变量名必须是大小写英文、数字和_的组合，且不能用数字开头，比如：\n1a = 1变量a是一个整数。\n1t_007 = 'T007'变量t_007是一个字符串。\n1Answer = True变量Answer是一个布尔值True。\n在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量，例如：\n1234a = 123 # a是整数print(a)a = 'ABC' # a变为字符串print(a)这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错。例如Java是静态语言，赋值语句如下（// 表示注释）：\n12int a = 123; // a是整数类型变量a = \"ABC\"; // 错误：不能把字符串赋给整型变量和静态语言相比，动态语言更灵活，就是这个原因。\n请不要把赋值语句的等号等同于数学的等号。比如下面的代码：\n12x = 10x = x + 2如果从数学上理解x = x + 2那无论如何是不成立的，在程序中，赋值语句先计算右侧的表达式x + 2，得到结果12，再赋给变量x。由于x之前的值是10，重新赋值后，x的值变成12。\n最后，理解变量在计算机内存中的表示也非常重要。当我们写：\n1a = 'ABC'时，Python解释器干了两件事情：\n在内存中创建了一个&#39;ABC&#39;的字符串；\n在内存中创建了一个名为a的变量，并把它指向&#39;ABC&#39;。\n也可以把一个变量a赋值给另一个变量b，这个操作实际上是把变量b指向变量a所指向的数据，例如下面的代码：\n12345&gt;&gt; a = 'ABC'&gt;&gt; b = a&gt;&gt; a = 'XYZ'&gt;&gt; print(b)ABC最后一行打印出变量b的内容到底是&#39;ABC&#39;呢还是&#39;XYZ&#39;？如果从数学意义上理解，就会错误地得出b和a相同，也应该是&#39;XYZ&#39;，但实际上b的值是&#39;ABC&#39;，让我们一行一行地执行代码，就可以看到到底发生了什么事：\n执行a = &#39;ABC&#39;，解释器创建了字符串&#39;ABC&#39;和变量a，并把a指向&#39;ABC&#39;：\n\n执行b = a，解释器创建了变量b，并把b指向a指向的字符串&#39;ABC&#39;：\n\n执行a = &#39;XYZ&#39;，解释器创建了字符串’XYZ’，并把a的指向改为&#39;XYZ&#39;，但b并没有更改：\n\n所以，最后打印变量b的结果自然是&#39;ABC&#39;了。\n常量所谓常量就是不能变的变量，比如常用的数学常数π就是一个常量。在Python中，通常用全部大写的变量名表示常量：\n1PI = 3.14159265359但事实上PI仍然是一个变量，Python根本没有任何机制保证PI不会被改变，所以，用全部大写的变量名表示常量只是一个习惯上的用法，如果你一定要改变变量PI的值，也没人能拦住你。\n最后解释一下整数的除法为什么也是精确的。在Python中，有两种除法，一种除法是/：\n12&gt;&gt;&gt; 10 / 33.3333333333333335/除法计算结果是浮点数，即使是两个整数恰好整除，结果也是浮点数：\n12&gt;&gt;&gt; 9 / 33.0还有一种除法是//，称为地板除，两个整数的除法仍然是整数：\n12&gt;&gt;&gt; 10 // 33你没有看错，整数的地板除//永远是整数，即使除不尽。要做精确的除法，使用/就可以。\n因为//除法只取结果的整数部分，所以Python还提供一个余数运算，可以得到两个整数相除的余数：\n12&gt;&gt;&gt; 10 % 31无论整数做//除法还是取余数，结果永远是整数，所以，整数运算结果永远是精确的。\n小结Python支持多种数据类型，在计算机内部，可以把任何数据都看成一个“对象”，而变量就是在程序中用来指向这些数据对象的，对变量赋值就是把数据和变量给关联起来。\n对变量赋值x = y是把变量x指向真正的对象，该对象是变量y所指向的。随后对变量y的赋值不影响变量x的指向。\n注意：Python的整数没有大小限制，而某些语言的整数根据其存储长度是有大小限制的，例如Java对32位整数的范围限制在-2147483648-2147483647。\nPython的浮点数也没有大小限制，但是超出一定范围就直接表示为inf（无限大）。\n字符串和编码字符编码我们已经讲过了，字符串也是一种数据类型，但是，字符串比较特殊的是还有一个编码问题。\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。\n你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n\n因此，Unicode字符集应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\nUnicode标准也在不断发展，但最常用的是UCS-16编码，用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。\n字母A用ASCII编码是十进制的65，二进制的01000001；\n字符0用ASCII编码是十进制的48，二进制的00110000，注意字符&#39;0&#39;和整数0是不同的；\n汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。\n你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节。如果你要传输的文本包含大量英文字符，用UTF-8编码就能节省空间：\n\n字符ASCIIUnicodeUTF-8\n\nA0100000100000000 0100000101000001\n\n中x01001110 0010110111100100 10111000 10101101\n从上面的表格还可以发现，UTF-8编码有一个额外的好处，就是ASCII编码实际上可以被看成是UTF-8编码的一部分，所以，大量只支持ASCII编码的历史遗留软件可以在UTF-8编码下继续工作。\n搞清楚了ASCII、Unicode和UTF-8的关系，我们就可以总结一下现在计算机系统通用的字符编码工作方式：\n在计算机内存中，统一使用Unicode编码，当需要保存到硬盘或者需要传输的时候，就转换为UTF-8编码。\n用记事本编辑的时候，从文件读取的UTF-8字符被转换为Unicode字符到内存里，编辑完成后，保存的时候再把Unicode转换为UTF-8保存到文件：\n\n浏览网页的时候，服务器会把动态生成的Unicode内容转换为UTF-8再传输到浏览器：\n\n所以你看到很多网页的源码上会有类似&lt;meta charset=&quot;UTF-8&quot; /&gt;的信息，表示该网页正是用的UTF-8编码。\nPython的字符串搞清楚了令人头疼的字符编码问题后，我们再来研究Python的字符串。\n在最新的Python 3版本中，字符串是以Unicode编码的，也就是说，Python的字符串支持多语言，例如：\n12&gt;&gt;&gt; print('包含中文的str')包含中文的str对于单个字符的编码，Python提供了ord()函数获取字符的整数表示，chr()函数把编码转换为对应的字符：\n12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文'如果知道字符的整数编码，还可以用十六进制这么写str：\n12&gt;&gt;&gt; '\\u4e2d\\u6587''中文'两种写法完全是等价的。\n由于Python的字符串类型是str，在内存中以Unicode表示，一个字符对应若干个字节。如果要在网络上传输，或者保存到磁盘上，就需要把str变为以字节为单位的bytes。\nPython对bytes类型的数据用带b前缀的单引号或双引号表示：\n1x = b'ABC'要注意区分&#39;ABC&#39;和b&#39;ABC&#39;，前者是str，后者虽然内容显示得和前者一样，但bytes的每个字符都只占用一个字节。\n以Unicode表示的str通过encode()方法可以编码为指定的bytes，例如：\n12345678&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; '中文'.encode('ascii')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128)纯英文的str可以用ASCII编码为bytes，内容是一样的，含有中文的str可以用UTF-8编码为bytes。含有中文的str无法用ASCII编码，因为中文编码的范围超过了ASCII编码的范围，Python会报错。\n在bytes中，无法显示为ASCII字符的字节，用\\x##显示。\n反过来，如果我们从网络或磁盘上读取了字节流，那么读到的数据就是bytes。要把bytes变为str，就需要用decode()方法：\n1234&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文'如果bytes中包含无法解码的字节，decode()方法会报错：\n1234&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8')Traceback (most recent call last):  ...UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte如果bytes中只有一小部分无效的字节，可以传入errors=&#39;ignore&#39;忽略错误的字节：\n12&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中'要计算str包含多少个字符，可以用len()函数：\n1234&gt;&gt;&gt; len('ABC')3&gt;&gt;&gt; len('中文')2len()函数计算的是str的字符数，如果换成bytes，len()函数就计算字节数：\n123456&gt;&gt;&gt; len(b'ABC')3&gt;&gt;&gt; len(b'\\xe4\\xb8\\xad\\xe6\\x96\\x87')6&gt;&gt;&gt; len('中文'.encode('utf-8'))6可见，1个中文字符经过UTF-8编码后通常会占用3个字节，而1个英文字符只占用1个字节。\n在操作字符串时，我们经常遇到str和bytes的互相转换。为了避免乱码问题，应当始终坚持使用UTF-8编码对str和bytes进行转换。\n由于Python源代码也是一个文本文件，所以，当你的源代码中包含中文的时候，在保存源代码时，就需要务必指定保存为UTF-8编码。当Python解释器读取源代码时，为了让它按UTF-8编码读取，我们通常在文件开头写上这两行：\n12#!/usr/bin/env python3 # -*- coding: utf-8 -*-第一行注释是为了告诉Linux/OS X系统，这是一个Python可执行程序，Windows系统会忽略这个注释；\n第二行注释是为了告诉Python解释器，按照UTF-8编码读取源代码，否则，你在源代码中写的中文输出可能会有乱码。\n申明了UTF-8编码并不意味着你的.py文件就是UTF-8编码的，必须并且要确保文本编辑器正在使用UTF-8 without BOM编码：\n\n如果.py文件本身使用UTF-8编码，并且也申明了# -*- coding: utf-8 -*-，打开命令提示符测试就可以正常显示中文：\n\n格式化最后一个常见的问题是如何输出格式化的字符串。我们经常会输出类似&#39;亲爱的xxx你好！你xx月的话费是xx，余额是xx&#39;之类的字符串，而xxx的内容都是根据变量变化的，所以，需要一种简便的格式化字符串的方式。\n\n在Python中，采用的格式化方式和C语言是一致的，用%实现，举例如下：\n1234&gt;&gt;&gt; 'Hello, %s' % 'world''Hello, world'&gt;&gt;&gt; 'Hi, %s, you have $%d.' % ('Michael', 1000000)'Hi, Michael, you have $1000000.'你可能猜到了，%运算符就是用来格式化字符串的。在字符串内部，%s表示用字符串替换，%d表示用整数替换，有几个%?占位符，后面就跟几个变量或者值，顺序要对应好。如果只有一个%?，括号可以省略。\n常见的占位符有：\n\n占位符替换内容\n\n%d整数\n\n%f浮点数\n\n%s字符串\n\n%x十六进制整数\n其中，格式化整数和浮点数还可以指定是否补0和整数与小数的位数：\n1234&gt;&gt;print('%2d-%02d' % (3, 1)) 3-01&gt;&gt;print('%.2f' % 3.1415926)3.14如果你不太确定应该用什么，%s永远起作用，它会把任何数据类型转换为字符串：\n12&gt;&gt;&gt; 'Age: %s. Gender: %s' % (25, True)'Age: 25. Gender: True'有些时候，字符串里面的%是一个普通字符怎么办？这个时候就需要转义，用%%来表示一个%：\n12&gt;&gt;&gt; 'growth rate: %d %%' % 7'growth rate: 7 %'format()另一种格式化字符串的方法是使用字符串的format()方法，它会用传入的参数依次替换字符串内的占位符{0}、{1}……，不过这种方式写起来比%要麻烦得多：\n12&gt;&gt;&gt; 'Hello, &#123;0&#125;, 成绩提升了 &#123;1:.1f&#125;%'.format('小明', 17.125)'Hello, 小明, 成绩提升了 17.1%'f-string最后一种格式化字符串的方法是使用以f开头的字符串，称之为f-string，它和普通字符串不同之处在于，字符串如果包含{xxx}，就会以对应的变量替换：\n1234&gt;&gt;&gt; r &#x3D; 2.5&gt;&gt;&gt; s &#x3D; 3.14 * r ** 2&gt;&gt;&gt; print(f&#39;The area of a circle with radius &#123;r&#125; is &#123;s:.2f&#125;&#39;)The area of a circle with radius 2.5 is 19.62上述代码中，{r}被变量r的值替换，{s:.2f}被变量s的值替换，并且:后面的.2f指定了格式化参数（即保留两位小数），因此，{s:.2f}的替换结果是19.62。\n小结Python 3的字符串使用Unicode，直接支持多语言。\n当str和bytes互相转换时，需要指定编码。最常用的编码是UTF-8。Python当然也支持其他编码方式，比如把Unicode编码成GB2312：\n12&gt;&gt;&gt; '中文'.encode('gb2312')b'\\xd6\\xd0\\xce\\xc4'但这种方式纯属自找麻烦，如果没有特殊业务要求，请牢记仅使用UTF-8编码。\n格式化字符串的时候，可以用Python的交互式环境测试，方便快捷。\n使用list和tuplelist列表 []Python内置的一种数据类型是列表：list。list是一种有序的集合，可以随时添加和删除其中的元素。\n比如，列出班里所有同学的名字，就可以用一个list表示：\n123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']变量classmates就是一个list。用len()函数可以获得list元素的个数：\n12&gt;&gt;&gt; len(classmates)3用索引来访问list中每一个位置的元素，记得索引是从0开始的：\n12345678910&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[1]'Bob'&gt;&gt;&gt; classmates[2]'Tracy'&gt;&gt;&gt; classmates[3]Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range当索引超出了范围时，Python会报一个IndexError错误，所以，要确保索引不要越界，记得最后一个元素的索引是len(classmates) - 1。\n如果要取最后一个元素，除了计算索引位置外，还可以用-1做索引，直接获取最后一个元素：\n12&gt;&gt;&gt; classmates[-1]'Tracy'以此类推，可以获取倒数第2个、倒数第3个：\n12345678&gt;&gt;&gt; classmates[-2]'Bob'&gt;&gt;&gt; classmates[-3]'Michael'&gt;&gt;&gt; classmates[-4]Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;IndexError: list index out of range当然，倒数第4个就越界了。\nlist是一个可变的有序表，所以，可以往list中追加元素到末尾：\n123&gt;&gt;&gt; classmates.append('Adam')&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy', 'Adam']也可以把元素插入到指定的位置，比如索引号为1的位置：\n123&gt;&gt;&gt; classmates.insert(1, 'Jack')&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy', 'Adam']要删除list末尾的元素，用pop()方法：\n1234&gt;&gt;&gt; classmates.pop()'Adam'&gt;&gt;&gt; classmates['Michael', 'Jack', 'Bob', 'Tracy']要删除指定位置的元素，用pop(i)方法，其中i是索引位置：\n1234&gt;&gt;&gt; classmates.pop(1)'Jack'&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy']要把某个元素替换成别的元素，可以直接赋值给对应的索引位置：\n123&gt;&gt;&gt; classmates[1] = 'Sarah'&gt;&gt;&gt; classmates['Michael', 'Sarah', 'Tracy']list里面的元素的数据类型也可以不同，比如：\n1&gt;&gt;&gt; L = ['Apple', 123, True]list元素也可以是另一个list，比如：\n123&gt;&gt;&gt; s = ['python', 'java', ['asp', 'php'], 'scheme']&gt;&gt;&gt; len(s)4要注意s只有4个元素，其中s[2]又是一个list，如果拆开写就更容易理解了：\n12&gt;&gt;&gt; p = ['asp', 'php']&gt;&gt;&gt; s = ['python', 'java', p, 'scheme']要拿到&#39;php&#39;可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组，类似的还有三维、四维……数组，不过很少用到。\n如果一个list中一个元素也没有，就是一个空的list，它的长度为0：\n123&gt;&gt;&gt; L = []&gt;&gt;&gt; len(L)0tuple元组 ()另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改，比如同样是列出同学的名字：\n1&gt;&gt;&gt; classmates = ('Michael', 'Bob', 'Tracy')现在，classmates这个tuple不能变了，它也没有append()，insert()这样的方法。其他获取元素的方法和list是一样的，你可以正常地使用classmates[0]，classmates[-1]，但不能赋值成另外的元素。\n不可变的tuple有什么意义？因为tuple不可变，所以代码更安全。如果可能，能用tuple代替list就尽量用tuple。\n\ntuple的陷阱：当你定义一个tuple时，在定义的时候，tuple的元素就必须被确定下来，比如：\n\n123&gt;&gt;&gt; t = (1, 2)&gt;&gt;&gt; t(1, 2)如果要定义一个空的tuple，可以写成()：\n123&gt;&gt;&gt; t = ()&gt;&gt;&gt; t()但是，要定义一个只有1个元素的tuple，如果你这么定义：\n123&gt;&gt;&gt; t = (1)&gt;&gt;&gt; t1定义的不是tuple，是1这个数！这是因为括号()既可以表示tuple，又可以表示数学公式中的小括号，这就产生了歧义，因此，Python规定，这种情况下，按小括号进行计算，计算结果自然是1。\n所以，只有1个元素的tuple定义时必须加一个逗号,，来消除歧义：\n123&gt;&gt;&gt; t = (1,)&gt;&gt;&gt; t(1,)Python在显示只有1个元素的tuple时，也会加一个逗号,，以免你误解成数学计算意义上的括号。\n最后来看一个“可变的”tuple：\n12345&gt;&gt;&gt; t = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; t[2][0] = 'X'&gt;&gt;&gt; t[2][1] = 'Y'&gt;&gt;&gt; t('a', 'b', ['X', 'Y'])这个tuple定义的时候有3个元素，分别是&#39;a&#39;，&#39;b&#39;和一个list。不是说tuple一旦定义后就不可变了吗？怎么后来又变了？\n别急，我们先看看定义的时候tuple包含的3个元素：\n\n当我们把list的元素&#39;A&#39;和&#39;B&#39;修改为&#39;X&#39;和&#39;Y&#39;后，tuple变为：\n\n表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变。即指向&#39;a&#39;，就不能改成指向&#39;b&#39;，指向一个list，就不能改成指向其他对象，但指向的这个list本身是可变的！\n理解了“指向不变”后，要创建一个内容也不变的tuple怎么做？那就必须保证tuple的每一个元素本身也不能变。\n条件判断计算机之所以能做很多自动化的任务，因为它可以自己做条件判断。\n比如，输入用户年龄，根据年龄打印不同的内容，在Python程序中，用if语句实现：\n1234age = 20if age &gt;= 18:    print('your age is', age)    print('adult')根据Python的缩进规则，如果if语句判断是True，就把缩进的两行print语句执行了，否则，什么也不做。\n也可以给if添加一个else语句，意思是，如果if判断是False，不要执行if的内容，去把else执行了：\n1234567age = 3if age &gt;= 18:    print('your age is', age)    print('adult')else:    print('your age is', age)    print('teenager')注意不要少写了冒号:。\n当然上面的判断是很粗略的，完全可以用elif做更细致的判断：\n1234567age = 3if age &gt;= 18:    print('adult')elif age &gt;= 6:    print('teenager')else:    print('kid')elif是else if的缩写，完全可以有多个elif，所以if语句的完整形式就是：\n12345678if &lt;条件判断1&gt;:    &lt;执行1&gt;elif &lt;条件判断2&gt;:    &lt;执行2&gt;elif &lt;条件判断3&gt;:    &lt;执行3&gt;else:    &lt;执行4&gt;if语句执行有个特点，它是从上往下判断，如果在某个判断上是True，把该判断对应的语句执行后，就忽略掉剩下的elif和else，所以，请测试并解释为什么下面的程序打印的是teenager：\n1234567age = 20if age &gt;= 6:    print('teenager')elif age &gt;= 18:    print('adult')else:    print('kid')if判断条件还可以简写，比如写：\n12if x:    print('True')只要x是非零数值、非空字符串、非空list等，就判断为True，否则为False。\n再议 input最后看一个有问题的条件判断。很多同学会用input()读取用户的输入，这样可以自己输入，程序运行得更有意思：\n12345birth = input('birth: ')\t//输出birth: if birth &lt; 2000:    print('00前')else:    print('00后')输入1982，结果报错：\n123Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unorderable types: str() &gt; int()这是因为input()返回的数据类型是str，str不能直接和整数比较，必须先把str转换成整数。Python提供了int()函数来完成这件事情：\n123456s = input('birth: ')birth = int(s)if birth &lt; 2000:    print('00前')else:    print('00后')再次运行，就可以得到正确地结果。但是，如果输入abc呢？又会得到一个错误信息：\n123Traceback (most recent call last):  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: invalid literal for int() with base 10: &#39;abc&#39;原来int()函数发现一个字符串并不是合法的数字时就会报错，程序就退出了。\n如何检查并捕获程序运行期的错误呢？后面的错误和调试会讲到。\n小结条件判断可以让计算机自己做选择，Python的if...elif...else很灵活。\n条件判断从上向下匹配，当满足条件时执行对应的块内语句，后续的elif和else都不再执行。\n\n循环要计算1+2+3，我们可以直接写表达式：\n12&gt;&gt;&gt; 1 + 2 + 36要计算1+2+3+…+10，勉强也能写出来。\n但是，要计算1+2+3+…+10000，直接写表达式就不可能了。\n为了让计算机能计算成千上万次的重复运算，我们就需要循环语句。\nPython的循环有两种，一种是for...in循环，依次把list或tuple中的每个元素迭代出来，看例子：\n123names = ['Michael', 'Bob', 'Tracy']for name in names:    print(name)执行这段代码，会依次打印names的每一个元素：\n123MichaelBobTracy所以for x in ...循环就是把每个元素代入变量x，然后执行缩进块的语句。\n再比如我们想计算1-10的整数之和，可以用一个sum变量做累加：\n1234sum = 0for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:    sum = sum + xprint(sum)如果要计算1-100的整数之和，从1写到100有点困难，幸好Python提供一个range()函数，可以生成一个整数序列，再通过list()函数可以转换为list。比如range(5)生成的序列是从0开始小于5的整数：\n12&gt;&gt;&gt; list(range(5))[0, 1, 2, 3, 4]range(101)就可以生成0-100的整数序列，计算如下：\n1234sum = 0for x in range(101):    sum = sum + xprint(sum)请自行运行上述代码，看看结果是不是当年高斯同学心算出的5050。\n第二种循环是while循环，只要条件满足，就不断循环，条件不满足时退出循环。比如我们要计算100以内所有奇数之和，可以用while循环实现：\n123456sum = 0n = 99while n &gt; 0:    sum = sum + n    n = n - 2print(sum)在循环内部变量n不断自减，直到变为-1时，不再满足while条件，循环退出。\nbreak在循环中，break语句可以提前退出循环。例如，本来要循环打印1～100的数字：\n12345n = 1while n &lt;= 100:    print(n)    n = n + 1print('END')上面的代码可以打印出1~100。\n如果要提前结束循环，可以用break语句：\n1234567n = 1while n &lt;= 100:    if n &gt; 10: # 当n = 11时，条件满足，执行break语句        break # break语句会结束当前循环    print(n)    n = n + 1print('END')执行上面的代码可以看到，打印出1~10后，紧接着打印END，程序结束。\n可见break的作用是提前结束循环。\ncontinue在循环过程中，也可以通过continue语句，跳过当前的这次循环，直接开始下一次循环。\n1234n = 0while n &lt; 10:    n = n + 1    print(n)上面的程序可以打印出1～10。但是，如果我们想只打印奇数，可以用continue语句跳过某些循环：\n123456n = 0while n &lt; 10:    n = n + 1    if n % 2 == 0: # 如果n是偶数，执行continue语句        continue # continue语句会直接继续下一轮循环，后续的print()语句不会执行    print(n)执行上面的代码可以看到，打印的不再是1～10，而是1，3，5，7，9。\n可见continue的作用是提前结束本轮循环，并直接开始下一轮循环。\n小结循环是让计算机做重复任务的有效的方法。\nbreak语句可以在循环过程中直接退出循环，而continue语句可以提前结束本轮循环，并直接开始下一轮循环。这两个语句通常都必须配合if语句使用。\n要特别注意，不要滥用break和continue语句。break和continue会造成代码执行逻辑分叉过多，容易出错。大多数循环并不需要用到break和continue语句，上面的两个例子，都可以通过改写循环条件或者修改循环逻辑，去掉break和continue语句。\n有些时候，如果代码写得有问题，会让程序陷入“死循环”，也就是永远循环下去。这时可以用Ctrl+C退出程序，或者强制结束Python进程。\n请试写一个死循环程序。\n使用dict和setdict {}Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度。\n举个例子，假设要根据同学的名字查找对应的成绩，如果用list实现，需要两个list：\n12names = ['Michael', 'Bob', 'Tracy']scores = [95, 75, 85]给定一个名字，要查找对应的成绩，就先要在names中找到对应的位置，再从scores取出对应的成绩，list越长，耗时越长。\n如果用dict实现，只需要一个“名字”-“成绩”的对照表，直接根据名字查找成绩，无论这个表有多大，查找速度都不会变慢。用Python写一个dict如下：\n123&gt;&gt;&gt; d = &#123;'Michael': 95, 'Bob': 75, 'Tracy': 85&#125;&gt;&gt;&gt; d['Michael']95为什么dict查找速度这么快？因为dict的实现原理和查字典是一样的。假设字典包含了1万个汉字，我们要查某一个字，一个办法是把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在list中查找元素的方法，list越大，查找越慢。\n第二种方法是先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。\ndict就是第二种实现方式，给定一个名字，比如&#39;Michael&#39;，dict在内部就可以直接计算出Michael对应的存放成绩的“页码”，也就是95这个数字存放的内存地址，直接取出来，所以速度非常快。\n你可以猜到，这种key-value存储方式，在放进去的时候，必须根据key算出value的存放位置，这样，取的时候才能根据key直接拿到value。\n把数据放入dict的方法，除了初始化时指定外，还可以通过key放入：\n123&gt;&gt;&gt; d['Adam'] = 67&gt;&gt;&gt; d['Adam']67由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉：\n123456&gt;&gt;&gt; d['Jack'] = 90&gt;&gt;&gt; d['Jack']90&gt;&gt;&gt; d['Jack'] = 88&gt;&gt;&gt; d['Jack']88如果key不存在，dict就会报错：\n1234&gt;&gt;&gt; d['Thomas']Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;KeyError: 'Thomas'要避免key不存在的错误，有两种办法，一是通过in判断key是否存在：\n12&gt;&gt;&gt; 'Thomas' in dFalse二是通过dict提供的get()方法，如果key不存在，可以返回None，或者自己指定的value：\n123&gt;&gt;&gt; d.get('Thomas')&gt;&gt;&gt; d.get('Thomas', -1)-1注意：返回None的时候Python的交互环境不显示结果。\n要删除一个key，用pop(key)方法，对应的value也会从dict中删除：\n1234&gt;&gt;&gt; d.pop('Bob')75&gt;&gt;&gt; d&#123;'Michael': 95, 'Tracy': 85&#125;请务必注意，dict内部存放的顺序和key放入的顺序是没有关系的。\n和list比较，dict有以下几个特点：\n查找和插入的速度极快，不会随着key的增加而变慢；\n需要占用大量的内存，内存浪费多。\n而list相反：\n查找和插入的时间随着元素的增加而增加；\n占用空间小，浪费内存很少。\n所以，dict是用空间来换取时间的一种方法。\ndict可以用在需要高速查找的很多地方，在Python代码中几乎无处不在，正确使用dict非常重要，需要牢记的第一条就是dict的key必须是不可变对象。\n这是因为dict根据key来计算value的存储位置，如果每次计算相同的key得出的结果不同，那dict内部就完全混乱了。这个通过key计算位置的算法称为哈希算法（Hash）。\n要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key：\n12345&gt;&gt;&gt; key = [1, 2, 3]&gt;&gt;&gt; d[key] = 'a list'Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: unhashable type: 'list'setset和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key。\n要创建一个set，需要提供一个list作为输入集合：\n123&gt;&gt;&gt; s = set([1, 2, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125;注意，传入的参数[1, 2, 3]是一个list，而显示的{1, 2, 3}只是告诉你这个set内部有1，2，3这3个元素，显示的顺序也不表示set是有序的。。\n重复元素在set中自动被过滤：\n123&gt;&gt;&gt; s = set([1, 1, 2, 2, 3, 3])&gt;&gt;&gt; s&#123;1, 2, 3&#125;通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果：\n123456&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;&gt;&gt;&gt; s.add(4)&gt;&gt;&gt; s&#123;1, 2, 3, 4&#125;通过remove(key)方法可以删除元素：\n123&gt;&gt;&gt; s.remove(4)&gt;&gt;&gt; s&#123;1, 2, 3&#125;set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作：\n123456&gt;&gt;&gt; s1 = set([1, 2, 3])&gt;&gt;&gt; s2 = set([2, 3, 4])&gt;&gt;&gt; s1 &amp; s2&#123;2, 3&#125;&gt;&gt;&gt; s1 | s2&#123;1, 2, 3, 4&#125;set和dict的唯一区别仅在于没有存储对应的value，但是，set的原理和dict一样，所以，同样不可以放入可变对象，因为无法判断两个可变对象是否相等，也就无法保证set内部“不会有重复元素”。试试把list放入set，看看是否会报错。\n再议不可变对象上面我们讲了，str是不变对象，而list是可变对象。\n对于可变对象，比如list，对list进行操作，list内部的内容是会变化的，比如：\n1234&gt;&gt;&gt; a = ['c', 'b', 'a']&gt;&gt;&gt; a.sort()\t//对原列表进行排序&gt;&gt;&gt; a['a', 'b', 'c']而对于不可变对象，比如str，对str进行操作呢：\n12345&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; a.replace('a', 'A')\t//把字符串中的 old（旧字符串） 替换成new(新字符串)'Abc'&gt;&gt;&gt; a'abc'虽然字符串有个replace()方法，也确实变出了&#39;Abc&#39;，但变量a最后仍是&#39;abc&#39;，应该怎么理解呢？\n我们先把代码改成下面这样：\n123456&gt;&gt;&gt; a = 'abc'&gt;&gt;&gt; b = a.replace('a', 'A')&gt;&gt;&gt; b'Abc'&gt;&gt;&gt; a'abc'要始终牢记的是，a是变量，而&#39;abc&#39;才是字符串对象！有些时候，我们经常说，对象a的内容是&#39;abc&#39;，但其实是指，a本身是一个变量，它指向的对象的内容才是&#39;abc&#39;：\n123┌───┐                  ┌───────┐│ a │─────────────────&gt;│ &#39;abc&#39; │└───┘                  └───────┘当我们调用a.replace(&#39;a&#39;, &#39;A&#39;)时，实际上调用方法replace是作用在字符串对象&#39;abc&#39;上的，而这个方法虽然名字叫replace，但却没有改变字符串&#39;abc&#39;的内容。相反，replace方法创建了一个新字符串&#39;Abc&#39;并返回，如果我们用变量b指向该新字符串，就容易理解了，变量a仍指向原有的字符串&#39;abc&#39;，但变量b却指向新字符串&#39;Abc&#39;了：\n123456┌───┐                  ┌───────┐│ a │─────────────────&gt;│ &#39;abc&#39; │└───┘                  └───────┘┌───┐                  ┌───────┐│ b │─────────────────&gt;│ &#39;Abc&#39; │└───┘                  └───────┘所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。\n小结使用key-value存储结构的dict在Python中非常有用，选择不可变对象作为key很重要，最常用的key是字符串。\ntuple虽然是不变对象，但试试把(1, 2, 3)和(1, [2, 3])放入dict或set中，并解释结果。\n函数我们知道圆的面积计算公式为：\nS = πr2\n当我们知道半径r的值时，就可以根据公式计算出面积。假设我们需要计算3个不同大小的圆的面积：\n123456r1 = 12.34r2 = 9.08r3 = 73.1s1 = 3.14 * r1 * r1s2 = 3.14 * r2 * r2s3 = 3.14 * r3 * r3当代码出现有规律的重复的时候，你就需要当心了，每次写3.14 * x * x不仅很麻烦，而且，如果要把3.14改成3.14159265359的时候，得全部替换。\n有了函数，我们就不再每次写s = 3.14 * x * x，而是写成更有意义的函数调用s = area_of_circle(x)，而函数area_of_circle本身只需要写一次，就可以多次调用。\n基本上所有的高级语言都支持函数，Python也不例外。Python不但能非常灵活地定义函数，而且本身内置了很多有用的函数，可以直接调用。\n抽象\n抽象是数学中非常常见的概念。举个例子：\n计算数列的和，比如：1 + 2 + 3 + ... + 100，写起来十分不方便，于是数学家发明了求和符号∑，可以把1 + 2 + 3 + ... + 100记作：$$\\sum_{n=1}^{100}$$这种抽象记法非常强大，因为我们看到 ∑ 就可以理解成求和，而不是还原成低级的加法运算。\n而且，这种抽象记法是可扩展的，比如：$$\\sum_{n=1}^{100}(n^2+1)$$还原成加法运算就变成了：\n(1 x 1 + 1) + (2 x 2 + 1) + (3 x 3 + 1) + … + (100 x 100 + 1)\n可见，借助抽象，我们才能不关心底层的具体计算过程，而直接在更高的层次上思考问题。\n写计算机程序也是一样，函数就是最基本的一种代码抽象的方式。\n调用函数Python内置了很多有用的函数，我们可以直接调用。\n要调用一个函数，需要知道函数的名称和参数，比如求绝对值的函数abs，只有一个参数。可以直接从Python的官方网站查看文档：\nhttp://docs.python.org/3/library/functions.html#abs\n也可以在交互式命令行通过help(abs)查看abs函数的帮助信息。\n调用abs函数：\n123456&gt;&gt;&gt; abs(100)100&gt;&gt;&gt; abs(-20)20&gt;&gt;&gt; abs(12.34)12.34调用函数的时候，如果传入的参数数量不对，会报TypeError的错误，并且Python会明确地告诉你：abs()有且仅有1个参数，但给出了两个：\n1234&gt;&gt;&gt; abs(1, 2)Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: abs() takes exactly one argument (2 given)如果传入的参数数量是对的，但参数类型不能被函数所接受，也会报TypeError的错误，并且给出错误信息：str是错误的参数类型：\n1234&gt;&gt;&gt; abs('a')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str'而max函数max()可以接收任意多个参数，并返回最大的那个：\n1234&gt;&gt;&gt; max(1, 2)2&gt;&gt;&gt; max(2, 3, 1, -5)3数据类型转换Python内置的常用函数还包括数据类型转换函数，比如int()函数可以把其他数据类型转换为整数：\n1234567891011121314&gt;&gt;&gt; int('123')123&gt;&gt;&gt; int(12.34)12&gt;&gt;&gt; float('12.34')12.34&gt;&gt;&gt; str(1.23)'1.23'&gt;&gt;&gt; str(100)'100'&gt;&gt;&gt; bool(1)True&gt;&gt;&gt; bool('')False函数名其实就是指向一个函数对象的引用，完全可以把函数名赋给一个变量，相当于给这个函数起了一个“别名”：\n123&gt;&gt;&gt; a = abs # 变量a指向abs函数&gt;&gt;&gt; a(-1) # 所以也可以通过a调用abs函数1小结调用Python的函数，需要根据函数定义，传入正确的参数。如果函数调用出错，一定要学会看错误信息，所以英文很重要！\n定义函数在Python中，定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回。\n我们以自定义一个求绝对值的my_abs函数为例：\n12345def my_abs(x):    if x &gt;= 0:        return x    else:        return -x请注意，函数体内部的语句在执行时，一旦执行到return时，函数就执行完毕，并将结果返回。因此，函数内部通过条件判断和循环可以实现非常复杂的逻辑。\n如果没有return语句，函数执行完毕后也会返回结果，只是结果为None。return None可以简写为return。\n在Python交互环境中定义函数时，注意Python会出现...的提示。函数定义结束后需要按两次回车重新回到&gt;&gt;&gt;提示符下：\n123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - python                           - □ x │├────────────────────────────────────────────────────────┤│&gt;&gt;&gt; def my_abs(x):                                      ││...     if x &gt;&#x3D; 0:                                      ││...         return x                                    ││...     else:                                           ││...         return -x                                   ││...                                                     ││&gt;&gt;&gt; my_abs(-9)                                          ││9                                                       ││&gt;&gt;&gt; _                                                   ││                                                        ││                                                        │└────────────────────────────────────────────────────────┘如果你已经把my_abs()的函数定义保存为abstest.py文件了，那么，可以在该文件的当前目录下启动Python解释器，用from abstest import my_abs来导入my_abs()函数，注意abstest是文件名（不含.py扩展名）：\n123456789101112131415┌────────────────────────────────────────────────────────┐│Command Prompt - python                           - □ x │├────────────────────────────────────────────────────────┤│&gt;&gt;&gt; from abstest import my_abs                          ││&gt;&gt;&gt; my_abs(-9)                                          ││9                                                       ││&gt;&gt;&gt; _                                                   ││                                                        ││                                                        ││                                                        ││                                                        ││                                                        ││                                                        ││                                                        │└────────────────────────────────────────────────────────┘import的用法在后续模块一节中会详细介绍。\n空函数如果想定义一个什么事也不做的空函数，可以用pass语句：\n12def nop():    passpass语句什么都不做，那有什么用？实际上pass可以用来作为占位符，比如现在还没想好怎么写函数的代码，就可以先放一个pass，让代码能运行起来。\npass还可以用在其他语句里，比如：\n12if age &gt;= 18:    pass缺少了pass，代码运行就会有语法错误。\n参数检查调用函数时，如果参数个数不对，Python解释器会自动检查出来，并抛出TypeError：\n1234&gt;&gt;&gt; my_abs(1, 2)Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: my_abs() takes 1 positional argument but 2 were given但是如果参数类型不对，Python解释器就无法帮我们检查。试试my_abs和内置函数abs的差别：\n12345678910&gt;&gt;&gt; my_abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 2, in my_absTypeError: unorderable types: str() &gt;= int()        &gt;&gt;&gt; abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str'当传入了不恰当的参数时，内置函数abs会检查出参数错误，而我们定义的my_abs没有参数检查，会导致if语句出错，出错信息和abs不一样。所以，这个函数定义不够完善。\n让我们修改一下my_abs的定义，对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance()实现：\n1234567def my_abs(x):    if not isinstance(x, (int, float)):        raise TypeError('bad operand type')    if x &gt;= 0:        return x    else:        return -x添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：\n12345&gt;&gt;&gt; my_abs('A')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 3, in my_absTypeError: bad operand type错误和异常处理将在后续讲到。\n返回多个值函数可以返回多个值吗？答案是肯定的。\n比如在游戏中经常需要从一个点移动到另一个点，给出坐标、位移和角度，就可以计算出新的坐标：\n123456import mathdef move(x, y, step, angle=0):    nx = x + step * math.cos(angle)    ny = y - step * math.sin(angle)    return nx, nyimport math语句表示导入math包，并允许后续代码引用math包里的sin、cos等函数。\n然后，我们就可以同时获得返回值：\n123&gt;&gt;&gt; x, y = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(x, y)151.96152422706632 70.0但其实这只是一种假象，Python函数返回的仍然是单一值：\n123&gt;&gt;&gt; r = move(100, 100, 60, math.pi / 6)&gt;&gt;&gt; print(r)(151.96152422706632, 70.0)原来返回值是一个tuple！但是，在语法上，返回一个tuple可以省略括号，而多个变量可以同时接收一个tuple，按位置赋给对应的值，所以，Python的函数返回多值其实就是返回一个tuple，但写起来更方便。\n小结定义函数时，需要确定函数名和参数个数；\n如果有必要，可以先对参数的数据类型做检查；\n函数体内部可以用return随时返回函数结果；\n函数执行完毕也没有return语句时，自动return None。\n函数可以同时返回多个值，但其实就是一个tuple。\n函数的参数定义函数的时候，我们把参数的名字和位置确定下来，函数的接口定义就完成了。对于函数的调用者来说，只需要知道如何传递正确的参数，以及函数将返回什么样的值就够了，函数内部的复杂逻辑被封装起来，调用者无需了解。\nPython的函数定义非常简单，但灵活度却非常大。除了正常定义的必选参数外，还可以使用默认参数、可变参数和关键字参数，使得函数定义出来的接口，不但能处理复杂的参数，还可以简化调用者的代码。\n位置参数我们先写一个计算x2的函数：\n12def power(x):    return x * x对于power(x)函数，参数x就是一个位置参数。\n当我们调用power函数时，必须传入有且仅有的一个参数x：\n1234&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(15)225现在，如果我们要计算x3怎么办？可以再定义一个power3函数，但是如果要计算x4、x5……怎么办？我们不可能定义无限多个函数。\n你也许想到了，可以把power(x)修改为power(x, n)，用来计算xn，说干就干：\n123456def power(x, n):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s对于这个修改后的power(x, n)函数，可以计算任意n次方：\n1234&gt;&gt;&gt; power(5, 2)25&gt;&gt;&gt; power(5, 3)125修改后的power(x, n)函数有两个参数：x和n，这两个参数都是位置参数，调用函数时，传入的两个值按照位置顺序依次赋给参数x和n。\n默认参数新的power(x, n)函数定义没有问题，但是，旧的调用代码失败了，原因是我们增加了一个参数，导致旧的代码因为缺少一个参数而无法正常调用：\n1234&gt;&gt;&gt; power(5)Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: power() missing 1 required positional argument: 'n'Python的错误信息很明确：调用函数power()缺少了一个位置参数n。\n这个时候，默认参数就排上用场了。由于我们经常计算x2，所以，完全可以把第二个参数n的默认值设定为2：\n123456def power(x, n=2):    s = 1    while n &gt; 0:        n = n - 1        s = s * x    return s这样，当我们调用power(5)时，相当于调用power(5, 2)：\n1234&gt;&gt;&gt; power(5)25&gt;&gt;&gt; power(5, 2)25而对于n &gt; 2的其他情况，就必须明确地传入n，比如power(5, 3)。\n从上面的例子可以看出，默认参数可以简化函数的调用。设置默认参数时，有几点要注意：\n一是必选参数在前，默认参数在后，否则Python的解释器会报错（思考一下为什么默认参数不能放在必选参数前面）；\n二是如何设置默认参数。\n当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。\n使用默认参数有什么好处？最大的好处是能降低调用函数的难度。\n举个例子，我们写个一年级小学生注册的函数，需要传入name和gender两个参数：\n123def enroll(name, gender):    print('name:', name)    print('gender:', gender)这样，调用enroll()函数只需要传入两个参数：\n123&gt;&gt;&gt; enroll('Sarah', 'F')name: Sarahgender: F如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。\n我们可以把年龄和城市设为默认参数：\n12345def enroll(name, gender, age=6, city='Beijing'):    print('name:', name)    print('gender:', gender)    print('age:', age)    print('city:', city)这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：\n12345&gt;&gt;&gt; enroll('Sarah', 'F')name: Sarahgender: Fage: 6city: Beijing只有与默认参数不符的学生才需要提供额外的信息：\n12enroll('Bob', 'M', 7)enroll('Adam', 'M', city='Tianjin')可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。\n有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll(&#39;Bob&#39;, &#39;M&#39;, 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值。\n也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll(&#39;Adam&#39;, &#39;M&#39;, city=&#39;Tianjin&#39;)，意思是，city参数用传进去的值，其他默认参数继续使用默认值。\n默认参数很有用，但使用不当，也会掉坑里。默认参数有个最大的坑，演示如下：\n先定义一个函数，传入一个list，添加一个END再返回：\n123def add_end(L=[]):    L.append('END')    return L当你正常调用时，结果似乎不错：\n1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END']当你使用默认参数调用时，一开始结果也是对的：\n12&gt;&gt;&gt; add_end()['END']但是，再次调用add_end()时，结果就不对了：\n1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END']很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了&#39;END&#39;后的list。\n原因解释如下：\nPython函数在定义的时候，默认参数L的值就被计算出来了，即[]，因为默认参数L也是一个变量，它指向对象[]，每次调用该函数，如果改变了L的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了。\n定义默认参数要牢记一点：默认参数必须指向不变对象！要修改上面的例子，我们可以用None这个不变对象来实现：\n12345def add_end(L=None):    if L is None:        L = []    L.append('END')    return L现在，无论调用多少次，都不会有问题：\n1234&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END']为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象。\n可变参数在Python函数中，还可以定义可变参数。顾名思义，可变参数就是传入的参数个数是可变的，可以是1个、2个到任意个，还可以是0个。\n我们以数学题为例子，给定一组数字a，b，c……，请计算a2 + b2 + c2 + ……。\n要定义出这个函数，我们必须确定输入的参数。由于参数个数不确定，我们首先想到可以把a，b，c……作为一个list或tuple传进来，这样，函数可以定义如下：\n12345def calc(numbers):\t\t//不可变参数    sum = 0    for n in numbers:        sum = sum + n * n    return sum但是调用的时候，需要先组装出一个list或tuple：\n1234&gt;&gt;&gt; calc([1, 2, 3])14&gt;&gt;&gt; calc((1, 3, 5, 7))84如果利用可变参数，调用函数的方式可以简化成这样：\n12345&gt;&gt;&gt; calc(1, 2, 3)\t14&gt;&gt;&gt; calc(1, 3, 5, 7)84\t↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓↓所以，我们把函数的参数改为可变参数：\n12345def calc(*numbers):\t\t//加*把list或tuple的元素变成可变参数传进去    sum = 0    for n in numbers:        sum = sum + n * n    return sum定义可变参数和定义一个list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数：\n1234&gt;&gt;&gt; calc(1, 2)5&gt;&gt;&gt; calc()0如果已经有一个list或者tuple，要调用一个可变参数怎么办？可以这样做：\n123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(nums[0], nums[1], nums[2])14这种写法当然是可行的，问题是太繁琐，所以Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去：\n123&gt;&gt;&gt; nums = [1, 2, 3]&gt;&gt;&gt; calc(*nums)\t\t//把list或tuple的元素变成可变参数传进去14*nums表示把nums这个list的所有元素作为可变参数传进去。这种写法相当有用，而且很常见。\n关键字参数可变参数允许你传入0个或任意个参数，这些可变参数在函数调用时自动组装为一个tuple。而关键字参数允许你传入0个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个dict。请看示例：\n12def person(name, age, **kw):    print('name:', name, 'age:', age, 'other:', kw)函数person除了必选参数name和age外，还接受关键字参数kw。在调用该函数时，可以只传入必选参数：\n12&gt;&gt;&gt; person('Michael', 30)name: Michael age: 30 other: &#123;&#125;也可以传入任意个数的关键字参数：\n12345&gt;&gt;&gt; person('Bob', 35, city='Beijing')name: Bob age: 35 other: &#123;'city': 'Beijing'&#125;            &gt;&gt;&gt; person('Adam', 45, gender='M', job='Engineer')name: Adam age: 45 other: &#123;'gender': 'M', 'job': 'Engineer'&#125;关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求。\n和可变参数类似，也可以先组装出一个dict，然后，把该dict转换为关键字参数传进去：\n123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, city=extra['city'], job=extra['job'])name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125;当然，上面复杂的调用可以用简化的写法：\n123&gt;&gt;&gt; extra = &#123;'city': 'Beijing', 'job': 'Engineer'&#125;&gt;&gt;&gt; person('Jack', 24, **extra)name: Jack age: 24 other: &#123;'city': 'Beijing', 'job': 'Engineer'&#125;`extra表示把extra这个dict的所有key-value用关键字参数传入到函数的kw`参数，kw将获得一个dict，注意kw获得的dict是extra的一份拷贝，对kw的改动不会影响到函数外的extra。\n命名关键字参数对于关键字参数，函数的调用者可以传入任意不受限制的关键字参数。至于到底传入了哪些，就需要在函数内部通过kw检查。\n仍以person()函数为例，我们希望检查是否有city和job参数：\n12345678def person(name, age, **kw):    if 'city' in kw:        # 有city参数        pass    if 'job' in kw:        # 有job参数        pass    print('name:', name, 'age:', age, 'other:', kw)但是调用者仍可以传入不受限制的关键字参数：\n1&gt;&gt;&gt; person('Jack', 24, city='Beijing', addr='Chaoyang', zipcode=123456)如果要限制关键字参数的名字，就可以用命名关键字参数，例如，只接收city和job作为关键字参数。这种方式定义的函数如下：\n12def person(name, age, *, city, job):    print(name, age, city, job)和关键字参数**kw不同，命名关键字参数需要一个特殊分隔符*，*后面的参数被视为命名关键字参数。\n调用方式如下：\n12&gt;&gt;&gt; person('Jack', 24, city='Beijing', job='Engineer')Jack 24 Beijing Engineer如果函数定义中已经有了一个可变参数，后面跟着的命名关键字参数就不再需要一个特殊分隔符*了：\n12def person(name, age, *args, city, job):    print(name, age, args, city, job)命名关键字参数必须传入参数名，这和位置参数不同。如果没有传入参数名，调用将报错：\n1234&gt;&gt;&gt; person('Jack', 24, 'Beijing', 'Engineer')Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;TypeError: person() takes 2 positional arguments but 4 were given由于调用时缺少参数名city和job，Python解释器把这4个参数均视为位置参数，但person()函数仅接受2个位置参数。\n命名关键字参数可以有缺省值，从而简化调用：\n12def person(name, age, *, city='Beijing', job):    print(name, age, city, job)由于命名关键字参数city具有默认值，调用时，可不传入city参数：\n12&gt;&gt;&gt; person('Jack', 24, job='Engineer')Jack 24 Beijing Engineer使用命名关键字参数时，要特别注意，如果没有可变参数，就必须加一个*作为特殊分隔符。如果缺少*，Python解释器将无法识别位置参数和命名关键字参数：\n123def person(name, age, city, job):    # 缺少 *，city和job被视为位置参数    pass参数组合在Python中定义函数，可以用必选参数、默认参数、可变参数、关键字参数和命名关键字参数，这5种参数都可以组合使用。但是请注意，参数定义的顺序必须是：必选参数、默认参数、可变参数、命名关键字参数和关键字参数。\n比如定义一个函数，包含上述若干种参数：\n12345def f1(a, b, c=0, *args, **kw):    print('a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw)def f2(a, b, c=0, *, d, **kw):    print('a =', a, 'b =', b, 'c =', c, 'd =', d, 'kw =', kw)在函数调用的时候，Python解释器自动按照参数位置和参数名把对应的参数传进去。\n1234567891011121314&gt;&gt;&gt; f1(1, 2)a = 1 b = 2 c = 0 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, c=3)a = 1 b = 2 c = 3 args = () kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b')a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;&#125;&gt;&gt;&gt; f1(1, 2, 3, 'a', 'b', x=99)a = 1 b = 2 c = 3 args = ('a', 'b') kw = &#123;'x': 99&#125;&gt;&gt;&gt; f2(1, 2, d=99, ext=None)a = 1 b = 2 c = 0 d = 99 kw = &#123;'ext': None&#125;最神奇的是通过一个tuple和dict，你也可以调用上述函数：\n123456789&gt;&gt;&gt; args = (1, 2, 3, 4)&gt;&gt;&gt; kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; f1(*args, **kw)a = 1 b = 2 c = 3 args = (4,) kw = &#123;'d': 99, 'x': '#'&#125;&gt;&gt;&gt; args = (1, 2, 3)&gt;&gt;&gt; kw = &#123;'d': 88, 'x': '#'&#125;&gt;&gt;&gt; f2(*args, **kw)a = 1 b = 2 c = 3 d = 88 kw = &#123;'x': '#'&#125;所以，对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的。\n虽然可以组合多达5种参数，但不要同时使用太多的组合，否则函数接口的可理解性很差。小结Python的函数具有非常灵活的参数形态，既可以实现简单的调用，又可以传入非常复杂的参数。\n默认参数一定要用不可变对象，如果是可变对象，程序运行时会有逻辑错误！\n要注意定义可变参数和关键字参数的语法：\n*args是可变参数，args接收的是一个tuple；\n**kw是关键字参数，kw接收的是一个dict。\n以及调用函数时如何传入可变参数和关键字参数的语法：\n可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；\n关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{&#39;a&#39;: 1, &#39;b&#39;: 2})。\n使用*args和**kw是Python的习惯写法，当然也可以用其他参数名，但最好使用习惯用法。\n命名的关键字参数是为了限制调用者可以传入的参数名，同时可以提供默认值。\n定义命名的关键字参数在没有可变参数的情况下不要忘了写分隔符*，否则定义的将是位置参数。\n递归函数在函数内部，可以调用其他函数。如果一个函数在内部调用自身本身，这个函数就是递归函数。\n举个例子，我们来计算阶乘n! = 1 x 2 x 3 x ... x n，用函数fact(n)表示，可以看出：$$fact(n)=n!=1\\times2\\times3\\times\\cdot\\cdot\\cdot\\times(n-1)\\times n=(n-1)!\\times n=fact(n-1)\\times n$$所以，fact(n)可以表示为n x fact(n-1)，只有n=1时需要特殊处理。\n于是，fact(n)用递归的方式写出来就是：\n1234def fact(n):    if n==1:        return 1    return n * fact(n - 1)上面就是一个递归函数。可以试试：\n123456&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(5)120&gt;&gt;&gt; fact(100)93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000如果我们计算fact(5)，可以根据函数定义看到计算过程如下：\n12345678910&#x3D;&#x3D;&#x3D;&gt; fact(5)&#x3D;&#x3D;&#x3D;&gt; 5 * fact(4)&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * fact(3))&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * fact(2)))&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * (2 * fact(1))))&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * (2 * 1)))&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * 2))&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * 6)&#x3D;&#x3D;&#x3D;&gt; 5 * 24&#x3D;&#x3D;&#x3D;&gt; 120递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。\n使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。由于栈的大小不是无限的，所以，递归调用的次数过多，会导致栈溢出。可以试试fact(1000)：\n1234567&gt;&gt;&gt; fact(1000)Traceback (most recent call last):  File \"&lt;stdin&gt;\", line 1, in &lt;module&gt;  File \"&lt;stdin&gt;\", line 4, in fact  ...  File \"&lt;stdin&gt;\", line 4, in factRuntimeError: maximum recursion depth exceeded in comparison解决递归调用栈溢出的方法是通过尾递归优化，事实上尾递归和循环的效果是一样的，所以，把循环看成是一种特殊的尾递归函数也是可以的。\n尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况。\n上面的fact(n)函数由于return n * fact(n - 1)引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：\n1234567def fact(n):    return fact_iter(n, 1)def fact_iter(num, product):    if num == 1:        return product    return fact_iter(num - 1, num * product)可以看到，return fact_iter(num - 1, num * product)仅返回递归函数本身，num - 1和num * product在函数调用前就会被计算，不影响函数调用。\nfact(5)对应的fact_iter(5, 1)的调用如下：\n123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5)===&gt; fact_iter(3, 20)===&gt; fact_iter(2, 60)===&gt; fact_iter(1, 120)===&gt; 120尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。\n遗憾的是，大多数编程语言没有针对尾递归做优化，Python解释器也没有做优化，所以，即使把上面的fact(n)函数改成尾递归方式，也会导致栈溢出。\n小结使用递归函数的优点是逻辑简单清晰，缺点是过深的调用会导致栈溢出。\n针对尾递归优化的语言可以通过尾递归防止栈溢出。尾递归事实上和循环是等价的，没有循环语句的编程语言只能通过尾递归实现循环。\nPython标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题。\n","plink":"https://dxsummer.gitee.io/posts/99832f47/"},{"title":"计算机四级网络工程师思维导图--常考重点","date":"2021-01-11T05:15:51.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2021-01-11T05:17:36.000Z","content":"计算机四级网络工程师考试快开始了。这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~\n此部分为整体归纳出来的常考重点~\nPS:\n思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~\n图片高清，但文字较小也很长，可以点击图片后放大学习哦~\n一、操作系统\n二、计算机网络\n","plink":"https://dxsummer.gitee.io/posts/b384d89a/"},{"title":"计算机四级网络工程师思维导图--操作系统部分","date":"2021-01-11T05:10:30.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2021-01-11T05:17:36.000Z","content":"计算机四级网络工程师考试快开始了。这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~\n此部分为操作系统部分~\nPS:\n思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~\n图片高清，但文字较小也很长，可以点击图片后放大学习哦~\n一、操作系统原理\n二、操作系统运行机制\n三、进程线程模型\n四、并发与同步\n五、内存管理\n六、文件管理\n七、I/O设备管理\n八、死锁\n","plink":"https://dxsummer.gitee.io/posts/14238658/"},{"title":"计算机四级网络工程师思维导图--计算机网络部分","date":"2021-01-11T05:02:56.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2021-01-11T05:17:36.000Z","content":"计算机四级网络工程师考试快开始了。这里总结和整理了相关的常考重点的思维导图，挺实用的，希望对大家有用哦~\n此部分为计算机网络部分~\nPS:\n思维导图来自微信公众号“方大熊”，自己做了稍微的整理，希望大家喜欢呀~\n图片高清，但文字较小也很长，可以点击图片后放大学习哦~\n一、网络技术基础\n二、局域网基础\n三、Internet基础\n","plink":"https://dxsummer.gitee.io/posts/2c5f6205/"},{"title":"计算机四级网络工程师知识点","date":"2021-01-11T04:57:24.000Z","date_formatted":{"ll":"2021年1月11日","L":"2021/01/11","MM-DD":"01-11"},"updated":"2021-01-11T05:00:34.000Z","content":"马上计算机考试了呢。相关的四级网络工程师的知识点也很重要呀~自己从网上下载并花时间整理了相关的资料，下面内容是经过总结而成~请放心食用！\nPS:以下内容为长文档，内容很多，建议配合文章目录学习哦\n\n操作系统原理一、操作系统概述1.操作系统（1）概念\n是计算机系统的一个系统软件，能有效地组织和管理计算机系统中的硬件和软件资源，合理（公平对待不同用户程序，不发生“死锁”和“饥饿”）组织计算机工作流程，控制程序的执行，并向用户提供各种服务功能，使用户能灵活、方便、有效地使用计算机，并使整个计算机系统高效运行；位于硬件之上，支撑软件（软件的编制和维护）之下。\nA.应用角度看主要作用：提供人机交互接口（提供给用户的接口是命令输入和系统调用）；B.软件开发角度看作用：软件开发的基础平台；C.安全保护角度看作用：第一道安全防线；D.系统发展角度看作用：虚拟机和扩展机\n（2）特性\nA.并发性：执行期间具有相互制约关系；程序与计算不再一一对应；结果不再现并发过程失去封闭性；B.共享性：CPU、内外存储器、外部设备；C.随机性（异步性）：何时退出？假死？中断？关机？重启？\n（3）功能\nA.进程管理：对CPU进行管理。包括进程控制（创建、撤销结束进程以及控制运行时候的各种状态转换）、进程同步（处理进程之间同步或互斥关系）、进程间通信（信息交换）和进程调度（按照一定算法从就绪队列中挑选一个进程让CPU执行它）；B.存储管理：管理计算机内存资源。包括回收与分配内存、存储保护（考虑程序可能发生越界的情况）和内存扩充（借助虚拟技术在逻辑上增加进程运行空间）；C.文件管理：文件存储空间的管理（管理/创建/删除/命名文件）；文件目录管理；文件系统的安全性（读写和存取权限）D.设备管理：除CPU和内存之外的所有输入输入设备，复杂外部设备分配和故障处理。技术包括：中断技术、通道技术、虚拟设备技术和缓冲技术。E.用户接区（作业管理）：\n（4）常见的操作系统\nUbuntu、Windows、Unix、DOS、BSD\n2.操作系统分类按页面使用环境和功能特征\n（1）批处理系统：分单道批处理系统和多道批处理系统，其中多道批处理效率和吞吐量较高但缺少人机交互性；指令有特权指令和一般指令；（2）分时系统：多用户共同、交互使用系统；独占性（用户感觉）；及时性（3）实时系统：多路性，及时性，交互性，可靠性，有过载防护能力\n按计算机体系结构分类\n（1）个人操作系统（2）网络操作系统：主从关系明显；有限制共享资源；（3）分布式操作系统：统一配置，所有主机使用一个操作系统；资源共享；相互通信；（4）嵌入式操作系统：成本低交互式系统是指用户交互式地向系统提出命令请求，系统接受每个用户的命令，采用时间片轮转方式处理服务，并通过交互方式在终端上向用户显示结果。多级反馈、时间片轮转和高优先级适用于交互式操作系统。\n3.操作系统结构（1）整体式结构：功能划分成多模块；（2）层次式结构：单向调用，同层不调用；（3）微内核结构（C/S结构）：将大多数的操作系统由用户进程实现；分割成多个部分，每一部分只处理一方面的功能，如文件服务、进程服务与服务器通信；特点：高可靠性、高灵活性、适合分布式处理、可移植性强、融入面向对象技术，但效率低，不适合频繁通信；微内核具备：线程调度、虚拟存储、消息传递、设备驱动、内核原语操作以及中断处理。\n4.指令（1）特权指令：包括输出指令、停机指令等，只有在监控程序才能执行特权指令，只能在内核状态（管态）下运行（屏蔽中断、关闭中断）；（2）一般指令：用户态下运行（关机、读文件、设置时间），管态下也可以执行。如果用户程序在用户态（目态）执行特权指令，则引起访管中断，这也是CPU由用户态向核心态转换的方法。\n5.临界资源、可重写入代码和不可重用资源（1）临界资源：（2）可重写入代码：硬盘，内存；（3）不可重用资源：时间片到时、硬件时钟到时\n6.三类接口可供用户使用（1）命令接口：提供一组命令供用户间接/直接操作；（2）程序调用：一组系统调用命令组成，是操作系统提供给编程人员唯一接口，调用命令供用户程序使用；（用户编程需要打印输出，提供指令：write()）（3）图像界面接口：图标、菜单、窗口，形成一个直观易懂，使用方便的计算机操作环境，终端窗口采用命令行。\n7.设备分配算法中，数据结构主要包含四个表分配顺序是系统设备表（SDT）、设备控制表（DCT）、控制器控制表（COCT）、通道控制表（CHCT）。\n8.程序状态字（PSW，专门的寄存器指示处理器状态）（1）包含：CPU工作状态码（指明管/目态）；条件码（指令结果）；终端屏蔽码（是否允许中断）；（2）状态标志：CF（有进位）、ZF（为零）、SF（符号）、OF（溢出）、TF（陷阱）、IF（中断屏蔽）、VIF（虚拟中断）、VIP（虚拟自断待决）、IOPL（IO特权级别）\n二、操作系统运行机制1.CPU中的存储器（1）用户可见寄存器：主要用于各种算术逻辑指令和访问指令（数据寄存器、地址寄存器、条件码寄存器）（2）控制和状态寄存器：用于控制处理器的操作（程序计数器PC、指令寄存器IR、程序状态寄存器PSW）\n2.中断与异常的分类（1）中断：（外部事件引起的）时钟中断；输入输出中断（键盘输入）；控制台中断；硬件故障中断；网卡上数据区满（数据传输完成）；（堆栈溢出）；（被0除）（2）异常：（内部事件引起的）程序性中断（执行指令产生的结果）；访管指令中断（被清零）；\n3.系统调用（1）概念：运行在用户态（CPU在用户程序中执行）被调用程序在系统态（CPU在系统程序中执行）；系统调用可嵌套使用，即一个被调用过程执行期间还可以调用另一个，一般可多次调用但不能无限制调用；（2）分类：进程控制类（创建/终止进程）、文件操作（打开）、进程通信类、设备管理类（请求/释放设备）、信息维护类（时间日期）；（3）参数传递：由陷入指令自带参数（只能携带几个）；通过寄存器传递参数（内存开辟专门的堆栈传递参数）；（4）一般调用在，被调用过程执行结束后，会直接返回调用程序；系统调用在结束调用，首先会对所要求的进程进行优先级分析，若调用进程不具备高优先级则会产生重新调度；\n三、进程线程模型1.多道程序环境特点独立性；随机性（输入输出都是随机的）；资源共享（导致执行速度制约）。\n2.进程（1）概念：计算机程序（指令、数据组成）关于数据集合上的一次运行活动，是资源分配的基本单位；（2）特点：并行性；独立性（独立资源分配单元）；异步性（不可预知速度的向前推行）；动态性；交往性。（3）组成：PCB、指令和数据三部分组成；（4）进程控制块（PCB）A.组成：进程名、进程号、存储信息、进程标识符、进程优先级、进程当前状态、资源清单、消息队列指针、进程队列指针、打开当前文件等调度信息和PSW、时钟、界地址寄存器等现场信息；B.组织方式：线性方式、索引方式、链接方式、队列方式（就绪队列、等待队列、运行队列）；C.特征：是进程的灵魂；必须常驻内存；PCB的运行状态只可以通过操作系统读取。（5）进程控制：通过原语实现对进程在整个生命周期中各种状态间的转换；用于进程控制的原语一般有创建进程、撤销进程、挂起进程、激活进程、阻塞进程、唤醒进程以及改变进程优先级等。（6）创建进程：A.步骤：申请空白PCB；为新进程分配资源；初始化PCB；将新进程插入就绪队列末尾。B.创建进程的时机：用户登录；系统初始化；用户系统调用；初始化批处理作业。\n3.进程状态及转换（1）三状态模型：运行状态、就绪状态、等待状态（阻塞状态）。其中运行状态转换到就绪状态有3种可能性：时间片用完；进程创建完成；被调度程序强占CPU（对于非强制式是：“一个进程运行结束”）；运行状态转换阻塞状态：请求系统服务、启动某种操作、新数据尚未到达、无新工作可做。（2）五状态模型：运行、就绪、阻塞、创建、结束。Linux上进程有五种状态：运行、中断、不可中断、僵尸状态、停止状态。（3）七状态模型；运行、就绪、阻塞、创建、结束、激活（外-&gt;内）、挂起（内-&gt;外）。\n4.线程（1）概念：进程中的实体，不能独立于进程存在；是CPU调度和分派的基本单位；不同的线程可以执行相同的程序；同一进程中各线程共享内存空间；自己不拥有系统资源，只拥有一点运行中必不可少的资源；每个线程有一个标识符和一张线程描述表，记录了线程执行的寄存器和用户栈等现场；（2）特点：花费开销少、切换花费时间少、内部通信快、能独立工作；（3）线程操作含义：\n\npthread_join：等待一个特定的线程退出；pthread_yield：线程让出CPU（主动释放）；\n\npthread_creat：创建线程库函数；pthread_exit：结束一个线程的库函数\n5.CPU调度分类高级调度（创建进程）、中级调度（调入内存）、低级调度（分配CPU）。\n6.调度（1）功能：记录系统中所有进程执行状态；从就绪队列中选出一个CPU分配给它；选中PCB有关现场信息（PSW、通用寄存器等）送往CPU的寄存器中，让他占用执行。（2）时机：CPU资源让出来不一定调度，CPU资源占用一定不调度；可强占方式（当优先级高的进程运行存在时，立即进行调度，转让CPU资源）与不可强占方式（进程执行完毕才释放CPU）。（3）调度算法：先来先服务FCFS（不可强占）；最短时间作业算法SJF；轮转法RR；最高响应比优先算法HRRF（介于FCFS与SJF之间的折中算法，即考虑等待时间又不使长作业等待时间过长）；多级反馈队列。操作系统不能在运行中动态改变进程调度算法。\n四、存储管理方案1.进程互斥的解决办法竞争各方平等协商；引入进程管理者\n2.计算机中资源共享的程序可分为三个层次（1）互斥；利用硬件解决的互斥方法简单、支持多个临界区、适用范围广；不能实现“让权等待”；（2）死锁：（3）饥饿：\n3.临界资源分成四个部分（1）进入区：（P原语）；while TS(&amp;lock)（2）临界区：访问临界资源的一段代码；n=fetch(balance)（3）退出区：（V原语）lock=FLASE（4）剩余区：代码其余的部分output(list)\n4.进程同步机制应遵循的准则空闲则入、忙则等待、有限等待、让权等待。\n5.信号量（1）只能通过初始化和两个标准的原语来访问；（2）初始化可指定一个非负整数值，表示空闲资源总数；若为负值，其绝对值表示当前等待临界区的进程数；P(empty) V(full)（3）同步：信息量empty，初始值K；信号量full，初始值0互斥：信号量mutex，初始值为1.（占用为1空闲为0）（4）系统直接通信时，发送原语：send(receiver,message)\n6.管程（1）定义了一个数据结构和能为并发进程所执行的一组操作。进程可在任何需要的时候调用管程中的过程，但它们不能在管程之外什么的过程中直接访问管程数据结构；管程能保障共享资源互斥执行；是一种同步机制；将共享变量及对共享变量的操作封装在一起（2）任一时刻中，管程中只有一个活跃进程；所有临界区转换成管程，则只许一个进程使用临界区内代码。管程本身无法保证互斥；（3）管程对象：共享的数据结构和一组操作过程。（4）为解决进程同步关系，引入条件变量，在条件变量上实施P、V操作；\n7.进程间的通信（1）共享内存：用于多个进程并发执行且相互通信，适合传输大量信息；设置一个公共内存区，一组向其中写，一组从公共内存读；不需要在系统中产生多份相同的拷贝。（2）消息机制：利用内存中若干缓存区组织成队列，依赖进程或基础框架来调用实际执行的代码；缓冲区中包括：消息缓冲区、消息指针、互斥信息量、同步信息量、发送和接收原语。（3）管道通信：通过两个进程，打开一个共享文件，实现进程间的通信；字符流形式联系，不足是通信速度较慢。（4）信箱通信：发送进程首先创建一个链接两个进程的通信机制，然后把向信息送入该机制；发送进程和接受进程不直接联系，接收进程可以在任何时刻从该机制中取出信息。\n8.PV操作PV操作可以实现两个进程互斥、进程同步和进程前趋关系；PV同步机制缺点：可读性差、不利于修改和维护、正确性差；P操作一次减一，V操作一次加一。\n9.可以实现进程互斥的算法Peterson算法、TS指令、Swap或Exchange命令、信号量；\n10.进程之间的关系有\n相互感知交互关系一个进程对其他进程的影响潜在控制问题\n\n相互不感知竞争两进程的结果无影响互斥、死锁、饥饿\n\n直接感知通信协作一个进程依赖其他进程死锁、饥饿\n\n间接感知共享协作一个进程依赖其他进程互斥、死锁、饥饿\n11.地址重定位将逻辑地址转换成绝对地址；动态重定位（每条指令执行时；需要软件硬件相互配合实现，其中硬件包括基址寄存器和一个地址转换线路组成）和静态重定位（程序执行前已转换好地址）。\n12.内存管理（1）单一用户管理：一个时间内，一个用户进程独占内存；（2）分区管理：固定分区；可变分区（空闲分区策略：最先适应算法、最优适应算法、最坏适应算法、下次适应算法）；可以满足多道程序设计且设计上最简单；内存使用不充分、较为严重碎片、不能提供虚拟内存、受物理内存不足限制。利用移动技术，可以实现碎片整合；利用交换技术，在磁盘上保存内存放不下的进程（代码、PCB和数据），需要时再装入内存中，是由操作系统控制。（3）页式管理：把一个逻辑地址连续分散存放到几个不连续的内存区域。不要求作业或进程的程序段和数据在内存中连续存放，从而有效解决“碎片”多的问题；动态页式管理提供了内存和外存统一管理的虚存实现方式，提高了存储空间利用率；页面大小可以改变但用户不可以动态改变页面大小。通常管理空闲物理内存的方法有：空闲块链表法、位示图、空闲页面表。A.空闲块的分配和回收：采用主存分配表、位示图和页表方式；页表中，存储块号与页号一一对应，一级页表共需访问内存2次完成数据提取；二级页表每执行一条指令至少需要访问3次内存；B.快表（TLB）存放在高速缓存（介于主存和CPU之间的存储器，高速缓存器与内存之间信息调度和传送是通过硬件完成的）中；页式虚拟存储管理，部分页在内存中，其余在外存中（磁盘文件区），需要用到：请求调用页和预调页策略。C.置换策略有：固定分配局部置换、可变分配全局置换、可变分配局部置换；（固定/可变指：块数是否可变；局部/全局：指作业以内或外）D.页面置换算法：FIFO：会出现Belady现象，随着分配给进程的物理页面增加，缺页率增加；LRU：最近最久未使用算法，需要记录访问位；LFU：最近最不经常使用算法，当前时间访问次数最少，需要访问计数器；NRU：最近未使用页面置换算法，需要记录访问位；CLOCK：时钟算法，需要记录访问位；理想页面置换算法（4）段氏管理：存储以段划分；（5）段页式管理：先分段、再分页、每页对应块、可连续可不连续存储。其中，页式、段氏式和段页式管理可以与虚拟存储技术结合使用。\n13.链接提高检索速度、节省存储空间的软链接，把所有编译后得到的目标模块连接装配起来，再与函数库想连接成一个整体的过程。\n14.虚拟页面存储管理（1）存在问题：页面抖动、Belady现象、缺页中断、页面写错误。（2）解决办法：采用工作集算法可以缓解页面抖动（操作系统为每一个进程保持一个工作集，工作集随时间而变化，每个进程提供与工作集大小相等的物理界面）（3）需要的硬件支持：足够大内外存；虚拟地址到物理地址映射机制；缺页中断处理机制。\n15.碎片（1）内碎片：分配出内存，没有得到利用。固定分区、页式、段页式（2）外碎片：内存空间无法满足分配要求。可变分区、虚拟段式。16.进程中断，选中一个页面进行淘汰时，只需将页面移除，修改页面有效位，其余标志位不变；当创建一个新进程，装入一个页面，对应页表项中的：内存号、驻留位、访问位需要修改；当页面被修改时，需要修改的位：访问位、修改位；将页面调入内存，需要修改位：内存号、驻留位、访问位。\n17.虚拟存储器（1）在虚拟存储系统中，进程的部分程序装入后便可运行；（2）虚拟存储技术允许用户使用比物理内存更大的存储空间；（3）虚拟内存必须有硬件支持。\n18程序的局部性分空间局部性和时间局部性，空间局部性是指一旦程序访问了某个存储单元，其附近的存储单元也将被访问，程序代码执行具有顺序性。时间局部性指程序在执行时呈现出局部性规律，即在一段时间内，整个程序的执行仅限于程序中的某一部分。\n五、文件系统设计与实现技术1.文件分类（1）按用途分：系统文件、用户文件、库函数文件；（2）按组织形式：普通文件、目录文件、特殊文件（Unix中I/O设备被视为特殊文件）；（3）保护方式：只读文件、读写文件、可执行文件、无保护文件；（4）存放实限分类：临时文件、永久文件、档案文件；（5）组织结构：逻辑文件（用户可见；无结构的字符流式文件、定长记录文件和不定长记录文件构成的记录树）、物理文件（存放在磁盘上：顺序文件、链式文件、索引文件）\n2.文件物理结构即文件存储的结构；顺序结构、链接结构、索引结构；\n\n存储介质磁带磁盘\n\n物理结构连续结构连续 链接 索引（多级索引）\n\n存取结构顺序顺序 顺序 顺序\n\n随机 &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp随机\n3.磁盘（1）寻访时间：寻道时间（最长）、延迟时间、传输时间（最短）；（2）磁盘调度：FCFS、SSTF（最短寻道时间，容易引起饥饿现象）、SCAN（电梯算法，来回服务）、C-SCAN（循环扫描，单向）\n4.文件目录实现按名存取，包含文件名和文件的起始地址，用以建立文件名（&lt;255字符）与存储地址的对应关系；必须信息：FCB、文件结构信息和文件管理信息。（1）FCB包含：文件名、文件号、用户名、文件物理地址、文件长度、口令、修改/访问/建立时间；（2）管理形式分：一级目录、二级目录、树型目录（搜索快；层次清楚；解决不用用户文件重命名问题；用户不可以创建根目录）（3）路径名搜索：全路径名和相对路径（加快搜索速度）；\n5.存储空间的分配与回收（文件存储空间的管理方法）位示图、空闲块表、空闲链表、成组链接表（UNIX）。\n6.文件系统（1）优化：块高速缓存；合理分配磁盘时间；磁盘驱动调度；目录项分解；（2）FAT：是文件分配表；链接结构；FAT16表示16位簇号，支持8个字符文件名；（3）安全：建立副本、定时转存、规定文件的存取权限。（4）文件存储空间：分配单位数据块；（5）从用户角度：建立文件系统的目标是实现“按名存取”；&amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp &amp;nbsp从系统角度：看文件系统主要关注文件存储位置；\n7.打开文件时，系统要完成的（1）根据文件名查找目录，找到FCB；（打开文件第一步，继续open()操作，将FCB写入内存）（2）根据打开方式，共享说明和用户身份检查，访问合格性；（3）根据文件号，打开文件表，看文件是否被打开；（4）在用户打开文件中取一空表项，填写打开方式等，并指向系统打开文件表对应的表项；\n8.物理结构是文件的逻辑块到磁盘号的转换；\n9.外存储存取过程读状态–&gt;置数据-&gt;置地址-&gt;置控制-&gt;读状态\n10.创建文件操作过程检查文件名是否合法；同目录下是否重名；目录中是否有空闲位置；填写目录项内容（文件名、用户名、存取权限、长度置零、首地址）；\n11.文件描述符内核利用文件描述符来访问文件。文件描述符是非负整数，打开现存文件或新建文件时，内核会返回一个文件描述符，读写文件也需要使用文件描述符来指定待读写的文件。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。\n2.对文件的操作（1）关闭文件操作：系统根据用户提供的文件名/文件标识符查找FCB；在该FCB的相关内容做修改；置FCB为“非活跃”；写回磁盘。（2）删除文件操作：查找文件；检查删除合法性；收回FCB资源；收回文件存储空间。（3）访问文件：首次访问时通常访问文件路径名，之后对文件访问通常使用文件描述符。\n六、I/O设备管理1.设备分类（1）按共享属性：独占设备、共享设备（磁盘）、虚拟设备；（2）按信息组织方式分类：块设备（磁盘/磁带，一般512B-4KB）；字符设备（键盘、显示器、打印机）；\n2.I/O硬件CPU和主存（中央部分）；接口；外围设备控制器（内有寄存器）；外围设备\n3.I/O设备数据传输控制方式（1）程序直接控制方式：“忙-等待”（2）中断控制方式：实现了主机和外围设备的并行工作；CPU是不是会跑去看数据是否可以输入输出；适用于键盘以字符为单位读取方式；关键硬件中断控制器、地址总线和数据总线、设备控制器；（3）DMA：对输入/输出设备由DMA完成，在DMA控制器的作用下，设备和主存之间可以批量进行数据交换，而不用CPU干预；“窃取”总线控制权；适用于对块设备的存取；DMA控制器、地址总线和数据总线；（4）通道控制方式：工作在内存中；实现外围设备的统一管理和外围设备与内存之间的数据传输；所需CPU干预更少；可以实现CPU、通道和输入输出设备三者之间的并行操作；适用于现代计算机内的大量数据交换；主要限于与I/O操作有关的指令和程序；通道控制器、地址总线、数据总线、设备控制器和通道程序代码；分数据选择通道、字节多路通道和数组多路通道。\n4.I/O软件分层中断处理程序（设备硬件）；设备驱动程序；与设备无关的系统软件（设备独立层）；用户控件的I/O软件（用户层）\n5.设备无关层实现功能（提供一致的系统调用）（1）统一命名：实现逻辑设备命名与物理设备的转换；（2）设备保护；（3）缓冲：对不同速度的设备使用缓冲区来匹配；（4）提供与设备无关的逻辑块；（5）独占设备的分配和释放；（6）出错处理：向用户报告出错处理情况；（7）存储设备的块分配。\n6.I/O设备管理（1）设备表：建立逻辑设备与物理设备之间的对应关系；（2）设备管理任务：缓冲区管理、设备分配（需要考虑：设备固有属性；设备分配算法；设备分配安全性；设备独立性）、设备处理、虚拟设备以及实现设备独立。（3）引入技术：缓冲技术、设备分配技术、SPLOOING技术、DMA技术、通道技术。（4）缓冲池管理：实现进程访问缓冲区同步。\n7.SPOOLING组成输入井和输出井、输入进程和输出进程、输入缓冲区和输出缓存区。\n七、死锁1.死锁在对资源的管理、分配和使用不当，会产生死锁现象；（1）产生原因：竞争资源；进程推进顺序不合理。（没有“调度不合理”的原因）（2）产生必要条件：互斥条件（资源互斥使用）；不可剥夺条件（已分配资源不可剥夺）；请求和保持条件（申请占有一部分资源，继续占用已分配的资源，部分分配资源）；循环等待条件（前一个进程拥有后一个进程所请求的资源，资源申请形成环路）；（3）进入阻塞状态，无法被唤醒。\n2.饥饿当等待时间进程推迟和响应带来明显影响时；\n3.活锁“忙等待式”，没有阻塞，可被调动，但无进展（不主动放弃CPU）；饥饿：“阻塞状态”，没有阻塞，但被无限推后，（主动放弃CPU）；\n4.解决死锁方法（1）预防死锁：“资源有序分配法”；SPOOLing系统的建立；一次分配所有资源；剥夺其他进程的资源。（静态分配，分配时加锁）（2）避免死锁：银行家算法；（3）死锁检测：定时运行资源分析程序；（4）剥夺资源法、撤销进程法和重启。\n5.几种死锁类型（1）同类资源死锁：“P1申请一页内存，P2申请一页资源…….”；（2）不同类资源死锁：“P1拥有设备A请求设备B，P2拥有设备B请求A”；（3）PV操作互斥死锁：“P1、P2先进行同步信号量P操作，再进行互斥信号量P操作”；（4）临时资源死锁：“P1等待P2发来信件Q后向P2发送信件R，P2等待P1发来信件R后向P1发送信件Q”。\n计算机网络一、网络技术基础1.网络分类（1）宽带城域网（MAN）：双环光纤传输；FDDI；（2）无线局域网（WLAN）；（3）无线自组网（Ad hoc）（自组织；对等；无线网络）；（4）无线传感网（WSN）：Ad hoc与传感器技术结合；（5）无线网状网（WMN）：用于扩大范围；对Wimax和WLAN的补充\n2.操作系统（1）Unix操作系统：小型机、C语言（第一版本由汇编语言编译）、部分开源；集中式、多用户，多任务，分时操作系统；贝尔公司开发；IBM—AIX SUN公司—Solaris HP—HP-UN（2）Linux操作系统：继承了Unix以网络为核心的设计，核心部分：内核；开源操作系统；版本很多；由不同组织管理维护；不是Unix操作系统的变种。Red Hat（3）Windows NT是微软公司开发的闭源系统；采用32位操作系统，可以提供全面的网络服务功能；基于不对等结构，分Windows NT Sever和Windows NT Workstation。\n3.拓扑结构（1）环型拓扑：传输延时确定；（2）网状拓扑：广域网普遍使用；\n4.数据报方式和虚拟电路方式（1）数据报方式（分组存储转发）：同一报文不同分组可以通过不同的传输路径；不同分组可能会出现乱序、重复和丢弃现象；分组均携带源地址和目的地址；延迟大，不适宜报文会话式；（2）虚电路方式：传输之前在源节点和目的节点之间建立逻辑连接；每个结点可以与任意结点建立多条虚电路连接，不需要路由选择；一次通信所有分组通过虚电路顺序传输，分组不需要携带目的地址和源地址等信息；结点只进行纠错。\n5.网络体系结构（1）ISO建立的OSI（开放系统互联）模型：A.物理层（透明传输比特流）、数据链路层（MAC&amp;LLC）、网络层（选择路由IPSec）、传输层（端到端服务）、会话层、表示层（加密/解密）、应用层（提供应用进程交换和远程操作）；（2）TCP/IP模型：IETF制定的A.主机-网络层、互联层（IP/ARP/ICMP）、传输层（TCP\\UDP）、应用层（FTP\\HTTP\\RIP\\NFS\\SMTP\\Telnet\\SNMP\\CIMP\\PGP\\S/MIME\\）B.开放式网络协议标准；与网络硬件无关；每一层服务上一层\n6.计算机网络以能够相互共享资源方式互联起来的自治计算机系统集合。\n7.ARPANETInternet的始祖，是世界范围内的广域网，是世界上开发的第一个运营的封包交换网络（分组交换网络技术），是美国国防部高级研究计划局研究的网络。\n二、局域网技术1.局域网三要素（1）网络拓扑：总线型、环型、星型；（2）传输介质：双绞线、同轴电缆（最早）、光纤和无线信道；（3）介质访问：按照介质访问控制方式分为共享介质和交换局域网。其中：共享介质（总线型局域网：利用CSMA/CD避免冲突；环型局域网：利用令牌环控制冲突）\n2.IEEE 802（1）对象：OSI的物理层和数据链路层。专门从事局域网的标准化工作。（不同局域网中，MAC和物理层可以不同，LLC（介质访问控制层）必须相同）（2）分类：802.3：定义CSMA/CD总线型介质访问MAC和物理层标准（以太网标准）；802.4：定义令牌环网的协议标准；802.11：无线局域网标准；802.15：无线个人区域网介质访问MAC和物理层标准；802.16：宽带无线局域网。\n3.共享以太网（1）概念：核心是集线器；ALOHA网络是基础；总线型局域网；核心技术：CSMA/CD；（2）帧结构：间导码7B 帧前定界符1B|目的地址6B源地址6B类型2B|数据46-1500B校验位4B（CRC）（接收同步，不计帧头） （帧头；类型：网络层协议） （帧长64-1518B）（3）以太网物理地址：长度48位，十六进制，两两一组，共6组；前三组生产公司，后三组生产商分配流水号，可分配地址2^47，第一位1则为组/广播；为0才可以分配给生产商。\n4.高速局域网标准（MAC层与原标准兼容，仅定义物理层标准）（1）802.3u：Fast Ethernet，百兆以太网；（2）802.3z：Gigabit Ethernet，千兆以太网，定义多模光纤或屏蔽双绞线；802.3ab：Gigabit Ethernet，千兆以太网，定义单模光纤或非屏蔽双绞线；采用GMII分隔物理层和MAC层；与传统以太网的帧格式一致；（3）802.3ae:10Gigabit Ethernet，万兆以太网，使用光纤传输，只有全双工模式，不存在介质访问控制，传输距离不受冲突检测的限制。（4）802.3ba：40/100Gigabit Ethernet（40Gbps网络使用波分复用技术，100GPS物理接口类型）\n5.交换式局域网（1）概念：典型的是交换式以太网，核心设备：以太网交换机（专用/共享端口）；可以在多个端口之间建立多个并发连接，实现多结点之间的并发连接，（2）帧转发方式：直接交换；存储转发；改进直接交换（接收一帧前64B，检测由主机进行）；（3）虚拟局域网（VLAN）组网方式：用交换机端口定义；MAC地址定义；基于网络层地址（IP）定义；基于广播组定义。\n6.无线局域网（1）按物理层传输方式分类：红外、直接序列扩频、跳频广播、微波；（2）红外无线局域网IR、跳频扩频FSSS（将频带划分为多个信道，使用2.5GHZ的ISM频段）、直接序列扩频DSSS（所有接受结果使用相同频段通信）、窄带微波无线局域网。（3）802.11定义的两种访问方式：无争用服务、争用服务；MAC层采用CSMA/CA避免冲突；支持AP访问模式和漫游访问模式；802.11管理帧为探测帧和认证帧；采用层次结构模型；MAC层主要功能是对无线环境的访问控制；物理层定义了红外、调频扩频与直接序列扩频的数据传输标准。（4）802.11协议族：\n\n802.11a:5HZ54M\n\n802.11b:2.4HZ11M（跳频）\n\n802.11g:2.4HZ54M\n\n802.11n:5G100M\n（5）网络结构为：端站（有无线网卡的用户结点）、接入点（AP）、接入控制器（AC在WLAN与外部网络之间充当网关作用）、AAA服务器（计费、认证、授权；802.11认证有三种：基于IEEE 802.1x的认证、基于PPoE的认证和基于Web的认证）\n（6）1000BASE-SX:多模光纤1000BASE-CX:屏蔽双绞线1000BASE-LX:单模光纤1000BASE-T:非屏蔽双绞线100BASE-FX:单/多模光纤\n7.不能够通信的原因不在一个虚拟子网中；不在一个子网中。\n8.总线局域网的特点所有结点都通过网卡连接到作为公共介质的总线上，通常采用双绞线或同轴电缆作为传输介质；所有的结点都可以发送或接收数据，但在一段时间内只允许一个结点通过总线发送数据（即半双工形式）；当一个结点通过总线以“广播”方式数据时，其他结点只能以“收听”方式接收数据；由于总线作为公共传输介质被多结点共享，因此会出现冲突现象。\n三、Internet基础1.互联网构成通信线路（基础设备）、路由器（主要设备，主要功能：维护路由表信息；转发IP数据报；选择最佳路径）、主机（信息资源和服务的载体）和信息资源。IP协议是Internet中的主要协议。\n2.Internet的接入方式（1）电话线接入；（2）ADSL接入：使用电话线路，完成非对称数据用户线路，ADSL调制解调器：具备网桥、路由器和调制解调的功能；（3）HFC接入：有线电视网接入（混合光纤/同轴电缆），非对称数字用户线路；（4）数据通信线路接入：（成本高）\n3.IP协议（1）定义：IP数据报格式、对数据寻址和路由、数据报分片和重组、差错控制和处理等。（2）IP服务特点：不可靠服务；面向无连接；尽最大努力投递；（一般不随意丢弃报文）（3）IP网络特点：隐藏底层物理网络细节；不制定拓扑结构，不要求网络之间全部互联；在物理网络之间转发数据，信息可以跨网传输；公平对待互联网中每一个网络；使用同一的地址描述法。\n4.IP地址（A\\B\\C\\D\\E类地址）（1）特殊IP地址：网络地址；广播地址（直接广播/有限广播：255.255.255.255）；回送地址（127.0.0.0）；本地地址（A:10.0.0.0/8;B:172.16.0.0/12;C:192.168.0.0/16）（2）若要发送广播：源地址是本机，目的地址：网络号不变，主机号全为1.\n5.地址解析协议ARP（1）工作在互联层，能够实现IP到MAC的解析；（2）工作原理：以广播形式发送请求报文（ARP请求），单播响应；（3）通过高速缓存技术避免大量请求报文出现，提高有效性；拥有计时器的目的是保证主机ARP表的正确性。\n6.IP数据报格式（1）组成：报头区和数据区；（2）数据报各字段及其功能：版本和协议类型；长度；服务类型；生存周期；头部校验和域（保证报头完整性，没有数据区校验字）；（3）报头长度：32bit双字节为单位；总长度以8bit字节为单位。包含与分片和重组有关：标识（原数据是谁）、标志（是否是最后一片）和片偏移（顺序重组）\n7.IP封装、分片（MTU:最大传输单元，一帧携带最多能携带的数据量。）和重组。8.IP数据报选项（1）目的：控制和测试；（2）选项数据：A.源路由：严格路由（严格按照路径转发）；松散路由（规定主要路由）；B.记录路由：记录经过的所有路由IP；C.时间戳\n9.差错与控制一个ICMP报文对应一个数据报（1）ICMP差错控制报文：拥塞控制（源抑制报文）、路由控制（重定向报文）；（2）请求/应答对：回应请求与应答（用于测试目的主机或路由器的可达性）、时间戳请求与应答（同步时间）、掩码请求与应答；（3）ICMP特点：不享受优先权和不享受特别的可靠性；报告伴随丢弃；报文包含IP数据报头和数据前64比特数据。（4）当路由器收到IP数据报，对IP数据报进行检测，当对其首部进行校验后发现数据报存在错误时，将抛弃该数据报。\n10.路由器与选择（1）特殊路由：默认路由、待定主机路由（制定到达的主机）（2）RIP协议（路由器信息协议）：采用V-D算法（距离-矢量算法），简单、中小型网络、多路径、动态IP互联网环境；距离按跳数计算；慢收敛（解决：限制路径最大距离；水平分割对策；保持策略；带触发刷新的毒性逆转对策）（3）OSPF协议：采用L-S算法（链路-状态算法），大型网络、多路径、动态IP互联网环境；每个路由都有一个LSA，最终获得一个LSDB（链路状态数据图），收敛比V-D算法快。\n11.IP组播技术（1）特点：使用组地址（D类地址）；动态组播地址，成员也是动态；不仅通过IP层，还与要底层硬件支持功能。（2）相关协议：组播管理协议（IGMP,CGMP）、组播路由协议。IGMP：Internet制定的，一方面主机通过本地路由器主动加入；一方面ICMP协议路由器会周期查询。组播路由由：源地址、组地址、入接口和出接口组成（前三个进行匹配）。\n12.IPv6（1）地址：128位（IPv4:32位）；送回地址（0:0:0:0:0:0:0:1）；（2）数据报格式：一个基本头（固定40B）、多个扩展头和一个高层协议数据单元组成。（3）扩展头种类：逐跳选项报头；目的选项报头；路由报头（强制数据报经过指定路由）；分片头；\n13.TCP与UDP（1）TCP:面向对象，可靠，全双工。（使用窗口机制进行流量控制；RTT算法进行数据丢失与重发；连接端口用12位二进制表示）（2）UDP:非面向连接，不可靠，高效率。（应用程序提供可靠性保障）\n14.NAT内外网地址翻译。分类：静态NAT、动态NAT、网络地址端口转换NAPT（多个内网主机共享一个全局IP地址，同时访问外部网络）\n15.MTU1500字节；一般IP首部为20字节，UDP首部为8字节，数据的净荷部分预留是1472字节；如果超出1472字节，就会出现分片现象。\n四、Internet基本服务1.应用进程响应并发请求分类（1）重复服务器：“先进先出”原则；（2）并发服务器：每来一条请求，创建一个子进程。\n2.对等计算机模型（P2P）基本结构（1）集中式（Napster，服务器通常只存储目录和索引信息）；（2）分布式非结构化（无中心节点；随机图；支持复杂查询；模糊查询；利用TTL机制控制泛洪；Gnutella）；（3）分布式结构化（无中心节点；采用分布式散列表DHT；支持精确关键字匹配查询；可扩展；维护复杂；pastry; tapestry; chord; CAN）；（4）混合式结构（索引结点维护搜索结点在搜索用户结点；skype; BT; pplive）\n3.域名解析方式（1）分类：递归解析（一次完成）、反复解析（分层多次解析）；（2）每一个域名服务器至少知道根服务器的IP地址及其父节点服务器的IP服务地址，才能解析。（本地域名服务器IP地址）（3）提高域名解析的效率：解析从本地域名服务器开始；在域名服务器使用高速缓存技术；在主机上采用高速缓冲技术。\n4.域名对象类型A—主机；MX—邮件交换；PTR—指针；CNAME—别名；SOA—授权开始；HINFO—描述主机信息\n5.远程登录中，网络虚拟终端利用NVT格式将不同的用户本地终端统一起来。6.FTP服务（1）C/S模型，利用TCP建立双向连接（一个控制连接/一个数据连接）；（2）建立联系方式：主动模式（服务器主动，使用PORT命令将端口发送给服务器）；被动模式（服务器被动，向服务器发送PASV命令）（3）FTP文件格式传输方式：文本文件传输（ASCII）；二进制文件传输（BINARY，不对文件格式进行任何变化，按照原始文件相同的位序以连续比特流方式进行传输）；（4）FTP口令描述：delete—删除远程主机上的文件命令；pwd—显示远程主机的当前工作目录；\n7.电子邮件系统（1）SMTP：服务器之间的传递；主要目的是实现发送邮件的。（2）POP3/IMAP：向邮件服务器进行读取（认证阶段、事务处理、更新阶段Quit）；（3）电子邮件报文格式：RFC822、MIME.（4）命令：PASS—用户邮件口令（认证）；STAT—查询报文总数和长度； REST—复位，删除标记，中止当前操作；NOOP—无操作（事务处理）\n8.Web服务（1）HTML：页面规范，解释单元，能够对请求和返回进行页面翻译，显示内容；（2）HTTP：客户机和服务器之间的传输协议，建立在TCP连接上，面向对象协议，精确定义了请求/相应报文；（3）URL：页面地址，统一资源定位器；（4）安全性：SSL协议（工作在传输层协议；位于TCP/IP协议与各类应用层协议之间）（浏览器安全性）（防止第三方偷看内容；防止第三方篡改）；CA证书（Web服务器）（证明自己）（5）浏览器组成：控制单元（解释键盘/鼠标输入命令）、客户单元、解释单元组成。Web服务器不但需要保存大量的Web页面，而且需要接受和处理浏览器的请求，实现HTTP服务器功能。Web服务器不具备编辑Web页面的功能。\n9.安全性（1）如何保护自己的计算机：浏览器将Internet世界划分成几个区域；（2）如何验证站点真实性：利用Web站点传来的证书；（3）如何避免他人假冒自己：用户可以在CA安全认证中心申请自己的证书，放在浏览器中；（4）在与Web交互敏感信息时如何避免第三方篡改或偷看：使用安全套接层技术SSL技术；（5）保证传输机密性：将Web站点放入可信站点区可保证信息传输的机密性；（6）防止病毒传播：使用SSL技术。\n9.网络蠕虫独立、通过漏洞传播、早期利用电子邮件传播、自我复制和主动传播；木马是没有复制能力的。\n五、新型网络应用1.即时通信（IM）（1）由IMPP工作组提出；IETF批准成为正式RFC文件；有RFC2778文件描述功能；该文件未提出即使通信系统必须使用同一标准。（2）模式：客户机/服务器；客户机/客户机\n2.QQ（1）客户机的两种聊天方式：UDP主/TCP辅；服务器中转（无法直接通信）；（2）采用自己私有的即时通信协议 ；（3）每次登陆时客户机会获得一个来自服务器的会话密钥。\n3.即时通信协议（基于SIP的SIMPLE；基于JABBER的XMPP）（1）SIP：工作在应用层；IEFT提出；可在TCP/UDP上传输；支持多种信息类型（文件、视频、图像）；用于创建、修改和释放一个或多个用户会话；分类（用户代理、代理服务器、重定服务器（用于规划SIP路径服务器，可与其他服务器共存一个设备中）、注册服务器）；SIP消息组成（起始行、消息头、一个标志消息头的空行、消息体）；SIP定义的6种请求消息（INVITE：邀请用户/服务器参加一个会话；ACK；OPTIONS:获取服务器相关能力；BYE:终止一次会话；CANCLE:取消挂起呼叫；REGISTER）；SIP消息通常可分为2类，从客户机到服务器的请求消息和从服务器到客户机的响应消息。（2）SIMPLE：以SIP为基础，不需建立会话，支持多媒体会话；IEFT的SIMPEL工作组制定；IM消息以message命令为载体传输，每条IM由单独message命令传输，彼此独立。（3）XMPP：工作在应用层;基于JABBER协议；由IEFT制定；由4个RFC文档组成；设计上延续E-mail系统；包含用户客户端、XMPP服务器、XMPP协议网管；XML是其核心，统一选址方案，实体地址叫做JID。（4）基本服务：呈现服务和即时消息服务。\n4.网络文件共享（1）NFS（网络文件系统）：Linux\\Windows上均可使用；与主机操作系统无关；采用C/S结构；若想远程计算B的某一个文件系统：”mount:B:/usr/lib(远程主机目录)/usr/lib(本机目录)”（2）NFS服务器共享出来的文件或目录都记录在/etc/exports文件中。\n5.Windows LAN文件共享Windows2000以前的系统使用NetBIOS协议；以后使用CIFS协议\n6.P2P文件共享（1）P2P:起源于Napster；BT（中心服务器tracker存放用户信息；种子文件：.torrent，包含存储用户信息和共享文件的信息）；源于MIT开源系统；加入DHT以实现无tracker服务器的文本传输；基于“六度分隔理论”、“世界最小理论假设”、“瓦斯特领导理论”。（2）Maze：支持即时通信；参考Kerberos机制；在线资源搜索和文件目录视图；支持多点下载和断点续传；基于积点的资源交易体系；有种子机制；分布式认证机制（类似于信用卡机制）；类似URL表示文件位置；混合型P2P系统；包括集中式的用户管理服务器（注册、登录）、目录收集服务器、检索服务器、心跳服务器和种子服务器。（3）P2P不支持种子机制；BT系统不支持积点机制；P2P可以实现用户之间直接传输；BT后期系统能够实现无Tracker服务器的文件传输；P2P与BT相互不兼容。\n5.IPTV（1）业务种类：近式点播（NVOD，多个视频流依次间隔发送同样的内容）、真实点播电视（TVOD）和交互式点播（IVOD）;（2）媒体内容分发（MCDN）技术组成：A.内容发布：借助相关技术，将内容发布或投递到距离用户最近的远程服务点；B.内容路由：网络负载均衡技术，重定向路由器以请求最近内容源响应；C.内容交换：根据内容可用性、服务器可用性等，利用应用层交换技术，智能平衡负载流量；D.性能管理：保证网络处于最佳状态，测量内容发布的端到端性能。\n6.VOIP（基于IP网络的语音传输技术）（1）组成：终端设备、网关（号码查询、建立通信、信号调制、压缩和解压缩、路由寻址）、多点控制单元（多终端）、网守（中央控制实体，负责用户注册和管理；消息控制中心；确定网关地址；计费管理；留存呼叫详细记录）（2）Skype：利用VOIP和P2P技术；混合式网络结构；AES算法作为密钥，密钥长度256bit；加密保存好友列表；支持免费多方通信；采用iLBS和iSAC编码技术；系统中SN是动态生成的；可以进行NAT穿越。\n7.搜索引擎组成搜索器、检索器、索引器、用户接口。\n8.ICQ、AOL采用OSCAR通信协议。9.网管模型（一般采用网络管理者-网管代理模型，管理者实际是运行在计算机操作系统上的一组应用程序，代理位于被管理的设备内部，一个管理者可以和多个代理之间进行信息交换）（1）组织模型描述网管系统的组成部分；（2）信息模型描述网管系统的对象命名；（3）通信模型描述网管系统的管理协议；\n六、网络管理与网络安全1.网络管理（1）管理对象：物理介质、计算机设备和网络互连设备（硬件资源）；操作系统、应用软件和通信软件（软件资源）；（2）目标：用户及运营商对网络的有效性、可靠性、开放性、综合性、安全性和经济性。（3）模型：集中式管理和分布式管理（时效好）\n2.网络管理功能（1）配置管理：包含两阶段：网络初次运行的初始配置管理阶段和网络正常运行的工作配置管理阶段；负责网络建设、业务展开和配置维护，达到网络性能最优；包括：设置系统中有关路由操作的参数、被管理对象的名字管理、初始化或关闭被管对象、根据要求收集系统当前状态的有关信息、获取系统重要变化信息、更改系统配置、生成网络拓扑。（2）故障管理：发现和排除故障；维护和监测错误日志；接收错误响应；跟踪辨别错误；（3）性能管理：计算机网络性能；收集统计信息；监控网络使用状况；维护网络使用状况；（4）计费管理（5）安全管理：对授权机制、访问控制、加密和解密关键字的管理。\n3.网络管理协议（1）CMIS和CMIP：由IOS制定；所用功能都要映射到应用层；采用报告机制（委托管理制）；实施复杂且花费高；（2）SNMP：工作在应用层；IETF制定；遵循ISO的管理模型，可以应用于TCP/IP环境下；收集数据的方式有轮询（不断收集，按顺序存储在MIB中，时效低）和基于中断（时效高，需要转发大量信息，消耗管理设备资源时间，改进：trap）两种；SNMP第一版安全性差；第二版提供验证、加密和时间同步机制，在安全性和更有效的传递管理信息方面加以改进；\n4.信息安全等级（1）美国制定（DOD5200.28-STD）：非安全保护类：D（客户机系统）；自主保护类：C1、C2（存取控制，以用户为单位）强制性安全保护类：B1（标记安全保护）B2（结构化安全保护）B3（安全域机制保护）A1（2）中国制定：自主保护级、指导保护级、监督保护级、强制保护级、专控保护级\n5.OSI安全框架（X.800）中安全攻击类型（1）被动攻击：不更改信息，窃听检测，内容泄漏，流量分析（重在预防）；（2）主动攻击：更改信息，消息篡改，DOS攻击，消息重放，拒绝，伪装（重在检测）；（3）服务攻击：针对特定服务攻击；邮件炸弹；端口攻击；分布式拒绝服务攻击；（4）非服务攻击：基于网络层或底层协议漏洞攻击；源路由攻击，地址欺骗，NetXray攻击。\n6.对称密码（1）DES：分组长度64位，分组置换，密钥长度56位；美国NIST采纳；（2）三重DES：多个密钥对DES进行三次加密；（3）高级加密（AES）：分组长度128，分组置换，密钥长度128,192或256位，性能不低三重DES；（4）Blowfish算法：可变长度密钥，分组长度64；（5）RC5：分组长度和密钥长度均变。\n7.非对称密钥（公钥密码）（1）RSA算法：发明者姓名命名；分组密码；加密强度取决于密钥长度（概率加密方法）；质数值越大，破解越难；（2）ElGamal算法：公钥密码体制和椭圆曲线加密体系；基于离散对数；常用于数字签名；密文是明文的两倍。（3）背包加密算法：目前一次背包不安全；\n8.密钥的验证认证中心（CA），验证实体身份；产生证书，将公钥和身份绑定；证书由CA进行数字签名；认证后公钥的发布不受限制；保管用户的公钥；\n9.认证技术（1）消息认证的方法：认证消息来源；认证信息的完整性；认证信息的序号和时间。（2）认证模式：单向和双向；（3）认证函数：信息加密函数；信息认证码；散列函数（Hush，消息通过散列函数生成摘要。MD5同步处理可得到128位摘要）（4）数字签名：防止抵赖（5）身份认证：口令认证、持证认证和生物识别；协议有Kerberos（对称密钥；TCP/IP环境下；美国麻省理工）、X.509（公钥体制；CCITT制定）\n10.安全电子邮件（应用层）（1）PGP：数字签名采用DSS/SHA或RSA/SHA；压缩：ZIP；兼容：64-BASE（2）S/MIME：支持数据加密和数字签名；\n11.IPSEC网络层安全协议；将互联层改造为逻辑连接的层；主要有身份认证头（AH）协议（对于发送方提供源身份认证和数据完整性，没有提供秘密性）和封装安全负载（ESP）协议（提供源身份认证和数据完整性，提供了秘密性）；源主机与网络主机进行握手并建立网络逻辑连接，该逻辑通道成为安全协议（SA）；SA定义的逻辑连接是单工的，三元组。\n12.防火墙分类（1）包过滤路由器：根据IP数据包进行处理，决定转发或丢弃；（2）应用级网关：代理服务器；（3）电路级网关：不允许端到端直接TCP连接；（4）堡垒主机。\n13.公钥加密和数字签名技术建立的安全基础设施为：PKI14.密钥分发中心（KDI）是一个独立的可信的服务器；对称密钥；知道每个用户的密文，可一次性方法密钥，与客户通过密文传输。\n15.安全电子交易协议SET安全电子交易协议SET是一种应用于Internet环境下，以信用卡为基础的安全电子交付协议，它给出了一套电子交易的过程规范。通过SET协议可以实现电子商务交易中的加密、认证、密钥管理机制等，保证了在Internet上使用信用卡进行电子购物的安全。主要目的是解决信用卡电子付款的安全保障性问题，这包括：保证信息的机密性、保证信息安全传输、不被窃听，只有收件人才能得到和解密信息。（常用于电子商务应用中；防止交易数据被篡改；需要认证中心的支持；验证交易双方的身份）\n","plink":"https://dxsummer.gitee.io/posts/8cc82580/"},{"title":"绘图和数据存储原理","date":"2020-11-30T01:22:20.000Z","date_formatted":{"ll":"2020年11月30日","L":"2020/11/30","MM-DD":"11-30"},"updated":"2020-12-20T08:26:22.000Z","content":"JavaScript的引入行内式行内式是将JavaScript代码作为HTML标签的属性值使用。\n\n 例如    \n\n单击“test”时，弹出一个警告框提示“Happy”。\n1&lt;a href=\"javascript:alert('Happy');\"&gt; test &lt;/a&gt;单击网页中的一个按钮时，就会触发按钮的单击事件。\n1&lt;input type=\"button\" onclick=\"alert('Happy'); \" value=\"test\" &gt;嵌入式 在HTML中运用&lt;script&gt;标签及其相关属性可以嵌入JavaScript脚本代码。\n12345&lt;head&gt;&lt;script type=\"text/javascript\"&gt;     // 此处为JavaScript代码&lt;/script&gt;&lt;/head&gt;外链式外链式是将所有的JavaScript代码放在一个或多个以.js为扩展名的外部JavaScript文件中，通过&lt;src &gt;标签将这些JavaScript文件链接到HTML文档中\n\n在编写JavaScript代码时可以省略type属性\n\n12&lt;script type=\"text/Javascript\" src=\"脚本文件路径\" &gt;&lt;/script&gt;\n优势\n\n利于后期修改和维护\n减轻文件体积、加快页面加载速度\n变量在程序运行期间，随时可能产生一些临时数据，应用程序会将这些数据保存在一些内存单元中。变量就是指程序中一个已经命名的存储单元，它的主要作用就是为数据操作提供存放信息的容器。\n","plink":"https://dxsummer.gitee.io/posts/1b3d4e9a/"},{"title":"过渡、变形和动画","date":"2020-11-23T01:05:48.000Z","date_formatted":{"ll":"2020年11月23日","L":"2020/11/23","MM-DD":"11-23"},"updated":"2020-11-28T04:49:58.000Z","content":"过渡效果transition-property指定应用过渡效果的CSS属性的名称\n1transition-property: none | all | property;\n属性值描述\n\nnone没有属性会获得过渡效果。\n\nall所有属性都将获得过渡效果。\n\nproperty定义应用过渡效果的CSS属性名称，多个名称之间以逗号分隔。\ntransition-duration过渡效果花费的时间\n默认值为0，常用单位是秒（s）或者毫秒（ms）。\n1transition-duration:time;transition-timing-function规定过渡效果的速度曲线，默认值为“ease“。\n1transition-timing-function:linear|ease|ease-in|ease-out|ease-in-out|cubic-bezier(n,n,n,n);\n属性值描述\n\nlinear指定以相同速度开始至结束的过渡效果，等同于cubic-bezier(0,0,1,1)）。\n\nease指定以慢速开始，然后加快，最后慢慢结束的过渡效果，等同于cubic-bezier(0.25,0.1,0.25,1）。\n\nease-in指定以慢速开始，然后逐渐加快（淡入效果）的过渡效果，等同于cubic-bezier(0.42,0,1,1）。\n\nease-out指定以慢速结束（淡出效果）的过渡效果，等同于cubic-bezier(0,0,0.58,1）。\n\nease-in-out指定以慢速开始和结束的过渡效果，等同于cubic-bezier(0.42,0,0.58,1）。\n\ncubic-bezier(n,n,n,n)定义用于加速或者减速的贝塞尔曲线的形状，它们的值在0~1之间。\ntransition-delay规定过渡效果何时开始\n默认值为0，常用单位是秒（s）或者毫秒（ms）\n正数:过渡动作会延迟触发。\n负数：过渡动作会从该时间点开始，之前的动作被截断。\n1transition-delay:time;transition 复合属性transition属性是一个复合属性，用于在一个属性中设置transition-property、transition-duration、transition-timing-function、transition-delay四个过渡属性。\n1transition：property duration timing-function delay;使用transition属性设置多个过渡效果时，它的各个参数必须按照顺序进行定义，不能颠倒。例如：\n1transition:border-radius 5s ease-in-out 2s;\n无论是单个属性还是简写属性，使用时都可以实现多个过渡效果。如果使用transition简写属性设置多种过渡效果，需要为每个过渡属性集中指定所有的值，并且使用逗号进行分隔。\n\n变形transform可以让元素在一个坐标系统中变形\n1transform：none | transform-functions;transform属性的默认值为none，适用于内联元素和块元素，表示不进行变形。transform-function用于设置变形函数，可以是一个或多个变形函数列表。\n2D转换平移使用translate（）方法能够重新定义元素的坐标，实现平移的效果\n12transform:translate（x-value,y-value）;transform:translate（100px,30px）;x-value指元素在水平方向上移动的距离，y-value指元素在垂直方向上移动的距离。如果省略了第二个参数，则取默认值0。当值为负数时，表示反方向移动元素。\n缩放scale() 方法用于缩放元素大小，该函数包含两个参数值，分别用来定义宽度和高度的缩放比例。\n12transform:scale(x-axis,y-axis);transform:scale(2,4);x-axis和y-axis参数值可以是正数、负数和小数。正数值表示基于指定的宽度和高度放大元素。负数值不会缩小元素，而是反转元素（如文字被反转），然后再缩放元素。如果第二个参数省略，则第二个参数等于第一个参数值。\n倾斜skew()方法能够让元素倾斜显示，该函数包含两个参数值，分别用来定义X轴和Y轴坐标倾斜的角度。\n12transform:skew(x-angle,y-angle);transform:skew(30deg,30deg);旋转rotate()方法能够旋转指定的元素对象，主要在二维空间内进行操作。该方法中的参数允许传入负值，这时元素将逆时针旋转。\n12transform:rotate(angle);transform:rotate(30deg);参数angle表示要旋转的角度值。如果角度为正数值，则按照顺时针进行旋转，否则，按照逆时针旋转。\n中心点变形操作都是以元素的中心点为基准进行的，如果需要改变这个中心点，可以使用transform-origin属性。\n1transform-origin: x-axis y-axis z-axis;默认值分别为50% 50% 0\n\n参数描述\n\nx-axis定义视图被置于X轴的何处。可能的值有： left center right length %\n\ny-axis定义视图被置于Y轴的何处。可能的值有： top center bottom length %\n\nz-axis定义视图被置于Z轴的何处。可能的值有： length\n3D转换旋转rotateX()函数用于指定元素围绕X轴旋转\n1transform:rotateX(a);参数a用于定义旋转的角度值，单位为deg，其值可以是正数也可以是负数。如果值为正，元素将围绕X轴顺时针旋转；反之，如果值为负，元素围绕X轴逆时针旋转。\nrotateY()函数指定一个元素围绕Y轴旋转\n1transform:rotateY(a);参数a与rotateX(a)中的a含义相同，用于定义旋转的角度。如果值为正，元素围绕Y轴顺时针旋转；反之，如果值为负，元素围绕Y轴逆时针旋转。\nrotate3D（）方法\n1rotate3d(x,y,z,angle);x、y、z可以取值0或1，当要沿着某一轴转动，就将该轴的值设置为1，否则设置为0。Angle为要旋转的角度。\n视距perspective属性可以简单的理解为视距，主要用于呈现良好的3D透视效果。例如我们前面设置的3D旋转果并不明显，就是没有设置perspective的原因。\n12perspective:参数值;perspective:250px;perspective属性参数值可以为none或者数值（一般为像素），其透视效果由参数值决定，参数值越小，透视效果越突出。\n\n在CSS3中包含很多转换的属性，通过这些属性可以设置不同的转换效果。\n\n\nCSS3中还包含很多转换的方法，运用这些方法可以实现不同的转换效果。\n\n\n方法名称描述\n\ntranslate3d(x,y,z)定义3D位移\n\ntranslateX(x)定义3D位移，仅使用用于 X 轴的值\n\ntranslateY(y)定义3D位移，仅使用用于 Y 轴的值\n\ntranslateZ(z)定义3D位移，仅使用用于Z 轴的值\n\nscale3d(x,y,z)定义 3D 缩放\n\nscaleX(x)定义 3D 缩放，通过给定一个 X 轴的值\n\nscaleY(y)定义 3D 缩放，通过给定一个 Y 轴的值\n\nscaleZ(z)定义 3D 缩放，通过给定一个 Z 轴的值\n动画@keyframes123@keyframes animationname &#123;         keyframes-selector&#123;css-styles;&#125;&#125;animationname：表示当前动画的名称，它将作为引用时的唯一标识，因此不能为空。\nkeyframes-selector：关键帧选择器，即指定当前关键帧要应用到整个动画过程中的位置，值可以是一个百分比、from或者to。其中，from和0%效果相同表示动画的开始，to和100%效果相同表示动画的结束。\ncss-styles：定义执行到当前关键帧时对应的动画状态，由CSS样式属性进行定义，多个属性之间用分号分隔，不能为空。\nanimation-name属性定义要应用的动画名称\n1animation-name: keyframename | none;animation-name 属性初始值为none，适用于所有块元素和行内元素。keyframename参数用于规定需要绑定到选择器的keyframe的名称，如果值为none，则表示不应用任何动画，通常用于覆盖或者取消动画。\nanimation-duration属性定义整个动画效果完成所需要的时间，以秒或毫秒计。\n1animation-duration: time;animation-duration 属性初始值为0，适用于所有块元素和行内元素。time参数是以秒（s）或者毫秒（ms）为单位的时间，默认值为0，表示没有任何动画效果。当值为负数时，则被视为0。\nanimation-timing-function属性用来规定动画的速度曲线，可以定义使用哪种方式来执行动画效果。\n1animation-timing-function:value;animation-timing-function包括linear、ease-in、ease-out、ease-in-out、cubic-bezier(n,n,n,n)等常用属性值。\n\n属性值描述\n\nlinear动画从头到尾的速度是相同的。\n\nease默认。动画以低速开始，然后加快，在结束前变慢。\n\nease-in动画以低速开始。\n\nease-out动画以低速结束。\n\nease-in-out动画以低速开始和结束。\n\ncubic-bezier(n,n,n,n)在cubic-bezier函数中自己的值。可能的值是从0到1的数值。\nanimation-delay属性用于定义执行动画效果之前延迟的时间，即规定动画什么时候开始。\n1animation-delay:time;参数time用于定义动画开始前等待的时间，其单位是秒或者毫秒，默认属性值为0。animation-delay属性适用于所有的块元素和行内元素。\nanimation-iteration-count属性用于定义动画的播放次数\n1animation-iteration-count: number | infinite;animation-iteration-count属性初始值为1，适用于所有的块元素和行内元素。如果属性值为number，则用于定义播放动画的次数；如果是infinite，则指定动画循环播放。\nanimation-direction属性定义当前动画播放的方向，即动画播放完成后是否逆向交替循环。\n1animation-direction: normal | alternate;animation-direction 属性初始值为normal，适用于所有的块元素和行内元素。该属性包括两个值，默认值normal表示动画每次都会正常显示。如果属性值是”alternate“，则动画会在奇数次数（1、3、5 等等）正常播放，而在偶数次数（2、4、6 等）逆向播放。\nanimation属性1animation: animation-name animation-duration animation-timing-function animation-delay animation-iteration-count animation-direction;使用animation属性时必须指定animation-name和animation-duration属性，否则持续的时间为0，并且永远不会播放动画。    \n","plink":"https://dxsummer.gitee.io/posts/540576d8/"},{"title":"多媒体嵌入","date":"2020-11-22T13:32:38.000Z","date_formatted":{"ll":"2020年11月22日","L":"2020/11/22","MM-DD":"11-22"},"updated":"2020-11-22T14:11:04.000Z","content":"视频文件视频格式：Ogg、MPEG4 、WebM\n1&lt;video src=\"视频文件路径\" controls=\"controls\"&gt;&lt;/video&gt;\n属性值描述\n\nautoplayautoplay当页面载入完成后自动播放视频。\n\nlooploop视频结束时重新开始播放。\n\npreloadpreload如果出现该属性，则视频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。\n\nposterurl当视频缓冲不足时，该属性值链接一个图像，并将该图像按照一定的比例显示出来。\n音频格式音频格式：Ogg、MP3、Wav\n1&lt;audio src=\"音频文件路径\" controls=\"controls\"&gt;&lt;/audio&gt;\n属性值描述\n\nautoplayautoplay当页面载入完成后自动播放音频。\n\nlooploop音频结束时重新开始播放。\n\npreloadpreload如果出现该属性，则音频在页面加载时进行加载，并预备播放。如果使用 “autoplay”，则忽略该属性。\n在HTML5中，运用source元素可以为video元素或audio元素提供多个备用文件。\n12345&lt;audio controls=\"controls\"&gt;\t&lt;source src=\"音频文件地址\" type=\"媒体文件类型/格式\"&gt;\t&lt;source src=\"音频文件地址\" type=\"媒体文件类型/格式\"&gt;\t……&lt;/audio&gt;兼容性视频格式\n\n格式IE 9Firefox 4.0Opera 10.6Chrome 6.0Safari 3.0\n\nOgg支持支持支持\n\nMPEG 4支持支持支持\n\nWebM支持支持支持\n音频格式\n\n格式IE 9Firefox 4.0Opera 10.6Chrome 6.0Safari 3.0\n\nOgg支持支持支持\n\nMP3支持支持支持\n\nWav支持支持支持\n","plink":"https://dxsummer.gitee.io/posts/159769da/"},{"title":"图","date":"2020-11-21T10:20:02.000Z","date_formatted":{"ll":"2020年11月21日","L":"2020/11/21","MM-DD":"11-21"},"updated":"2020-11-23T12:25:28.000Z","content":"图图：Graph=(V,E)\nV：顶点(数据元素)的有穷非空集合\nE：边的有穷集合\n无向图：每条边都是无方向的\n有向图：每条边都是有方向的\n完全图：任意两个点都有一条边相连\n路径：接续的边构成的顶点序列。路径长度：路径上边或弧的数目/权值之和。回路(环)：第一个顶点和最后一个顶点相同的路径。简单路径：除路径起点和终点可以相同外，其余顶点均不相同的路径。简单回路(简单环)：除路径起点和终点相同外，其余顶点均不相同的路径。\n连通图（强连通图）在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是连通图（强连通图）。\n权与网图中边或弧所具有的相关数称为权。表明从一个顶点到另一个顶点的距离或耗费。带权的图称为网\n\n例:(b)、(c) 是 (a) 的子图\n\n极小连通子图：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通\n生成树：包含无向图G 所有顶点的极小连通子图。\n生成森林：对非连通图，由各个连通分量的生成树的集合\n六度空间理论\n你和任何一个陌生人之间所间隔的人不会超过6个，也就是说，最多通过6个中间人你就能够认识任何一个陌生人。\n存储结构数组（邻接矩阵）表示法建立一个顶点表（记录各个顶点信息）和一个邻接矩阵（表示各个顶点之间关系）\n设图 A = (V, E) 有 n 个顶点，则图的邻接矩阵是一个二维数组 A.Edge[n][n]，定义为：\n优点：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边、找顶点的邻接点等等。\n缺点：n个顶点需要n*n个单元存储边;空间效率为O(n2)。 对稀疏图而言尤其浪费空间。\n12345678910//用两个数组分别存储顶点表和邻接矩阵#define MaxInt 32767                    \t//表示极大值，即∞#define MVNum 100                       \t//最大顶点数 typedef char VerTexType;              \t//假设顶点的数据类型为字符型 typedef int ArcType;                  \t//假设边的权值类型为整型 typedef struct&#123;   VerTexType vexs[MVNum];            \t\t//顶点表   ArcType arcs[MVNum][MVNum];      \t//邻接矩阵   int vexnum,arcnum;                \t\t//图的当前点数和边数 &#125;AMGraph;邻接表（链式）表示法优点：空间效率高，容易寻找顶点的邻接点；\n缺点：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103//算法6.2　采用邻接表表示法创建无向图#include &lt;iostream&gt;using namespace std;#define MVNum 100                        \t//最大顶点数 #define OK 1typedef char VerTexType;\t\t\t\t\t//顶点信息typedef int OtherInfo;\t\t\t\t\t\t//和边相关的信息 //- - - - -图的邻接表存储表示- - - - - typedef struct ArcNode&#123;                \t\t//边结点     int adjvex;                          \t//该边所指向的顶点的位置     struct ArcNode *nextarc;          \t\t//指向下一条边的指针     OtherInfo info;                      \t//和边相关的信息 &#125;ArcNode; typedef struct VNode&#123;     VerTexType data;                    \t//顶点信息     ArcNode *firstarc;                \t\t//指向第一条依附该顶点的边的指针 &#125;VNode, AdjList[MVNum];               \t\t//AdjList表示邻接表类型 typedef struct&#123;     AdjList vertices;                 \t\t//邻接表     int vexnum, arcnum;              \t\t//图的当前顶点数和边数 &#125;ALGraph;int LocateVex(ALGraph G , VerTexType v)&#123;\t//确定点v在G中的位置\tfor(int i = 0; i &lt; G.vexnum; ++i)\t\tif(G.vertices[i].data == v)\t\t\treturn i;   return -1;&#125;//LocateVexint CreateUDG(ALGraph &amp;G)&#123; \t//采用邻接表表示法，创建无向图G\tint i , k;\tcout &lt;&lt;\"请输入总顶点数，总边数中间以空格隔开:\";\tcin &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t//输入总顶点数，总边数     cout &lt;&lt; endl;\t\tcout &lt;&lt; \"输入点的名称，如 a \" &lt;&lt;endl;\tfor(i = 0; i &lt; G.vexnum; ++i)&#123;          \t//输入各点，构造表头结点表\t\tcout &lt;&lt; \"请输入第\" &lt;&lt; (i+1) &lt;&lt; \"个点的名称:\";\t\tcin &gt;&gt; G.vertices[i].data;           \t//输入顶点值 \t\tG.vertices[i].firstarc=NULL;\t\t\t//初始化表头结点的指针域为NULL     &#125;//for\tcout &lt;&lt; endl;    \tcout &lt;&lt; \"请输入一条边依附的顶点,如 a b\" &lt;&lt; endl;\tfor(k = 0; k &lt; G.arcnum;++k)&#123;        \t\t//输入各边，构造邻接表\t\tVerTexType v1 , v2;\t\tint i , j;\t\tcout &lt;&lt; \"请输入第\" &lt;&lt; (k + 1) &lt;&lt; \"条边依附的顶点:\";\t\tcin &gt;&gt; v1 &gt;&gt; v2;                 \t\t//输入一条边依附的两个顶点\t\ti = LocateVex(G, v1);  j = LocateVex(G, v2);\t\t//确定v1和v2在G中位置，即顶点在G.vertices中的序号 \t\tArcNode *p1=new ArcNode;               \t//生成一个新的边结点*p1 \t\tp1-&gt;adjvex=j;                   \t\t//邻接点序号为j \t\tp1-&gt;nextarc= G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;  \t\t//将新结点*p1插入顶点vi的边表头部\t\tArcNode *p2=new ArcNode;                //生成另一个对称的新的边结点*p2 \t\tp2-&gt;adjvex=i;                   \t\t//邻接点序号为i \t\tp2-&gt;nextarc= G.vertices[j].firstarc;  G.vertices[j].firstarc=p2;  \t\t//将新结点*p2插入顶点vj的边表头部     &#125;//for     return OK; &#125;//CreateUDGint main()&#123;\tcout &lt;&lt; \"************算法6.2　采用邻接表表示法创建无向图**************\" &lt;&lt; endl &lt;&lt; endl;\tALGraph G;\tCreateUDG(G);\tint i;\tcout &lt;&lt; endl;\tcout &lt;&lt; \"*****邻接表表示法创建的无向图*****\" &lt;&lt; endl;\t\tfor(i = 0 ; i &lt; G.vexnum ; ++i)&#123;\t\tVNode temp = G.vertices[i];\t\tArcNode *p = temp.firstarc;\t\tif(p == NULL)&#123;\t\t\tcout &lt;&lt; G.vertices[i].data;\t\t\tcout &lt;&lt; endl;\t\t&#125;\t\telse&#123;\t\t\tcout &lt;&lt; temp.data;\t\t\twhile(p)&#123;\t\t\t\tcout &lt;&lt; \"-&gt;\";\t\t\t\tcout &lt;&lt; p-&gt;adjvex;\t\t\t\tp = p-&gt;nextarc;\t\t\t&#125;\t\t&#125;\t\tcout &lt;&lt; endl;\t&#125;\treturn 0;&#125;//main十字链表有向图无向图邻接矩阵与邻接表表示法的关系联系：邻接表中每个链表对应于邻接矩阵中的一行，链表中结点个数等于一行中非零元素的个数。\n\n区别：\n① 对于任一确定的无向图，邻接矩阵是唯一的（行列号与顶点编号一致），但邻接表不唯一（链接次序与顶点编号无关）。② 邻接矩阵的空间复杂度为O(n2) ** , 而邻接表的空间复杂度为O(n+e)**。\n\n用途：邻接矩阵多用于稠密图；而邻接表多用于稀疏图\n\n图的遍历定义：从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使每个顶点仅被访问一次，就叫做图的遍历，它是图的基本运算\n实质：找每个顶点的邻接点的过程\n特点：图中可能存在回路，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边又回到了曾经访问过的顶点\n\n","plink":"https://dxsummer.gitee.io/posts/ee040603/"},{"title":"DIV+CSS布局","date":"2020-11-16T01:28:01.000Z","date_formatted":{"ll":"2020年11月16日","L":"2020/11/16","MM-DD":"11-16"},"updated":"2020-11-16T04:50:30.000Z","content":"标签的浮动设置了浮动属性的元素会脱离标准文档流的控制，移动到其父元素中指定位置的过程。\n1选择器&#123;float:属性值;&#125;\n属性值描述\n\nleft元素向左浮动\n\nright元素向右浮动\n\nnone元素不浮动（默认值）\n清除浮动由于浮动元素不再占用原文档流中的位置，所以会对页面中其他元素的排版产生影响，如果要避免这种影响，就需要对元素清除浮动。\n1选择器&#123;clear:属性值;&#125;\n属性值描述\n\nleft不允许左侧有浮动元素（清除左侧浮动的影响）\n\nright不允许右侧有浮动元素（清除右侧浮动的影响）\n\nboth同时清除左右两侧浮动的影响\n\n clear属性只能清除元素左右两侧浮动的影响。然而在制作网页时，经常会遇到一些特殊的浮动影响。\n\n空标签\n在浮动元素之后添加空标签，并对该标签应用“clear:both”样式，可清除浮动。这个空标签可以为&lt;div&gt;、&lt;p&gt;、&lt;hr /&gt;等任何标签。\n12345678910&lt;style type=\"text/css\"&gt;.box04&#123; clear:both;&#125;                /*对空标签应用clear:both;*/&lt;/style&gt;&lt;div class=\"father\"&gt;\t&lt;div class=\"box01\"&gt;box01&lt;/div&gt;\t&lt;div class=\"box02\"&gt;box02&lt;/div&gt;\t&lt;div class=\"box03\"&gt;box03&lt;/div&gt;\t&lt;div class=\"box04\"&gt;&lt;/div&gt;        &lt;!--在浮动标签后添加空标签--&gt;&lt;/div&gt;\noverflow\n​    “overflow:hidden;”样式，也可以清除浮动对该元素的影响，该方法弥补了空标签清除浮动的不足。\n12345678910111213&lt;style type=\"text/css\"&gt; .father&#123;                              /*没有给父标签定义高度*/\tbackground:#ccc;             \tborder:1px dashed #999; \toverflow:hidden;               /*对父标签应用overflow:hidden;*/    &#125;&lt;/style&gt;&lt;div class=\"father\"&gt;\t&lt;div class=\"box01\"&gt;box01&lt;/div&gt;\t&lt;div class=\"box02\"&gt;box02&lt;/div&gt;\t&lt;div class=\"box03\"&gt;box03&lt;/div&gt;&lt;/div&gt;\nafter伪对象\n使用after伪对象也可以清除浮动，但是该方法只适用于IE8及以上版本浏览器和其他非IE浏览器。\n\n标签的定位属性浮动布局虽然灵活，但是却无法对元素的位置进行精确的控制。\n通过CSS定位（CSS position）可以实现网页元素的精确定位。元素的定位属性主要包括定位模式和边偏移两部分。\n定位模式1选择器&#123;position:属性值；&#125;\n值描述\n\nstatic自动定位（默认定位方式）\n\nrelative相对定位，相对于其原文档流的位置进行定位\n\nabsolute绝对定位，相对于其上一个已经定位的父元素进行定位\n\nfixed固定定位，相对于浏览器窗口进行定位\n边偏移通过边偏移属性top、bottom、left或right，来精确定义定位元素的位置，其取值为不同单位的数值或百分比，如下表所示。\n\n边偏移属性描述\n\ntop顶端偏移量，定义元素相对于其父元素上边线的距离\n\nbottom底部偏移量，定义元素相对于其父元素下边线的距离\n\nleft左侧偏移量，定义元素相对于其父元素左边线的距离\n\nRight右侧偏移量，定义元素相对于其父元素右边线的距离\n定位属性静态定位静态定位是元素的默认定位方式\n各个元素在HTML文档流中默认的位置\n在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置\n相对定位 relative相对定位是将元素相对于它在标准文档流中的位置进行定位\n绝对定位 absolute绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素进行定位，若所有父元素都没有定位，则依据body根元素（浏览器窗口）进行定位。\n固定定位固定定位是绝对定位的一种特殊形式，它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。\n布局其他属性overflow属性overflow属性可以解决溢出问题，其基本语法格式如下：\n1选择器&#123;overflow:属性值;&#125;\n属性值描述\n\nvisible内容不会被修剪，会呈现在元素框之外（默认值）\n\nhidden溢出内容会被修剪，并且被修剪的内容是不可见的\n\nauto在需要时产生滚动条，即自适应所要显示的内容\n\nscroll溢出内容会被修剪，且浏览器会始终显示滚动条\nZ-index标签层叠123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt;  div &#123;     position: relative;     width: 100px;     height: 100px;   &#125;   p &#123;     position: absolute;     font-size: 20px;     width: 100px;     height: 100px;   &#125;   .a &#123;     background-color: blue;     z-index: 1;   &#125;   .b &#123;     background-color: green;     z-index: 2;     top: 20px;     left: 20px;   &#125;   .c &#123;     background-color: red;     z-index: 3;     top: -20px;     left: 40px;   &#125;&lt;/style&gt; &lt;body&gt;   &lt;div&gt;     &lt;p class=\"a\"&gt;a&lt;/p&gt;     &lt;p class=\"b\"&gt;b&lt;/p&gt;   &lt;/div&gt;  &lt;div&gt;     &lt;p class=\"c\"&gt;c&lt;/p&gt;   &lt;/div&gt; &lt;/body&gt;通栏布局头部、导航、焦点图或页面底部等经常需要通栏显示\n\n设置为通栏后，无论页面放大或缩小，该模块都将横铺于浏览器窗口中。\n\nHTML5结构元素header元素具有引导和导航作用的结构元素，该元素可以包含所有通常放在页面头部的内容\n1234&lt;header&gt;   &lt;h1&gt;网页主题&lt;/h1&gt;\t...&lt;/header&gt;nav标签定义导航链接，是HTML5新增的元素，将具有导航性质的链接归纳在一个区域中，使页面元素的语义更加明确。\n12345678&lt;nav&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;公司概况&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;产品展示&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;联系我们&lt;/li&gt;    &lt;/ul&gt;&lt;/nav&gt;footer标签页面或者区域的底部\n123456789&lt;article&gt;\t文章内容\t&lt;footer&gt;\t\t文章分页列表\t&lt;/footer&gt;&lt;/article&gt;&lt;footer&gt;\t页面底部&lt;/footer&gt;article标签代表文档、页面或者应用程序中与上下文不相关的独立部分，该元素经常被用于定义一篇日志、一条新闻或用户评论等。\nsection标签对网站或应用程序中页面上的内容进行分块，一个section元素通常由内容和标题组成。\n\n不要将section元素用作设置样式的页面容器，那是div的特性。\n\n如果article元素、aside元素或nav元素更符合使用条件，那么不要使用section元素。\n\n没有标题的内容区块不要使用section元素定义。\n\naside标签定义当前页面或者文章的附属信息部分(引用、侧边栏、广告、导航条)\n用法主要分为两种:\n被包含在article元素内作为主要内容的附属信息。\n在article元素之外使用，作为页面或站点全局的附属信息部分。\n网页模块的命名规范驼峰式除了第一个单词外后面的单词首写字母都要大写（例如：partOne）。\n帕斯卡每一个单词之间用“_”连接（例如：content_one）。\n\n相关模块命名相关模块命名\n\n头header内容content/container\n\n导航nav尾footer\n\n侧栏sidebar栏目column\n\n左边、右边、中间left right center登录条loginbar\n\n标志logo广告banner\n\n页面主体main热点hot\n\n新闻news下载download\n\n子导航subnav菜单menu\n\n子菜单submenu搜索search\n\n友情链接frIEndlink版权copyright\n\n滚动scroll标签页tab\n\n文章列表list提示信息msg\n\n小技巧tips栏目标题title\n\n加入joinus指南guild\n\n服务service注册regsiter\n\n状态status投票vote\n\n合作伙伴partner\n\nCSS文件命名CSS文件命名\n\n主要样式master基本样式base\n\n模块样式module版面样式layout\n\n主题themes专栏columns\n\n文字font表单forms\n\n打印print\n","plink":"https://dxsummer.gitee.io/posts/f02a39f0/"},{"title":"树和二叉树","date":"2020-11-07T12:20:23.000Z","date_formatted":{"ll":"2020年11月7日","L":"2020/11/07","MM-DD":"11-07"},"updated":"2020-11-21T08:12:46.000Z","content":"逻辑结构树n（n≥0）个结点的有限集，它或为空树（n = 0）；或为非空树，对于非空树T：\n有且仅有一个称之为根的结点\n除根结点以外的其余结点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm, 其中每一个集合本身又是一棵树，并且称为根的子树（SubTree）\n\n树是n个结点的有限集\n\n基本术语根：即根结点(没有前驱)\n\n叶子：即终端结点(没有后继)\n\n森林：指m棵不相交的树的集合(例如删除A后的子树个数)\n\n有序树：结点各子树从左至右有序，不能互换（左为第一）\n\n无序树：结点各子树可互换位置\n\n双亲：即上层的那个结点(直接前驱)\n\n孩子：即下层结点的子树的根(直接后继)\n\n兄弟：同一双亲下的同层结点（孩子之间互称兄弟）\n\n堂兄弟：即双亲位于同一层的结点（但并非同一双亲）\n\n祖先：即从根到该结点所经分支的所有结点\n\n子孙：即该结点下层子树中的任一结点\n\n结点：即树的数据元素\n\n结点的度：结点挂接的子树数\n\n结点的层次：从根到该结点的层数（根结点算第一层）\n\n终端结点：即度为0的结点，即叶子\n\n分支结点：即度不为0的结点（也称为内部结点）\n\n树的度：所有结点度中的最大值\n\n树的深度(或高度)：指所有结点中最大的层数\n\n二叉树n（n≥0）个结点所构成的集合，它或为空树（n = 0）；或为非空树，对于非空树T：\n有且仅有一个称之为根的结点；\n除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。\n特点结点的度小于等于2\n有序树（子树有序，不能颠倒）\n性质🍑1. 在二叉树的第 i 层上至多有2i-1个结点( i &gt;= 1 )\n2. 深度为 k 的二叉树至多有 2k - 1个结点( k &gt;= 1 )\n3. 对于任何一棵二叉树，终端结点数（叶子数）为 n0 ，若度为2的结点数有n2个，则叶子数n0=n2+1\n4. 具有n个结点的完全二叉树的深度必为[log2n]＋1 （[x]不大于x的最大整数，[5.7]=[5] ）\n5.  \n对完全二叉树，若从上至下、从左至右编号，则编号为i 的结点，其左孩子编号必为2i，其右孩子编号必为2i＋1；\n\n其双亲的编号必为i/2。\n\n特殊形态的二叉树满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。满二叉树是完全二叉树的一个特例。\n顺序存储按满二叉树的结点层次编号，依次存放二叉树中的数据元素。\n问题链式存储\n含有两个指针域的节点结构、三个指针域的结点结构\n\n1234typedef struct BiNode&#123;   TElemType   data;   struct  BiNode   *lchild,*rchild; //左右孩子指针&#125;BiNode,*BiTree;\neg\n在n个结点的二叉链表中，有n+1个空指针域\n\n遍历二叉树指按某条搜索路线遍访每个结点且不重复（又称周游）。\n它是树结构插入、删除、修改、查找和排序运算的前提，是二叉树一切运算的基础和核心。\n先序遍历算法12345678Status PreOrderTraverse(BiTree T)&#123;  if(T==NULL) return OK; //空二叉树  else&#123;         cout&lt;&lt;T-&gt;data; //访问根结点     PreOrderTraverse(T-&gt;lchild); //递归遍历左子树     PreOrderTraverse(T-&gt;rchild); //递归遍历右子树    &#125;&#125;中序遍历算法12345678Status InOrderTraverse(BiTree T)&#123;  if(T==NULL) return OK; //空二叉树  else&#123;         InOrderTraverse(T-&gt;lchild); //递归遍历左子树  cout&lt;&lt;T-&gt;data; //访问根结点     InOrderTraverse(T-&gt;rchild); //递归遍历右子树    &#125;&#125;后序遍历算法12345678Status PostOrderTraverse(BiTree T)&#123;  if(T==NULL) return OK; //空二叉树  else&#123;         PostOrderTraverse(T-&gt;lchild); //递归遍历左子树     PostOrderTraverse(T-&gt;rchild); //递归遍历右子树     cout&lt;&lt;T-&gt;data; //访问根结点    &#125;&#125;计算二叉树结点总数如果是空树，则结点个数为0；\n\n否则，结点个数为左子树的结点个数+右子树的结点个数再+1。\n\n1234int NodeCount(BiTree T)&#123;  if(T == NULL ) return 0;  \t\t\t      else return NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+1;&#125;计算二叉树叶子结点总数如果是空树，则叶子结点个数为0；\n\n否则，为左子树的叶子结点个数+右子树的叶子结点个数。\n\n1234567int LeadCount(BiTree T)&#123; \tif(T==NULL) \t//如果是空树返回0\t\treturn 0;\tif (T-&gt;lchild == NULL &amp;&amp; T-&gt;rchild == NULL)\t\treturn 1; //如果是叶子结点返回1\telse return LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);&#125;计算二叉树深度如果是空树，则深度为0；\n否则，递归计算左子树的深度记为m，递归计算右子树的深度记为n，二叉树的深度则为m与n的较大者加1。 \n结论由二叉树的前序序列和中序序列，或由其后序序列和中序序列均能唯一地确定一棵二叉树，\n但由前序序列和后序序列却不一定能唯一地确定一棵二叉树。 \n线索化二叉树若结点有左子树，则lchild指向其左孩子；否则， lchild指向其直接前驱(即线索)；\n若结点有右子树，则rchild指向其右孩子；否则， rchild指向其直接后继(即线索) 。\nLTag  :若 LTag=0, lchild域指向左孩子；若 LTag=1, lchild域指向其前驱。RTag  :若 RTag=0, rchild域指向右孩子；若 RTag=1, rchild域指向其后继。 \n线索：指向结点前驱和后继的指针\n线索链表：加上线索二叉链表\n线索二叉树：加上线索的二叉树（图形式样）\n线索化：对二叉树以某种次序遍历使其变为线索二叉树的过程\n先序线索二叉树中序线索二叉树后序线索二叉树树的存储结构二叉链表1234typedef struct CSNode&#123;  ElemType data;  struct CSNode *firstchild,*nextsibling;&#125;CSNode,*CSTree;哈夫曼编码(远程通讯)基本思想：使权大的结点靠近根\n操作要点：对权值的合并、删除与替换，总是合并当前值最小的两个\n基本思想：概率大的字符用短码，小的用长码，构造哈夫曼树\n根据给定的n个权值{w1,w2,……wn}，构造n棵只有根结点的二叉树。\n\n在森林中选取两棵根结点权值最小的树作左右子树，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。\n\n在森林中删除这两棵树，同时将新得到的二叉树加入森林中。重复上述两步，直到只含一棵树为止，这棵树即哈夫曼树。\n\n构造算法的实现一棵有n个叶子结点的Huffman树有2n-1个结点\n采用顺序存储结构——一维结构数组\n结点类型定义\n1234typedef  struct&#123;  int weght;\t//结点的权值\t   int parent,lch,rch;\t//双亲、左孩子、右孩子下标&#125;*HuffmanTree;\t//动态分配数组存储哈夫曼树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869//算法5.10 构造赫夫曼树#include&lt;iostream&gt;using namespace std;typedef struct&#123;\tint weight;\tint parent,lchild,rchild;&#125;HTNode,*HuffmanTree;void Select(HuffmanTree HT,int len,int &amp;s1,int &amp;s2)&#123;\tint i,min1=0x3f3f3f3f,min2=0x3f3f3f3f;//先赋予最大值\tfor(i=1;i&lt;=len;i++)\t&#123;\t\tif(HT[i].weight&lt;min1&amp;&amp;HT[i].parent==0)\t\t&#123;\t\t\tmin1=HT[i].weight;\t\t\ts1=i;\t\t&#125;\t\t&#125;\tint temp=HT[s1].weight;//将原值存放起来，然后先赋予最大值，防止s1被重复选择\tHT[s1].weight=0x3f3f3f3f;\tfor(i=1;i&lt;=len;i++)\t&#123;\t\tif(HT[i].weight&lt;min2&amp;&amp;HT[i].parent==0)\t\t&#123;\t\t\tmin2=HT[i].weight;\t\t\ts2=i;\t\t&#125;\t&#125;\tHT[s1].weight=temp;//恢复原来的值&#125;void CreatHuffmanTree(HuffmanTree &amp;HT,int n)&#123;\t//构造赫夫曼树HT\tint m,s1,s2,i;\tif(n&lt;=1) return;\tm=2*n-1;\tHT=new HTNode[m+1];  \t\t//0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点   \tfor(i=1;i&lt;=m;++i)        \t//将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0   \t   &#123; HT[i].parent=0;  HT[i].lchild=0;  HT[i].rchild=0; &#125;\tcout&lt;&lt;\"请输入叶子结点的权值：\\n\";\tfor(i=1;i&lt;=n;++i)        \t//输入前n个单元中叶子结点的权值  \t\tcin&gt;&gt;HT[i].weight;  \t/*――――――――――初始化工作结束，下面开始创建赫夫曼树――――――――――*/ \tfor(i=n+1;i&lt;=m;++i) \t&#123;  \t//通过n-1次的选择、删除、合并来创建赫夫曼树\t\tSelect(HT,i-1,s1,s2);\t\t//在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点,\t\t// 并返回它们在HT中的序号s1和s2\t\tHT[s1].parent=i; \t\t\tHT[s2].parent=i;   \t\t//得到新结点i，从森林中删除s1，s2，将s1和s2的双亲域由0改为i\t\tHT[i].lchild=s1;   \t\tHT[i].rchild=s2 ;\t\t\t\t\t\t\t//s1,s2分别作为i的左右孩子\t\tHT[i].weight=HT[s1].weight+HT[s2].weight; \t//i 的权值为左右孩子权值之和\t&#125;\t\t\t\t\t\t\t\t\t\t\t\t//for &#125;\t\t\t\t\t\t\t\t\t\t\t\t\t// CreatHuffmanTreevoid main()&#123;\tHuffmanTree HT;\tint n;\tcout&lt;&lt;\"请输入叶子结点的个数：\\n\";\tcin&gt;&gt;n;\tCreatHuffmanTree(HT,n);\tcout&lt;&lt;\"哈夫曼树建立完毕！\\n\";&#125;哈夫曼编码是不等长编码。哈夫曼编码是前缀编码，即任一字符的编码都不是另一字符编码的前缀。哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的结点总数为 2n-1。发送过程：根据由哈夫曼树得到的编码表送出字符数据接收过程：按左0、右1的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束。\n","plink":"https://dxsummer.gitee.io/posts/ec2e91f9/"},{"title":"表格和表单","date":"2020-11-06T07:01:35.000Z","date_formatted":{"ll":"2020年11月6日","L":"2020/11/06","MM-DD":"11-06"},"updated":"2020-11-15T09:53:42.000Z","content":"表格&lt;table&gt;属性\n&lt;table&gt;标签属性在实体表格中的表现如下图所示：\n\n&lt;tr&gt;标签的属性\n属性描述常用属性值\n\nheight设置行高度像素值\n\nalign设置一行内容的水平对齐方式left、center、right\n\nvalign设置一行内容的垂直对齐方式top、middle、bottom\n\nbgcolor设置行背景颜色预定义的颜色值、十六进制#RGB、rgb(r,g,b)\n\nbackground设置行背景图像url地址\n\n注意\n\n&lt;tr&gt;标签无宽度属性width，其宽度取决于表格标签&lt;table&gt;。\n\n对&lt;tr&gt;标签应用valign属性，用于设置一行内容的垂直对齐方式。\n\n虽然可以对&lt;tr&gt;标签应用background属性，但是在&lt;tr&gt;标签中此属性兼容问题严重。\n\n&lt;td&gt;标签的属性\n属性名含义常用属性值\n\nwidth设置单元格的宽度像素值\n\nheight设置单元格的高度像素值\n\nalign设置单元格内容的水平对齐方式left、center、right\n\nvalign设置单元格内容的垂直对齐方式top、middle、bottom\n\nbgcolor设置单元格的背景颜色预定义的颜色值、十六进制#RGB、rgb(r,g,b)\n\nbackground设置单元格的背景图像url地址\n\ncolspan设置单元格横跨的列数（用于合并水平方向的单元格）正整数\n\nrowspan设置单元格竖跨的行数（用于合并竖直方向的单元格）正整数\n\n注意\n\n在&lt;td&gt;标签的属性中，重点掌握colspan和rolspan，其他的属性了解即可，不建议使用，均可用CSS样式属性替代。\n\n当对某一个&lt;td&gt;标签应用width属性设置宽度时，该列中的所有单元格均会以设置的宽度显示。\n\n当对某一个&lt;td&gt;标签应用height属性设置高度时，该行中的所有单元格均会以设置的高度显示。\n\n&lt;th&gt;表头标签默认加粗居中显示\nCSS控制表格样式表格边框\n注意\n\nborder-collapse属性的属性值除了collapse（合并）之外，还可以为separate（分离），默认为separate。\n\n当表格的border-collapse属性设置为collapse时， HTML中设置的cellspacing属性值无效。\n\n行标签&lt;tr&gt;无border样式属性，本书不再做具体的演示，初学者可以自己测试加深理解。\n\n单元格边距设置单元格内容与边框之间的距离，可以对&lt;td&gt;标签应用内边距样式属性padding，或对&lt;table&gt;标签应用HTML标签属性cellpadding。\n12345th,td&#123;\tborder:1px solid #30F;     /*为单元格单独设置边框*/    padding:20px;              /*为单元格内容与边框设置20px的内边距*/    margin:20px;     /*为单元格与单元格边框之间设置20px的外边距*/ &#125;单元格的宽高对单元格标签&lt;td&gt;应用width和height属性，可以控制单元格宽度和高度。\n1234td&#123;\twidth:20px;\tHeight:20px;&#125;\n对同一行中的单元格定义不同的高度，或对同一列中的单元格定义不同的宽度时，最终的宽度或高度将取其中的较大者。\n\n表单创建&lt;form&gt;&lt;/form&gt;标签用来创建表单。\n123&lt;form action=\"url地址\" method=\"提交方式\" name=\"表单名称\"&gt;\t各种表单控件&lt;/form&gt;&lt;form&gt;与&lt;/form&gt;之间的表单控件是由用户自定义的，action、method和name为表单标签&lt;form&gt;的常用属性。\n表单控件input控件&lt;input /&gt;元素是表单中最常见的元素，网页中常见的单行文本框、单选按钮、复选框等都是通过它定义的。\n1&lt;input type=\"控件类型\"/&gt;\n&lt;input /&gt;标签为单标签，type属性为其最基本的属性，其取值有多种，用于指定不同的控件类型。\n\nhidden对于用户是不可见的，通常用于后台的程序\n\n请输入邮政编码：\n\n1234&lt;form action=\"#\" method=\"get\"&gt;请输入邮政编码：&lt;input type=\"text\" name=\"code\" pattern=\"[0-9]&#123;6&#125;\" placeholder=\"请输入6位数的邮政编码\" /&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;textarea控件\n    文本内容\ncols和rows为&lt;textarea&gt;标记的必须属性\n\ncols用来定义多行文本输入框每行中的字符数\n\nrows用来定义多行文本输入框显示的行数，取值均为正整数。\n\n123&lt;textarea cols=\"每行中的字符数\" rows=\"显示的行数\"&gt;\t文本内容&lt;/textarea&gt;\n属性属性值描述\n\nname由用户自定义控件的名称\n\nreadonlyreadonly该控件内容为只读（不能编辑修改）\n\ndisableddisabled第一次加载页面时禁用该控件（显示为灰色）\nselect控件\n        选项1\n        选项2\n        选项3\n       ...\n123456&lt;select&gt;        &lt;option&gt;选项1&lt;/option&gt;        &lt;option&gt;选项2&lt;/option&gt;        &lt;option&gt;选项3&lt;/option&gt;       ...&lt;/select&gt;\n&lt;select&gt;和&lt;option&gt;标签属性\n\n\n城区：\n    \n        \n            东城区\n            西城区\n            朝阳区\n            海淀区\n        \n        \n            浦东新区\n            徐汇区\n            虹口区\n        \n    \n\n12345678910111213141516&lt;form action=\"#\" method=\"post\"&gt;城区：&lt;br /&gt;\t&lt;select&gt;        &lt;optgroup label=\"北京\"&gt;            &lt;option&gt;东城区&lt;/option&gt;            &lt;option&gt;西城区&lt;/option&gt;            &lt;option&gt;朝阳区&lt;/option&gt;            &lt;option&gt;海淀区&lt;/option&gt;        &lt;/optgroup&gt;        &lt;optgroup label=\"上海\"&gt;            &lt;option&gt;浦东新区&lt;/option&gt;            &lt;option&gt;徐汇区&lt;/option&gt;            &lt;option&gt;虹口区&lt;/option&gt;        &lt;/optgroup&gt;    &lt;/select&gt;&lt;/form&gt;HTML5表单新属性form属性autocomplete将表单控件输入的内容记录下来，下次输入，显示在下拉列表里\n1&lt;form id=\"formBox\" autocomplete=\"on\"&gt;novalidate&lt;form&gt;标签内的所有表单控件不被验证\n1&lt;form action=\"form_action.asp\" method=\"get\" novalidate=\"novalidate\"&gt;datalist表单控件  (既可选择也可填写)网页中的列表通过datalist内的option进行创建。如果用户不希望从列表中选择某项，也可以自行输入其他内容。\n\ndatalist控件通常与input控件配合使用，来定义input的取值。\n\n在使用&lt;datalist&gt;控件时，需要通过id属性为其指定一个唯一的标识，然后为input控件指定list属性，将该属性值设置为datalist对应的id属性值即可。\n\n\n请输入用户名：\n\n    admin\n    lucy\n    lily\n\n        \n123456789&lt;form action=\"#\" method=\"post\"&gt;请输入用户名：&lt;input type=\"text\" list=\"namelist\"/&gt;&lt;datalist id=\"namelist\"&gt;    &lt;option&gt;admin&lt;/option&gt;    &lt;option&gt;lucy&lt;/option&gt;    &lt;option&gt;lily&lt;/option&gt;&lt;/datalist&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;\t\t&lt;/form&gt;全新的input请输入您的邮箱：\n1请输入您的邮箱：&lt;input type=\"email\" name=\"formmail\"/&gt;请输入个人网址：\n1请输入个人网址：&lt;input type=\"url\" name=\"user_url\"/&gt;请输入电话号码：\n1请输入电话号码：&lt;input type=\"tel\" name=\"telphone\" pattern=\"^\\d&#123;11&#125;$\"/&gt;输入搜索关键词：\n1输入搜索关键词：&lt;input type=\"search\" name=\"searchinfo\"/&gt;请选取一种颜色：\n1请选取一种颜色：&lt;input type=\"color\" name=\"color1\"/&gt;\n请输入数值：\nvalue: 输入框的默认值 max ：输入框接受的最大值 min： 最小值   step: 输入域合法的间隔（单击按钮跳动的±4，默认1)\n1请输入数值：&lt;input type=\"number\" name=\"number1\" value=\"1\" min=\"1\" max=\"20\" step=\"4\"/&gt;时间日期 : 月、年：周、年：小时分钟：时间、日、月、年：时间、日月年：\n123456&lt;input type=\"date\"/&gt;&lt;input type=\"month\"/&gt;&lt;input type=\"week\"/&gt;&lt;input type=\"time\"/&gt;&lt;input type=\"datetime\"/&gt;&lt;input type=\"datetime-local\"/&gt;autofocus属性 自动获取该焦点页面加载完毕后会自动获取该焦点\n1234&lt;form action=\"#\" method=\"get\"&gt;请输入搜索关键词：&lt;input type=\"text\" name=\"user_name\" autocomplete=\"off\" autofocus=\"true\"/&gt;&lt;br/&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;&lt;/form&gt;form属性 子元素在任意位置可以把表单内的子元素写在页面中的任一位置，只需为这个元素指定form属性并设置属性值为该表单的id即可\n\n例\n\n\n请输入您的姓名：\n    \n\n下面的输入框在form元素外，但因为指定了form属性为表单的id，所以该输入框仍然属于表单的一部分。\n请输入您的昵称：123456&lt;form action=\"#\" method=\"get\" id=\"user_form\"&gt;请输入您的姓名：&lt;input type=\"text\" name=\"first_name\"/&gt;&lt;input type=\"submit\" value=\"提交\" /&gt;\t&lt;/form&gt;&lt;p&gt;下面的输入框在form元素外，但因为指定了form属性为表单的id，所以该输入框仍然属于表单的一部分。&lt;/p&gt;请输入您的昵称：&lt;input type=\"text\" name=\"last_name\" form=\"user_form\"/&gt;&lt;br/&gt;list属性指定输入框所绑定的datalist元素，其值是某个datalist元素的id。\n\n请输入网址：\n\n    \n    \n    \n\n\n123456789&lt;form action=\"#\" method=\"get\"&gt;请输入网址：&lt;input type=\"url\" list=\"url_list\" name=\"weburl\"/&gt;&lt;datalist id=\"url_list\"&gt;\t&lt;option label=\"新浪\" value=\"http://www.sina.com.cn\"&gt;&lt;/option&gt;    &lt;option label=\"搜狐\" value=\"http://www.sohu.com\"&gt;&lt;/option&gt;    &lt;option label=\"IT\" value=\"http://www.it.cn/\"&gt;&lt;/option&gt;&lt;/datalist&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;multiple属性 选择多个值输入框可以选择多个值，该属性适用于email和file类型的input元素。\n\n电子邮箱：&nbsp;&nbsp;（如果电子邮箱有多个，请使用逗号分隔）\n上传照片：\n\n12345&lt;form action=\"#\" method=\"get\"&gt;电子邮箱：&lt;input type=\"email\" name=\"myemail\" multiple/&gt;&amp;nbsp;&amp;nbsp;（如果电子邮箱有多个，请使用逗号分隔）&lt;br/&gt;&lt;br/&gt;上传照片：&lt;input type=\"file\" name=\"selfile\" multiple/&gt;&lt;br/&gt;&lt;br/&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;\nmin、max和step属性min、max和step属性用于为包含数字或日期的input输入类型规定限值\n适用于date、pickers、number和range标签\npattern属性 正则表达式验证input类型输入框中，用户输入的内容是否与所定义的正则表达式相匹配\n适用于的类型是：text、search、url、tel、email和password的&lt;input/&gt;标签。\n常用的正则表达式和说明\n\n正则表达式说明\n\n^[0-9]*$数字\n\n^\\d{n}$n位的数字\n\n^\\d{n,}$至少n位的数字\n\n^\\d{m,n}$m-n位的数字\n\n^(0|[1-9][0-9]*)$零和非零开头的数字\n\n^([1-9][0-9]*)+(.[0-9]{1,2})?$非零开头的最多带两位小数的数字\n\n^(-|+)?\\d+(.\\d+)?$正数、负数、和小数\n\n^\\d+$ 或 ^[1-9]\\d*|0$非负整数\n\n^-[1-9]\\d*|0$ 或 ^((-\\d+)|(0+))$非正整数\n\n^[\\u4e00-\\u9fa5]{0,}$汉字\n\n^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$英文和数字\n\n^[A-Za-z]+$由26个英文字母组成的字符串\n\n^[A-Za-z0-9]+$由数字和26个英文字母组成的字符串\n\n^\\w+$ 或 ^\\w{3,20}$由数字、26个英文字母或者下划线组成的字符串\n\n^[\\u4E00-\\u9FA5A-Za-z0-9_]+$中文、英文、数字包括下划线\n\n^\\w+([-+.]\\w+)@\\w+([-.]\\w+)*.\\w+([-.]\\w+)$Email地址\n\n[a-zA-z]+://[^\\s]* 或 ^http://([\\w-]+.)+[\\w-]+(/[\\w-./?%&amp;=]*)?$URL地址\n\n^\\d{15}|\\d{18}$身份证号(15位、18位数字)\n\n^([0-9]){7,18}(x|X)?$ 或 ^\\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$以数字、字母x结尾的短身份证号码\n\n^[a-zA-Z][a-zA-Z0-9_]{4,15}$帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)\n\n^[a-zA-Z]\\w{5,17}$密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)\n\neg\n\n\n账&nbsp;&nbsp;&nbsp;&nbsp;号：（以字母开头，允许5-16字节，允许字母数字下划线）\n密&nbsp;&nbsp;&nbsp;&nbsp;码：（以字母开头，长度在6~18之间，只能包含字母、数字和下划线）\n身份证号：（15位、18位数字）\nEmail地址：\n\n1234567891011&lt;form action=\"#\" method=\"get\"&gt;    账号：&lt;input type=\"text\" name=\"username\" pattern=\"^[a-zA-Z][a-zA-Z0-9_]&#123;4,15&#125;$\" /&gt;（以字母开头，允许5-16字节，允许字母数字下划线）&lt;br/&gt;    密码：&lt;input type=\"password\" name=\"pwd\" pattern=\"^[a-zA-Z]\\w&#123;5,17&#125;$\" /&gt;（以字母开头，长度在6~18之间，只能包含字母、数字和下划线）&lt;br/&gt;\t身份证号：&lt;input type=\"text\" name=\"mycard\" pattern=\"^\\d&#123;15&#125;|\\d&#123;18&#125;$\" /&gt;（15位、18位数字）&lt;br/&gt;    Email地址：&lt;input type=\"email\" name=\"myemail\" pattern=\"^\\w+([-+.]\\w+)*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*$\"/&gt;    &lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;placeholder属性 提示信息为input类型的输入框提供相关提示信息，以描述输入框期待用户输入何种内容。\n\n请输入邮政编码：\n\n1234&lt;form action=\"#\" method=\"get\"&gt;请输入邮政编码：&lt;input type=\"text\" name=\"code\" pattern=\"[0-9]&#123;6&#125;\" placeholder=\"请输入6位数的邮政编码\" /&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;required属性 内容不能为空规定输入框填写的内容不能为空，否则不允许用户提交表单。\n\n请输入姓名：\n\n1234&lt;form action=\"#\" method=\"get\"&gt;请输入姓名：&lt;input type=\"text\" name=\"user_name\" required=\"required\"/&gt;&lt;input type=\"submit\" value=\"提交\"/&gt;&lt;/form&gt;","plink":"https://dxsummer.gitee.io/posts/80afbc07/"},{"title":"导航栏","date":"2020-11-01T07:27:39.000Z","date_formatted":{"ll":"2020年11月1日","L":"2020/11/01","MM-DD":"11-01"},"updated":"2020-11-01T07:38:50.000Z","content":"一级导航栏\n1234567891011121314151617181920212223242526272829303132&lt;style type=\"text/css\"&gt;*&#123; margin:0; padding:0; &#125;ul,li&#123; list-style:none;&#125;#nav&#123; \twidth:1000px; \theight:40px; \tline-height:40px; \tborder:1px solid tccc; \tbackground:#ffc;\tmargin:20px auto;\t&#125;#nav li&#123; \tfloat:left;\t&#125;#nav a&#123;\tfont-size:14px;\tcolor:#000;\ttext-decoration:none;\tpadding:0 20px;&#125;#nav a:hover&#123; color:#f00; background:#FC6;&#125;&lt;/style&gt;&lt;body&gt;&lt;div id=\"nav\"&gt;    &lt;ul&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;首页&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;网页设计&lt;/a&gt;&lt;/li&gt;        &lt;li&gt;&lt;a href=\"#\"&gt;c语言程序设计&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;二级导航栏123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;style type=\"text/css\"&gt;*&#123;padding:0; margin:0; list-style:none;&#125;.nav&#123;\twidth:1000px;\theight:40px;\tborder:1px solid #000;\tbackground: #ffc;\tmargin:20px auto;\tline-height:40px;\tposition : relative;\t//设置位置&#125;.nav ul li a&#123;\tdisplay:block;\theight:42px;\tpadding:0 30px;\ttext-decoration:none;\tcolor:#000;&#125;.nav ul li&#123;float:left;&#125;.nav li a:hover&#123;\tcolor:#FFF;\tbackground:#000;&#125;.nav li ol li&#123;\t\tfloat:none;\t//取消左对齐\tbackground: #0F6;\t&#125;.nav li ol li a&#123;\tbackground:none;\t&#125;.nav ul li ol&#123;\t//设置为不显示 设置位置\tdisplay:none;\tposition : absolute;&#125;.nav li:hover ol&#123;display:block;&#125;\t//鼠标经过设置为块&lt;/style&gt;&lt;body&gt;&lt;div class=\"nav\"&gt;&lt;ul&gt;\t&lt;li&gt;&lt;a href=\"#\"&gt;测试&lt;/a&gt;        &lt;ol&gt;            &lt;li&gt;&lt;a href=\"#\"&gt;111&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"#\"&gt;111&lt;/a&gt;&lt;/li&gt;            &lt;li&gt;&lt;a href=\"#\"&gt;111&lt;/a&gt;&lt;/li&gt;        &lt;/ol&gt;    &lt;/li&gt;    &lt;li&gt;&lt;a href=\"#\"&gt;测试&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=\"#\"&gt;测试&lt;/a&gt;&lt;/li&gt;    &lt;li&gt;&lt;a href=\"#\"&gt;测试&lt;/a&gt;&lt;/li&gt;    &lt;/ul&gt;&lt;/div&gt;&lt;/body&gt;","plink":"https://dxsummer.gitee.io/posts/25281569/"},{"title":"列表和超链接","date":"2020-10-25T09:33:17.000Z","date_formatted":{"ll":"2020年10月25日","L":"2020/10/25","MM-DD":"10-25"},"updated":"2020-10-25T14:31:52.000Z","content":"列表标签123&lt;ul&gt;&lt;/ul&gt;\t标签用于定义无序列表&lt;li&gt;&lt;/li&gt;\t标签用于描述具体的列表项每对&lt;ul&gt;&lt;/ul&gt;中至少应包含一对&lt;li&gt;&lt;/li&gt;。无序列表 ul&lt;ul&gt;和&lt;li&gt;都拥有type属性，用于指定列表项目符号。\n\n不赞成使用无序列表的type属性，一般通过CSS样式属性替代。\n\n&lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有的元素。但是&lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入文字的做法是不被允许的。\n\n\ntype属性值显示效果\n\ndisc（默认值）●\n\ncircle○\n\nsquare■\n\n例\n\n\n    春\n    夏\n    秋\n    冬\n12345678&lt;body&gt;\t&lt;ul&gt;\t\t&lt;li  type=\"square\" &gt;春&lt;/li&gt;\t\t&lt;li&gt;夏&lt;/li&gt;\t\t&lt;li&gt;秋&lt;/li&gt;\t\t&lt;li&gt;冬&lt;/li&gt;\t&lt;/ul&gt;&lt;/body&gt;有序列表 ol每对&lt;ol&gt;&lt;/ol&gt;中至少应包含一对&lt;li&gt;&lt;/li&gt;。\n有序列表中，除了type属性之外，还可以为&lt;ol&gt;定义start属性、为&lt;li&gt;定义value属性。\n定义列表定义列表常用于图文混排，其中&lt;dt&gt;&lt;/dt&gt;标签中插入图片，&lt;dd&gt;&lt;/dd&gt;标签中放入对图片解释说明的文字。\n&lt;dl&gt; &lt;dt&gt; &lt;dd&gt; 3个标签之间不允许出现其他标签\n&lt;dl&gt; 必须与&lt;dt&gt;相邻\n\n列表的嵌套123456789101112131415&lt;h2&gt;饮品&lt;/h2&gt;&lt;ul&gt;\t&lt;li&gt;咖啡    \t\t&lt;ol&gt;                    &lt;!--有序列表的嵌套--&gt;        \t\t&lt;li&gt;拿铁&lt;/li&gt;            \t&lt;li&gt;摩卡&lt;/li&gt;        \t&lt;/ol&gt;     &lt;/li&gt;    &lt;li&gt;茶        &lt;ul&gt;                     &lt;!--无序列表的嵌套--&gt;         \t\t&lt;li&gt;碧螺春&lt;/li&gt;            \t&lt;li&gt;龙井&lt;/li&gt;        &lt;/ul&gt;    &lt;/li&gt;&lt;/ul&gt;CSS控制列表样式定义无序或有序列表时，可以通过标签的属性控制列表的项目符号，但是这种方式实现的效果并不理想，因此需要使用CSS中的列表样式属性。\nlist-style-type因为各个浏览器对list-style-type属性的解析不同。因此，在实际网页制作过程中不推荐使用   list-style-type属性。\nlist-style-image1ul&#123;list-style-image:url(图片路径);&#125;123&lt;style type=\"text/css\"&gt;ul&#123;list-style-image:url(images/book.png);&#125;  &lt;/style&gt;list-style-positioninside：列表项目符号位于列表文本以内。\noutside：列表项目符号位于列表文本以外。\n12345&lt;style type=\"text/css\"&gt;.in&#123;list-style-position:inside;&#125;   .out&#123;list-style-psition:outside;&#125; li&#123; border:1px solid #CCC;&#125;&lt;/style&gt;list-style 复合属性在实际网页制作过程中，为了更高效地控制列表项目符号，通常将list-style的属性值定义为none，然后通过为&lt;li&gt;设置背景图像的方式实现不同的列表项目符号。\n1list-style:列表项目符号 列表项目符号的位置 列表项目图像;链接超链接通过超链接，实现页面之间的跳转\nhref用于指定链接目标的url地址，当为&lt;a&gt;标签应用href属性时，它就具有了超链接的功能。\ntarget：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，意为在原窗口中打开，_blank为在新窗口中打开。\n1&lt;a href=\"跳转目标\" target=\"目标窗口的弹出方式\"&gt;文本或图像&lt;/a&gt;1、暂时没有确定链接目标时，通常将&lt;a&gt;标签的href属性值定义为“#” (即href=&quot;#&quot;)，表示该链接暂时为一个空链接。2、不仅可以创建文本超链接，在网页中各种网页元素，如图像、 表格、音频、视频等都可以添加超链接。3、当给图像添加超链接时，图像会自动加上边框，通常需要清除超链接图像的边框。\n锚点链接通过创建锚点链接，用户能够快速定位到目标内容。\n创建锚点步骤\n使用“&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt;”创建链接文本\n使用相应的id名标注跳转目标的位置\n12345&lt;a href=\"#one\"&gt;平面广告设计&lt;/a&gt;...&lt;h3 id=\"one\"&gt;平面广告设计&lt;/h3&gt;链接伪类定义超链接时，为了提高用户体验，经常需要为超链接指定不同的状态，使得超链接在点击前、点击后和鼠标悬停时的样式不同。\n在CSS中通过链接伪类可以实现不同的链接状态\n伪类并不是真正意义上的类，它的名称是由系统定义的，通常由标签名、类名或id名加“：”构成。\n\n超链接标签&lt;a&gt;的伪类含义\n\na:link{ CSS样式规则; }未访问时超链接的状态\n\na:visited{ CSS样式规则; }访问后超链接的状态\n\na:hover{ CSS样式规则; }鼠标经过、悬停时超链接的状态\n\na:active{ CSS样式规则; }鼠标点击不动时超链接的状态\n同时使用链接的4种伪类时，通常按照a:link、a:visited、a:hover和a:active的顺序书写，否则定义的样式可能不起作用。\n\n除了文本样式之外，链接伪类还常常用于控制超链接的背景、边框等样式。\n\n123456789101112&lt;style type=\"text/css\"&gt;a:link,a:visited&#123;\t/*未访问和访问后*/\tcolor:#FC0;\ttext-decoration:none;         /*清除超链接默认的下划线*/\tmargin-right:20px;&#125;a:hover&#123;                             \tcolor:#0F0;\ttext-decoration:underline;  /*鼠标悬停时出现下划线*/&#125;a:active&#123; color:#F00;&#125;            &lt;/style&gt;","plink":"https://dxsummer.gitee.io/posts/9a7f11f9/"},{"title":"串、数组和广义表","date":"2020-10-24T15:38:06.000Z","date_formatted":{"ll":"2020年10月24日","L":"2020/10/24","MM-DD":"10-24"},"updated":"2020-11-03T12:31:34.000Z","content":"常用的串运算12345#include&lt;string.h&gt;串比较，strcmp(char s1,char s2) 串复制，strcpy(char to,char from)串连接，strcat(char to,char from) 求串长，strlen(char s)串(String)零个或多个字符组成的有限序列\n顺序存储后面算法描述当中所用到的顺序存储的字符串都是从下标1的数组分量开始存储的，下标为0的分量闲置不用\n123456//--------串的定长顺序存储结构------#define MAXLEN 255\t\t//串的最大长度typedef struct&#123;    char ch[MAXLEN+1];\t//存储串的一维数组    int length;\t\t//串当前的长度&#125;SString;12345//--------串的堆式顺序存储结构------typedef struct&#123;    char *ch;\t\t//若是非空串，则按串长分配存储空间，否则ch为Null    int length;\t\t//串的当前长度&#125;HString;链式存储优点：操作方便缺点：存储密度较低\n存储密度=串值所占的存储位/实际分配的存储位\n\n可将多个字符存放在一个结点中，以克服其缺点\n\n12345678910#define CHUNKSIZE 80       //可由用户定义的块大小typedef struct Chunk&#123;   char  ch[CHUNKSIZE];   struct Chunk *next;&#125;Chunk;typedef struct&#123;   Chunk *head,*tail;      //串的头指针和尾指针   int curlen;                    //串的当前长度&#125;LString;串的模式匹配算法算法目的 : 确定主串中所含子串第一次出现的位置（定位）\n算法种类 : BF算法（又称古典的、经典的、朴素的、穷举的）\nKMP算法（特点：速度快）\n\nBF算法\neg\n\n123456789101112131415161718192021222324int Index(SString S, SString T, int pos)&#123;\t//返回模式T在主串S中第pos个字符之后第s一次出现的位置。若不存在，则返回值为0\t//其中，T非空，1≤pos≤StrLength(S)\tint i = pos;\tint j = 1;\twhile(i &lt;= S[0]&amp;&amp;j &lt;= T[0])\t&#123;\t\tif(S[i]==T[j])\t\t&#123;\t\t\t++i;\t\t\t++j;\t\t&#125; //继续比较后继字符\t\telse\t\t&#123;\t\t\ti=i-j+2;\t\t\tj=1;\t\t&#125; //指针后退重新开始匹配\t&#125;\tif (j &gt; T.length)\t\treturn i - T.length;\t//匹配成功\telse\t\treturn 0;\t//匹配失败&#125;\n若n为主串长度，m为子串长度，最坏情况是\n\n主串前面n-m个位置都部分匹配到子串的最后一位，即这n-m位各比较了m次,最后m位也各比较了1次\n总次数为：(n-m)*m+m＝(n-m+1)*m若m&lt;&lt;n，则算法复杂度O(n*m)\nKMP（Knuth Morris Pratt）算法利用已经部分匹配的结果而加快模式串的滑动速度？    且主串S的指针i不必回溯！可提速到O(n+m)！\n1234567891011121314151617int Index_KMP(SString S, SString T, int pos)&#123; \t// 利用模式串T的next函数求T在主串S中第pos个字符之后的位置的KMP算法\t//其中，T非空，1≤pos≤S.Length\tint i = pos, j = 1;\twhile (i &lt;= S.length &amp;&amp; j &lt;= T.length)\t\tif (j == 0 || S.ch[i] == T.ch[j]) // 继续比较后继字\t\t&#123;\t\t\t++i;\t\t\t++j;\t\t&#125;\t\telse\t\t\tj = next[j]; // 模式串向右移动\tif (j &gt; T[0]) // 匹配成功\t\treturn i - T[0];\telse\t\treturn 0;&#125;计算next函数值1234567891011121314void get_next(SString T, int next[])&#123;//求模式串T的next函数值并存入数组next     i= 1; next[1] = 0; j = 0;        while( i&lt;T.length)     &#123;          if(j==0 || T.ch[i] == T.ch[j])          &#123;                ++i; ++j;                 next[i] = j;          &#125;          else                j = next[j];     &#125;&#125;数组数组一旦被定义，他的维数和维界就不再改变\n一维数组二维数组​              \n三维数组a[m1][m2] [m3] 各维元素个数为  m1, m2, m3\n 下标为 i1, i2, i3的数组元素的存储位置：    \n特殊矩阵的压缩存储什么是压缩存储？\n​    若多个数据元素的值都相同，则只分配一个元素值的存储空间，且零元素不占存储空间。\n什么样的矩阵能够压缩？ \n​    一些特殊矩阵，如：对称矩阵，对角矩阵，三角矩阵，稀疏矩阵等。\n 什么叫稀疏矩阵？\n​    矩阵中非零元素的个数较少（一般小于5%）\n","plink":"https://dxsummer.gitee.io/posts/32c38e43/"},{"title":"ACM数据结构","date":"2020-10-24T07:13:14.000Z","date_formatted":{"ll":"2020年10月24日","L":"2020/10/24","MM-DD":"10-24"},"updated":"2020-12-20T08:25:32.000Z","content":"顺序表应用多余元素删除之移位算法Description\n一个长度不超过10000数据的顺序表，可能存在着一些值相同的“多余”数据元素（类型为整型），编写一个程序将“多余”的数据元素从顺序表中删除，使该表由一个“非纯表”（值相同的元素在表中可能有多个）变成一个“纯表”（值相同的元素在表中只保留第一个）。\n要求：\n1、必须先定义线性表的结构与操作函数，在主函数中借助该定义与操作函数调用实现问题功能；\n2、本题的目标是熟悉顺序表的移位算法，因此题目必须要用元素的移位实现删除；\nInput\n第一行输入整数n，代表下面有n行输入；\n之后输入n行，每行先输入整数m，之后输入m个数据，代表对应顺序表的每个元素。\nOutput\n输出有n行，为每个顺序表删除多余元素后的结果\nSample\nInput \n1234545 6 9 6 8 93 5 5 55 9 8 7 6 510 1 2 3 4 5 5 4 2 1 3Output \n12346 9 859 8 7 6 51 2 3 4 5Answer\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152#include&lt;stdio.h&gt;typedef struct&#123;    int data[10010];&#125;SL;            //定义顺序表void creatlist(SL *l,int n)&#123;\tint i;\t    for(i=0;i&lt;n;i++)\t    &#123;\t        scanf(\"%d\",&amp;l-&gt;data[i]);\t    &#125;&#125;               //创建顺序表int deletelist(SL *l,int n)&#123;\tint i,j,k;\t    for(i=0;i&lt;n-1;i++)\t        for( j=i+1;j&lt;n;j++)  //循环遍历\t        &#123;\t          if(l-&gt;data[i]==l-&gt;data[j])\t            &#123;\t                n--;\t                for( k=j;k&lt;n;k++)  //将后面的移到前面\t                    l-&gt;data[k]=l-&gt;data[k+1];\t                j--;\t            &#125;\t        &#125;\t        return n;&#125;               //删除重复元素void printlist(SL *l,int n)&#123;\tint i;\t    for(i=0;i&lt;n;i++)\t        if(i==n-1)\t            printf(\"%d\\n\",l-&gt;data[i]);\t        else printf(\"%d \",l-&gt;data[i]);&#125;               //输出顺序表int main()&#123;    int n;    scanf(\"%d\",&amp;n);    while(n--)    &#123;        int m;        scanf(\"%d\",&amp;m);        SL l;        creatlist(&amp;l,m);        m=deletelist(&amp;l,m);        printlist(&amp;l,m);    &#125;    return 0;&#125;有序顺序表归并Description\n已知顺序表A与B是两个有序的顺序表，其中存放的数据元素皆为普通整型，将A与B表归并为C表，要求C表包含了A、B表里所有元素，并且C表仍然保持有序。\nInput\n输入分为三行：第一行输入m、n（1&lt;=m,n&lt;=10000）的值，即为表A、B的元素个数；第二行输入m个有序的整数，即为表A的每一个元素；第三行输入n个有序的整数，即为表B的每一个元素；\nOutput\n输出为一行，即将表A、B合并为表C后，依次输出表C所存放的元素。\nSample\nInput \n1235 31 3 5 6 92 4 10Output \n11 2 3 4 5 6 9 10Answer\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include&lt;iostream&gt;#include&lt;stdlib.h&gt;#include&lt;stdio.h&gt;#define MaxSize 100001using namespace std;typedef int element;typedef struct List&#123;    element data[MaxSize];    int size;&#125;list,list1,list2,list3;void init(list1 &amp;l1,list2 &amp;l2,int a,int b,list3 &amp;l3)&#123;    for(int i = 0 ; i &lt; a;i++)&#123;        l1.data[i] = 0;    &#125;    l1.size = a;     for(int i = 0 ; i &lt; b;i++)&#123;        l2.data[i] = 0;    &#125;    l2.size = b;     for(int i = 0 ; i &lt; a + b;i++)&#123;        l3.data[i] = 0;    &#125;    l3.size = a + b;&#125; void input(list1 &amp;l1,list2 &amp;l2,int a,int b)&#123;    int j;    for(int i = 0 ; i &lt; a;i++)&#123;\t\t//对顺序表A赋值         cin &gt;&gt; j;        l1.data[i] = j;    &#125;     for(int i = 0 ; i &lt; b;i++)&#123;\t//对顺序表B赋值         cin &gt;&gt; j;        l2.data[i] = j;    &#125;&#125; void merge(list1 &amp;l1,list2 &amp;l2,list3 &amp;l3)&#123;    int aa = 0,bb = 0,index=0;    int c = l1.size + l2.size;    while(c--)&#123; \t//a b对比 将较小值放到前面         int a = (aa &gt;= l1.size ? 65535 : l1.data[aa]);        int b = (bb &gt;= l2.size ? 65535 : l2.data[bb]);        if(a &gt; b)&#123;            l3.data[index++] = b;            bb++;        &#125;\t\telse&#123;            l3.data[index++] = a;            aa++;        &#125;    &#125;&#125; void output(list3 &amp;l3)&#123;    int i;    for(i = 0 ; i &lt; l3.size;i++)&#123;        printf(\"%d \",l3.data[i]);    &#125;&#125; int main()&#123;    int a,b;    list1 l1;    list2 l2;    list3 l3;    cin &gt;&gt; a &gt;&gt; b;    init(l1,l2,a,b,l3);\t//初始化     input(l1,l2,a,b);\t//负值     merge(l1,l2,l3);\t    output(l3);&#125;有序顺序表查询Description\n顺序表内按照由小到大的次序存放着n个互不相同的整数，任意输入一个整数，判断该整数在顺序表中是否存在。如果在顺序表中存在该整数，输出其在表中的序号；否则输出“No Found!”。\nInput\n第一行输入整数n (1 &lt;= n &lt;= 100000)，表示顺序表的元素个数；第二行依次输入n个各不相同的有序非负整数，代表表里的元素；第三行输入整数t (1 &lt;= t &lt;= 100000)，代表要查询的次数；第四行依次输入t个非负整数，代表每次要查询的数值。\n保证所有输入的数都在 int 范围内。\nOutput\n输出t行，代表t次查询的结果，如果找到在本行输出该元素在表中的位置，否则本行输出No Found!\nSample\nInput \n1234101 22 33 55 63 70 74 79 80 87455 10 2 87Output \n12344No Found!No Found!10Answer\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#include&lt;stdio.h&gt;#include&lt;stdlib.h&gt;#include&lt;math.h&gt;#include&lt;iostream&gt;#define max 100005using namespace std;typedef struct&#123;\tint *elem;\tint length;\tint listsize;&#125;List;void creat(List &amp;L,int n)&#123;\tL.elem=new int[max];\tif(!L.elem) exit(OVERFLOW);\tfor(int i=0;i&lt;n;i++)&#123;\t\tcin&gt;&gt;L.elem[i];\t\tL.length++;\t&#125;&#125;int search(List L,int left,int right,int num)             //由于时间限制，必须用到二分查找。&#123;    while(left&lt;=right)    &#123;        int mid=(left+right)/2;        if(L.elem[mid]&lt;num)            left=mid+1;        else if (L.elem[mid]&gt;num)            right=mid-1;        else            return mid+1;    &#125;    return 0;&#125;int main()&#123;\tint n,m,x;\tList L;\tcin&gt;&gt;n;\tcreat(L,n);\tcin&gt;&gt;m;\tfor(int i=0;i&lt;m;i++)&#123;\t\tcin&gt;&gt;x;\t\tint loc=search(L,0,n,x);\t\tif(loc)        &#123;            cout&lt;&lt;loc&lt;&lt;endl;        &#125;        else        &#123;            cout&lt;&lt;\"No Found!\"&lt;&lt;endl;        &#125;    &#125;    return 0;&#125;链表链表的逆置Description\n输入多个整数，以-1作为结束标志，顺序建立一个带头结点的单链表，之后对该单链表的数据进行逆置，并输出逆置后的单链表数据。\nInput\n输入多个整数，以-1作为结束标志。\nOutput\n输出逆置后的单链表数据。\nSample\nInput \n112 56 4 6 55 15 33 62 -1Output \n162 33 15 55 6 4 56 12Answer\n12345678910111213141516171819202122232425262728293031323334353637383940414243#include&lt;stdio.h&gt;#include&lt;malloc.h&gt; struct node&#123;    int data;    struct node *next;&#125;;//逆序建立链表struct node *Creat()&#123;    struct node *head,*p;    head=(struct node *)malloc(sizeof(struct node));    head-&gt;next=NULL;    p=(struct node *)malloc(sizeof(struct node));    scanf(\"%d\",&amp;p-&gt;data);    while(p-&gt;data!=-1)    &#123;        p-&gt;next=head-&gt;next;        head-&gt;next=p;        p=(struct node *)malloc(sizeof(struct node));        scanf(\"%d\",&amp;p-&gt;data);    &#125;    return (head);&#125; int main()&#123;    struct node *head;    head=Creat();//    if(head-&gt;next!=NULL)//    &#123;//        printf(\"%d\",head-&gt;next-&gt;data);//        head=head-&gt;next;//    &#125;    while(head-&gt;next!=NULL)    &#123;        printf(\"%d \",head-&gt;next-&gt;data);        head=head-&gt;next;    &#125;    printf(\"\\n\");    return 0;&#125;链表的逆置Description\n输入多个整数，以-1作为结束标志，顺序建立一个带头结点的单链表，之后对该单链表的数据进行逆置，并输出逆置后的单链表数据。\nInput\n输入多个整数，以-1作为结束标志。\nOutput\n输出逆置后的单链表数据。\nSample\nInput \n112 56 4 6 55 15 33 62 -1Output \n162 33 15 55 6 4 56 12Answer\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;iostream&gt; using namespace std;struct node&#123;    int date;    struct node *next;&#125;;struct node *head,*p,*tail;int main()&#123;    int i;    int n;    scanf(\"%d\",&amp;n);    head = new node;    head-&gt;next = NULL;    tail = head;    for(i=0; i&lt;n; i++)\t//录入数据     &#123;        p = new node;        scanf(\"%d\",&amp;p-&gt;date);        p-&gt;next = NULL;        tail-&gt;next = p;        tail = p;    &#125;    int m;//要删除的数字    int t=0;//要删除的数字的个数    scanf(\"%d\",&amp;m);    printf(\"%d\\n\",n);    p = head-&gt;next;    while(p-&gt;next)    &#123;        printf(\"%d \",p-&gt;date);        p = p-&gt;next;    &#125;    printf(\"%d\\n\",p-&gt;date);    p = head;    while(p-&gt;next)    &#123;        if(p-&gt;next-&gt;date==m)//前移         &#123;            t++;            tail = p-&gt;next;            p-&gt;next = tail-&gt;next;            delete(tail);//释放指针指向的内存地址         &#125;        else            p = p-&gt;next;    &#125;    printf(\"%d\\n\",n-t);//剩余     p = head-&gt;next;    while(p-&gt;next)    &#123;        printf(\"%d \",p-&gt;date);        p = p-&gt;next;    &#125;    printf(\"%d\\n\",p-&gt;date);    return 0;&#125;顺序建立链表Description\n输入N个整数，按照输入的顺序建立单链表存储，并遍历所建立的单链表，输出这些数据。\nInput\n第一行输入整数的个数N；第二行依次输入每个整数。\nOutput\n输出这组整数。\nSample\nInput \n12812 56 4 6 55 15 33 62Output \n112 56 4 6 55 15 33 62Answer\n1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;struct node&#123;    int data;    struct node *next;&#125;;int main()&#123;    struct node *head,*p,*tail;    int n,i;    head = (struct node *)malloc(sizeof(struct node));    head-&gt;next = NULL;    tail = head;    scanf(\"%d\",&amp;n);    for(i=0;i&lt;n;i++)    &#123;        p = (struct node *)malloc(sizeof(struct node));        scanf(\"%d\",&amp;p-&gt;data);        p-&gt;next =NULL;        tail-&gt;next = p;        tail = p;    &#125;    struct node *q;    q = head-&gt;next;    while(q!=NULL)    &#123;        if(q-&gt;next != NULL)           &#123;           printf(\"%d \",q-&gt;data);           &#125;           else &#123;             printf(\"%d\\n\",q-&gt;data);           &#125;        q = q-&gt;next;    &#125;    return 0;&#125;栈一般算术表达式转换成后缀式Description\n对于一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出之。\nInput\n输入一个算术表达式，以‘#’字符作为结束标志。\nOutput\n输出该表达式转换所得到的后缀式。\nInput \n1a*b+(c-d/e)*f#Output \n1ab*cde/-f*+Answer c++\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int cmp(char a)&#123;    if(a == '-' || a == '+') return 1;    if(a == '*' || a == '/') return 2;    if(a == ')') return 3;    if(a == '(') return 4;    return 0;&#125; typedef struct&#123;   char * base;    char  *top;&#125;SqStack;char a[1000];void InitStack(SqStack &amp;S)&#123;    S.base = (char *)malloc(1000*sizeof(char));    S.top = S.base;&#125;void Push(SqStack &amp;S, char  e)&#123;    *S.top++ = e;&#125;void Pop(SqStack &amp;S)&#123;    char e;    e = *--S.top;    cout &lt;&lt; e;&#125;int main()&#123;    while(~scanf(\"%s\", a))    &#123;        int i;        SqStack S;        InitStack(S);        for(i = 0; a[i]!='#'; i++)        &#123;            if(a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z')                cout &lt;&lt; a[i];            else            &#123;                if(S.base == S.top)                &#123;                    Push(S, a[i]);                &#125;                else                &#123;                    if(cmp(*(S.top-1)) &gt;= cmp(a[i]))                    &#123;                        if(*(S.top-1) != '(')                        &#123;                              Pop(S);                              Push(S, a[i]);                        &#125;                       else                       &#123;                             Push(S, a[i]);                       &#125;                    &#125;                    else                    &#123;                       if(a[i] == ')')                       &#123;                           while(*(S.top-1) != '(')                           &#123;                               Pop(S);                           &#125;                           S.top--;                       &#125;                       else                       &#123;                           Push(S, a[i]);                       &#125;                    &#125;                &#125;             &#125;        &#125;        while(S.top != S.base)        &#123;            Pop(S);        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;进制转换Description\n输入一个十进制非负整数，将其转换成对应的 R (2 &lt;= R &lt;= 9) 进制数，并输出。\nInput\n第一行输入需要转换的十进制非负整数；第二行输入 R。\nOutput\n输出转换所得的 R 进制数。\nSample\nInput \n1212798Output \n12377Answer\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define stackinitsize 100#define stackcreat 10#define ok 1#define overflow -1#define error -1typedef struct\t//定义结构体 &#123;    int *base;    int *top;    int stacksize;&#125; sqstack;int initstack(sqstack *s)\t// &#123;    s-&gt;base=(int*)malloc(stackinitsize*sizeof(int));    if(!s-&gt;base)exit(overflow);    s-&gt;top=s-&gt;base;    s-&gt;stacksize=stackinitsize;    return ok;&#125;int push(sqstack *s,int e)&#123;    if(s-&gt;top-s-&gt;base&gt;=s-&gt;stacksize)    &#123;        s-&gt;top=(int*)realloc(s-&gt;base,(s-&gt;stacksize+stackcreat)*sizeof(int));        if(!s-&gt;base)exit(overflow);        s-&gt;top=s-&gt;base+s-&gt;stacksize;    &#125;    *s-&gt;top++=e;    return ok;&#125;int pop(sqstack *s)&#123;    if(s-&gt;top==s-&gt;base)return error;    s-&gt;top--;    return ok;&#125;int stackempty(sqstack *s)&#123;    if(s-&gt;top==s-&gt;base)return 1;    else return 0;&#125;int gettop(sqstack *s)&#123;    int e;    if(s-&gt;top==s-&gt;base)return error;    e=*(s-&gt;top-1);    return e;&#125;int main()&#123;    int n,r,e;    sqstack s;    scanf(\"%d\",&amp;n);    scanf(\"%d\",&amp;r);    if(n==0)printf(\"0\\n\");//注意如果被除数为零，则都是零    initstack(&amp;s);//创建栈     while(n)//不断相除，将余数存到栈里面    &#123;        push(&amp;s,n%r);        n=n/r;    &#125;    while(!stackempty(&amp;s))//当栈不空的时候，把栈里面的数字输出    &#123;        e=gettop(&amp;s);        pop(&amp;s);        printf(\"%d\",e);    &#125;    printf(\"\\n\");    return 0;&#125;后缀式求值Description\n对于一个基于二元运算符的后缀表示式（基本操作数都是一位正整数），求其代表的算术表达式的值。\nInput\n输入一个算术表达式的后缀式字符串，以‘#’作为结束标志。\nOutput\n求该后缀式所对应的算术表达式的值，并输出之。\nSample\nInput \n159*684&#x2F;-3*+#Output \n157Hint\n基本操作数都是一位正整数!\nAnswer\n123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;stdio.h&gt;#include&lt;string.h&gt; int ls[1000];char a[1000];int main()&#123;    while(~scanf(\"%s\",a))    &#123;        int i, k = -1;        for(i = 0; a[i] != '#'; i++)        &#123;            if(a[i] &gt;= '0' &amp;&amp; a[i] &lt;= '9')            &#123;                ls[++k] = a[i] - '0';            &#125;            else            &#123;                if(a[i] == '*')                &#123;                    ls[k-1] = ls[k-1] * ls[k];                    k = k-1;                &#125;                if(a[i] == '/')                &#123;                      ls[k-1] = ls[k-1] / ls[k];                    k = k-1;                &#125;                if(a[i] == '+')                &#123;                      ls[k-1] = ls[k-1] + ls[k];                    k = k-1;                &#125;                if(a[i] == '-')                &#123;                      ls[k-1] = ls[k-1] - ls[k];                    k = k-1;                &#125;            &#125;        &#125;        printf(\"%d\\n\",ls[0]);    &#125;    return 0;&#125;括号匹配Description\n 给你一串字符，不超过50个字符，可能包括括号、数字、字母、标点符号、空格，你的任务是检查这一串字符中的( ) ,[ ],{ }是否匹配。\nInput\n 输入数据有多组，处理到文件结束。\nOutput\n 如果匹配就输出“yes”，不匹配输出“no”\nSample\nInput \n12sin(20+10)&#123;[&#125;]Output \n12yesnoAnswer\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123;    char s[51],b[51];    int i,len;    while(gets(s))    &#123;        int j=-1;        int flag=1;        len=strlen(s);        for(i=0; i&lt;len; i++)        &#123;            if(s[i]=='('||s[i]=='&#123;'||s[i]=='[')//前括号一律收入栈中                b[++j]=s[i];            if(s[i]==')')//若遇到对应的后括号            &#123;                if(j==-1)//先判断栈是否为空                &#123;                    flag=0;                    break;//若为空直接退出循环                &#125;                if(j&gt;-1&amp;&amp;b[j]=='(')//若不为空看是否能找到对应的匹配的括号                &#123;                    j--;//找到就让其出栈                &#125;                else                &#123;                    flag=0;                    break;//不匹配就退出循环                &#125;            &#125;            if(s[i]==']')            &#123;                if(j==-1)                &#123;                    flag=0;                    break;                &#125;                if(j&gt;-1&amp;&amp;b[j]=='[')                &#123;                    j--;                &#125;                else                &#123;                    flag=0;                    break;                &#125;            &#125;            if(s[i]=='&#125;')            &#123;                if(j==-1)                &#123;                    flag=0;                    break;                &#125;                if(j&gt;-1&amp;&amp;b[j]=='&#123;')                &#123;                    j--;                &#125;                else                &#123;                    flag=0;                    break;                &#125;            &#125;        &#125;        if(flag==0||j&gt;-1)//最后要考虑到栈只要不为空都不能完成匹配            printf(\"no\\n\");        else if(j==-1) printf(\"yes\\n\");    &#125;    return 0;&#125;树和二叉树遍历二叉树Description\n已知二叉树的一个按先序遍历输入的字符序列，如abc,,de,g,,f,,, (其中,表示空结点)。请建立二叉树并按中序和后序的方式遍历该二叉树。\nInput\n连续输入多组数据，每组数据输入一个长度小于50个字符的字符串。\nOutput\n每组输入数据对应输出2行：第1行输出中序遍历序列；第2行输出后序遍历序列。\nSample\nInput \n1abc,,de,g,,f,,,Output \n12cbegdfacgefdbaAnswer\n这道题就是考察中序和后序遍历二叉树的规则，如果是中序遍历的话，先遍历左子树，然后输出根节点，之后遍历右子树。而后序遍历则是先遍历左子树，然后是右子树，最后是根节点。其实前中后遍历的方法就是根据根节点遍历的先后顺序来决定的。此外，本题还考察了二叉树的建立，二叉树的建立实际上是充分利用了递归的思想，从根节点逐层递归到叶子结点即最深层结点。本人比较喜欢用链表进行二叉树的建立。因为不容易丢失数据。详情见AC代码。\nPS：好多人问我示例数据建立起来的二叉树是怎样的，从一串字符或者数字建立起立体的二叉树（先序），其实就是根据先序建立的特点使数据串进行立体化，先序输出二叉树就是先输出根节点，之后输出左子树，最后右子树。比如本题示例，\n1abc,,de,g,,f,,,a一定是根节点，之后b是a结点的左孩子，c是b的左孩子，之后两个，，（符号）是空，说明c结点是叶子结点（没有孩子）\n然后回溯到b结点，d是b结点的右孩子，e是d结点的左孩子，之后的逗号（，）是表示e结点的左孩子为空，g是e结点的右孩子，之后的两个逗号（，）表示g没有孩子，即g结点是叶子结点。然后再回溯到d结点，f结点是d结点的右孩子，之后的两个逗号（，）表示f没有孩子，即f是叶子结点。再回溯到a结点，最后一个逗号（，）表示的是a结点的右孩子为空。\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;bits/stdc++.h&gt;using namespace std;char a[100];//用a数组来作为中继数组存放数据int x;struct node//树节点的建立&#123;\tint data;\tstruct node*lchild,*rchild;//定义左孩子和右孩子&#125;;struct node*creat()//二叉树的建立&#123;\tstruct node*root;\tchar c;\tc=a[x++];\tif(c==',')//如果是符号“，”则进行空指针的处理\t&#123;\t\treturn NULL;\t&#125;\telse//否则就将数据存放到新建立的结点中\t&#123;\t\troot=(struct node*)malloc(sizeof(struct node));\t\troot-&gt;data=c;\t\troot-&gt;lchild=creat();\t\troot-&gt;rchild=creat(); \t&#125;\treturn root;&#125;void mid(struct node*root)//中序遍历&#123;\tif(root)\t&#123;\t\tmid(root-&gt;lchild);\t\tprintf(\"%c\",root-&gt;data);\t\tmid(root-&gt;rchild);\t&#125;&#125;void after(struct node*root)//后序遍历&#123;\tif(root)\t&#123;\t\tafter(root-&gt;lchild);\t\tafter(root-&gt;rchild);\t\tprintf(\"%c\",root-&gt;data);\t&#125;&#125;int main()&#123;\tstruct node*root;\twhile(~scanf(\"%s\",a))\t&#123;\t\tx=0;\t\troot=(struct node*)malloc(sizeof(struct node));\t\troot=creat();\t\tmid(root);\t\tprintf(\"\\n\");\t\tafter(root);\t\tprintf(\"\\n\");\t&#125;\treturn 0;&#125;哈夫曼编码Description字符的编码方式有多种，除了大家熟悉的ASCII编码，哈夫曼编码(Huffman Coding)也是一种编码方式，它是可变字长编码。该方法完全依据字符出现概率来构造出平均长度最短的编码，称之为最优编码。哈夫曼编码常被用于数据文件压缩中，其压缩率通常在20%～90%之间。你的任务是对从键盘输入的一个字符串求出它的ASCII编码长度和哈夫曼编码长度的比值。\nInput 输入数据有多组，每组数据一行，表示要编码的字符串。Output 对应字符的ASCII编码长度la，huffman编码长度lh和la/lh的值(保留一位小数)，数据之间以空格间隔。SampleInput \n12AAAAABCDTHE_CAT_IN_THE_HATOutput \n1264 13 4.9144 51 2.8Answer\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include&lt;string.h&gt;char s[500];int q[1000],t[1000];void arrange(int a[],int left,int right)&#123;    int x=a[left],i=left,j=right;    if(i&gt;=j)return ;    while(i&lt;j)    &#123;        while(i&lt;j&amp;&amp;a[j]&gt;=x)j--;        a[i]=a[j];        while(i&lt;j&amp;&amp;a[i]&lt;=x)i++;        a[j]=a[i];    &#125;    a[i]=x;    arrange(a,left,i-1);    arrange(a,i+1,right);&#125;int main()&#123;    int len,i;    while(~scanf(\"%s\",s))    &#123;        memset(t,0,sizeof(t));        int top=0,rear=0;        len=strlen(s);        int m=len*8;//ASCLL码值每位占8个字节        for(i=0; i&lt;len; i++)        &#123;            t[s[i]]++;        &#125;//记录下每个字符出现的次数。        for(i=0; i&lt;500; i++)        &#123;            if(t[i])            &#123;                q[top++]=t[i];//让这些记录的数字入队            &#125;        &#125;        arrange(q,0,top-1);//从小到大排好序        int sum=0;        int x1,x2;        while(top!=rear)        &#123;            x1=q[rear++];//为什么是rear++，因为到最后一个的时候top是指在最后一个数的后面，此时rear指在最后一个数，            //这样rear++就立刻不满足下面的条件,里面的sum也不会增加了            if(top!=rear)            &#123;                x2=q[rear++];//为了让rear指向第三个数，进行排序                sum+=x1+x2;                q[top++]=x1+x2;//存放的是x1+x2，而不是sum                arrange(q,rear,top-1);            &#125;        &#125;        printf(\"%d %d %.1lf\\n\",m,sum,1.0*m/sum);    &#125;    return 0;&#125;树-堆结构练习——合并果子之哈夫曼树Description 在一个果园里，多多已经将所有的果子打了下来，而且按果子的不同种类分成了不同的堆。多多决定把所有的果子合成一堆。每一次合并，多多可以把两堆果子合并到一起，消耗的体力等于两堆果子的重量之和。可以看出，所有的果子经过n-1次合并之后，就只剩下一堆了。多多在合并果子时总共消耗的体力等于每次合并所消耗体力之和。因为还要花大力气把这些果子搬回家，所以多多在合并果子时要尽可能地节省体力。假定每个果子重量都为1，并且已知果子的种类数和每种果子的数目，你的任务是设计出合并的次序方案，使多多耗费的体力最少，并输出这个最小的体力耗费值。例如有3种果子，数目依次为1，2，9。可以先将1、2堆合并，新堆数目为3，耗费体力为3。接着，将新堆与原先的第三堆合并，又得到新的堆，数目为12，耗费体力为12。所以多多总共耗费体力=3+12=15。可以证明15为最小的体力耗费值。\nInput 第一行是一个整数n(1&lt;=n&lt;=10000),表示果子的种类数。第二行包含n个整数，用空格分隔，第i个ai(1&lt;=ai&lt;=20000)是第i个果子的数目。\nOutput 输出包括一行，这一行只包含一个整数，也就是最小的体力耗费值。输入数据保证这个值小于2^31。\nSample*Input *\n1231 2 9Output \n115Answer\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475#include &lt;cstdio&gt;#include &lt;cstring&gt;#include &lt;cstdlib&gt;#include &lt;iostream&gt;using namespace std;struct N&#123;    int data;    N *l,*r;&#125;;struct N *creat()&#123;    N *p = (N *)malloc(sizeof(N));    p-&gt;l = p-&gt;r = NULL;    return p;&#125;void insert(N *&amp;root,int data)&#123;    if(root == NULL)    &#123;        root = creat();        root-&gt;data = data;    &#125;    else if(data &gt;= root-&gt;data)    &#123;        insert(root-&gt;r,data);    &#125;    else    &#123;        insert(root-&gt;l,data);    &#125;&#125;int check(N *&amp;root)&#123;    if(root-&gt;l == NULL)    &#123;        int t = root-&gt;data;        root = root-&gt;r;        return t;    &#125;    else        return check(root-&gt;l);&#125;int main()&#123;    int n,t,i,sum = 0;    cin&gt;&gt;n;    N *root = NULL;    for(i = 0 ;i &lt; n; i++)    &#123;        cin&gt;&gt;t;        insert(root,t);    &#125;    int a,b;    for(i = 1;i &lt; n; i++)    &#123;        a = check(root);        b = check(root);        sum += a+b;        insert(root,a+b);    &#125;    cout&lt;&lt;sum&lt;&lt;endl;    return 0;&#125;图深度优先遍历–迷宫探索Description有一个地下迷宫，它的通道都是直的，而通道所有交叉点(包括通道的端点)上都有一盏灯和一个开关；请问如何从某个起点开始在迷宫中点亮所有的灯并回到起点？Input连续T组数据输入，每组数据第一行给出三个正整数，分别表示地下迷宫的结点数N(1 &lt; N &lt;= 1000)、边数M(M &lt;= 3000)和起始结点编号S，随后M行对应M条边，每行给出一对正整数，表示一条边相关联的两个顶点的编号。\nOutput若可以点亮所有结点的灯，则输出从S开始并以S结束的序列，序列中相邻的顶点一定有边，否则只输出部分点亮的灯的结点序列，最后输出0，表示此迷宫不是连通图。访问顶点时约定以编号小的结点优先的次序访问，点亮所有可以点亮的灯后，以原路返回的方式回到起点。\nSampleInput \n1234567891016 8 11 22 33 44 55 66 43 61 5Output \n11 2 3 4 5 6 5 4 3 2 1Answer\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include&lt;iostream&gt;#include&lt;queue&gt;#include&lt;cstring&gt;using namespace std;int g[1010][1010];int v[1010];int un;int p[1010];void dfs(int n,int k)&#123;    p[un++]=k;    v[k]=1;    for(int i=1; i&lt;=n; i++)    &#123;        if(g[k][i]&amp;&amp;!v[i])        &#123;            dfs(n,i);            p[un++]=k;        &#125;    &#125;&#125;int main()&#123;    int t;    cin&gt;&gt;t;    while(t--)    &#123;        int n,m,s;        cin&gt;&gt;n&gt;&gt;m&gt;&gt;s;        memset(g,0,sizeof(g));             memset(v,0,sizeof(v));        for(int i=0; i&lt;m; i++)      //建立邻接矩阵        &#123;            int u,v;            cin&gt;&gt;u&gt;&gt;v;            g[u][v]=g[v][u]=1;        &#125;        un=0;        dfs(n,s);        for(int i=0;i&lt;un;i++)            if(!i)                cout&lt;&lt;p[i];            else                cout&lt;&lt;\" \"&lt;&lt;p[i];        if(2*n-1!=un) cout&lt;&lt;\" \"&lt;&lt;0;        cout&lt;&lt;endl;    &#125;    return 0;&#125;广度优先遍历——从起始点到目标点的最短步数（BFS）Description 在古老的魔兽传说中，有两个军团，一个叫天灾，一个叫近卫。在他们所在的地域，有n个隘口，编号为1..n，某些隘口之间是有通道连接的。其中近卫军团在1号隘口，天灾军团在n号隘口。某一天，天灾军团的领袖巫妖王决定派兵攻打近卫军团，天灾军团的部队如此庞大，甚至可以填江过河。但是巫妖王不想付出不必要的代价，他想知道在不修建任何通道的前提下，部队是否可以通过隘口及其相关通道到达近卫军团展开攻击；如果可以的话，最少需要经过多少通道。由于n的值比较大（n&lt;=1000），于是巫妖王找到了擅长编程的你 =_=，请你帮他解决这个问题，否则就把你吃掉变成他的魔法。为了拯救自己，赶紧想办法吧。\nInput 输入包含多组，每组格式如下。\n第一行包含两个整数n,m（分别代表n个隘口，这些隘口之间有m个通道）。\n下面m行每行包含两个整数a，b；表示从a出发有一条通道到达b隘口（注意：通道是单向的）。\nOutput 如果天灾军团可以不修建任何通道就到达1号隘口，那么输出最少经过多少通道，否则输出NO。\nSampleInput \n12342 11 22 12 1Output \n12NO1123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;struct node&#123;    int data;//存储结点的序号    int step;//存储已经遍历的结点&#125;q[2100];int map[1001][1001];//存储关系int v[1001];//存储已经遍历的点int n,m;void BFS(int x)//此处不可用n&#123;    int in=0,out=0;//in表示队头，out表示队尾。    struct node t;    q[in].data=x,q[in].step=0;//将x,和0，传入结构体数组q中(队列)。    in++;    v[t.data]=1;//标记该点已经被遍历    while(in&gt;out)    &#123;        t=q[out++];        if(t.data==1)//当结点到达1时表示可以到达1号关隘        &#123;            printf(\"%d\\n\",t.step);//输出当前步数            return ;        &#125;        int i;        for(i=0; i&lt;n; i++)        &#123;            if(v[i]==0&amp;&amp;map[t.data][i]==1)//满足没有被遍历过，并且存在关系            &#123;                q[in].data=i;                q[in].step=t.step+1;//入队列                in++;                v[i]=1;            &#125;        &#125;    &#125;    printf(\"NO\\n\");    return ;&#125;int main()&#123;    while(scanf(\"%d%d\",&amp;n,&amp;m)!=EOF)    &#123;        memset(map,0,sizeof(map));        memset(v,0,sizeof(v));        int i,a,b;        for(i=0; i&lt;m; i++)        &#123;            scanf(\"%d %d\",&amp;a,&amp;b);            map[a][b]=1;        &#125;        BFS(n);    &#125;    return 0;&#125;最小生成树——村村通公路Description\n当前农村公路建设正如火如荼的展开，某乡镇政府决定实现村村通公路，工程师现有各个村落之间的原始道路统计数据表，表中列出了各村之间可以建设公路的若干条道路的成本，你的任务是根据给出的数据表，求使得每个村都有公路连通所需要的最低成本。\nInput\n连续多组数据输入，每组数据包括村落数目N(N &lt;= 1000)和可供选择的道路数目M(M &lt;= 3000)，随后M行对应M条道路，每行给出3个正整数，分别是该条道路直接连通的两个村庄的编号和修建该道路的预算成本，村庄从1～N编号。 \nOutput\n输出使每个村庄都有公路连通所需要的最低成本，如果输入数据不能使所有村庄畅通，则输出-1，表示有些村庄之间没有路连通。 \nSample\nInput \n1234567895 81 2 121 3 91 4 111 5 32 3 62 4 93 4 44 5 6Output \n119Answer\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include&lt;stdio.h&gt;#include&lt;string.h&gt;#include&lt;stdlib.h&gt;#define inf 0x3f3f3f3fint sum;int flag;int a[1010][1010];int b[1010];int lowcost[1010];int n;void prime();int main()&#123;    int u, v, m;    int cost;    while(~scanf(\"%d %d\", &amp;n, &amp;m))    &#123;        sum = 0;        flag = 0;        memset(a, inf, sizeof(a));        memset(b, 0, sizeof(b));        for(int i = 1; i &lt;= m; i++)        &#123;            scanf(\"%d %d %d\", &amp;u, &amp;v, &amp;cost);            a[u][v] = a[v][u] = cost;        &#125;        prime();        if(!flag)        &#123;            printf(\"%d\\n\", sum);        &#125;        else            printf(\"-1\\n\");    &#125;    return 0;&#125; void prime()&#123;    int t, k, i, j;    b[1] = 1;    for(i = 1; i &lt;= n; i++)     //初始化    &#123;        lowcost[i] = a[i][1];    &#125;    for(i = 2; i &lt;= n; i++)    &#123;        t = inf;        for(j = 1; j &lt;= n; j++)        &#123;                                           //找到到1最近的            if(b[j] == 0&amp;&amp; lowcost[j] &lt; t)            &#123;                t = lowcost[j];                k = j;            &#125;        &#125;        if(t == inf)        &#123;            flag = 1;            break;            //如果到1都没有连接则不连通        &#125;        b[k] = 1;        sum+=t;        for(j = 1; j&lt;= n; j++)          &#123;            if(!b[j] &amp;&amp; lowcost[j] &gt;a[j][k])                lowcost[j] = a[j][k];        &#125;    &#125;&#125;最短路径 驴友计划Description做为一个资深驴友，小新有一张珍藏的自驾游线路图，图上详细的标注了全国各个城市之间的高速公路距离和公路收费情况，现在请你编写一个程序，找出一条出发地到目的地之间的最短路径，如果有多条路径最短，则输出过路费最少的一条路径。Input连续T组数据输入，每组输入数据的第一行给出四个正整数N,M，s，d，其中N(2 &lt;= N &lt;= 500)是城市数目，城市编号从0～N-1，M是城市间高速公路的条数，s是出发地的城市编号，d是目的地的城市编号；随后M行，每行给出一条高速公路的信息，表示城市1、城市2、高速公路长度、收费额，中间以空格间隔，数字均为整数且不超过500，输入数据均保证有解。 \nOutput在同一行中输出路径长度和收费总额，数据间用空格间隔。 \nSampleInput \n123456714 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20Output \n13 4012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485#include &lt;stdio.h&gt;#include &lt;string.h&gt;#define MAX 1000000007int map[500][500][2],v1[500],d[500][2];void spfa(int s,int n)&#123;    int i,f=0,top=0,q[20000],num=MAX;    memset(v1,0,sizeof(v1));    for(i=0;n&gt;i;i++)    &#123;        d[i][0]=MAX;        d[i][1]=MAX;    &#125;    v1[s]=1;    d[s][0]=0;    d[s][1]=0;    q[top]=s;    top++;    while(f&lt;top)    &#123;        v1[q[f]]=0;        for(i=0;n&gt;i;i++)        &#123;            if(d[i][0]&gt;d[q[f]][0]+map[q[f]][i][0])            &#123;                d[i][0]=d[q[f]][0]+map[q[f]][i][0];                d[i][1]=d[q[f]][1]+map[q[f]][i][1];                if(v1[i]==0)                &#123;                    v1[i]=1;                    q[top]=i;                    top++;                &#125;            &#125;            else if(d[i][0]==d[q[f]][0]+map[q[f]][i][0]&amp;&amp;d[i][1]&gt;d[q[f]][1]+map[q[f]][i][1])            &#123;                d[i][1]=d[q[f]][1]+map[q[f]][i][1];                if(v1[i]==0)                &#123;                    v1[i]=1;                    q[top]=i;                    top++;                &#125;            &#125;        &#125;        f++;    &#125;&#125;int main()&#123;    int t,i,i1,i2,n,m,s,d1,u,v,w,z;    scanf(\"%d\",&amp;t);    for(i=1;t&gt;=i;i++)    &#123;        scanf(\"%d %d %d %d\",&amp;n,&amp;m,&amp;s,&amp;d1);        for(i1=0;n&gt;i1;i1++)        &#123;            for(i2=0;n&gt;i2;i2++)            &#123;                if(i1==i2)                &#123;                    map[i1][i2][0]=0;                &#125;                else                &#123;                    map[i1][i2][0]=MAX;                &#125;            &#125;        &#125;        for(i1=1;m&gt;=i1;i1++)        &#123;            scanf(\"%d %d %d %d\",&amp;u,&amp;v,&amp;w,&amp;z);            if(map[u][v][0]&gt;w)            &#123;                map[u][v][0]=w;                map[u][v][1]=z;                map[v][u][0]=w;                map[v][u][1]=z;            &#125;        &#125;        spfa(s,n);        printf(\"%d %d\\n\",d[d1][0],d[d1][1]);    &#125;    return 0;&#125;拓扑排序 判断给定图是否存在合法拓扑序列Description 给定一个有向图，判断该有向图是否存在一个合法的拓扑序列。\nInput 输入包含多组，每组格式如下。\n第一行包含两个整数n，m，分别代表该有向图的顶点数和边数。(n&lt;=10)\n后面m行每行两个整数a b，表示从a到b有一条有向边。\nOutput 若给定有向图存在合法拓扑序列，则输出YES；否则输出NO。\nSampleInput \n12341 02 21 22 1Output \n12YESNO123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdio.h&gt;#include &lt;string.h&gt;#include &lt;stdlib.h&gt;int s[20][20], v[20], degree[20];void find(int n)&#123;    int i, j, k, flag;    for(i = 1; i &lt;= n; i++)    &#123;        flag = 0;        for(j = 1; j &lt;= n; j++)        &#123;            if(degree[j] == 0 &amp;&amp; v[j] == 0)            &#123;                v[j] = 1;                for(k = 1; k &lt;= n; k++)                &#123;                    if(s[j][k])                        degree[k]--;                &#125;                flag = 1;                break;            &#125;        &#125;    &#125;    if(!flag)        printf(\"NO\\n\");    else        printf(\"YES\\n\");&#125;int main()&#123;    int n, m, u, w;    while(scanf(\"%d %d\", &amp;n, &amp;m) != EOF)    &#123;        memset(s, 0, sizeof(s));        memset(v, 0, sizeof(v));        memset(degree, 0, sizeof(degree));        while(m--)        &#123;            scanf(\"%d %d\", &amp;u, &amp;w);            s[u][w] = 1;            degree[w]++;        &#125;        find(n);    &#125;    return 0;&#125;查找表树的种类统计Description随着卫星成像技术的应用，自然资源研究机构可以识别每一个棵树的种类。请编写程序帮助研究人员统计每种树的数量，计算每种树占总数的百分比。\nInput输入一组测试数据。数据的第1行给出一个正整数N (n &lt;= 100000)，N表示树的数量；随后N行，每行给出卫星观测到的一棵树的种类名称，树的名称是一个不超过20个字符的字符串，字符串由英文字母和空格组成，不区分大小写。\nOutput按字典序输出各种树的种类名称和它占的百分比，中间以空格间隔，小数点后保留两位小数。\nSampleInput \n1232This is an Appletreethis is an appletreeOutput \n1this is an appletree 100.00%1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#include &lt;string.h&gt;using namespace std;int n;struct node&#123;    char c[30];    int num;    struct node * l;    struct node * r;&#125;;  struct node * creat(struct node * p, char *s)&#123;    if(p == NULL)    &#123;        p = (struct node *)malloc(sizeof(struct node));        strcpy(p-&gt;c, s);        p-&gt;num = 1;        p-&gt;l = NULL;        p-&gt;r = NULL;    &#125;    else if(strcmp(p-&gt;c, s) &gt; 0)        p-&gt;l = creat(p-&gt;l, s);    else if(strcmp(p-&gt;c, s) &lt; 0)        p-&gt;r = creat(p-&gt;r, s);    else if(strcmp(p-&gt;c, s) == 0)        p-&gt;num++;    return p;&#125;;  void mid(struct node * p)&#123;    if(p)    &#123;        mid(p-&gt;l);        printf(\"%s %.2lf%c\\n\",p-&gt;c,p-&gt;num*100.0/n,'%');        mid(p-&gt;r);    &#125;&#125;  int main()&#123;    struct node * Tree = NULL;    char s[30];    cin &gt;&gt; n;    getchar();    for(int j = 0; j &lt; n; j++)    &#123;        cin.getline(s, 30);        for(int i = 0; s[i] != '\\0'; i++)        &#123;            if(s[i] &gt;= 'A' &amp;&amp; s[i] &lt;= 'Z')                s[i] = s[i] + 32;        &#125;        Tree = creat(Tree, s);    &#125;    mid(Tree);    return 0;&#125;二分查找Description\n在一个给定的无重复元素的递增序列里，查找与给定关键字相同的元素，若存在则输出找到的位置,不存在输出-1。\nInput一组输入数据，输入数据第一行首先输入两个正整数n ( n &lt; = 10^6 )和m ( m &lt; = 10^4 )，n是数组中数据元素个数，随后连续输入n个正整数，输入的数据保证数列递增。随后m行输入m个待查找的关键字key\nOutput若在给定的序列中能够找到与关键字key相等的元素，则输出位序(序号从0开始)，否则输出-1。\nSampleInput \n123458 34 6 8 9 13 20 21 226817Output \n12312-112345678910111213141516171819202122232425262728293031#include&lt;stdio.h&gt;int Search(int a[],int l,int r,int key)  &#123;      int i = l,j = r;      while(i &lt;= j)      &#123;          int mid = (i + j)/2;          if(a[mid] == key)              return mid;          else if(key &lt; a[mid])              j = mid-1;          else              i = mid+1;      &#125;      return -1;  &#125;   int main()&#123;\tint n,m,x;\tscanf(\"%d%d\",&amp;n,&amp;m);\tint a[n+1];\tfor(int i=0;i&lt;n;i++)&#123;\t\tscanf(\"%d\",&amp;a[i]);\t&#125;\tfor(int i=0;i&lt;m;i++)&#123;\t\tscanf(\"%d\",&amp;x);\t\tint k=Search(a,0,n-1,x);\t\tprintf(\"%d\\n\",k);\t&#125;\treturn 0;&#125;哈希查找 线性之哈希表Description根据给定的一系列整数关键字和素数p,用除留余数法定义hash函数H(Key)=Key%p,将关键字映射到长度为p的哈希表中，用线性探测法解决冲突。重复关键字放在hash表中的同一位置。\nInput连续输入多组数据，每组输入数据第一行为两个正整数N(N &lt;= 1500)和p(p &gt;= N的最小素数)，N是关键字总数，p是hash表长度，第2行给出N个正整数关键字，数字间以空格间隔。\nOutput输出每个关键字在hash表中的位置，以空格间隔。注意最后一个数字后面不要有空格。\nSampleInput \n123456785 521 21 21 21 214 524 15 61 884 524 39 61 155 524 39 61 15 39Output \n12341 1 1 1 14 0 1 34 0 1 24 0 1 2 012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;  #include &lt;stdlib.h&gt;  #include &lt;string.h&gt;    int main()  &#123;      int n,p,i,j;      int ha[1100],a[1100];      while (~scanf (\"%d %d\",&amp;n,&amp;p))      &#123;          memset (ha,0,sizeof (ha));          for (i=0; i&lt;n; i++)          &#123;              int d = 0;              scanf (\"%d\",&amp;a[i]);              int t = a[i]%p;              if (!ha[t])              &#123;                  ha[t] = a[i];                  printf (\"%d\",t);              &#125;//if              else//当ha[t]位置被存储过的时候有两种情况，一种是通过线性探测法找到此元素已经被存储过的位置tmp，另一种是通过线性探测法找到下一个存储位置(t+d)%p              &#123;                  int tmp;                  bool vis;                  while (ha[(t+d)%p])                  &#123;                      vis = false;                      if (ha[(t+d)%p]==a[i])//此元素已经被存储过                      &#123;                          tmp = (t+d)%p;//tmp为a[i]存储过的位置                          vis = true;                          break;                      &#125;                      d++;                  &#125;                  ha[(t+d)%p] = a[i];                  if (vis)                      printf (\"%d\",tmp);                  else printf (\"%d\",(t+d)%p);              &#125;//else              if (i==n-1)                  printf (\"\\n\");              else              printf (\" \");          &#125;//for      &#125;//for      return 0;  &#125;字符串哈希DescriptionWell, how do you feel about mobile phone? Your answer would probably be something like that “It’s so convenient and benefits people a lot”. However, If you ask Merlin this question on the New Year’s Eve, he will definitely answer “What a trouble! I have to keep my fingers moving on the phone the whole night, because I have so many greeting message to send!” Yes, Merlin has such a long name list of his friends, and he would like to send a greeting message to each of them. What’s worse, Merlin has another long name list of senders that have sent message to him, and he doesn’t want to send another message to bother them Merlin is so polite that he always replies each message he receives immediately). So, before he begins to send message, he needs to figure to how many friends are left to be sent. Please write a program to help him. Here is something that you should note. First, Merlin’s friend list is not ordered, and each name is alphabetic strings and case insensitive. These names are guaranteed to be not duplicated. Second, some senders may send more than one message to Merlin, therefore the sender list may be duplicated. Third, Merlin is known by so many people, that’s why some message senders are even not included in his friend list.InputThere are multiple test cases. In each case, at the first line there are two numbers n and m (1&lt;=n,m&lt;=20000), which is the number of friends and the number of messages he has received. And then there are n lines of alphabetic strings(the length of each will be less than 10), indicating the names of Merlin’s friends, one per line. After that there are m lines of alphabetic strings, which are the names of message senders. The input is terminated by n=0.OutputFor each case, print one integer in one line which indicates the number of left friends he must send.SampleInput \n123456789105 3InkfishHenryCarpMaxJerichoCarpMaxCarp0Output \n1312345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;list&gt;#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;#include &lt;algorithm&gt;#include &lt;vector&gt;#include &lt;cstring&gt;using namespace std; int main()&#123;\tint n;\twhile (scanf(\"%d\", &amp;n), n != 0) &#123;\t\tint m;\t\tscanf(\"%d\", &amp;m);\t\tint send = n;\t\tvector&lt;string&gt; a;\t\tvector&lt;string&gt; b;\t\tstring s; \t\tfor (int i = 0; i &lt; n; i++) &#123;\t\t\tcin&gt;&gt;s;\t\t\t//scanf(\"%s\", s);\t\t\tfor (int k = 0; k &lt; s.length(); k++)\t\t\t\ts[k] = tolower(s[k]);\t\t\ta.push_back(s);\t\t&#125;\t\tsort(a.begin(), a.end());\t\tfor (int i = 0; i &lt; m; i++) &#123;\t\t\tcin&gt;&gt;s;\t\t\t//scanf(\"%s\", s);\t\t\tfor (int k = 0; k &lt; s.length(); k++)\t\t\t\ts[k] = tolower(s[k]);\t\t\tb.push_back(s);\t\t&#125;\t\tsort(b.begin(), b.end());\t\tlist&lt;string&gt;::iterator i;\t\tlist&lt;string&gt;::iterator j; \t\t/*for (i = b.begin(); i != b.end(); i++) &#123;\t\t\tfor (j = a.begin(); j != a.end(); j++) &#123;\t\t\t\tif (*i == *j) &#123;\t\t\t\t\tsend--;\t\t\t\t\t*j = \"\";\t\t\t\t&#125;\t\t\t&#125;\t\t&#125;*/ \t\tfor(int i = 0; i &lt; m; i++) &#123;\t\t\tint start = 0,end = n - 1, mid;\t\t\twhile (start &lt;= end) &#123;\t\t\t\tmid = start + (end - start)/2;\t\t\t\tif (b[i] == a[mid]) &#123;\t\t\t\t\tsend--;\t\t\t\t\ta[mid]=\"8787\";\t\t\t\t\tbreak;\t\t\t\t&#125;\t\t\t\telse if(b[i] &gt; a[mid]) &#123;\t\t\t\t\tstart=mid+1;\t\t\t\t&#125;\t\t\t\telse if(b[i] &lt; a[mid]) &#123;\t\t\t\t\tend=mid-1;\t\t\t\t&#125;\t\t\t&#125;\t\t&#125; \t\tprintf(\"%d\\n\", send);\t&#125; \t//system(\"pause\");    return 0;&#125;内排序快速排序堆排序桶排序","plink":"https://dxsummer.gitee.io/posts/5d201f0e/"},{"title":"栈和队列","date":"2020-10-19T13:37:29.000Z","date_formatted":{"ll":"2020年10月19日","L":"2020/10/19","MM-DD":"10-19"},"updated":"2020-11-21T06:57:52.000Z","content":"栈顺序栈\n“进” ＝压入=PUSH（)“出” ＝弹出=POP( )\n\n定义：只能在表的一端（栈顶）进行插入和删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序栈或链栈存储均可，但以顺序栈更常见\n运算规则：只能在栈顶运算，且访问结点时依照后进先出（LIFO）的原则\n实现方式：关键是编写入栈和出栈函数，具体实现依顺序栈或链栈的不同而不同，基本操作有入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空等\n表示123456#define MAXSIZE  100//顺序栈存储空间的初始分配量typedef struct &#123;\tSElemType *base;//栈底指针\tSElemType *top;//栈顶指针\tint stacksize;//栈可用的最大容量&#125; SqStack;初始化构造一个空栈步骤：\n分配空间并检查空间是否分配失败，若失败则返回错误\n\n设置栈底和栈顶指针 S.top = S.base;\n\n设置栈大小\n\n123456789Status InitStack(SqStack &amp;S) &#123;\t//构造一个空栈S\tS.base = new SElemType[MAXSIZE];//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间\tif (!S.base)\t\texit(OVERFLOW); //存储分配失败\tS.top = S.base; //top初始为base，空栈\tS.stacksize = MAXSIZE; //stacksize置为栈的最大容量MAXSIZE\treturn OK;&#125;判断顺序栈是否为空\n12345bool StackEmpty( SqStack S )&#123;\tif(S.top == S.base) return true;   else return false;&#125;求顺序栈的长度\n1234int StackLength( SqStack S )&#123;\treturn S.top – S.base;&#125;清空顺序栈\n12345Status ClearStack( SqStack S )&#123;\tif( S.base ) S.top = S.base;\treturn OK;&#125;销毁顺序栈\n12345678910Status DestroyStack( SqStack &amp;S )&#123;\tif( S.base )\t&#123;\t\tdelete S.base ;\t\tS.stacksize = 0;\t\tS.base = S.top = NULL;\t&#125;  return OK;&#125;进栈判断是否栈满，若满则出错\n元素e压入栈顶\n栈顶指针加1\n1234567Status Push(SqStack &amp;S, SElemType e) &#123;\t// 插入元素e为新的栈顶元素\tif (S.top - S.base == S.stacksize)\t\treturn ERROR; //栈满\t*(S.top++) = e; //元素e压入栈顶，栈顶指针加1 *S.top=e;S.top++;\treturn OK;&#125;出栈判断是否栈空，若空则出错\n获取栈顶元素e\n栈顶指针减1\n1234567Status Pop(SqStack &amp;S, SElemType &amp;e) &#123;\t//删除S的栈顶元素，用e返回其值\t\tif (S.base == S.top)\t\treturn ERROR;//栈空\te = *(--S.top); //栈顶指针减1，将栈顶元素赋给e --S.top;e=*S.top;\treturn OK;&#125;取栈顶元素判断是否空栈，若空则返回错误\n否则通过栈顶指针获取栈顶元素\n1234Status GetTop( SqStack S)  &#123;\tif (S.top != S.base) //栈非空\t\treturn *(S.top - 1); //返回栈顶元素的值，栈顶指针不变&#125;链栈运算是受限的单链表，只能在链表头部进行操作，故没有必要附加头结点。栈顶指针就是链表的头指针\n1234typedef struct StackNode &#123;\tSElemType data;\tstruct StackNode *next;&#125; StackNode, *LinkStack;初始化1234Status InitStack(LinkStack &amp;S) &#123; // 构造一个空栈 S，栈顶指针置空\tS = NULL;\treturn OK;&#125;判断链栈是否为空\n12345Status StackEmpty(LinkStack S)&#123;\t    if (S==NULL) return TRUE; \telse return FALSE;&#125;进栈12345678Status Push(LinkStack &amp;S, SElemType e) &#123;//在栈顶插入元素e\tLinkStack p;\tp = new StackNode; //生成新结点\tp-&gt;data = e; //将新结点数据域置为e\tp-&gt;next = S; //将新结点插入栈顶\tS = p; //修改栈顶指针为p\treturn OK;&#125;出栈12345678910Status Pop(LinkStack &amp;S, SElemType &amp;e) &#123;//删除S的栈顶元素，用e返回其值\tLinkStack p;\tif (S == NULL)\t\treturn ERROR; //栈空\te = S-&gt;data; //将栈顶元素赋给e\tp = S; //用p临时保存栈顶元素空间，以备释放\tS = S-&gt;next; //修改栈顶指针\tdelete p; //释放原栈顶元素的空间\treturn OK;&#125;取栈顶元素1234SElemType GetTop(LinkStack S) &#123;//返回S的栈顶元素，不修改栈顶指针\tif (S != NULL) //栈非空\t\treturn S-&gt;data; //返回栈顶元素的值，栈顶指针不变&#125;栈与递归递归的定义：若一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称他们是递归的。若一个过程直接地或间接地调用自己, 则称这个过程是递归的过程。\n12345long Fact ( long n ) &#123;    if ( n == 0) return 1;    else return n * Fact (n-1); &#125;\n以下三种情况常常用到递归方法\n递归定义的数学函数\n具有递归特性的数据结构\n可递归求解的问题\n优点：结构清晰，程序易读\n缺点：每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。\n栈（一般算术表达式转换成后缀式）Description\n对于一个基于二元运算符的算术表达式，转换为对应的后缀式，并输出之。\nInput\n输入一个算术表达式，以‘#’字符作为结束标志。\nOutput\n输出该表达式转换所得到的后缀式。\nInput \n1a*b+(c-d/e)*f#Output \n1ab*cde/-f*+c++\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394#include &lt;iostream&gt;#include &lt;algorithm&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cstdlib&gt;using namespace std;int cmp(char a)&#123;    if(a == '-' || a == '+') return 1;    if(a == '*' || a == '/') return 2;    if(a == ')') return 3;    if(a == '(') return 4;    return 0;&#125; typedef struct&#123;   char * base;    char  *top;&#125;SqStack;char a[1000];void InitStack(SqStack &amp;S)&#123;    S.base = (char *)malloc(1000*sizeof(char));    S.top = S.base;&#125;void Push(SqStack &amp;S, char  e)&#123;    *S.top++ = e;&#125;void Pop(SqStack &amp;S)&#123;    char e;    e = *--S.top;    cout &lt;&lt; e;&#125;int main()&#123;    while(~scanf(\"%s\", a))    &#123;        int i;        SqStack S;        InitStack(S);        for(i = 0; a[i]!='#'; i++)        &#123;            if(a[i] &gt;= 'a' &amp;&amp; a[i] &lt;= 'z')                cout &lt;&lt; a[i];            else            &#123;                if(S.base == S.top)                &#123;                    Push(S, a[i]);                &#125;                else                &#123;                    if(cmp(*(S.top-1)) &gt;= cmp(a[i]))                    &#123;                        if(*(S.top-1) != '(')                        &#123;                              Pop(S);                              Push(S, a[i]);                        &#125;                       else                       &#123;                             Push(S, a[i]);                       &#125;                    &#125;                    else                    &#123;                       if(a[i] == ')')                       &#123;                           while(*(S.top-1) != '(')                           &#123;                               Pop(S);                           &#125;                           S.top--;                       &#125;                       else                       &#123;                           Push(S, a[i]);                       &#125;                    &#125;                &#125;             &#125;        &#125;        while(S.top != S.base)        &#123;            Pop(S);        &#125;        cout &lt;&lt; endl;    &#125;    return 0;&#125;队列队列是一种先进先出(FIFO) 的线性表. 在表一端插入,在另一端删除\n定义：只能在表的一端（队尾）进行插入，在另一端（队头）进行删除运算的线性表\n逻辑结构：与线性表相同，仍为一对一关系\n存储结构：用顺序队列或链队存储均可\n运算规则：先进先出（FIFO）\n实现方式：关键是编写入队和出队函数，具体实现依顺序队或链队的不同而不同\n队列的顺序表示 一维数组base[M]123456#define M  100   //最大队列长度Typedef struct &#123;   QElemType *base;  //初始化的动态分配存储空间   int  front;            //头指针      int  rear;             //尾指针&#125;SqQueue;存在问题循环队列\n问题：队空：front==rear    队满：front==rear\n\n解决方案：\n另外设一个标志以区别队空、队满\n少用一个元素空间：队空：front==rear\n队满：(rear+1)%M==front\n初始化1234567Status InitQueue(SqQueue &amp;Q) &#123;//构造一个空队列Q\tQ.base = new QElemType[MAXQSIZE]; //为队列分配一个最大容量为MAXSIZE的数组空间\tif (!Q.base)\t\texit(OVERFLOW); //存储分配失败\tQ.front = Q.rear = 0; //头指针和尾指针置为零，队列为空\treturn OK;&#125;求循环队列的长度123int QueueLength(SqQueue Q) &#123;//返回Q的元素个数，即队列的长度\treturn (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;&#125;入队1234567Status EnQueue(SqQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\tif ((Q.rear + 1) % MAXQSIZE == Q.front) //尾指针在循环意义上加1后等于头指针，表明队满\t\treturn ERROR;\tQ.base[Q.rear] = e; //新元素插入队尾\tQ.rear = (Q.rear + 1) % MAXQSIZE; //队尾指针加1\treturn OK;&#125;出队1234567Status DeQueue(SqQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值\tif (Q.front == Q.rear)\t\treturn ERROR; //队空\te = Q.base[Q.front]; //保存队头元素\tQ.front = (Q.front + 1) % MAXQSIZE; //队头指针加1\treturn OK;&#125;取循环队列的队头元素1234SElemType GetHead(SqQueue Q) &#123;//返回Q的队头元素，不修改队头指针\tif (Q.front != Q.rear) //队列非空\t\treturn Q.base[Q.front]; //返回队头元素的值，队头指针不变&#125;链队12345678typedef struct QNode &#123;\tQElemType data;\tstruct QNode *next;&#125; QNode, *QueuePtr;typedef struct &#123;\tQueuePtr front; //队头指针c\tQueuePtr rear; //队尾指针&#125; LinkQueue;初始化12345Status InitQueue(LinkQueue &amp;Q) &#123;//构造一个空队列Q\tQ.front = Q.rear = new QNode; //生成新结点作为头结点，队头和队尾指针指向此结点\tQ.front-&gt;next = NULL; //头结点的指针域置空\treturn OK;&#125;入队123456789Status EnQueue(LinkQueue &amp;Q, QElemType e) &#123;//插入元素e为Q的新的队尾元素\tQueuePtr p;\tp = new QNode; //为入队元素分配结点空间，用指针p指向\tp-&gt;data = e; //将新结点数据域置为e\tp-&gt;next = NULL;\tQ.rear-&gt;next = p; //将新结点插入到队尾\tQ.rear = p; //修改队尾指针\treturn OK;&#125;出队123456789101112Status DeQueue(LinkQueue &amp;Q, QElemType &amp;e) &#123;//删除Q的队头元素，用e返回其值 \tQueuePtr p;\tif (Q.front == Q.rear)\t\treturn ERROR; //若队列空，则返回ERROR\tp = Q.front-&gt;next; //p指向队头元素\te = p-&gt;data; //e保存队头元素的值\tQ.front-&gt;next = p-&gt;next; //修改头指针\tif (Q.rear == p)\t\tQ.rear = Q.front; //最后一个元素被删，队尾指针指向头结点\tdelete p; //释放原队头元素的空间\treturn OK;&#125;取链队的队头元素1234SElemType GetHead(LinkQueue Q) &#123;//返回Q的队头元素，不修改队头指针\tif (Q.front != Q.rear) //队列非空\t\treturn Q.front-&gt;next-&gt;data; //返回队头元素的值，队头指针不变&#125;","plink":"https://dxsummer.gitee.io/posts/8d66b5f2/"},{"title":"盒子模型","date":"2020-10-18T04:17:26.000Z","date_formatted":{"ll":"2020年10月18日","L":"2020/10/18","MM-DD":"10-18"},"updated":"2020-10-29T14:30:32.000Z","content":"边框属性\n在设置边框宽度时，必须同时设置边框样式，如果未设置样式或设置为none，则不论宽度设置为多少都无效。注意：常用取值单位为像素。\n\n颜色border-color:transparent 透明色\nCSS3在原边框颜色属性（border-color）的基础上派生了4个边框颜色属性。border-top/right/bottom/left-colors \n例如对段落文本&lt;p&gt;添加渐变边框效果，示例代码如下：\n12345678p&#123;\tborder-style:solid;\tborder-width:10px;\t-moz-border-top-colors:#a0a #909 #808 #707 #606 #505 #404 #303;\t-moz-border-right-colors:#a0a #909 #808 #707 #606 #505 #404 #303;\t-moz-border-bottom-colors:#a0a #909 #808 #707 #606 #505 #404 #303;\t-moz-border-left-colors:#a0a #909 #808 #707 #606 #505 #404 #303;&#125;内边距属性内外边距清除\n1234*&#123;\tpadding:0;         /*清除内边距*/\tmargin:0;          /*清除外边距*/&#125;\n外边距属性块级元素水平居中\n1.num&#123;margin:0 auto;&#125;\n背景属性颜色图像12345body&#123;background-color:#CCC; background-image:url(images/jianbian.jpg);&#125;图像平铺1background-repeat:图像平铺属性背景图像的位置1background-position:图像位置属性背景图像固定1background-attachment:图像固定属性综合设置元素的背景12background:背景色 url(\"图像\") 平铺 定位 固定;background: url(img/wdjl.jpg) no-repeat 50px 80px fixed;盒子的宽与高盒子模型新增属性颜色透明度通过引入RGBA模式和opacity属性，对背景与图片设置不透明度\n12rgba(r,g,b,alpha);p&#123;background-color:rgba(255,0,0,0.5);&#125;\nopacity属性用于定义标签的不透明度，参数opacityValue表示不透明度的值，它是一个介于0~1之间的浮点数值。其中，0表示完全透明，1表示完全不透明，而0.5则表示半透明。\n1opacity：opacityValue;\n圆角1border-radius:水平半径参数1 水平半径参数2 水平半径参数3 水平半径参数4/垂直半径参数1 垂直半径参数2 垂直半径参数3 垂直半径参数4;水平半径参数和垂直半径参数设置2两个参数值时,第一个参数值代表左上和右下圆角半径 , 第二个表示右上左下\n\n三个参数值,第一个参数值左上 第二个参数值右上左下 第三个参数值 右下\n\n需要注意的是，当应用值复制原则设置圆角边框时，如果“垂直半径参数”省略，则会默认等于“水平半径参数”的参数值。此时圆角的水平半径和垂直半径相等。\n\n图片边框1border-image: border-image-source/ border-image-slice/ border-image-width/ border-image-outset/ border-image-repeat;12345678910111213141516&lt;style type=\"text/css\"&gt;p&#123;\twidth:362px; \theight:362px;\tborder-style:solid; \tborder-image-source:url(3.png); /*设置边框图片路径*/\tborder-image-slice:33%;           /*边框图像顶部、右侧、底部、左侧向内偏移量*/\tborder-image-width:40px;          /*设置边框宽度*/\tborder-image-outset:0;\t\t  /*设置边框图像区域超出边框量*/\tborder-image-repeat:repeat;\t      /*设置图片平铺方式*/\t&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;&lt;/p&gt;&lt;/body&gt;阴影box-shadow属性也可以改变阴影的投射方向以及添加多重阴影效果。\n1box-shadow: h-shadow v-shadow blur spread color outset;\n参数值描述\n\nh-shadow水平阴影位置(必选)\n\nv-shadow垂直阴影的位置(必选)\n\nblur阴影模糊半径\n\nspread阴影扩展半径 不能为负\n\ncolor阴影颜色\n\noutset/inset外阴影/内阴影\n1box-shadow:5px 5px 10px 2px #999 inset,-5px -5px 10px 2px #333 inset;渐变线性渐变1background-image:linear-gradient(渐变角度,颜色值1,颜色值2...,颜色值n);linear-gradient用于定义渐变方式为线性渐变，括号内用于设定渐变角度和颜色值。\n径向渐变1background-image:radial-gradient(渐变形状 圆心位置,颜色值1,颜色值2...,颜色值n);重复渐变重复线性渐变\n1background-image:repeating-linear-gradient(渐变角度,颜色值1,颜色值2...,颜色值n);重复径向渐变\n1background-image:repeating-radial-gradient(渐变形状 圆心位置,颜色值1,颜色值2...,颜色值n);多背景图像1234background-image:url(images/caodi.png),url(images/taiyang.png),url(images/tiankong.png);修剪背景图像设置背景图像的大小1background-size:属性值1 属性值2;设置背景图像的显示区域1background-origin:属性值;在上面的语法格式中，background-origin属性有三种取值，分别表示不同的含义，具体解释如下。\npadding-box：背景图像相对于内边距区域来定位。\nborder-box：背景图像相对于边框来定位。\ncontent-box：背景图像相对于内容框来定位。\n设置背景图像的裁剪区域1background-clip:属性值;在语法格式上，background-clip属性和background-origin 属性的取值相似，但含义不同，具体解释如下。\nborder-box：默认值，从边框区域向外裁剪背景。\npadding-box：从内边距区域向外裁剪背景。\ncontent-box：从内容区域向外裁剪背景。\n元素的类型和转换&lt;div&gt;和&lt;span&gt;标签块元素: &lt;h1&gt;—&lt;h6&gt; &lt;div&gt; &lt;ul&gt; &lt;p&gt; &lt;ol&gt; &lt;li&gt; 其中&lt;div&gt;标签是最典型的块元素。\n行内元素: &lt;strong&gt; &lt;b&gt; &lt;a&gt; &lt;em&gt; &lt;span&gt; &lt;u&gt; 其中&lt;span&gt;标签最典型的行内元素。\n元素类型的转换 display块元素垂直外边距的合并嵌套块元素垂直外边距的合并如果父标签没有上内边距及边框,则父标签的上边距会与子标签的上边距发生重合,取最大者\neg:\n12345678910111213141516171819202122&lt;style type=\"text/css\"&gt;*&#123;margin:0; padding:0;&#125;   /*使用通配符清除所有HTML标记的默认边距*/div.father&#123;\twidth:400px;\theight:400px;\tbackground:#FC0;\t\tmargin-top:20px;      /*定义第一个div的上外边距为20px*/\tborder-top:1px solid #FCC;       /*定义父div的上边框*/ \t&#125;div.son&#123;\twidth:200px;\theight:200px;\tbackground:#63F;\t\tmargin-top:40px;      /*定义第二个div的上外边距为40px*/\t&#125;&lt;/style&gt;&lt;body&gt;&lt;div class=\"father\"&gt;     &lt;div class=\"son\"&gt;&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;","plink":"https://dxsummer.gitee.io/posts/998dffd6/"},{"title":"css选择器","date":"2020-10-09T06:32:51.000Z","date_formatted":{"ll":"2020年10月9日","L":"2020/10/09","MM-DD":"10-09"},"updated":"2020-10-17T15:37:08.000Z","content":"CSS基础选择器标签选择器用HTML标签名称作为选择器，按标签名称分类，为页面某一类标签指定统一的css样式\n1标签名&#123;属性1:属性值1;属性2:属性值2;属性3:属性值3；&#125;12345p&#123;    font-size:12px;     color:#666;     font-family:\"微软雅黑\"；&#125;类选择器使用.进行标识\n类名的第一个字符不能使用数字\n严格区分大小写，一般采用小写英文\n1.类名&#123;属性1:属性值1;属性2:属性值2;属性3:属性值3；&#125;\n1234567891011121314&lt;style type=\"text/css\"&gt;.red&#123;color:red;&#125;\t\t//类选择器.green&#123;color:green;&#125;.font22&#123;font-size:22px;&#125;p&#123;\t\t\t//标签选择器   text-decoration:underline;    font-family:\"微软雅黑\";&#125;&lt;/style&gt;&lt;h2 class=\"red\"&gt;二级标题文本&lt;/h2&gt;&lt;p class=\"green font22\"&gt;段落一文本内容&lt;/p&gt;\t\t//类支持定义多个值&lt;p class=\"red font22\"&gt;段落二文本内容&lt;/p&gt;&lt;p&gt;段落三文本内容&lt;/p&gt;id选择器使用#进行标识，后面紧跟id名\n绝大多数HTML元素都可以定义id属性，元素id名是唯一的，只能对应于文档中某一个具体的元素\n同一个id也可以应用于多个标签，浏览器不会报错，但不允许\nid选择器不支持像类选择器那样定义多个值 id=&quot;bold font24&quot;错误\n1#id名&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;\n123456789&lt;style type=\"text/css\"&gt;#bold &#123;font-weight:bold;&#125;#font24 &#123;font-size:24px;&#125;&lt;/style&gt;&lt;p id=\"bold\"&gt;段落1：id=\"bold\"，设置粗体文字。&lt;/p&gt;&lt;p id=\"font24\"&gt;段落2：id=\"font24\"，设置字号为24px。&lt;/p&gt;&lt;p id=\"font24\"&gt;段落3：id=\"font24\"，设置字号为24px。&lt;/p&gt;\t\t//不允许 行6已经用过font24&lt;p id=\"bold font24\"&gt;段落4：id=\"bold font24\"，同时设置粗体和字号24px。&lt;/p&gt;\t\t//错误通配符选择器用*号表示，它是所有选择器中作用范围最广的，能匹配页面中所有的元素\n通配符选择器设置的样式对所有的HTML标签都生效，不管标签是否需要该样式\n1*&#123;属性1:属性值1; 属性2:属性值2; 属性3:属性值3; &#125;1234*&#123;\tmargin: 0;\t/*定义外边距*/    padding: 0;\t/*定义内边距*/&#125;CSS复合选择器标签指定式选择器（交集选择器）由两个选择器构成，其中第一个为标签选择器，第二个为class选择器或id选择器，两个选择器之间不能有空格，如h3.special或p#one\n\n123456789&lt;style type=\"text/css\"&gt;p&#123; color:blue;&#125;.special&#123; color:green;&#125;p.special&#123; color:red;&#125;    /*标签指定式选择器*/   &lt;/style&gt;&lt;p&gt;普通段落文本（蓝色）&lt;/p&gt;&lt;p class=\"special\"&gt;指定了.special类的段落文本（红色）&lt;/p&gt;&lt;h3 class=\"special\"&gt;指定了.special类的标题文本（绿色）&lt;/h3&gt;后代选择器把外层标签写在前面，内层标签写在后面，中间用空格分隔。当标签发生嵌套时，内层标签就成为外层标签的后代。\n\n1234567&lt;style type=\"text/css\"&gt;p strong&#123;color:red;&#125;     /*后代选择器*/strong&#123;color:blue;&#125;\t\t//标签选择器&lt;/style&gt;&lt;p&gt;段落文本&lt;strong&gt;嵌套在段落中，使用strong标记定义的文本（红色）。&lt;/strong&gt;&lt;/p&gt;&lt;strong&gt;嵌套之外由strong标记定义的文本（蓝色）。&lt;/strong&gt;并集选择器各个选择器通过逗号连接而成的，任何形式的选择器都可以作为并集选择器的一部分。若某些选择器定义的样式完全或部分相同，可利用并集选择器为它们定义相同的样式。\n\n12345678910&lt;style type=\"text/css\"&gt;h2,h3,p&#123;color:red; font-size:14px;&#125;              /*不同标签组成的并集选择器*/h3,.special,#one&#123;text-decoration:underline;&#125;   /*标签、类、id组成的的并集选择器*/&lt;/style&gt;&lt;h2&gt;二级标题文本。&lt;/h2&gt;&lt;h3&gt;三级标题文本,加下画线。&lt;/h3&gt;&lt;p class=\"special\"&gt;段落文本1，加下画线。&lt;/p&gt;&lt;p&gt;段落文本2，普通文本。&lt;/p&gt;&lt;p id=\"one\"&gt;段落文本3，加下画线。&lt;/p&gt;CSS的层叠性和继承性层叠性多种CSS样式的叠加\n\n123456789101112&lt;style type=\"text/css\"&gt;p&#123;    font-size:12px;    font-family:\"楷体\";&#125;.special&#123; font-size:16px;&#125;#one&#123; color:red;&#125;&lt;/style&gt;&lt;p class=\"special\" id=\"one\"&gt;段落文本1&lt;/p&gt;&lt;p&gt;段落文本2&lt;/p&gt;&lt;p&gt;段落文本3&lt;/p&gt;继承性书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。\n不必在元素的每个后代上添加相同的样式\n\n12p,div,h1,h2,h3,h4,ul,ol&#123;color:black;&#125;body&#123;color:black;&#125;\t//与行1相同CSS的优先级标签选择器权重1、类选择器权重10、id选择器权重100\n\n继承样式的权重为0。不管父元素样式的权重多大，被子元素继承时，它的权重都为0，子元素定义的样式会覆盖继承来的样式\n\n行内样式优先。应用style属性的元素，其行内式的权重很高，远大于100。\n\n权重相同时，CSS遵循就近原则。 内嵌式比外链式更靠近HTML元素，行内式&gt;内嵌式&gt;外链式\n\nCSS定义了一个！important（位于属性值和分号之间），该命令被赋予最大的优先级\n1#header&#123;color:red!important;&#125;\n属性选择器E[att^=value] 前缀选择名称为E的标记，且该标记定义了att属性，att属性值包含前缀为value的子字符串。\n1div[id^=section]​    表示匹配包含id属性，且id属性值是以“section”字符串开头的div元素。\n12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;E[att^=value] 属性选择器的应用&lt;/title&gt;&lt;style type=\"text/css\"&gt;p[id^=\"one\"]&#123;\tcolor:pink;\tfont-family:\"微软雅黑\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=\"one\"&gt;\t为了看日出，我常常早起。那时天还没有大亮，周围非常清静，船上只有机器的响声。&lt;/p&gt;&lt;p id=\"two\"&gt;\t天空还是一片浅蓝，颜色很浅。转眼间天边出现了一道红霞，慢慢地在扩大它的范围，加强它的亮光。我知道太阳要从天边升起来了，便不转眼地望着那里。&lt;/p&gt;&lt;p id=\"one1\"&gt;\t果然过了一会儿，在那个地方出现了太阳的小半边脸，红是真红，却没有亮光。这个太阳好象负着重荷似地一步一步、慢慢地努力上升，到了最后，终于冲破了云霞，完全跳出了海面，颜色红得非常可爱。一刹那间，这个深红的圆东西，忽然发出了夺目的亮光，射得人眼睛发痛，它旁边的云片也突然有了光彩。&lt;/p&gt;&lt;p id=\"two1\"&gt;\t有时太阳走进了云堆中，它的光线却从云里射下来，直射到水面上。这时候要分辨出哪里是水，哪里是天，倒也不容易，因为我就只看见一片灿烂的亮光。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;E[att$=value] 后缀选择名称为E的标记，且该标记定义了att属性，att属性值包含后缀为value的子字符串。与E[att^=value]选择器一样，E元素可以省略，如果省略则表示可以匹配满足条件的任意元素。\n1div[id$=section]表示匹配包含id属性，且id属性值是以“section”字符串结尾的div元素。\n12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;E[att$=value] 属性选择器的应用&lt;/title&gt;&lt;style type=\"text/css\"&gt;p[id$=\"main\"]&#123;\tcolor:#0cf;\tfont-family: \"宋体\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=\"old1\"&gt;\t盼望着，盼望着，东风来了，春天的脚步近了。&lt;/p&gt;&lt;p id=\"old2\"&gt;\t小草偷偷地从土里钻出来，嫩嫩的，绿绿的。园子里，田野里，瞧去，一大片一大片满是的。坐着，躺着，打两个滚，踢几脚球，赛几趟跑，捉几回迷藏。风轻悄悄的，草绵软软的。&lt;/p&gt;&lt;p id=\"oldmain\"&gt;\t桃树、杏树、梨树，你不让我，我不让你，都开满了花赶趟儿。红的像火，粉的像霞，白的像雪。花里带着甜味，闭了眼，树上仿佛已经满是桃儿、杏儿、梨儿！花下成千成百的蜜蜂嗡嗡地闹着……&lt;/p&gt;&lt;p id=\"newmain\"&gt;\t“吹面不寒杨柳风”，不错的，像母亲的手抚摸着你。风里带来些新翻的泥土的气息，混着青草味，还有各种花的香，都在微微润湿的空气里酝酿。鸟儿将窠巢安在繁花嫩叶当中，高兴起来了……&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;E[att*=value] 包含E[att*=value]选择器用于选择名称为E的标记，且该标记定义了att属性，att属性值包含value子字符串。该选择器与前两个选择器一样，E元素也可以省略，如果省略则表示可以匹配满足条件的任意元素。\n1div[id*=section]表示匹配包含id属性，且id属性值包含“section”字符串的div元素。\n12345678910111213141516171819202122232425262728&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;E[att*=value]属性选择器的使用&lt;/title&gt;&lt;style type=\"text/css\"&gt;p[id*=\"demo\"]&#123;\tcolor:#0ca; \tfont-family: \"宋体\"; \tfont-size:20px;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;p id=\"demo1\"&gt;\t 我们消受得秦淮河上的灯影，当四月犹皎的仲夏之夜。&lt;/p&gt;&lt;p id=\"main1\"&gt;\t 在茶店里吃了一盘豆腐干丝，两个烧饼之后，以至歪的脚步踅上夫子庙前停泊着的画访，就懒洋洋到躺到藤椅上去了。好郁蒸的江南，傍也还是热的。\"快开船罢！\"桨声响了。&lt;/p&gt;&lt;p id=\"newdemo\"&gt;\t 小的灯舫初次在河中荡漾；于我，情景是颇朦胧，滋味是怪羞涩的。我要错认它作七里的山塘；可是，河房里明窗洞启，映着玲珑入画的栏干，顿然省得身在何处了……&lt;/p&gt;&lt;p id=\"olddemo\"&gt;\t 又早是夕阳西下，河上妆成一抹胭脂的薄媚。是被青溪的姊妹们所薰染的吗？还是匀得她们脸上的残脂呢？寂寂的河水，随双桨打它，终没言语。密匝匝的绣恨逐老去的年华，已都如蜜饧似的融在流波的心窝里、连呜咽也将嫌它多事，更哪里论到哀嘶……&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;关系选择器子元素选择器 &gt;选择某个元素的第一级子元素\n希望选择只作为 h1 元素子元素的 strong 元素，可以这样写：h1 &gt; strong\n123456789101112131415161718&lt;!doctype html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;子元素择器的应用&lt;/title&gt;&lt;style type=\"text/css\"&gt;h1&gt;strong&#123;\tcolor:red;\tfont-size:20px;\tfont-family:\"微软雅黑\";&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;这个&lt;strong&gt;知识点&lt;/strong&gt;很&lt;strong&gt;重要&lt;/strong&gt;&lt;/h1&gt;&lt;h1&gt;首都&lt;em&gt;&lt;strong&gt;人民&lt;/strong&gt;&lt;/em&gt;欢迎你！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt;相邻兄弟选择器（+、~）临近兄弟选择器该选择器使用加号“+”来链接前后两个选择器。选择器中的两个元素有同一个父亲，而且第二个元素必须紧跟第一个元素。\n123456789101112131415&lt;style type=\"text/css\"&gt;p+h2&#123;\tcolor:green;\tfont-family:\"宋体\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;《赠汪伦》&lt;/h2&gt;&lt;p&gt;李白乘舟将欲行，&lt;/p&gt;&lt;h2&gt;忽闻岸上踏歌声。&lt;/h2&gt;\t//作用者&lt;h2&gt;桃花潭水深千尺，&lt;/h2&gt;&lt;h2&gt;不及汪伦送我情。&lt;/h2&gt;&lt;/body&gt;普通兄弟选择器普通兄弟选择器使用 “~”来链接前后两个选择器。选择器中的两个元素有同一个父亲，但第二个元素不必紧跟第一个元素。\n1234567891011121314&lt;style type=\"text/css\"&gt;p~h2&#123;\tcolor:pink;\tfont-family:\"微软雅黑\";\tfont-size:20px;&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;你站在桥上看风景&lt;/p&gt;&lt;h2&gt;看风景的人在楼上看你&lt;/h2&gt;&lt;h2&gt;明月装饰了你的窗子&lt;/h2&gt;&lt;h2&gt;你装饰了别人的梦&lt;/h2&gt;&lt;/body&gt;结构化伪类选择器:root选择器:root选择器用于匹配文档根元素，在HTML中，根元素始终是html元素。也就是说使用“:root选择器”定义的样式，对所有页面元素都生效。对于不需要该样式的元素，可以单独设置样式进行覆盖。\n123456789101112&lt;style type=\"text/css\"&gt;:root&#123;color:red;&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;《面朝大海春暖花开》&lt;/h2&gt;&lt;p&gt;从明天起做个幸福的人喂马劈柴周游世界 从明天起关心粮食和蔬菜我有一所房子 面朝大海春暖花开&lt;/p&gt;&lt;/body&gt;:not选择器如果对某个结构元素使用样式，但是想排除这个结构元素下面的子结构元素，让它不使用这个样式，可以使用:not选择器。\n123456789101112131415&lt;style type=\"text/css\"&gt;body *:not(h3)&#123;\tcolor: orange;\tfont-size: 20px;\tfont-family: \"宋体\";&#125;&lt;/style&gt;&lt;body&gt;&lt;h3&gt;《世界上最远的距离》&lt;/h3&gt;\t&lt;p&gt;世界上最远的距离&lt;/p&gt; &lt;p&gt;不是生与死的距离&lt;/p&gt; &lt;p&gt;而是我站在你面前&lt;/p&gt; &lt;p&gt;你却不知道我爱你...&lt;/p&gt;&lt;/body&gt;:only-child选择器匹配属于某父元素的唯一子元素的元素，也就是说，如果某个父元素仅有一个子元素，则使用“:only-child 选择器”可以选择这个子元素。\n\n123456789101112131415161718&lt;style type=\"text/css\"&gt;strong:only-child&#123;color:red;&#125;&lt;/style&gt;&lt;body&gt;\t&lt;p&gt;    \t&lt;strong&gt;一代宗师&lt;/strong&gt;    \t&lt;strong&gt;英雄&lt;/strong&gt;    &lt;/p&gt;\t&lt;p&gt;    \t&lt;strong&gt;复仇者联盟4&lt;/strong&gt;    &lt;/p&gt;\t&lt;p&gt;    \t&lt;strong&gt;非诚勿扰&lt;/strong&gt;    \t&lt;strong&gt;火影忍者&lt;/strong&gt;        &lt;strong&gt;进击的巨人&lt;/strong&gt;    &lt;/p&gt;&lt;/body&gt;:first-child和:last-child选择器:first-child选择器和:last-child选择器分别用于为父元素中的第一个或者最后一个子元素设置样式。\n1234567891011121314151617181920&lt;style type=\"text/css\"&gt;p:first-child&#123;   color:pink;   font-size:16px;   font-family:\"宋体\";\t&#125;p:last-child&#123;   color:blue;   font-size: 16px;   font-family: \"微软雅黑\";&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;第一篇 毕业了&lt;/p&gt;&lt;p&gt;第二篇 关于考试&lt;/p&gt;&lt;p&gt;第三篇 夏日飞舞&lt;/p&gt;&lt;p&gt;第四篇 惆怅的心&lt;/p&gt;&lt;p&gt;第五篇 畅谈美丽&lt;/p&gt;&lt;/body&gt;:nth-child(n)和:nth-last-child(n)选择器如果用户想要选择第2个或倒数第2个子元素，这两个选择器就不起作用了。为此，CSS3引入了:nth-child(n)和:nth-last-child(n)选择器，它们是:first-child选择器和:last-child选择器的扩展。\n1234567891011121314151617181920&lt;style type=\"text/css\"&gt;p:nth-child(2)&#123;   color:pink;   font-size:16px;   font-family:\"宋体\";&#125;p:nth-last-child(2)&#123;  color:blue;  font-size: 16px;  font-family: \"微软雅黑\";&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;第一篇 毕业了&lt;/p&gt;&lt;p&gt;第二篇 关于考试&lt;/p&gt;&lt;p&gt;第三篇 夏日飞舞&lt;/p&gt;&lt;p&gt;第四篇 惆怅的心&lt;/p&gt;&lt;p&gt;第五篇 畅谈美丽&lt;/p&gt;&lt;/body&gt;:nth-of-type(n)和:nth-last-of-type(n)选择器:nth-of-type(n)和:nth-last-of-type(n)选择器用于匹配属于父元素的特定类型的第 n 个子元素和倒数第n个子元素。\n12345678910111213141516&lt;style type=\"text/css\"&gt;h2:nth-of-type(odd)&#123;color:#f09;&#125;\t//奇数h2:nth-of-type(even)&#123;color:#12ff65;&#125;\t//偶数p:nth-last-of-type(2)&#123;font-weight:bold;&#125;&lt;/style&gt;&lt;body&gt;&lt;h2&gt;网页设计&lt;/h2&gt;&lt;p&gt;网页设计是根据企业希望向浏览者传递的信息（包括产品、服务、理念、文化），进行网站功能策划，然后进行的页面设计美化工作。&lt;/p&gt;&lt;h2&gt;Java&lt;/h2&gt;&lt;p&gt;Java是一种可以撰写跨平台应用程序的面向对象的程序设计语言。&lt;/p&gt;&lt;h2&gt;iOS&lt;/h2&gt;&lt;p&gt;iOS是由苹果公司开发的移动操作系统。&lt;/p&gt;&lt;h2&gt;PHP&lt;/h2&gt;&lt;p&gt;PHP（外文名:PHP: Hypertext Preprocessor，中文名：“超文本预处理器”）是一种通用开源脚本语言。&lt;/p&gt;&lt;/body&gt;:empty选择器:empty选择器用来选择没有子元素或文本内容为空的所有元素。\n123456789101112131415&lt;style type=\"text/css\"&gt;p&#123;\twidth:150px;\theight:30px;&#125;:empty&#123;background-color: #999;&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;北京校区&lt;/p&gt;&lt;p&gt;上海校区&lt;/p&gt;&lt;p&gt;广州校区&lt;/p&gt;&lt;p&gt;&lt;/p&gt;&lt;p&gt;武汉校区&lt;/p&gt;\t&lt;/body&gt;伪元素选择器:before选择器:before伪元素选择器用于在被选元素的内容前面插入内容，必须配合content属性来指定要插入的具体内容。\n1234&lt;元素&gt;:before&#123;\tcontent:文字/url();&#125;1234567891011121314&lt;style type=\"text/css\"&gt;p:before&#123;\t content:\"学习IT视频教程\";\t color:#c06;\t font-size: 20px;\t font-family: \"微软雅黑\";\t font-weight: bold;&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;专注于Java、.Net、PHP、网页设计和平面设计、IOS、C++工程师的培养，提供的免费视频教程是目前覆盖面最广，项目最真实的视频教程之一。&lt;/p&gt;&lt;/body&gt;:after选择器:after伪元素选择器用于在某个元素之后插入一些内容，使用方法与:before选择器相同。\n1234567&lt;style type=\"text/css\"&gt;p:after&#123;content:url(zhongqiu.png);&#125;&lt;/style&gt;&lt;body&gt;&lt;p&gt;十五的月亮&lt;br&gt;&lt;/p&gt;&lt;/body&gt;","plink":"https://dxsummer.gitee.io/posts/676848e4/"},{"title":"css基础","date":"2020-10-02T07:15:23.000Z","date_formatted":{"ll":"2020年10月2日","L":"2020/10/02","MM-DD":"10-02"},"updated":"2020-10-10T15:06:32.000Z","content":"css样式规则1选择器&#123;属性1：属性值1；属性2：属性值2；属性3：属性值3；····&#125;每条声明由一个属性和属性值组成，以“键值对”的形式出现\nCSS样式中的选择器严格区分大小写\n\n多个属性之间必须用英文状态下的;隔开\n\n若属性的属性值由多个单词组成且中间包含空格，则必须加&quot;&quot;\n1p &#123;font-family:\"Times New Roman\"&#125;\n在CSS代码中空格是不被解析的，{}``;前后的空格可有可无\n1h1&#123; color:green; font-size:14px; &#125;1234h1&#123;   \tcolor:green;\t/* 定义颜色的属性*/  \tfont-size:14px;\t/*定义字体大小属性*/  &#125;代码2可读性更高\n\n属性值和单位之间不能出现空格\n1h1&#123;font-size:14 px; &#125;\t/* 14和单位px之间有空格，浏览器解析时会出现错误*/\n引入CSS样式表行内式（内联式）通过标签的style属性来设置标签样式，没有做到结构与样式分离\n1&lt;标签名 style=\"属性1：属性值1；属性2：属性值2；属性3：属性值3；\"&gt;内容&lt;/标签名&gt;style：标签的属性\n1&lt;h1 style=\"font-size：20px；color：blue；\"&gt;使用CSS行内式修饰一级标签的字体大小和颜色&lt;/h1&gt;内嵌式只对其所在的HTML页面有效\n网站不建议使用这种方法，不能充分发挥CSS代码重用的优势\n写在HTML文档的&lt;head&gt;标签之中\n12345&lt;head&gt;&lt;style type=\"text/css\"&gt;\t选择器&#123;属性1：属性值1；属性2：属性值2；属性3：属性值3；&#125;&lt;/style&gt;&lt;/head&gt;123456789&lt;style type=\"text/css\"&gt;.red&#123;color:red;&#125;.green&#123;color:green;&#125;.font22&#123;font-size:22px;&#125;p&#123;   text-decoration:underline;    font-family:\"微软雅黑\";&#125;&lt;/style&gt;&lt;style&gt;标签一般位于&lt;title&gt;标签之后，也可以放到HTML文档的任何地方\n外链式(链入式)同CSS可以被不同的HTML页面链接使用\n外链式是使用频率最高，最实用的CSS样式表\n123&lt;head&gt;&lt;link href=\"css文件的路径\" type=\"text/css\" rel=\"stylesheet\" /&gt;&lt;/head&gt;1&lt;link href=\"style.css\" type=\"text/css\" rel=\"stylesheet\" /&gt;必须指定&lt;link /&gt;标签的3个属性\nhref：定义所链接外部样式表文件的URL，可以是相对路径，也可以是绝对路径\ntype：定义所链接文档的类型，&quot;text/css&quot;表示链接的外部文件为CSS样式表\nrel：定义当前文档与被链接文档之间的关系，&quot;stylesheet&quot;表示被链接的文档是一个样式表文件\n导入式与外链式相同，针对外部样式表文件\n两者加载时间和顺序不同\n当一个页面被加载时&lt;link /&gt;引用的CSS样式表同时被加载\n@import会等到页面全部下载完成后再被加载，当网速慢时，会造成不好的用户体验\n\n1234&lt;style type=\"text/css\" &gt;\t@import url(css文件路径); 或 @import \"css文件路径\"；    /*在此还可以存放其他css样式*/&lt;/style&gt;123&lt;style type=\"text/css\" &gt;\t@import \"style.css\";&lt;/style&gt;123&lt;style type=\"text/css\" &gt;\t@import url(style.css);&lt;/style&gt;设置文本样式字体样式font-size用于设置字号\n\n相对长度单位说明\n\nem相对于当前对象内文本的字体尺寸\n\npx像素，最常用，推荐使用\n\n绝对长度单位说明\n\nin英寸\n\ncm厘米\n\nmm毫米\n\npt点\nfont-family用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等。\n中文字体需要加&quot;&quot;，英文一般不需要，英文字体名称必须位于中文字体名称之前\n如果字体名中包含、#、$等符号，字体必须加英文状态下的单引号或双引号\n1p&#123; font-family:\"微软雅黑\";&#125;12body&#123;font-family: Arial,\"华文云彩\",\"宋体\",\"黑体\"；&#125;\t//正确body&#123;font-family: \"华文云彩\",\"宋体\",\"黑体\",Arial；&#125;\t//错误font-weight用于定义字体的粗细\n\n值描述\n\nnormal默认值。定义标准的字符。\n\nbold定义粗体字符。\n\nbolder定义更粗的字符。\n\nlighter定义更细的字符。\n\n100~900（100的整数倍）定义由细到粗的字符。其中400等同于normal，700等同于bold，值越大字体越粗。\nfont-style定义字体风格，如设置斜体、倾斜或正常字体\n\n值描述\n\nnormal默认值，浏览器会显示标准的字体样式\n\nitalic浏览器会显示斜体的字体样式（文字本身的斜体）\n\noblique浏览器会显示倾斜的字体样式（强制斜体）\nfont综合属性1选择器&#123;font: font-style font-weight font-size/line-height font-family;&#125;123456p&#123;\tfont-style:Arial,\"宋体\";    font-size:30px;    font-weight:bold;    line-height:40px;&#125;等价于：\n1p&#123;font:italic bold 30px/40px Arial,\"宋体\";&#125;必须保留font-size、font-family，否则font属性不起作用\n@font-faceCSS3的新增属性，用于定义服务器字体。通过@font-face属性，开发者可以在用户计算机未安装字体时，使用任何喜欢的字体\n1234@font-face&#123;\t\tfont-family:jianzhi;\t//字体名称\t\tsrc:url(FZJZJW.TTF);\t//字体路径&#125;文本外观属性color：文本颜色red、green、blue\n十六进制 #FF0000 最常用\nRGB rgb(255,0,0) rgb(100%,0%,0%) 0不能省略\n\n十六进制颜色值 每两位一个颜色分量 分别表示颜色红、绿、蓝，#FF6600可缩写为#F60\n\nletter-spacing: 字间距定义字间距，所谓字间距就是字符与字符之间的空白。\nletter-spacing属性，其属性值可为不同单位的数值，允许使用负值，默认为normal。\n1h2&#123;letter-spacing:20px;&#125;word-spacing：单词间距定义英文单词之间的间距，对中文字符无效。\n属性值可为不同单位的数值，允许使用负值，默认为normal\nline-height：行间距设置行间距，所谓行间距就是行与行之间的距离，即字符的垂直间距，一般称为行高。\n像素px、相对值em、百分比%\ntext-transform：文本转换控制英文字符的大小写。\n\n值描述\n\nnone不转换（默认值）\n\ncapitalize首字母大写\n\nuppercase全部字符转换为大写\n\nlowercase全部字符转换为小写\ntext-decoration：文本装饰设置文本的下划线，上划线，删除线等装饰效果\n\n值描述\n\nnone没有装饰（正常文本默认值）\n\nunderline下划线\n\noverline上划线\n\nline-through删除线\ntext-align：水平对齐方式设置文本内容水平对齐，相当于html中的align对齐属性\n仅适用于块级元素，对行内元素无效\n\n如果需要对图像设置水平对齐，可以为图像添加一个父标签&lt;p&gt;,然后对父标签应用text-align,可实现图像水平对齐\n\n\n值描述\n\nleft左对齐（默认值）\n\nright右对齐\n\ncenter居中对齐\ntext-indent：首行缩进设置首行文本的缩进。\nem字符宽度倍数（建议）、%、数值\n适用于块级元素，对行内元素无效\nwhite-space: 空白符处理设置空白符的处理方式\n\n值描述\n\nnormal常规（默认值），文本中的空格、空行无效，满行（到达区域边界）后自动换行\n\npre预格式化，按文档的书写格式保留空格、空行原样显示\n\nnowrap空格空行无效，强制文本不能换行，除非遇到换行标签&lt;br /&gt;。内容超出元素的边界也不换行，若超出浏览器页面则会自动增加滚动条。\ntext-shadow：阴影效果为页面中的文本添加阴影效果。\nh-shadow用于设置水平阴影的距离，v-shadow用于设置垂直阴影的距离，blur用于设置模糊半径，color用于设置阴影颜色。\n1选择器&#123;text-shadow:h-shadow v-shadow blur color&#125;1p&#123;text-shadow:10px 10px 10px red&#125;\n阴影的水平或垂直距离参数可以负值，但阴影的模糊半径只能为正值\n可以给文字添加多个阴影，产生阴影叠加效果\n\n1p&#123;text-shadow:10px 10px 10px red,20px 20px 20px green;&#125;text-overflow：标示对象内溢出文本用于处理溢出的文本\n1选择器&#123;text-overflow:属性值；&#125;clip：修剪溢出文本，不显示省略标签“…”。ellipsis：用省略标签“…”替代被修剪文本，省略标签插入的位置是最后一个字符。\n\n123456789101112&lt;style type=\"text/css\"&gt;P&#123;\twidth:200px; \theight:100px; \tborder:1px solid #000;\twhite-space:nowrap;        /*强制文本不能换行*/\toverflow:hidden;           /*修剪溢出文本*/\ttext-overflow:ellipsis;    /*用省略标签标示被修剪的文本*/&#125;&lt;/style&gt;&lt;p&gt;把很长的一段文本中溢出的内容隐藏，出现省略号&lt;/p&gt;word-wrap实现长单词和URL地址的自动换行。\nnormal：只在允许的断字点换行（浏览器保持默认处理）。break-word：在长单词或 URL 地址内部进行换。\n12345678910111213&lt;style type=\"text/css\"&gt;\tp&#123;       width:100px;        height:100px;       border:1px solid #000;    &#125;\t.break_word&#123;word-wrap:break-word;&#125;   /*网址在段落内部换行*/&lt;/style&gt;&lt;span&gt;word-wrap:normal;&lt;/span&gt;&lt;p&gt;网页平面ui设计学院http://icd.XXXXXXX.cn/&lt;/p&gt;&lt;span&gt;word-wrap:break-word;&lt;/span&gt;&lt;p class=\"break_word\"&gt;网页平面ui设计学院http://icd.XXXXXXXXX.cn/&lt;/p&gt;","plink":"https://dxsummer.gitee.io/posts/dfb45e1c/"},{"title":"线性表","date":"2020-10-01T15:17:20.000Z","date_formatted":{"ll":"2020年10月1日","L":"2020/10/01","MM-DD":"10-01"},"updated":"2020-10-11T14:03:06.000Z","content":"线性表的定义和特点同一线性表的元素必定具有相同的特性，即属于同一数据对象，相邻数据元素之间存在着序偶关系\n由n（n&gt;=0）个数据特性相同的元素构成的有限序列称为线性表\n线性表中元素的个数n（n&gt;=0）定义为线性表的长度，n=0时称为空表\n非空线性表或线性结构的特点\n存在唯一的一个被称作“第一个”的数据元素\n存在唯一的一个被称作“最后一个”的数据元素\n除第一个之外，结构中的每个数据元素均只有一个前驱\n除最后一个之外，结构中的每个数据元素均只有一个后继\n什么是线性表线性表，全名为线性存储结构。使用线性表存储数据的方式可以这样理解，即“把所有数据用一根线儿串起来，再存储到物理空间中”。\n首先，用“一根线儿”把它们按照顺序“串”起来，如图 2 所示：\n图 2 数据的”线性”结构\n图 2 中，左侧是“串”起来的数据，右侧是空闲的物理空间。把这“一串儿”数据放置到物理空间，我们可以选择以下两种方式，如图 3 所示。\n图 3 两种线性存储结构\n图 3a) 是多数人想到的存储方式，而图 3b) 却少有人想到。我们知道，数据存储的成功与否，取决于是否能将数据完整地复原成它本来的样子。如果把图 3a) 和图 3b) 线的一头扯起，你会发现数据的位置依旧没有发生改变（和图 1 一样）。因此可以认定，这两种存储方式都是正确的。\n将具有“一对一”关系的数据“线性”地存储到物理空间中，这种存储结构就称为线性存储结构（简称线性表）。\n使用线性表存储的数据，如同向数组中存储数据那样，要求数据类型必须一致，也就是说，线性表存储的数据，要么全不都是整形，要么全部都是字符串。一半是整形，另一半是字符串的一组数据无法使用线性表存储。\n顺序存储结构和链式存储结构图 3 中我们可以看出，线性表存储数据可细分为以下 2 种：\n如图 3a) 所示，将数据依次存储在连续的整块物理空间中，这种存储结构称为顺序存储结构（简称顺序表）；\n\n如图 3b) 所示，数据分散的存储在物理空间中，通过一根线保存着它们之间的逻辑关系，这种存储结构称为链式存储结构（简称链表）；\n\n也就是说，线性表存储结构可细分为顺序存储结构和链式存储结构。\n线性表常用术语数据结构中，一组数据中的每个个体被称为“数据元素”（简称“元素”）。例如，图 1 显示的这组数据，其中 1、2、3、4 和 5 都是这组数据钟的一个元素。\n另外，对于具有“一对一”逻辑关系的数据，我们一直在用“某一元素的左侧（前边）或右侧（后边）”这样不专业的词，其实线性表中有更准确的术语：\n某一元素的左侧相邻元素称为“直接前驱”，位于此元素左侧的所有元素都统称为“前驱元素”；\n某一元素的右侧相邻元素称为“直接后继”，位于此元素右侧的所有元素都统称为“后继元素”；\n以图 1 数据中的元素 3 来说，它的直接前驱是 2 ，此元素的前驱元素有 2 个，分别是 1 和 2；同理，此元素的直接后继是 4 ，后继元素也有 2 个，分别是 4 和 5。如图 4 所示：\n图 4 前驱和后继\n顺序表示和实现顺序存储表示用一组地址连续的存储单元依次存储线性表的数据元素，这种表示也称线性表的顺序存储结构或顺序映像，这种存储结构的线性表为顺序表\n逻辑上相邻的数据元素，物理次序也相邻\n顺序表存储数据时，会提前申请一整块足够大小的物理空间，然后将数据依次存储起来，存储时做到数据元素之间不留一丝缝隙\n\n线性表的顺序存储结构是一种随机存取\n\n\n\nLOC(ai+1) = LOC(ai) + l\nLOC(ai) = LOC(a1) + (i-1) x l\n\ni：第i个数据元素    \n\nLOC(ai)：第i个数据元素的存储地址    \n\nL：每个元素占用L个存储单位\n\n基本操作的实现类型定义123456#define  MAXSIZE 100     //最大长度typedef struct &#123; \t ElemType  *elem;      //指向数据元素的基地址  \tint  length;                 //线性表的当前长度                         &#125;SqList；ElemType可以是int、float、char，也可以是结构体类型struct\nlength当前数据元素的个数，C语言数组的下标是从0开始的，而位置序号从1开始\n\n图书表的顺序存储结构类型定义\n\n12345678910111213#define MAXSIZE 10000\t//图书表可能达到的最大长度 typedef struct\t\t\t//图书信息定义&#123;    char no[20];\t\t\t//图书ISBN   char name[50];\t\t//图书名字   float price; \t\t\t//图书价格&#125;Book;typedef struct&#123;    Book *elem;\t             //存储空间的基地址    int length;\t\t//图书表中当前图书个数 c&#125;SqList;\t\t//图书表的顺序存储结构类型为SqListSqList L;将L定义为Sqlist类型的变量，利用L.elem[i-1]访问表中位置序号为i的图书记录\n初始化使用顺序表存储数据之前，除了要申请足够大小的物理空间之外，为了方便后期使用表中的数据，顺序表还需要实时记录以下 2 项数据：\n顺序表申请的存储容量；\n顺序表的长度，也就是表中存储数据元素的个数；\n提示：正常状态下，顺序表申请的存储容量要大于顺序表的长度。\n初始化线性表L （参数用引用）\n1234567Status InitList_Sq(SqList &amp;L)                   //构造一 个空的顺序表L&#123;    L.elem=new ElemType[MAXSIZE];   //为顺序表分配空间    if(!L.elem) exit(OVERFLOW);           //存储分配失败    L.length=0;\t\t\t\t     //空表长度为0    return OK;&#125;取值(随机存取) O(1)根据位置i获取相应位置数据元素的内容\n1234567int GetElem(SqList L,int i,ElemType &amp;e)&#123;  if (i&lt;1||i&gt;L.length) return ERROR;      //判断i值是否合理，若不合理，返回ERROR  e=L.elem[i-1];   //第i-1的单元存储着第i个数据  return OK;&#125;查找 O(n)顺序表中查找目标元素，可以使用多种查找算法实现，比如说二分查找算法、插值查找算法等。这里，我们选择顺序查找算法，具体实现代码为：\n1234567在线性表L中查找值为e的数据元素int LocateELem(SqList L,ElemType e)&#123;  \tfor (i=0;i&lt; L.length;i++)      \tif (L.elem[i]==e) return i+1;                 \t return 0;&#125;插入 O(n)向已有顺序表中插入数据元素，根据插入位置的不同，可分为以下 3 种情况：\n插入到顺序表的表头；\n在表的中间位置插入元素；\n尾随顺序表中已有元素，作为顺序表中的最后一个元素；\n虽然数据元素插入顺序表中的位置有所不同，但是都使用的是同一种方式去解决，即：通过遍历，找到数据元素要插入的位置，然后做如下两步工作：\n将要插入位置元素以及后续的元素整体向后移动一个位置；\n将元素放到腾出来的位置上；\n例如，在 {1,2,3,4,5} 的第 3 个位置上插入元素 6，实现过程如下：\n遍历至顺序表存储第 3 个数据元素的位置，如图 1 所示：\n图 1 找到目标元素位置\n将元素 3 以及后续元素 4 和 5 整体向后移动一个位置，如图 2 所示：\n图 2 将插入位置腾出\n将新元素 6 放入腾出的位置，如图 3 所示：\n图 3 插入目标元素\n\n在线性表L中第i个数据元素之前插入数据元素e \n\n12345678910Status ListInsert_Sq(SqList &amp;L,int i ,ElemType e)&#123;   if(i&lt;1 || i&gt;L.length+1) return ERROR;\t         //i值不合法   if(L.length==MAXSIZE) return ERROR;    //当前存储空间已满        for(j=L.length-1;j&gt;=i-1;j--)        L.elem[j+1]=L.elem[j];    //插入位置及之后的元素后移    L.elem[i-1]=e;                     //将新元素e放入第i个位置    ++L.length;\t\t     \t//表长增1    return OK;&#125;删除从顺序表中删除指定元素，实现起来非常简单，只需找到目标元素，并将其后续所有元素整体前移 1 个位置即可。\n后续元素整体前移一个位置，会直接将目标元素删除，可间接实现删除元素的目的。\n例如，从 {1,2,3,4,5} 中删除元素 3 的过程如图 4 所示：\n图 4 顺序表删除元素的过程示意图\n\n将线性表L中第i个数据元素删除\n\n12345678Status ListDelete_Sq(SqList &amp;L,int i)&#123;   if((i&lt;1)||(i&gt;L.length)) return ERROR;\t //i值不合法   for (j=i;j&lt;=L.length-1;j++)                   　  　L.elem[j-1]=L.elem[j];       //被删除元素之后的元素前移     --L.length;               \t                 //表长减1  return OK;&#125;链式表示和实现结点在存储器中的位置是任意的，即逻辑上相邻的数据元素在物理上不一定相邻\n线性表的链式表示又称为非顺序映像或链式映像。\n数据元素本身，其所在的区域称为数据域；\n\n指向直接后继元素的指针，所在的区域称为指针域；即链表中存储各数据元素的结构如图 3 所示：\n\n   图 3 节点结构\n图 3 所示的结构在链表中称为结点。也就是说，链表实际存储的是一个一个的节点，真正的数据元素包含在这些节点中，如图 4 所示：\n图 4 链表中的节点\n\n单链表、双链表、循环链表： \n\n结点只有一个指针域的链表，称为单链表或线性链表\n有两个指针域的链表，称为双链表\n首尾相接的链表称为循环链表\n头指针是指向链表中第一个结点的指针\n首元结点是指链表中存储第一个数据元素a1的结点\n头结点是在链表的首元结点之前附设的一个结点；数据域内只放空表标志和表长等信息\n如何表示空表？\n有头结点时，当头结点的指针域为空时表示空表\n在链表中设置头结点有什么好处？\n便于首元结点的处理首元结点的地址保存在头结点的指针域中,所以在链表的第一个位置上的操作和其它位置一致，无须进行特殊处理\n便于空表和非空表的统一处理无论链表是否为空，头指针都是指向头结点的非空指针，因此空表和非空表的处理也就统一了。\n头结点的数据域内装的是什么？\n 头结点的数据域可以为空，也可存放线性表长度等附加信息，但此结点不能计入链表长度值。\n单链表的定义和实现12345678typedef struct Lnode&#123;     ElemType   data;       //数据域     struct LNode  *next;   //指针域&#125;LNode,*LinkList;   // *LinkList为Lnode类型的指针LNode *p\t//p为指向单链表中某个节点的指针 *p表示该结点LinkList L\t//L为单链表的头指针指针变量p：表示结点地址结点变量*p：表示一个结点\n基本操作初始化(构造一个空表 )12345Status InitList_L(LinkList &amp;L)&#123;    L=new LNode;                    \t   L-&gt;next=NULL;　　　　　   return OK; &#125;销毁\n1234567891011Status DestroyList_L(LinkList &amp;L)&#123;    LinkList p;       while(L)        &#123;            p=L;              L=L-&gt;next;            delete p;          &#125;     return OK; &#125;清空\n123456789Status ClearList(LinkList &amp; L)&#123;  // 将L重置为空表    LinkList p,q;   p=L-&gt;next;   //p指向第一个结点   while(p)       //没到表尾       &#123;  q=p-&gt;next; delete p;     p=q;   &#125;   L-&gt;next=NULL;   //头结点指针域为空    return OK; &#125;求表长\n12345678910int  ListLength_L(LinkList L)&#123;//返回L中数据元素个数    LinkList p;    p=L-&gt;next;  //p指向第一个结点     i=0;                  while(p)&#123;//遍历单链表,统计结点数           i++;           p=p-&gt;next;    &#125;     return i;                              &#125;判断表是否为空\n12345678int ListEmpty(LinkList L)&#123; \t//若L为空表，则返回1，否则返回0    if(L-&gt;next)   //非空      return 0;   else     return 1; &#125;取值（根据位置i获取相应位置数据元素的内容）12345678910//获取线性表L中的某个数据元素的内容Status GetElem_L(LinkList L,int i,ElemType &amp;e)&#123;     p=L-&gt;next;j=1; //初始化     while(p&amp;&amp;j&lt;i)&#123;\t//向后扫描，直到p指向第i个元素或p为空        p=p-&gt;next; ++j;      &#125;      if(!p || j&gt;i)return ERROR; //第i个元素不存在      e=p-&gt;data; //取第i个元素      return OK; &#125;//GetElem_L查找（根据指定数据获取数据所在的位置）12345678//在线性表L中查找值为e的数据元素LNode *LocateELem_L (LinkList L，Elemtype e) &#123; //返回L中值为e的数据元素的地址，查找失败返回NULL  p=L-&gt;next;  while(p &amp;&amp;p-&gt;data!=e)          p=p-&gt;next;                \t\t  return p; \t&#125;插入（插在第 i 个结点之前）1234567891011//在L中第i个元素之前插入数据元素e Status ListInsert_L(LinkList &amp;L,int i,ElemType e)&#123;      p=L;j=0;       while(p&amp;&amp;j&lt;i−1)&#123;p=p-&gt;next;++j;&#125;\t//寻找第i−1个结点       if(!p||j&gt;i−1)return ERROR;\t//i大于表长 + 1或者小于1        s=new LNode;\t\t\t//生成新结点s       s-&gt;data=e;      \t\t           //将结点s的数据域置为e       s-&gt;next=p-&gt;next;\t   \t          //将结点s插入L中       p-&gt;next=s;       return OK; &#125;//ListInsert_L删除（删除第 i 个结点）12345678910111213//将线性表L中第i个数据元素删除 Status ListDelete_L(LinkList &amp;L,int i,ElemType &amp;e)&#123;    p=L;j=0;     while(p-&gt;next &amp;&amp;j&lt;i-1)&#123;                  //寻找第i个结点，并令p指向其前驱         p=p-&gt;next; ++j;     &#125;     if(!(p-&gt;next)||j&gt;i-1) return ERROR; //删除位置不合理     q=p-&gt;next;                                        //临时保存被删结点的地址以备释放     p-&gt;next=q-&gt;next; \t                  //改变删除结点前驱结点的指针域     e=q-&gt;data; \t                                //保存删除结点的数据域     delete q; \t                                //释放删除结点的空间  return OK; &#125;//ListDelete_L单链表的建立（前插法）123456789void CreateList_F(LinkList &amp;L,int n)&#123;      L=new LNode;       L-&gt;next=NULL; //先建立一个带头结点的单链表       for(i=n;i&gt;0;--i)&#123;         p=new LNode; //生成新结点         cin&gt;&gt;p-&gt;data; //输入元素值         p-&gt;next=L-&gt;next;L-&gt;next=p; \t//插入到表头      &#125; &#125;//CreateList_F单链表的建立（尾插法）123456789101112void CreateList_L(LinkList &amp;L,int n)&#123;       //正位序输入n个元素的值，建立带表头结点的单链表L       L=new LNode;       L-&gt;next=NULL; \t      r=L; \t                                //尾指针r指向头结点       for(i=0;i&lt;n;++i)&#123;         p=new LNode;\t　\t       //生成新结点         cin&gt;&gt;p-&gt;data;   \t\t       //输入元素值         p-&gt;next=NULL; r-&gt;next=p;       //插入到表尾         r=p; \t                                  //r指向新的尾结点       &#125; &#125;//CreateList_L顺序表和链表的比较","plink":"https://dxsummer.gitee.io/posts/40f24371/"},{"title":"结构体变量和结构体类型的定义","date":"2020-10-01T15:17:20.000Z","date_formatted":{"ll":"2020年10月1日","L":"2020/10/01","MM-DD":"10-01"},"updated":"2020-10-11T14:25:56.000Z","content":"结构体类型定义定义方式1：\n1234Typedef struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125; *LinkList;定义方式2：\n123456struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125;;Typedef struct  LNode  *LinkList;以上两个定义方式是等价的，是将 *LinkList 定 义为 struct LNode 类型，即 LinkList 被定义为一个类型名。这样就可以用 LinkList 来定义说明新的变量了，如：\n1LinkList  L;即将 L 定义为 struct LNode 类型的指针变量。\n结构体类型变量定义定义方式1：\n12345struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125;LnodeA;定义方式2：\n123456struct  LNode &#123;   int  data;  // 数据域   struct LNode   *next;  // 指针域&#125;;struct  LNode LnodeA;以上两个定义方式也是等价的，这样就将 LnodeA 定义为一个 struct LNode 类型的变量，即 LnodeA 为一个 struct LNode 类型的变量名。\n","plink":"https://dxsummer.gitee.io/posts/4d0d4efc/"},{"title":"HTML5","date":"2020-09-19T08:04:16.000Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-10-10T02:35:42.000Z","content":"\n为什么有单表签\n\n单表签本身就可以描述一个功能，不需要选择 例如 水平线标签&lt;hr/&gt;\n标签嵌套关系123456&lt;html&gt;\t&lt;head&gt;\t&lt;/head&gt;\t&lt;body&gt;\t&lt;/body&gt;&lt;/html&gt;标签属性1&lt;标签名 属性1=\"属性值1\" 属性2=\"属性值2\" ...&gt; 内容 &lt;/标签名&gt;我是剧中文本1&lt;p align=\"center\"&gt;我是剧中文本&lt;/p&gt;\n键值对：对“属性”设置“属性值”\n例如 color=&quot;red&quot;、width=200px\n\n定义页面元信息标签&lt;meta/&gt;设置网页关键字\n1&lt;meta name=\"keywords\" content=\"千图网,免费素材下载,千图网免费素材图库,矢量图,矢量图库,图片素材,网页素材,免费素材,PS素材,网站素材,设计模板,设计素材,www.58pic.com,网页模板免费下载,千图,素材,素材,免费设计,图片\"/&gt;\n设置网站描述（不超200字）\n1&lt;meta name=\"description\" content=\"千图网(www.58pic.com) 是专注正版图片设计素材下载的网站！提供矢量图素材、背景图片素材、矢量图库、psd素材、字体模板、设计素材、PPT模板、视频素材、插画绘画、平面设计模板、Excel模板素材以及网页模板、网站设计素材、网页图标的下载服务。\"/&gt;\n这是网页作者\n1&lt;meta name=\"author\" content=\"网络部\"\n设置字符集\n1&lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=gbk\" /&gt;\n设置页面自动刷新与跳转\n1&lt;meta http-equiv=\"refresh\" content=\"10; url= https://www.baidu.com/\" /&gt;\n页面格式化标签标题标签\n一个页面只能用一个&lt;h1&gt;标签 常用于网站logo部分\n不建议使用h标签的align对齐属性，可使用CSS样式设置\n\n标题文本1&lt;h5 align=\"center/left/right\"&gt;标题文本&lt;/h5&gt;段落标签标题文本1&lt;p align=\"center/left/right\"&gt;标题文本&lt;/p&gt;水平线1&lt;hr 属性=\"属性值\" /&gt;\n属性名含义属性值\n\nalign对齐方式可选left，right，center 3种值，默认 center， 居中对齐显示\n\nsize粗细以像素为单位，默认2像素\n\ncolor颜色可用颜色名称、十六进制#RGB、rgb(r，g，b)表示\n\nwidth宽度可以是确定的像素值，也可以是浏览器窗口的百分比，默认100%\n换行标签1&lt;br /&gt;文本样式标签 文本内容\n1&lt;font size=\"6\" color=\"red\" face=\"宋体\"&gt; 文本内容&lt;/font&gt;1&lt;font 属性=\"属性值\"&gt; 文本内容&lt;/font&gt;\n属性名含义\n\nface字体\n\nsize文字大小 1~7整数\n\ncolor颜色\n文本格式化标签\n标签效果\n\n&lt;b&gt;&lt;/b&gt;和&lt;strong&gt;&lt;/strong&gt;粗体显示\n\n&lt;u&gt;&lt;/u&gt;和&lt;ins&gt;&lt;/ins&gt;下划线\n\n&lt;i&gt;&lt;/i&gt;和&lt;em&gt;&lt;/em&gt;斜体\n\n&lt;s&gt;&lt;/s&gt;和&lt;del&gt;&lt;/del&gt;删除\n\n&lt;sub&gt;&lt;/sub&gt;下标\n\n&lt;sup&gt;&lt;/sup&gt;上标\ntime标签本消息发布于2020年9月19日\n1&lt;time datetime=\"2015-08-15\" pubdate= \"pubdate\"&gt;本消息发布于2020年9月19日&lt;/time&gt;mark标签wikew\n1&lt;mark&gt;wikew&lt;/mark&gt;cite标签(参考文献说明)—————我\n1&lt;cite&gt;—————我&lt;/cite&gt;图像标签图像格式GIF\n支持动画，无损，支持透明，256种颜色\n\nPNG\n体积小，支持Alpha透明（全透明、半透明、不透明），256种颜色\n\nJPG\n有损压缩，超过256种颜色\n\n图像标签&lt;img/&gt;1&lt;img src=\"图像URL\" /&gt;\n属性属性值描述\n\nsrcURL图片路径\n\nalt文本图像不能显示的交替文本\n\ntitle文本鼠标悬停显示内容\n\nwidth像素宽度\n\nheight像素高度\n\nborder数字边框的宽度\n\nvspace像素垂直边距\n\nhspace像素水平边距\n\nalignlefttopmiddlebottomrighttop：图像顶端和文本的第一行文字对齐，其他文字居图像下方middle：图像水平中线和文本的第一行文字对齐，其他文字居图像下方bottom：图像底部和文本的第一行文字对齐，其他文字居图像下方\n","plink":"https://dxsummer.gitee.io/posts/98f3a6d9/"},{"title":"绪论","date":"2020-09-19T06:29:02.000Z","date_formatted":{"ll":"2020年9月19日","L":"2020/09/19","MM-DD":"09-19"},"updated":"2020-09-19T08:00:48.000Z","content":"基本概念和术语1.1 数据、数据元素、数据项、数据对象关系\n数据（data)：所有能输入到计算机中去的描述客观事物的符号\n数据对象(Data Object)：相同特性数据元素的集合，是数据的一个子集\n数据元素（data element）：数据的基本单位，也称结点（node）或记录（record）\n数据项（data item）：有独立含义的数据最小单位，也称域(field)\n1.2 数据结构\n逻辑结构集合结构：数据元素同属一个集合，单个数据元素之间没有任何关系。\n\n线性结构：类似于线性关系，也就是说，线性结构中的数据元素之间是一对一的关系。注意：重点在一对一。\n\n树形结构：树形结构中的数据元素之间存在一对多的关系。（各元素及元素关系所组成图形类似于树状图）。注意：关系为一对多。如下图所示。\n\n图形结构：数据元素之间是多对多的关系。\n\n存储结构(物理结构)物理结构又叫存储结构，分为四种种，顺序存储结构、链式存储结构、索引结构、散列结构。\n顺序存储结构：一段连续的内存空间。\n优点：随机访问\n缺点：插入删除效率低，大小固定\n\n链式存储结构：不连续的内存空间，借助指针\n优点：大小动态扩展，插入删除效率高\n缺点：不能随机访问。\n\n索引存储结构：为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。\n优点：对顺序查找的一种改进，查找效率高\n缺点：需额外空间存储索引\n散列存储结构：选取某个函数，数据元素根据函数计算存储位置\n可能存在多个数据元素存储在同一位置，引起地址冲\n优点：查找基于数据本身即可找到，查找效率高，存取效率高。\n缺点：存取随机，不便于顺序查找。\n1.3 数据类型和抽象数据类型数据类型数据类型是一个值的集合和定义在此集合上的一组操作的总称。例如 c语言中的整型，浮点型，他们的取值范围不同，进行运算时所遵循的规范也不同\n抽象数据类型抽象数据类型=逻辑结构＋抽象运算抽象数据类型暂不考虑计算机的具体存储结构和运算的具体实现。抽象数据类型实质上，就是在描述问题本身（与计算机无关）。目标：在不涉及具体的，和计算机系统相关的细节情况下，优先理解问题本身，在此基础上，实现用计算机求解问题的过程。\n我们可以认为抽象数据类型是包含着数据类型的，也就是说，抽象数据类型是一个更大的概念\n例如：在定义一个学生类型的抽象数据类型时，学生对象既包含整型的年龄，身高，又包含char类型的姓名，这时，我们就可以用一个结构体定义这个学生类型\n12345ADT &lt;抽象数据类型名&gt;&#123;数据对象：&lt;数据对象的定义&gt;数据关系：&lt;数据关系的定义&gt;基本操作：&lt;基本操作的定义&gt;&#125;这里，Student是一个抽象数据类型，而里面的int,char类型又是不同的数据类型\n12345struct Student &#123;char sno; //学号int age; //年龄… …&#125;这里，Student是一个抽象数据类型，而里面的int,char类型又是不同的数据类型\n1.4 算法和算法分析算法：解决某类问题而规定的一个有限长的操作序列\n算法的五个重要特征：有穷性\n确定性\n可行性\n有输入\n有输出\n算法优劣基本标准正确性\n可读性\n健壮性\n高效性：包括时间和空间（占用存储合理），\n算法效率的度量一条语句的重复执行次数称作语句频度\n1234567for(i=1;i&lt;=n;i++)\t\t\t\t\t\t//n+1\tfor(j=1;j&lt;=n;j++)\t\t\t\t\t//n*(n+1)    &#123;        C[i][j]=0;\t\t\t\t\t\t//n²        for(k=1;k&lt;=n;k++)\t\t\t\t//n²*（n+1）            c[i][j]=c[i][j]+a[i][k]*b[k][j];\t//n³    &#125;所有语句频度之和f(n)\n1f(n)&#x3D;2n³+3n²+2n+1算法中基本语句重复执行的次数是问题规模n的某个函数f(n),算法的时间量度\n  它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度简称时间复杂度  语句的频度指的是该语句重复执行的次数\n算法的存储空间需求  如果所占空间量依赖于特定的输入，除特别指明外，均按最坏情况来分析\n1T（n）&#x3D;O(f(n))  它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度 简称时间复杂度\n语句的频度指的是该语句重复执行的次数\n空间复杂度1S（n)&#x3D;O(f(n))\n数组逆序，将一维数组a中的n个数逆序存放到原数组中\n\n1234567算法1for(i&#x3D;0;i&lt;n&#x2F;2;i++)&#123;\tt&#x3D;a[i];\ta[i]&#x3D;a[n-i-1];\ta[n-i-1]&#x3D;t;&#125;算法1 需要借助t，与问题规模n大小无关，所以空间复杂度为O（1）\n12345算法2for(i&#x3D;0;i&lt;n;i++)\tb[i]&#x3D;a[n-i-1];for(i&#x3D;0;i&lt;n;i++)\ta[i]&#x3D;b[i];算法2 借助大小为n的辅助数组b，空间复杂度为O(n)\n","plink":"https://dxsummer.gitee.io/posts/43830010/"},{"title":"Eclipse使用手册","date":"2020-09-10T12:04:31.000Z","date_formatted":{"ll":"2020年9月10日","L":"2020/09/10","MM-DD":"09-10"},"updated":"2020-09-10T14:12:30.000Z","content":"Java Eclipse下载与安装安装(1) Eclipse 是一个开放源代码的项目，其官方网站是 www.eclipse.org。图 1 所示为 Eclipse 官方网站的首页。\n\nEclipse IDE for Java EE Developers下载地址\n\n\n(2) 从首页中单击 DOWNLOAD 按钮，进入图 2 所示的页面。\n\n(3) 点击 Download Packages，进入 Eclipse 下载页面。从 Eclipse IDE for Java EE Developers 后面选择适合当前系统的版本，这里单击 64 bit 按钮，下载 64 位的安装包，如图 3 所示。\n\n(4) 点击“64-bit”后跳转到“Choose a mirror close to you”界面。点击“Sellect Another Mioor”，选择“大连东软信息学院”，如图 4 所示。\n\n(5) 下载完成后或者下载没有开始，进入如下所示的页面。如果下载没有开始，点击“click here”重新开始下载。\n\n下载完成后会得到一个名为 eclipse_java_mars_2_win32_x86_64.zip 的压缩文件。虽然 Eclipse 本身是用 Java 语言编写，但下载的压缩包中并不包含 Java 运行环境（即安装 Eclipse，应首先安装 JDK），需要用户自己另行安装 JRE，并且要在操作系统的环境变量中指明 JRE 中 bin 的路径。\n(6) Eclipse 的安装非常简单，只需将下载的压缩包进行解压，然后双击 eclipse.exe 文件即可。Eclipse 第一次启动时会要求用户选择一个工作空间（Workspace），如图 6 所示。\n\n配置汉化由于 Eclipse 是一个开源项目，因此所有社区和开发者都可以为 Eclipse 开发扩展功能。下面介绍为 Eclipse 安装汉化包的方法。\n(7) Eclipse 有一个子项目 Babel，专门负责 Eclipse 程序的多国语言包，其官方网站是 www.eclipse.org/babel，进入后的Babel 项目首页如图 7 所示。\n\n(8) 从页面导航中单击 Downloads 链接进入下载页面。在下载页面的 Babel Language Pack Zips 标题下选择对应 Eclipse 版本的超链接下载语言包。前面下载 Eclipse 的安装文件是 eclipse_java_mars_2_win32_x86_64.zip，因此这里单击 Mars 链接，如图 8 所示。\n\n(9) 在进入的语言选择页面中列出了当前支持的所有语言列表，从中单击 Chinese(Simplified) 链接进入简体中文的下载列表，在这里又针对不同插件和功能分为多个 ZIP 压缩包。从列表中单击 BabelLanguagePack_birt_zh_4.5.0.v20151128060001.zip 链接，下载完整版语言包，如图 9 所示。\n\n(10) 下载后会得到 BabelLanguagePack_birt_zh_4.5.0.v20151128060001.zip 文件，将其解压并覆盖 Eclipse\\drogins文件夹中同名的 features 目录和 plugins 目录，这样下次启动 Eclipse 时便会自动加载语言包。\n(11) 在工作空间选择页面中，单击“浏览”按钮，将工作空间放到 E:\\java_workspace，然后选中“将此值用作缺省值并且不再询问”复选框，再单击“确定”按钮。\n(12) 启动 Eclipse，进入 Eclipse 的欢迎界面。选择“帮助”|“关于 Eclipse”命令，可以在弹出的对话框中查看当前 Eclipse 的详细信息。\n开始配置在 Eclipse 中编写程序，必须先创建项目。Eclipse 中有很多项目，其中 Java 项目用于管理和编写 Java 程序，具体步骤如下。\n(1) 在图 1 所示的界面中选择“file（文件）”|“new（新建）”|“Java Project（Java项目）”命令，打开“New Java Project（新建Java项目）”对话框。\n(2) 设置“Project name（项目名）”为 HelloJava，选中“Use default location（使用缺省位置）”复选框，将项目保存到工作空间中，其他暂时不用设置，如图 1 所示。\n图 1 New Java Project（新建Java项目）对话框\n(3) 单击“Next（下一步）”按钮，在进入的对话框中更改项目的 Sourse（源码）选项，如图 2 所示。同时还可以设置 Project（项目）、Libraries（库）、Order and Export（排序和导出）方面的选项，分别如图 3、图 4 和图 5 所示。\n图 2 设置Sourse（源码）选项\n图 3 设置Project（项目）选项\n图 4 设置Libraries（库）选项\n图 5 设置Order and Export（排序和导出）选项\n(3) 单击“Finish（完成）”按钮，创建名为 HelloJava 的项目，Eclipse 会自动生成相关代码和布局结构。在 Eclipse 左侧“Package Explorer（包资源管理器）”窗格中会显示整个 Java 项目的目录结构，默认为空项目。\n(4) 右击 src 目录，选择“new（新建）”|“Class（类）” 命令，打开“New Java Class（新建 Java 类）”对话框。设置类的名称为 HelloJava，并选中 public static void main(String[] args) 复选框为新类生成 main() 方法，如图 6 所示。\n图 6 New Java Class（新建Java类）对话框\n(7) 最后单击“Finish（完成）”按钮，会看到生成的 HelloJava.java 文件的内容，并处于编辑状态，如图 7 所示。\n图 7 HelloJava.java 文件\n\n例一\n\n1) 对生成的源代码进行修改，最终文件代码如下。\n12345678910public class HelloJava &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F; TODO自动生成的方法存根        System.out.println(&quot;    *&quot;);        System.out.println(&quot;   ***&quot;);        System.out.println(&quot;  *****&quot;);        System.out.println(&quot; *******&quot;);        System.out.println(&quot;*********&quot;);    &#125;&#125;读者输入上面代码的时候，会充分体会到 Eclipse 强大的代码辅助功能。图 8 所示为代码的自动提示补全功能。\n图 8 自动补全代码\n2) 编写完成之后按 Ctrl+S 快捷键保存修改。在工具栏中单击“运行”按钮后，如果程序没有编译错误，在底部的“Console（控制台）”窗格中会看到输出的等腰三角形，这就是程序的运行效果，如图 9 所示。\n图 9 查看输出结果\n字体配置在第一次使用 Eclipse 编写程序时，由于 Eclipse 默认使用的是 Cosnolas 字体，字号为 10，所以编辑器中的字体非常小，不方便查看。\n我们可以通过下面所示的方法来修改编辑器的字体大小。如图 1 所示，具体修改方法为：\n选择“窗口”|“首选项”命令，打开“首选项”对话框，从左侧窗格依次展开“General（常规）”|“Appearance（外观）”|“Colors and Fonts（颜色和字体）”选项。\n从右侧选择 Java 下的“Java Editor Text Font（Java编辑器文本字体）”选项。\n单击“Edit（编辑）”按钮，在弹出的“字体”对话框中设置字体的样式和大小。\n图 1 设置编辑器字体大小\n设置完成后，依次单击“Apply and Close（确定）”按钮返回 Eclipse，此时即可看到修改效果。图 2 所示为 14 号字体的效果。\n图 2 14号字体的效果\n快捷键大全编辑类快捷键\n编辑类快捷键\n\nCtrl+1快速修复（最经典的快捷键，可以解决很多问题，比如 import 类、try catch 包围等）\n\nCtrl+Shift+F格式化当前代码\n\nCtrl+Shift+M添加类的 import 导入\n\nCtrl+Shift+O组织类的 import 导入（既有 Ctrl+Shift+M 的作用，又可以去除没用的导入，一般用这个导入包）\n\nCtrl+Y重做（与撤销 Ctrl+Z 相反）\n\nAlt+/内容辅助（用户编辑的好帮手，省了很多次键盘敲打，太常用了）\n\nCtrl+D删除当前行或者多行（不用为删除一行而按那么多次的删除键）\n\nAlt+↓当前行和下面一行交互位置（特别实用，可以省去先剪切，再粘贴了）\n\nAlt+↑当前行和上面一行交互位置（同上）\n\nCtrl+Alt+↓复制当前行到下一行\n\nCtrl+Alt+↑复制当前行到上一行\n\nShift+Enter在当前行的下一行插入空行（这时鼠标可以在当前行的任一位置，不一定是最后）\n\nCtrl+/注释当前行，再按则取消注释\n选择类快捷键\n选择类快捷键\n\nAlt+Shift+↑选择封装元素\n\nAlt+Shift+←选择上一个元素\n\nAlt+Shift+→选择下一个元素\n\nShift+←从光标处开始往左选择字符\n\nShift+→从光标处开始往右选择字符\n\nCtrl+Shift+←选中光标左边的单词\n\nCtrl+Shift+→选中光标右边的单词\n移动类快捷键\n移动类快捷键\n\nCtrl+←光标移到左边单词的开头，相当于 vim 的 b\n\nCtrl+→光标移到右边单词的末尾，相当于 vim 的 e\n搜索类快捷键\n搜索类快捷键\n\nCtrl+K参照选中的 Word 快速定位到下一个（如果没有选中 word，则搜索上一次使用搜索的 word）\n\nCtrl+Shift+K参照选中的 Word 快速定位到上一个\n\nCtrl+J正向增量查找（按下 Ctrl+J 后，你所输入的每个字母编辑器都提供快速匹配定位到某个单词，如果没有，则在状态栏中显示没有找到了，查一个单词时，特别实用，要退出这个模式，按 escape 键）\n\nCtrl+Shift+J反向增量查找（和上条相同，只不过是从后往前查）\n\nCtrl+Shift+U列出所有包含字符串的行\n\nCtrl+H打开搜索对话框\n\nCtrl+G工作区中的声明\n\nCtrl+Shift+G工作区中的引用\n导航类快捷键\n导航类快捷键\n\nCtrl+Shift+T搜索类（包括工程和关联的第三 jar 包）\n\nCtrl+Shift+R搜索工程中的文件\n\nCtrl+E快速显示当前 Editer 的下拉列表（如果当前页面没有显示的用黑体表示）\n\nF4打开类型层次结构\n\nF3跳转到声明处\n\nAlt+←前一个编辑的页面\n\nAlt+→下一个编辑的页面（当然是针对上面那条来说了）\n\nCtrl+PageUp/PageDown在编辑器中，切换已经打开的文件\n调试类快捷键\n调试类快捷键\n\nF5单步跳入\n\nF6单步跳过\n\nF7单步返回\n\nF8继续\n\nCtrl+Shift+D显示变量的值\n\nCtrl+Shift+B在当前行设置或者去掉断点\n\nCtrl+R运行至行（超好用，可以节省好多的断点）\n重构\n重构（一般重构的快捷键都是 Alt+Shift 开头的）类快捷键\n\nAlt+Shift+R重命名方法名、属性或者变量名 （尤其是变量和类的 Rename，比手工方法能节省很多劳动力）\n\nAlt+Shift+M把一段函数内的代码抽取成方法 （这是重构里面最常用的方法之一了，尤其是对一大堆泥团代码有用）\n\nAlt+Shift+C修改函数结构（比较实用，有 N 个函数调用了这个方法，修改一次搞定）\n\nAlt+Shift+L抽取本地变量（可以直接把一些魔法数字和字符串抽取成一个变量，尤其是多处调用的时候）\n\nAlt+Shift+F把 Class 中的 local 变量变为 field 变量 （比较实用的功能）\n\nAlt+Shift+I合并变量\n\nAlt+Shift+V移动函数和变量（不常用）\n\nAlt+Shift+Z撤销（重构的后悔药）\n其他快捷键\n其他快捷键\n\nAlt+Enter显示当前选择资源的属性，windows 下的查看文件的属性就是这个快捷键，通常用来查看文件在 windows 中的实际路径\n\nCtrl+↑文本编辑器 上滚行\n\nCtrl+↓文本编辑器 下滚行\n\nCtrl+M最大化当前的 Edit 或 View （再按则反之）\n\nCtrl+O显示类中方法和属性的大纲，能快速定位类的方法和属性（在查找 Bug 时非常有用）\n\nCtrl+T快速显示当前类的继承结构\n\nCtrl+W关闭当前 Editer（windows 下关闭打开的对话框也是这个，还有 qq、旺旺、浏览器等都是）\n\nCtrl+L文本编辑器 转至行\n\nF2显示工具提示描述\n","plink":"https://dxsummer.gitee.io/posts/4865d579/"},{"title":"Java编程基础","date":"2020-09-10T11:24:37.000Z","date_formatted":{"ll":"2020年9月10日","L":"2020/09/10","MM-DD":"09-10"},"updated":"2020-09-29T03:38:02.000Z","content":"\nJava 程序运行流程\n\n\n\nJVM 是 Java 平台架构的基础，Java 的跨平台特性正是通过在 JVM 中运行 Java 程序实现的。\n\n\nJava的基本语法Java的基本语法格式123[修饰符] class 类名 &#123;\t程序代码&#125;12345public class HelloWord &#123;\tpublic static void main(String[] args) &#123;\t\tSystem.out.println(\"只是第一个Java程序！\");\t&#125;&#125;Java严格区分大小写\n\n一个连续的字符串不能分开在两行中书写\n12System.out.println(\"只是第一个\t\t\tJava程序！\");\n为方便阅读可用‘+’连接两个字符串\n\n12System.out.println(\"只是第一个\"+\t\t\t\"Java程序！\");\n注释多行注释/*...*/可以嵌套//\n12/*int=10;\t//定义一个整型cint x=5;*/\n多行注释/*...*/不能嵌套/*...*/\n\n关键字数据类型：boolean、int、long、short、byte、float、double、char、class、interface。\n流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。\n修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。\n动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。\n保留字：true、false、null、goto、const。\n\n由于 Java 区分大小写，因此 public 是关键字，而 Public 则不是关键字。但是为了程序的清晰及可读性，要尽量避免使用关键字的其他形式来命名。\n\npackage：包的声明\nimport：用于引用包\nclass：类的声明\n标识符标识符由数字和字母、$、_构成\n标识符的第一个符号不能是数字，也不能是关键字\n\n定义标识符规范\n\n包名所有字母一律小写，com.itheima.example01\n\n类名和接口名每个单词的首字母都要大写 ArrayList\n\n常量名所有字母都大写，单词之间下划线 DAY_OF_MONTH\n\n变量名和方法名的第一个单词首字母小写，第二个单词开始首字母大写lineNumber\n\n变量\n整型类型变量\n类型名占用空间\n\nbyte8位（1字节）\n\nshort16位（2字节）\n\nint32位（4字节）\n\nlong64位（8字节）【 c语言32位 4字节 与int相同】\nlong 赋值的后面要加 L（l），说明赋值位 long 类型123long num=2200000000L;\t//所赋值超过int型的取值范围，后面必须加 Llong num=198L;\t\t\t//所赋值未超过int型的取值范围，后面可以加 Llong num=198;\t\t\t//所赋值未超过int型的取值范围，后面可省略 L浮点类型变量\n类型名占用空间\n\nfloat32位（4字节）\n\ndouble64位（8字节）\n一个小数会被默认为double类型的值，为一个 float 类型变量赋值时，要在后面加 F （f）12float f = 123.4f;\t//为float类型的变量赋值时，后面必须加f或Fdouble d1=199.3d;\t//为double类型的变量赋值时，后面可以加d或D（也可省略）字符类型变量char 占2字节 C语言中是1字节12char c='a';\tchar c=97;布尔类型变量12boolean flag=false;flag=true;变量的类型转化自动类型转换\n123byte b=3;int x=b;\t\t//程序把byte类型的变量b转换成int类型，无须特殊声明double y=x;\t\t//将int类型的变量x转换成double类型，无须特殊声明强制类型转换（显示类型转换）12int num=4;byte b=(byte)num;int    298    00000000 00000000 00000001 00101010\nbyte  42                                                               00101010\n表达式类型自动提升1234byte b=3;short s=4;char c=5;byte b2=（byte）（b+s+c）;\t//將byte、short、char类型数值相加，再赋值给byte类型byte、short、char在运算期间类型会自动提升为int，然后再进行运算1byte b2=b+s+c;\t//报错 因为(b+s+c)为int常量整型常量二进制：0b 0B 开头 \n八进制：0 开头\n十六进制：0x 0X 开头\n浮点型单精度浮点型： F f 结尾\n双精度浮点型：D d  结尾    \n结尾不加后缀，默认为double双精度浮点型\n12e3f\t3.6d\t5.022e+23f","plink":"https://dxsummer.gitee.io/posts/95a56e9d/"},{"title":"java环境搭建","date":"2020-09-08T13:13:33.000Z","date_formatted":{"ll":"2020年9月8日","L":"2020/09/08","MM-DD":"09-08"},"updated":"2020-09-10T13:40:00.000Z","content":"JDK安装JDK\nOracle官方下载 Java se\n\nJava SE Development Kit 8 Downloads\n开发工具：JDK核心功能模块，包含一系列Java程序必需的可执行文件，包含 专用JRE环境\n源代码：Java程序的运行环境，所有核心类库的源代码\n公共JRE：Java运行环境\n\nJVM是运行Java程序的核心虚拟机\nJDK目录介绍bin：可执行程序  javac.exe (Java编译器)\njava.exe（Java运行工具）\njar.exe (打包工具)\njavadoc.exe (文档生成工具)\n\ndb: 小型数据库\ninclude：JDK通过C、C++实现，存放头文件\nlib ( library ) :  Java类库或库文件，开发工具使用的归档包文件\njavafx-src.zip: Java FX ( java图形用户界面工具 ) 所有核心类库的源代码\nsrc.zip: src文件夹的压缩文件，JDK核心类的源代码\nREADNE： 说明文档\n\n\nJava源文件扩展名: “HelloWord.java”\n编译后执行文件 java字码文件：”HelloWord.class“\n\n系统环境变量PATH环境变量JAVA_HOME\nPATH - %JAVA_HOME%\\bin（加到path最上面）\n常用开发工具1）Notepad++Notepad++ 是 Windows 操作系统下的一套文本编辑器，有完整的中文化接口及支持多国语言编写的功能（UTF8 技术）。\nNotepad++ 优点：\n功能比 Windows 中的 Notepad（记事本）强大，除了可以用来制作一般的纯文字说明文件，也十分适合编写计算机程序代码。\n不仅有语法高亮度显示，也有语法折叠功能，并且支持宏以及扩充基本功能的外挂模组。\n是免费软件，可以免费使用，自带中文，支持所有主流的计算机程序语言。\nNotepad++ 缺点：\n比起专用的 IDE 缺少语法检查，颜色选取，代码的 outline，注释的解析，TODO，调试工具集成，部署工具集成等等好多功能。\n打开大文件比较慢\n\n2）EditPlusEditPlus 是一款由韩国 Sangil Kim （ES-Computing）出品的小巧但是功能强大的可处理文本、HTML 和程序语言的 Windows 编辑器，甚至可以通过设置用户工具将其作为 C，Java，Php 等等语言的一个简单的 IDE。\nEditPlus 优点：\nEditPlus 界面简洁美观，且启动速度快。\n对中文支持比较好。\n支持多种日期、时间输入；支持语法高亮；支持代码折叠；支持代码自动完成。\n配置功能强大，且比较容易，扩展也比较强。\n适合编辑网页。\nEditPlus 缺点：\n不支持代码提示功能。\n不免费，收费单位美元，注册费用高\n功能较简单。\n版本更新比较慢。\n\n3）UltraEditUltraEdit 是一套功能强大的文本编辑器，可以编辑文本、十六进制、ASCII 码，完全可以取代记事本，它是一款需要花费 49.95 美元的共享软件。\nUltraEdit 优点：\n提供了友好界面的编程编辑器，支持语法高亮，代码折叠和宏。\n内置了对于 HTML、PHP 和 JavaScript 等语法的支持，可同时编辑多个文件，而且即使开启很大的文件速度也不会慢。\nUltraEdit 缺点：\n启动速度较慢。\n默认的设置中不支持 Pascal 语言。\n对中文支持不是很好。\n\n4）Sublime TextSublime Text 是由程序员 Jon Skinner 于 2008 年 1 月份所开发出来，它最初被设计为一个具有丰富扩展功能的 Vim。\n它是一款收费软件，但是可以无限期试用，它是一个跨平台的编辑器，同时支持 Windows、Linux、Mac OS X 等操作系统。\nSublime Text 优点：\n主流前端开发编辑器\n体积较小，运行速度快\n文本功能强大\n支持编译功能且可在控制台看到输出\n\n5）VimVim 是从 Vi 发展出来的一个文本编辑器。代码补全、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用。是 Unix 系统用户最喜欢的文本编辑器。\nVim 优点：\n支持多种操作系统\n打开大文件速度较快，在大文件中查找的速度也非常快。\n免费，开源\n有搜索高亮功能\n支持多中编辑语言\n功能强大\nVim 缺点：\n比较难学\n虽然有菜单，但 Windows 用户第一次上手会很难\n界面不太好看\n键盘命令多，必须长期使用才能熟练。\n\n","plink":"https://dxsummer.gitee.io/posts/560c49b8/"},{"title":"中专教师资格证考试","date":"2020-08-17T12:54:39.000Z","date_formatted":{"ll":"2020年8月17日","L":"2020/08/17","MM-DD":"08-17"},"updated":"2020-08-17T13:08:58.000Z","content":"中职专业课教师资格证考试经历转自知乎：蕴锦流觞\n先上图吧，拿到了教师证偷偷激动了好久（表面很淡定）。\n\n其实在考教资之前犹豫了很久，一是因为自己非师范出身，二是觉得自己怎么也达不到做一个光荣的人民教师标准，三是受高中时某位老师影响，觉得老师真的很辛苦。所以，一直很排斥去考教师证。然后去年突然不知道怎么想通了，教师证只是一个证件，当老师还是要经过很多磨炼的，就开始投入到了教资考试中。\n一、教资笔试\n关于笔试，知乎上已经有很多大神级别的分享帖了，我也是浏览了许多，集各家所长以后开始备考，详细的过程就不细说了，大家可以去搜索其他高分回答，就我自己备考经验进行简单总结如下：\n1、教材及真题：中公教师资格证教材真题套装。\n2、笔记：买了知乎上一位叫大七的妹子的笔记，不过貌似她现在专注学业，不再整理了。\n3、关注的公众号：一起考教师、教师资格证作文。\n4、刷题的APP：一起考教师（里面的模考大赛强烈推荐参加）。\n5、网课：看了有道精品课里面一些免费的公开课。\n6、心得：a、一定要做真题，一定要做真题，一定要做真题。重要的事情放前面说，真题可以发现一些出题套路，简答啊，材料分析啊，考的知识点比较固定。不刷题真的不容易过。\nb、该背的东西一定要背，千万别心存侥幸。是有很多人欧气，但是未必是你。随着近几年考教资的人越来越多，裸考能过的几率已经逐渐消失。\nc、多总结，虽然上面推荐的公众号会经常发一些总结好的资料。但是自己一定也要学会总结，这就是学而不思则罔吧。\n二、教资面试\n这可能是我写这篇文章的初衷吧，我为小众学科叫屈。当我决定要报考中职的面试，我发现一件很尴尬的事：市面上几乎没有中职的面试课程。也就是完全要靠自己准备和摸索了。所以，我很积极地去做各种准备，我是江苏的，以我们省为例子，大致经历如下：\n1、找到考试形式：\n很多人都知道中职类的面试是只要通过中学两门公共科目笔试，对于面试到底考什么却不清楚。最好在省教育考试网上找找有没有公告。通过公告可以了解面试评分标准，面试内容和形式。江苏的中职专业课教资面试大致是三部分：专业概述、讲课、答辩。\n\n2、面试准备：\nA、选定自己要报考的科目\n中职专业课的科目是相当多，根据公告最下面附件里的目录进行选择。\n\n目录里面也有指定教材，当然如果买不到指定教材，也可以买其他版本的。但是必须买一本，因为面试时，要自己带教材去考试，不带教材是不让考试的。\nB、专业概述\n三部分中讲课和答辩其实和其他科目差不多，那么这个专业概述到底是什么呢？我们到底该怎么准备呢？我其实很焦虑，在网上搜索了许久也没搜到，幸好碰到一位已经通过前辈的帮助，感动非常，这年头还是好人多呀。我就自己准备专业概述来说几点：\n(1)、一定要像演讲一样准备稿子，专业概述在代替其他科目的结构化问答占分还是很大，可以提前准备抓住这部分的分值。\n(2)、稿子演讲的时间准备差不多为4分钟，太长了容易超时，太短了考官会问很多问题。一定要自己反复练习，尽量不要卡壳，最好脱稿。\n(3)、专业概述怎么写？可以从你选的专业几个方面来写：1、专业的发展现状2、专业的培养目标3、专业的主要课程4、专业的就业前景。字数大概普通笔记本两页就可以了。这些内容完全可以从招生简介和一些文章上提取加上自己润色。例如：加入一些真实数据，以我为例，网民人数上升百分比；加入一些案例，电子商务发展迅速，亚马逊、天猫等。\n(4)、考官提问：一般来说当你说完专业概述，考官也就最多问一个或两个问题，通常十分简单，所以不要紧张，从容应对，不要胡编，真诚回答就行。\nC、课程试讲\n(1)、要熟悉自己的教材，可以在书里画出重难点。因为自带教材，其实有效缩小了范围，只在一本书上，而且可以带进考场，那么在书上写写画画做小抄是允许的，但是不能夹带纸质材料进去。\n(2)、有可能的话，买一本对应教案。有的书本后面，会有增值服务，赠送电子版教案，对于一些没有经验的考生来说就是捷径。参考上面的教师提问和重难点划分。\n(3)、多练习试讲。这点我自己没做好，导致上场以后这部分发挥不好。这部分好心妹纸推荐我看了老师们微课，大家也可以多观摩学习。\n\n(4)、答辩\n江苏中职专业课答辩一般带有一定运气成分，什么意思呢？我的那组考官问了我跟专业相关的问题：网购和传统商务的优缺点？网购存在各种问题，为什么大家依旧选择网购？如果碰到这种问题，一定要冷静下来理清思路，然后分层次回答，切忌慌乱囫囵吞枣。思路可以是分别简述他们的优缺点，可以加上自己的观点，如我回答的完第一个问题后说我认为这两种形式是不会被互相替代掉的，阐述一下自己想法。中职专业课面试的老师是大学的老师，对于专业是精通的能看出来你认真准备与否。如果抽到常规题，那么就按照一般答辩思路去回答就好。\n3、面试流程\nA、报名\n和笔试一样的过程，看清楚该选择的考点和是否需要现场审核。目前江苏所有报考中职专业课及中职实习指导教师的考生（含师范生）选择江苏理工学院考区。是网上审核。一定要看清公告上要求！\nB、流程\n（1）按准考证规定的时间，提前30分钟到达考点。一天貌似只有两个时间段，上午和下午。我是下午场的，要求12：15到达，提醒下午场的考生一定要吃午饭。\n（2）到点后，考场外会贴出分配的表格。上面找到你的姓名、准考证、科目、候考室和考场号。然后排队进入候考室。\n\n\n（3）进入候考室会进行面试顺序抽签。一个考场是9个人，如果不小心抽到9，那么要等到最后，所以大家一定要吃午饭，会饿死。候考室会有人发装手机的信封、试讲章节抽签单、领取物品单，按要求填写然后将手机装入上交。\n（4）候考。手机关机上交后就是漫长的候考，你可以翻书复习，看教案，喝水，但是尽量不要大声说话，过程挺难熬。时间差不多会有人让你带上教材、笔、证件、准考证、两张单子排队。出了候考室在备考室外面进行试讲章节抽签，如果课本上没有章节就重新抽。（这里有个技巧，抽到很难讲的操作课可以跟抽签人主动要求重新抽取，一般不会拒绝）\n（5）备课。抽签完，进入备课室，有20分钟备课。其中写教案要尽量压缩在十分钟，还有十分钟进行梳理和简单串联。写教案这个就不细说了，要写简案就行。最好提前把板书设计好。\n\n（6）面试。进入考场后，记得要先将准考证和那个写着抽题的单子交给学生助理，然后上台后要对考官进行问好。考官会按流程引导你，尽量让自己不要紧张，放轻松。试讲的时候要写板书，字丑的同学有机会要练练黑板字。等整个面试结束后，要把教案交给学生助理，拿回自己的准考证。\n（7）离场。回到候考室，将物品领取单交给工作人员，自己不可以再进候考室。所以在前面离开候考室之前，把自己物品整理好，尽量放进一个包里。\n三、教资认定\n1、网上申请\n当成绩合格后，就要关注当地教师证认定时间了。一般在教育局的网站上会有相关通知，在规定的时间内进行认定申请。申请认定时如果没有符合的普通话证成绩也无法认定。所以没有的同学要考一个普通话证。\n2、现场审核\n网上申请之后，会要求带相关材料进行现场审核，具体时间、地点和材料清单关注当地教育局网站。\n3、体检\n同样，在审核成功后，教育局会通知你去指定医院参加体检。一般要求带身份证和照片，自己缴纳体检费用，医保卡有的时候可刷。（具体流程根据各地教育局要求）\n4、领证\n在体检无误后，就是等待领证了，这个时间有长有短，江苏一般是体检后一个月多一点。时刻关注教育局网站上通知。一般是去现场审核地方凭身份证领取，应届生同时需要带毕业证书。领取时还会发一张认定申请表，记得交到档案存放的地方，放进档案里。\n最后，一些重要网站给大家列举下来：\n1、教师资格证考试报名网站：NTCE - 中国教育考试网\n2、教师资格证认定网站：中国教师资格网\n3、中国语言文字网（普通话考试信息）：中国语言文字网\n4、当地的教育局网站（自行查找，不列举）\n祝大家都能早日通过考试！\n","plink":"https://dxsummer.gitee.io/posts/81a6fc20/"},{"title":"程序员注释","date":"2020-07-30T09:14:41.000Z","date_formatted":{"ll":"2020年7月30日","L":"2020/07/30","MM-DD":"07-30"},"updated":"2020-09-08T09:00:54.000Z","content":"1234567891011121314151617181920*                   ___&#x3D;&#x3D;&#x3D;&#x3D;-_  _-&#x3D;&#x3D;&#x3D;&#x3D;___*             _--^^^#####&#x2F;&#x2F;      \\\\#####^^^--_*          _-^##########&#x2F;&#x2F; (    ) \\\\##########^-_*         -############&#x2F;&#x2F;  |\\^^&#x2F;|  \\\\############-*       _&#x2F;############&#x2F;&#x2F;   (@::@)   \\############\\_*      &#x2F;#############((     \\\\&#x2F;&#x2F;     ))#############\\*     -###############\\\\    (oo)    &#x2F;&#x2F;###############-*    -#################\\\\  &#x2F; VV \\  &#x2F;&#x2F;#################-*   -###################\\\\&#x2F;      \\&#x2F;&#x2F;###################-*  _#&#x2F;|##########&#x2F;\\######(   &#x2F;\\   )######&#x2F;\\##########|\\#_*  |&#x2F; |#&#x2F;\\#&#x2F;\\#&#x2F;\\&#x2F;  \\#&#x2F;\\##\\  |  |  &#x2F;##&#x2F;\\#&#x2F;  \\&#x2F;\\#&#x2F;\\#&#x2F;\\#| \\|*  &#96;  |&#x2F;  V  V  &#96;   V  \\#\\| |  | |&#x2F;#&#x2F;  V   &#39;  V  V  \\|  &#39;*     &#96;   &#96;  &#96;      &#96;   &#x2F; | |  | | \\   &#39;      &#39;  &#39;   &#39;*                      (  | |  | |  )*                     __\\ | |  | | &#x2F;__*                    (vvv(VVV)(VVV)vvv)* *      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~* *                神兽保佑            永无BUG123456789101112131415161718192021*                                                     __----~~~~~~~~~~~------___*                                    .  .   ~~&#x2F;&#x2F;&#x3D;&#x3D;&#x3D;&#x3D;......          __--~ ~~*                    -.            \\_|&#x2F;&#x2F;     |||\\\\  ~~~~~~::::... &#x2F;~*                 ___-&#x3D;&#x3D;_       _-~o~  \\&#x2F;    |||  \\\\            _&#x2F;~~-*         __---~~~.&#x3D;&#x3D;~||\\&#x3D;_    -_--~&#x2F;_-~|-   |\\\\   \\\\        _&#x2F;~*     _-~~     .&#x3D;~    |  \\\\-_    &#39;-~7  &#x2F;-   &#x2F;  ||    \\      &#x2F;*   .~       .~       |   \\\\ -_    &#x2F;  &#x2F;-   &#x2F;   ||      \\   &#x2F;*  &#x2F;  ____  &#x2F;         |     \\\\ ~-_&#x2F;  &#x2F;|- _&#x2F;   .||       \\ &#x2F;*  |~~    ~~|--~~~~--_ \\     ~&#x3D;&#x3D;-&#x2F;   | \\~--&#x3D;&#x3D;&#x3D;~~        .\\*           &#39;         ~-|      &#x2F;|    |-~\\~~       __--~~*                       |-~~-_&#x2F; |    |   ~\\_   _-~            &#x2F;\\*                            &#x2F;  \\     \\__   \\&#x2F;~                \\__*                        _--~ _&#x2F; | .-~~____--~-&#x2F;                  ~~&#x3D;&#x3D;.*                       ((-&gt;&#x2F;~   &#39;.|||&#39; -_|    ~~-&#x2F; ,              . _||*                                  -_     ~\\      ~~---l__i__i__i--~~_&#x2F;*                                  _-~-__   ~)  \\--______________--~~*                                &#x2F;&#x2F;.-~~~-~_--~- |-------~~~~~~~~*                                       &#x2F;&#x2F;.-~~~--\\*                       ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~* *                               神兽保佑            永无BUG123456789*                   江城子 . 程序员之歌* *               十年生死两茫茫，写程序，到天亮。*                   千行代码，Bug何处藏。*               纵使上线又怎样，朝令改，夕断肠。* *               领导每天新想法，天天改，日日忙。*                   相顾无言，惟有泪千行。*               每晚灯火阑珊处，夜难寐，加班狂。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647* ......................................&amp;&amp;.........................* ....................................&amp;&amp;&amp;..........................* .................................&amp;&amp;&amp;&amp;............................* ...............................&amp;&amp;&amp;&amp;..............................* .............................&amp;&amp;&amp;&amp;&amp;&amp;..............................* ...........................&amp;&amp;&amp;&amp;&amp;&amp;....&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;........* ..................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..............* ................&amp;...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.................* .......................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........* ...................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...............* ..................&amp;&amp;&amp;   &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............* ...............&amp;&amp;&amp;&amp;&amp;@  &amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........* ..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;&amp;....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;.........* ..........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;........* ........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;....&amp;&amp;&amp;.......* .......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....&amp;&amp;......* ........&amp;&amp;&amp;&amp;&amp;.....................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.............* ..........&amp;...................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............* ................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............* ..................&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;............* ..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;....&amp;&amp;&amp;&amp;&amp;............* ...........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;......&amp;&amp;&amp;&amp;............* .........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;............* .......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........&amp;&amp;&amp;&amp;............* ......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;&amp;&amp;...............&amp;&amp;&amp;.............* .....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............................&amp;&amp;..............* ....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.................&amp;&amp;...........................* ...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....................&amp;&amp;&amp;&amp;......................* ...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.&amp;&amp;&amp;........................&amp;&amp;&amp;&amp;&amp;...................* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;..........................&amp;&amp;&amp;&amp;&amp;&amp;&amp;...............* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;............&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;&amp;&amp;&amp;.............* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.................&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........* ..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........* ..&amp;&amp;.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.......* ...&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;......* ....&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....* .......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..............&amp;&amp;&amp;&amp;&amp;&amp;&amp;....* .......&amp;&amp;&amp;&amp;&amp;.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;..&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...&amp;..........&amp;&amp;&amp;&amp;&amp;&amp;....* ........&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;...........&amp;..&amp;&amp;&amp;&amp;...* .......&amp;&amp;&amp;........&amp;&amp;&amp;.&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;.....&amp;&amp;&amp;&amp;&amp;.................&amp;&amp;&amp;&amp;...* .......&amp;&amp;&amp;...............&amp;&amp;&amp;&amp;&amp;&amp;&amp;.......&amp;&amp;&amp;&amp;&amp;&amp;&amp;&amp;............&amp;&amp;&amp;...* ........&amp;&amp;...................&amp;&amp;&amp;&amp;&amp;&amp;.........................&amp;&amp;&amp;..* .........&amp;.....................&amp;&amp;&amp;&amp;........................&amp;&amp;....* ...............................&amp;&amp;&amp;.......................&amp;&amp;......* ................................&amp;&amp;......................&amp;&amp;.......* .................................&amp;&amp;..............................* ..................................&amp;..............................1212345678910111213141516171819202122232425262728293031&#x2F;&#x2F;                            _ooOoo_&#x2F;&#x2F;                           o8888888o&#x2F;&#x2F;                           88&quot; . &quot;88&#x2F;&#x2F;                           (| -_- |)&#x2F;&#x2F;                            O\\ &#x3D; &#x2F;O&#x2F;&#x2F;                        ____&#x2F;&#96;---&#39;\\____&#x2F;&#x2F;                      .   &#39; \\\\| |&#x2F;&#x2F; &#96;.&#x2F;&#x2F;                       &#x2F; \\\\||| : |||&#x2F;&#x2F; \\&#x2F;&#x2F;                     &#x2F; _||||| -:- |||||- \\&#x2F;&#x2F;                       | | \\\\\\ - &#x2F;&#x2F;&#x2F; | |&#x2F;&#x2F;                     | \\_| &#39;&#39;\\---&#x2F;&#39;&#39; | |&#x2F;&#x2F;                      \\ .-\\__ &#96;-&#96; ___&#x2F;-. &#x2F;&#x2F;&#x2F;                   ___&#96;. .&#39; &#x2F;--.--\\ &#96;. . __&#x2F;&#x2F;                .&quot;&quot; &#39;&lt; &#96;.___\\_&lt;|&gt;_&#x2F;___.&#39; &gt;&#39;&quot;&quot;.&#x2F;&#x2F;               | | : &#96;- \\&#96;.;&#96;\\ _ &#x2F;&#96;;.&#96;&#x2F; - &#96; : | |&#x2F;&#x2F;                 \\ \\ &#96;-. \\_ __\\ &#x2F;__ _&#x2F; .-&#96; &#x2F; &#x2F;&#x2F;&#x2F;         &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#96;-.____&#96;-.___\\_____&#x2F;___.-&#96;____.-&#39;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x2F;&#x2F;                            &#96;&#x3D;---&#x3D;&#39;&#x2F;&#x2F;&#x2F;&#x2F;         .............................................&#x2F;&#x2F;            佛祖镇楼        永不宕机          BUG辟易&#x2F;&#x2F;          佛曰:&#x2F;&#x2F;                  写字楼里写字间，写字间里程序员；&#x2F;&#x2F;                  程序人员写程序，又拿程序换酒钱。&#x2F;&#x2F;                  酒醒只在网上坐，酒醉还来网下眠；&#x2F;&#x2F;                  酒醉酒醒日复日，网上网下年复年。&#x2F;&#x2F;                  但愿老死电脑间，不愿鞠躬老板前；&#x2F;&#x2F;                  奔驰宝马贵者趣，公交自行程序员。&#x2F;&#x2F;                  别人笑我忒疯癫，我笑自己命太贱；&#x2F;&#x2F;                  不见满街漂亮妹，哪个归得程序员？---------------------123456789101112131415161718192021*　　　　　　　　┏┓　　　┏┓+ +*　　　　　　　┏┛┻━━━┛┻┓ + +*　　　　　　　┃　　　　　　　┃ 　*　　　　　　　┃　　　━　　　┃ ++ + + +*　　　　         ██ ━██  ┃+*　　　　　　　┃　　　　　　　┃ +*　　　　　　　┃　　　┻　　　┃*　　　　　　　┃　　　　　　　┃ + +*　　　　　　　┗━┓　　　┏━┛*　　　　　　　　　┃　　　┃　　　　　　　　　　　*　　　　　　　　　┃　　　┃ + + + +*　　　　　　　　　┃　　　┃　　　　Code is far away from bug with the animal protecting　　　　　　　*　　　　　　　　　┃　　　┃ + 　　　　神兽保佑,代码无bug　　*　　　　　　　　　┃　　　┃*　　　　　　　　　┃　　　┃　　+　　　　　　　　　*　　　　　　　　　┃　 　　┗━━━┓ + +*　　　　　　　　　┃ 　　　　　　　┣┓*　　　　　　　　　┃ 　　　　　　　┏┛*　　　　　　　　　┗┓┓┏━┳┓┏┛ + + + +*　　　　　　　　　　┃┫┫　┃┫┫*　　　　　　　　　　┗┻┛　┗┻┛+ + + +1234567891011121314151617181920212223242526272829303132333435363738394041424344 * ━━━━━━神兽出没━━━━━━ * 　　　┏┓　　　┏┓ * 　　┏┛┻━━━┛┻┓ * 　　┃　　　　　　　┃ * 　　┃　　　━　　　┃ * 　　┃　┳┛　┗┳　┃ * 　　┃　　　　　　　┃ * 　　┃　　　┻　　　┃ * 　　┃　　　　　　　┃ * 　　┗━┓　　　┏━┛Code is far away from bug with the animal protecting * 　　　　┃　　　┃    神兽保佑,代码无bug * 　　　　┃　　　┃ * 　　　　┃　　　┗━━━┓ * 　　　　┃　　　　　　　┣┓ * 　　　　┃　　　　　　　┏┛ * 　　　　┗┓┓┏━┳┓┏┛ * 　　　　　┃┫┫　┃┫┫ * 　　　　　┗┻┛　┗┻┛ * * ━━━━━━感觉萌萌哒━━━━━━ *&#x2F;&#x2F;** * 　　　　　　　　┏┓　　　┏┓ * 　　　　　　　┏┛┻━━━┛┻┓ * 　　　　　　　┃　　　　　　　┃ 　 * 　　　　　　　┃　　　━　　　┃ * 　　　　　　　┃　＞　　　＜　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┃...　⌒　...　┃ * 　　　　　　　┃　　　　　　　┃ * 　　　　　　　┗━┓　　　┏━┛ * 　　　　　　　　　┃　　　┃　Code is far away from bug with the animal protecting　　　　　　　　　　 * 　　　　　　　　　┃　　　┃   神兽保佑,代码无bug * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┃  　　　　　　 * 　　　　　　　　　┃　　　┃ * 　　　　　　　　　┃　　　┃　　　　　　　　　　　 * 　　　　　　　　　┃　　　┗━━━┓ * 　　　　　　　　　┃　　　　　　　┣┓ * 　　　　　　　　　┃　　　　　　　┏┛ * 　　　　　　　　　┗┓┓┏━┳┓┏┛ * 　　　　　　　　　　┃┫┫　┃┫┫ * 　　　　　　　　　　┗┻┛　┗┻┛","plink":"https://dxsummer.gitee.io/posts/8f0fd6d2/"},{"title":"三级网络技术考过指南","date":"2020-07-30T02:31:31.000Z","date_formatted":{"ll":"2020年7月30日","L":"2020/07/30","MM-DD":"07-30"},"updated":"2021-01-11T04:59:08.000Z","content":"前言（必读）\n文章转载\n\n本文档总大小 5MB 左右，请注意流量若手机端浏览不便，请尝试使用电脑浏览器\n这份指南写于我备考三级一周后，因为做了几套题之后感觉这个考试的知识点和题型很固定，而将这些知识点和做法概括总结出来可以帮助以后考试的同学。\n对于没有相应基础的绝大多数同学，如果想考过三级网络技术，首先要克服见到陌生复杂题目的恐惧感。话说回来，其实这些题没有哪一道是真正需要动脑进行复杂思考的，只是知识点没见过，做题的方法不清楚，一旦知道了就能写对。这个考试没有什么含金量，一周的练习基本上足够了。\n我们专业去年上了计算机网络这门课，但跟这个考试的关系不大，只有少量的考点学过。所以我对题目的解析是很业余的，但这也是个好处，正是因为不专业写的就比较直白，适合没有基础的同学参考。\n后增：为什么考三级？既然二级都过了，再考个三级呗，有的学校可能还有实践学分。别人二级office的很多，你三级看上去就显得厉害一点。\n【重要更新】自2018年3月份全国计算机等级考试（第51次）起，取消了三级获证的前置条件。直接报名考三级就可以了，不再需要对应的二级科目通过。\n为什么三级选网络技术这科？\n因为我考的时候，查了查发现考这个的最多，考的人越多的科目考试题就可能越标准规范，我对其他的科目也没有特别有兴趣的，所以就考这个了。所以我也只能写网络技术，所以你们选网络技术备考也就最方便。\n要不要考四级？从用我的角度来讲，这个考试本来就没什么含金量，我没有考。还想考计算机方面的证，可以去考软考 [ 计算机技术与软件专业技术资格（水平）考试 ] 。如果考研想考计算机，可以去了解CCF CSP考试，对一些学校复试上机可能有用。听说计算机等级考试四级比三级还简单，也是买题做题就行了。\n\n1.基础准备1.1 题库买一本三级网络技术题库或者是题库软件（20 元左右），不需要买更多，总之有成套的题可以做就行。真题目前大概有二十套左右。\n1.2 二进制转换应该学过\n网络技术用到的一般是八位二进制数。也就是 0 ~ 255，即 0000 0000 ~ 1111 1111（每四位空一格便于观察）\n我做题前在草稿纸上先这样画\n这样，比如说我看见 1001 1000 这个数，就知道这是 128+16+8 对应的数。\n反过来，十进制转换二进制也可以利用这个简图。还有一些规律，自己做题中摸索吧，你可能会找到更好的方法。\n下面几组记忆一下，做题时会比较方便（不要畏难，做题见多了就记住了）\n\n二进制十进制\n\n1000 0000128\n\n1100 0000192\n\n1110 0000224\n\n1111 0000240\n\n1111 1111255\n1.3 基础概念如果是学过计算机网络相关知识的同学可以不看，下面是非专业的不标准的可能还有错的描述，仅仅是为了完全没有基础的同学有个粗略了解。\n计算机网络是一些电脑相互链接组成的，这些电脑叫做主机，可能相距很远，也可能是一间屋子里的。\n就像正常情况下两个人要用同一种语言交流一样。主机之间的联系也要按照相同的标准才行，这些标准叫做协议。因为主机之间的联系是一件复杂的事。所以有多种协议解决不同方面的问题，比如 TCP、BGP、DHCP 等等。\n相距太远的主机之间不能直接联系，就需要一些设备，比如路由器、交换机等等，你只知道他们都是为了主机联系的中间转发设备就行。\n还需要地址，因为没有地址就不知道主机在哪，这个标识主机的就是 IP 地址。IP 地址是类似这样的：10000000.1110000.01000000.10110001，一共 32 位，为了人看起来方便就写成 128.224.64.177 这种点分十进制的形式。\n还有一种叫做 MAC 地址，是标识硬件设备的地址。\n主机还可以广播给整个网络，广播地址是 IP地址 32 位全置 1 的地址，即 255.255.255.255。\n当你访问一个网站，你的电脑先将网址发送给 DNS 服务器（域名解析服务器），这个服务器能将你写的网址域名变成 IP 地址，这样你的电脑就知道想要访问的网页放在哪了。\n上面这些并不能让你真正理解计算机网络（其实我也不是很清楚），主要是让你在见到陌生名词的时候别害怕，有些名词不理解也不会影响做题。\n1.4 备考建议这就是个人的方法了，也不一定适合你。\n【1】首先对着一套三级题和答案看一遍，每道题都看答案解析是怎么说的。看答案不必弄懂（当然你要真的全弄懂也很厉害），知道怎么选出来就行，不明白跳过也行。同时也找找看看我笔记里写没写这道题的知识点。\n这一遍是比较简略的，对题目有个简单的印象就够了。但这遍也是比较困难的，因为几乎都是陌生的东西。\n【2】接下来，同时做两三套试题甚至更多套。按着笔记里的知识点做，看到哪个知识点就到这些套题里找，对照着做题来掌握这个知识点。如果笔记里没有提到或者没写详细的就看答案怎么说，实在不明白的还可以跳过。\n这个阶段是需要比较认真的看了，我这个阶段是在写笔记中度过的。经过这个阶段你就能明白哪些知识点考察比较固定，一些题的固定做法是什么，对考试有比较完全的认识了。\n【3】接下来，就把剩下的套题都做了，反正一共就二十套左右。怎么做都行，按套或者按题型什么的自己安排，反正做一遍。如果没时间了，至少把选择题做一遍。\n这一遍就是完善熟练的阶段，还可能有一些我笔记里没写的知识点你也会了。\n【补充】有的同学还是感觉难，那就先把第一道大题和最后一道大题的两个填表都仔细弄会了。这两个表就 20 分到手了。接下来学习可能会感觉踏实一点。\n\n2.选择题（40 道 40 分）根据做题方法不同划为三类\n第一类：几乎每套题都考，掌握简单做法即可选出正确答案\n第二类：每套题里有 5 道左右，看上去非常复杂的大段配置代码\n第三类：从四个选项里选出一项正确或错误的，其中部分知识点是常考的，比较零散\n2.1 第一类选择题2.1.1 问传输速度OC-3 对应 155.52 MbpsOC-12 对应 622.08 Mbps\n（显然，这是一道送分题）\n2.1.2 求交换机带宽通常是求总带宽例：某交换机有 12 个 10/100 Mbps 电端口和 2 个 1000 Mbps 光端口，所有端口都在全双工状态下，那么总带宽为（ ）解：忽略 10/100 中的 10，当成 100 Mbps 就好。12 * 100 + 2 * 1000 = 3200，又因为全双工所以乘以 2 得 6400 Mbps ,即 6.4 Gbps\n有时候求上联端口带宽例：某交换机有 16个100/1000 Mbps 全双工下联端口，那么上联端口带宽至少为（ ）解：16 * 1000 * 2 = 32000 Mbps = 32 Gbps，上联一般是下联的 1/20 ，所以至少为 32 除以 20 得 1.6 Gbps\n2.1.3 系统可用性与停机时间\n可用性停机时间\n\n99.9%≤8.8小时\n\n99.99%≤53分钟\n\n99.999%≤5分钟\n也是送分题，但要记准确。比如 53 分钟，有时候会问 55 分钟的情况，要是记成 50 或者大约 1 小时就没法做了。\n2.1.4 写地址块的子网掩码例：IP 地址块 59.67.159.125/11 的子网掩码可写为（ ）解：不用看 IP 地址，只看 /11 就够了。11 代表子网掩码的前 11 位都是 1 ，所以可以写出子网掩码 11111111.11100000.00000000.00000000 转换为十进制即是 255.224.0.0做题熟练后其实不用写上面那堆 1 和 0 就能选出正确答案。\n2.1.5 网络地址转换 NAT会给你一个这样的图，问你 ① ② 是什么只需要知道②和紧挨着它的 S 数字相同，所以②应该是 202.0.1.1,5001 ;同理，①是 10.0.0.1,3342。还有时候会问某个小方框里的 S,D 分别是什么，看上面的图你会发现，上面两个方框和下面两个方框里的数字是对称的，做题时对称一下就写出答案了。\n2.1.6 IP 地址块聚合第一种：问聚合后的地址块\n下面演示三个地址的聚合步骤为：转成二进制；对齐找前多少位是相同的；转回十进制写答案。这样就得出聚合后的地址为：192.67.159.192/26Tips：转换二进制时，因为前三段十进制本来就一样，所以可以只转换最后一段；不要一个一个数有多少位相同的，因为前三段相同就知道有 3 * 8 = 24 位，再加上 2 就是 26。\n第二种：问聚合后可用 IP 数\n下面两种情况的做法由网友 Yes 补充，十分感谢，之前我写的不当方法已删除。\n【第一种情况】如未来教育上机考试第一套试题第10题：\n“ IP 地址块 202.113.79.128/27、202.113.79.160/27 和 202.113.79.192/27 经过聚合后可用的地址数为___”\n因为格式都是 xxx.xxx.xxx.xxx/27，本题中“/”后边的数字都是相同的。\n所以遇到这种题，先把前两个 IP 聚合求出可用地址数，然后单独算出第三个 IP 地址可用地址数，两个地址数相加即正确答案。\n【第二种情况】如未来教育上机考试第三套试题第10题：\n“ IP 地址块 202.113.79.0/27、202.113.79.32/27、202.113.79.64/26 经过聚合后可用的地址数为___”\n本题中“/”后边的数字前两个是相同的，第三个与前两个不同。\n所以遇到这种题，直接将三个 IP 聚合得到地址块，然后求出三个 IP 的可用地址数。\n2.1.7 路由表距离更新例：R1,R2 是一个系统中采用RIP路由协议的两个相邻路由器，R1 的路由表如（a）所示，R1 收到 R2 发送的报文（b）后，R1 更新后的距离值从上到下依次是（ ）解：做法如下步骤为：b距离+1；与a距离比较；更新为距离最小的。则更新后的距离值从上到下依次是 0、4、4、3、2\n还经常这样考——给出更新后距离值和（a）中的距离，求（b）报文距离的可能值。规则不变，上面的做法反过去求就行。\n2.1.8 IPv6 地址简化表示例：某地址 FF23:0:0:0:0510:0:0:9C5B，可以简化为 FF23::0510:0:0:9C5B，双冒号替代连续出现的 0 位段，不能简化为 FF23::0510::9C5B，因为双冒号只能使用一次，可以简化为 FF23::510:0:0:9C5B，因为 0510 就是 510 ，不能简化为 FF23::051:0:0:9C5B，因为 0510 不是 51。\n例：下列 IPv6 地址表示中错误的是（ ）A) ::10F:BC:0:0:03DAB) FE::0:45:03/48C) FE31:0:BC:3E:0:050D:BC::03DAD) FF34:42:BC::3E:50F:21:03D解：IPv6 地址是 128 位划分为 8 段的地址，而 C 项不算双冒号那段已经有了 8 段，双冒号又至少压缩一个 0 位段，所以超了 8 段，是错误的。B 中的 /48 做题时可以忽略，写不写没关系。做这种题先看有没有包含两个** :: **的选项，再看最长的那项有没有超过 8 段。\n2.1.9 数据包例：下图是 A 发送的数据包通过路由器转发到 B 的过程示意图，求数据包 3 中的目的IP地址和目的MAC地址解：无论哪个数据包，目的 IP 地址就是 B 的 IP 地址，所以数据包 3 的目的 IP 为 129.42.56.216；而目的 MAC 地址就是下一个路由器的 MAC 地址，数据包 3 的下一个路由器是 R3，所以数据包 3 的目的 MAC 地址是 00d0.63c3.3c41。\n2.1.10 三种备份备份速度从快到慢：增量备份、差异备份、完全备份（备份越详细越慢）恢复速度从快到慢：完全备份、差异备份、增量备份（和上面顺序相反，也好理解，备份时详细的恢复快）空间占用从多到少：完全备份、差异备份、增量备份（备份越详细占用空间越多）题目通常问你其中某一种的顺序。\n【补充】恢复备份时使用的备份数的顺序，使用备份数最多的是增量备份，最少的是完全备份。\n2.2 第二类选择题这部分将进一步体现本指南的优越性\n我们先来看一道“第二类选择题”的四个选项，不需要看题。\n-从这开始-到这结束看起来异常复杂，但这是在我完全不懂知识点的情况下就能选对的题。下面要讲的是技巧方法，不是知识点，适用于这类题首先，你需要来回观察这四个选项，找出他们的不同点。可能是两句颠倒的代码，可能是一个单词一个数，也可能是其他的。这是我把他们不同的地方做了荧光标记首先一眼看上去，C 项的大段数字位置和其他三项不一样，所以排除 C；然后，看蓝色的数字，只有 A 项和其他三项不一样，所以排除 A；最后，看绿色的地方，只有 B 项少了一句，所以排除 B；选 D。\n悟性比较高的同学肯定已经明白了，为了大家更好的体会，再换一道题演示：不先写选项了，直接展示标记后的方法一样，找出不同点，然后“少数服从多数”，最后选 C。\n下面一道题自己练习一下答案是C。\n说出来你可能不信，这种方法可以解决80%以上的“第二类选择题”，有的题可能没办法排除掉三个选项，这时候就要结合一下题目内容推断来做或者蒙。\n2.3 第三类选择题下面列举的是高频考点，需要记忆，但不要死记。一开始可能感觉很陌生很难，做题碰见得多了就熟悉了能迅速选出答案。\n2.3.1 弹性分组环 RPR每一个节点都执行SRP公平算法\n与 FDDI 一样使用双环结构\n传统的 FDDI 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由源结点从环中回收\n而 RPR 环，当源结点向目的节点成功发送一个数据帧之后，这个数据帧由目的结点从环中回收\nRPR 采用自愈环设计思路，能在 50ms 时间内隔离故障结点和光纤段\n两个 RPR 结点间的裸光纤最大长度可达 100公里\nRPR 的外环（顺时针）和内环（逆时针）都可以用于传输分组和控制分组\n2.3.2 无线接入技术主要有 WLAN、WiMAX、WiFi、WMAN 和 Ad hoc ( WiFi 肯定知道，记住无线技术一般是W开头的，但有个特殊的A开头)\nAPON 不是无线传输技术，这个经常是迷惑项\n2.3.3 城域网 QoS题库有一道题中说 QoS是广域网的缩写 可能是写错了考的时候通常只写英文缩写，下面写上中文名是为了方便你记忆（其他的地方也应该养成粗略推测英文缩写的习惯）\n主要的技术有 资源预留（RSVP）、区分服务（DiffServ）、多协议标记交换（MPLS）\n2.3.4 接入技术特征ADSL 使用一对铜双绞线，具有非对称技术特性，上行速率 64 kbps640 kbps，下行速率 500 kbps7 Mbps\n采用 ADSL 技术可以通过 PSTN 接入 Internet\nCable Modom（电缆调制解调器）利用频分复用的方法将信道分为上行信道和下行信道，把用户计算机与有线电视同轴电缆连接起来\n光纤传输距离可达 100km 以上（这个知道光纤很远就行了）\n2.3.5 服务器技术热插拔功能允许用户在不切断电源的情况下更换硬盘、板卡等（不能更换主板卡）\n集群技术中，如果一台主机出现故障，不会影响正常服务，但会影响系统性能\n磁盘性能表现在储存容量和 I/O 速度（I/O=input/output 即输入/输出，学过计算机应该知道）\n服务器总体性能取决于 CPU 数量、CPU 主频、系统内存、网络速度\n2.3.6 综合布线双绞线可以避免电磁干扰\n嵌入式插座用来连接双绞线\n多介质插座用来连接铜缆和光纤，满足用户“光纤到桌面”的需求\n建筑群子系统可以是多种布线方式的任意组合，地下管道布线是最理想的方式\nSTP 比 UTP 贵、复杂、抗干扰能力强、辐射小\n水平布线子系统电缆长度在 90 m 以内\n干线线缆铺设经常采用点对点结合和分支结合两种方式\n2.3.7 BGP 协议BGP 是边界网关协议，而不是内部网关协议（所以遇到问某两个自治系统之间使用什么协议，就选 BGP）\nBGP 交换路由信息的节点数不小于自治系统数\n一个 BGP 发言人使用 TCP（不是UDP）与其他自治系统的 BGP 发言人交换信息\nBGP 采用路由向量协议，而 RIP 采用距离向量协议\nBGP 发言人通过 update 而不是 noticfication 分组通知相邻系统\nopen 分组用来与相邻的另一个 BGP 发言人建立关系，两个 BGP 发言人需要周期性地交换 keepalive 分组来确认双方的相邻关系\n2.3.8 RIP 协议RIP 是内部网关协议中使用最广泛的一种协议，它是一种分布式、基于距离向量的路由选择协议，要求路由器周期性地向外发送路由刷新报文\n路由刷新报文主要内容是由若干个（V，D）组成的表。V 标识该路由器可以到达的目标网络（或目的主机）；D 指出该路由器到达目标网络（或目标主机）的距离。距离D对应该路由器上的跳数。其他路由器在接收到某个路由器的（V，D）报文后，按照最短路径原则\\对各自的路由表进行刷新\n使用 RIP v1 路由协议在配置网络地址时无须给定子网掩码\\\n2.3.9 OSPF 协议OSPF 是内部网关协议的一种，每个区域有一个 32 位的标识符，区域内路由器不超过 200 个\n区域内每个路由器包含本区域的完整网络拓扑，而不是全网的情况（拓扑的意思是链接形式和位置关系之类的）\n链路状态“度量”主要指费用、距离、延时、带宽等\nOSPF 采用洪泛法交换链路状态信息\n2.3.10 集线器工作在物理层，连接到一个集线器的所有结点共享一个冲突域\n集线器不是基于 MAC 地址完成数据转发，而是用广播的方法\n在链路中串接一个集线器可以监听数据包\n每次只有一个结点能够发送数据，而其他的结点都处于接收数据的状态。这些结点执行CSMA/CD介质访问控制方法\n2.3.11 交换机是一种工作在数据链路层的网络设备，基本功能是维护一个表示 MAC 地址和交换机端口对应关系的交换表\n在源端口与目的端口间建立虚链接\n具有三种交换模式：1.快速转发直通式，接收到前 14 个字节就转发数据；2.碎片丢弃式，缓存前 64 个字节；3.储存转发式，转发之前读取整个帧\n三层交换机是具有部分路由器功能的交换机，用于加快大型局域网内部的数据交换\n2.3.12 路由器丢包率是衡量路由器超负荷工作时的性能指标之一\n背板能力决定路由器吞吐量\n传统路由器一般采用共享背板的结构，高性能路由器一般采用交换式的结构\n突发处理能力不是以最小帧间隔值来衡量的\n语音视频业务对延时抖动要求较高\n高端路由器应达到：无故障连续工作时间大于 10 万小时；故障恢复时间小于 30 分钟；切换时间小于 50 毫秒\n2.3.13 IEEE 802.11IEEE 802.11 最初定义的三个物理层包括了两个扩频技术和一个红外传播规范，无线频道定义在 2.4GHz ISM频段，传输速度 1~2 Mbps\n802.11b 最大容量 33 Mbps，将传输速率提高到 11 Mbps，802.11a和802.11g 将传输速率提高到 54 Mbps\nIEEE 802.11b 标准使用的是开放的 2.4GHZ 频段，无须申请就可以直接使用\nIEEE 802.1d 是当前最流行的 STP（生成树协议）标准\n2.3.14 蓝牙同步信道速率 64 kbps，跳频速率为 1600 次/s\n工作在 2.402 ~ 2.480 GHz 的 ISM 频段\n非对称的异步信道速率为 723.2 kbps / 57.6 kbps\n对称的异步信道速率为 433.9 kbps\n发射功率为100mw时，最大传输距离为100米\n2.3.15 Serv-U FTP 服务器使用动态 IP 地址时，服务器 IP 地址应配置为空，而不是 0.0.0.0。（为空代表全部 IP 地址）\n每个 Serv-U FTP 服务器中的虚拟服务器由 IP 地址和端口号唯一识别，而不是依靠 IP 地址\n向服务器中添加“anonymous”，系统自动判定为匿名。而不是创建新域时自动添加一个“anonymous”匿名\n服务器最大用户数是指服务器允许同时在线的最大用户数量\n用户上传下载选项要求 FTP 客户端在下载信息的同时也要上传文件\n2.3.16 DNS 服务器允许客户机在发生更改时动态更新其资源记录\nDNS 服务器中的根服务器被自动加入到系统中，不需管理员手工配置\n转发器是网络上的 DNS 服务器（不是路由器），用于外域名的 DNS 查询\n使用 nslookup 命令可以测试正向和反向查找区域\n主机记录的生存时间指该记录被客户端查询到，放在缓存中的持续时间\n2.3.17 DHCP 服务器负责多个网段 IP 地址分配时需配置多个作用域\n添加保留时需在 DHCP 客户机上获得其 MAC 地址信息（添加排除时不需从客户端获得 MAC 地址）\n不添加排除和保留时，服务器可将地址池内的 IP 地址动态指派给 DHCP 客户机\n地址池是作用域应用排除范围之后剩余的 IP 地址\n保留是指确保 DHCP 客户端永远可以得到同一 IP 地址，客户端可以释放该租约\n收到非中继转发的“DHCP发现”消息时,选择收到该消息的子网所处的网段分配 IP 地址\n2.3.18 WWW 服务器Web 站点可以配置静态和动态 IP 地址\n访问 Web 站点时可以使用站点的域名或站点的 IP 地址\n建立 Web 站点时必须为该站点指定一个主目录，也可以是虚拟的子目录\nWeb 站点的性能选项包括影响带宽使用的属性和客户端 Web 连接的数量\n在 Web 站点的主目录选项卡中，可配置主目录的读取和写入等权限\n2.3.19 Wmail 邮件服务器Winmail 用户不可以使用 Outlook 自行注册新邮箱\nWinmail 快速设置向导中创建新用户时，输入新建用户的信息，包括用户名、域名及用户密码（不是系统邮箱的密码）\n建立路由时，需在 DNS 服务器中建立该邮件服务器主机记录和邮件交换器记录\n邮件系统工作过程：1.用户在客户端创建新邮件；2.客户端软件使用 SMTP 协议将邮件发到发件方的邮件服务器；3.发件方邮件服务器使用 SMTP 协议将邮件发到收件方的邮件服务器；4.接收方邮件服务器将收到邮件储存待处理；5.接收方客户端软件使用 POP3 或 IMAP4 协议从邮件服务器读取邮件\n邮件交换器记录的配置只能在服务器上，不能通过浏览器配置\nWinmail 支持基于 Web 方式的访问和管理，管理工具包括系统设置、域名设置等\n发送邮件时通常采用 SMTP 协议，接收邮件时通常采用 POP3 或者 IMAP 协议。Winmail 用户使用浏览器查看邮件会使用到 HTTP 协议\n2.3.20 PIX 防火墙监视模式中，可以更新操作系统映像和口令恢复\n防火墙开机自检后处于非特权模式，输入“enable”进入特权模式\n2.3.21 可信计算机评估准则没有保护就是 D类，不能用于多用户环境下重要信息处理\n提到用户自主保护就是 C类\n2.3.22 入侵防护系统HIPS 基于主机的入侵防护系统，安装在受保护的主机系统中\nNIPS 基于网络的入侵防护系统，布置在网络出口\nAIPS 基于应用的入侵防护系统，部署于应用服务器前端\n（他们的首字母 H、N、A 即 Host、Net、Application）\n2.3.23 网络攻击DDos 攻击：利用已经攻占的多个系统向目标攻击，被害设备面对大量请求无法正常处理而拒绝服务\nSYN Flooding 攻击：利用 TCP 三次握手过程，使受害主机处于会话请求之中，直至连接超时停止响应\nSQL 注入攻击：属于利用系统漏洞，防火墙（基于网络的防护系统）无法阻断\nLand攻击：向某个设备发送数据包，并将数据包的源 IP 地址和目的地址都设置成攻击目标的地址\n基于网络的防护系统也无法阻断 Cookie篡改 和 DNS欺骗\nTear doop 、Smurf 攻击可以被路由器阻止\n2.3.24 无线局域网设备无线接入点（AP）：集合无线或者有线终端（类似于集线器和交换机），负责频段管理和漫游工作（SSID 是客户端设备用来访问接入点的唯一标识）\n无线路由器：具有无线路由功能和 NAT 功能的 AP ，可用来建立小的无线局域网。\n无线网桥：用于连接几个不同的网段，实现较远距离的无线通信（网桥最重要的维护工作是构建和维护 MAC 地址表）\n无线网卡：实现点对点通信，安装于各终端节点\n2.3.25 VLANVLAN name 用 1~32 个字符表示，它可以是字母和数字。不给定名字的 VLAN 系统自动按缺省的 VLAN 名（VLAN00xxx）\nVLAN ID的取值范围是 1~4094。其中无法执行“no vlan 1”命令\n2.3.26 Cisco 路由器上的存储器Flash 主要用于存储当前使用的操作系统映像文件和微代码\nNVRAM 主要存储启动配置文件或备份配置文件\nRAM 主要存储路由表、快速交换缓存、ARP 缓存、数据分组缓冲区和缓冲队列、运行配置文件等\nROM 主要用来永久保存路由器的开机诊断程序、引导程序和操作系统软件\n2.3.27 防火墙对应端口的连接方案pix525 在缺省情况下\nethernet0 被命名为外部接口 outside，安全级别是 0\nethernet1 被命名为内部接口 inside，安全级别是 100\nethernet2 被命名为中间接口 dmz，安装级别是 50\n2.3.28 STP 生成树结构无论是根的确定，还是树状结构的生成，主要依靠 BPDU 提供的信息\nBridge ID 由两个字节的优先级值和 6 个字节的交换机 MAC 地址组成，优先级取值范围是0~61440，增值量是4096，优先值越小，优先级越高\nMAC 地址最小的为根网桥\nBPDU 数据包有两种类型，配置 BPDU 不超过 35 个字节，拓扑变化通知 BPDU 不超过 4 个字节\n2.3.29 Catelyst 配置命令Catelyst3548 设置时间的格式是：clock set 小时:分钟:秒 日 月 年\nCatelyst6500 设置时间的格式是：set time 星期 月/日/年 小时 分钟 秒\n2.3.30 其他有一些知识点因为考频不是很高或者比较复杂，就不写了，自己做题时积累或者放弃。\n在遇到陌生题目时，试着结合常识思考推断。比如说，某网络计划有三台计算机，但只有一个 VLAN 端口，需要的设备是（）这里需要的其实就是路由器，联想宿舍上网的情况\n3.大题（前四道每道10分，最后一道20分）3.1 第一道 填地址表例：\n\nIP 地址115.151.29.58\n\n子网掩码255.240.0.0\n\n地址类别【1】\n|网络地址|【2】|\n|直接广播地址|【3】|\n|主机号|【4】||子网内第一个可用 IP 地址|【5】|\n解：\n\nIP 地址类别IP 首段范围\n\nA类1~127\n\nB类128~191\n|C类|192~223|\n则【1】填：A类对 IP地址和子网掩码做如下处理：熟练以后其实没有看起来这么麻烦，做两道就会了。少数情况会给出表格的后两项，让你补充前五项，原理其实是一样的，倒推一下。这道题是大题里面考点最稳定的一道，必须掌握。\n3.2 第二道 配置路由器例：一般就考这些空，做几道之后就能填上大部分，小部分可以放弃。\n【来自张斌的修改建议，由于不方便改图就直接贴在这里了】network __ area 0和#area 0 range ___，这两个空的讲解可以修改为“R3所在的子网号+子网掩码的反码/子网掩码，如果有两个子网号则先对两个子网进行聚合，然后填写聚合后的子网号+子网掩码的反码/子网掩码”，因为就题库中的题目而言，有两个子网号的情况还是挺多的。除此之外，还可以增加当配置R4时的#ip route _____，空里应该是目的网络子网号（与上题同）+子网掩码（与上题同）+下一跳路由器地址（R3的地址），阴影中有两个子网号时同样先进行聚合。R3由于本身就是阴影区域的一部分，故目的网络和目的子网掩码都是0.0.0.0。同理，如果配置R1或R2，他们都是阴影区域的一部分，目的网络与子网掩码也都是0.0.0.0。\n3.3 第三道 DHCP 报文例：\n3.4 第四道 sniffer 数据包例1：根据图中信息回答以下问题\n该主机执行的命令是（ ），该主机配置的 DNS 服务器的 IP 地址是（ ）解：看图中有 ICMP 几个字母，还有个邮箱地址，所以命令是 tracert mail.tj.edu.cn，DNS服务器的 IP 地址是第一行第二个地址 202.113.64.3（只要这么问，就基本是第一行第二个）\n图中 ② ③ ④ 处分别是（ ）解：② 处前面 Protocol 意思是协议，协议就是 ICMP；③ 写源地址，就是第一行第一个地址 202.113.64.137；④ Destination address 意思是目的地址，这个位置应该写题中有的网址 mail.tj.edu.cn。\n例2：根据图中信息回答以下问题\n该主机配置的域名服务器的 IP 地址是（ ）解：和上题一样，还是第一行第二个 202.113.64.3\n① 处的信息应该是（ ）解：填 ACK。一般都是有一个 SEQ，后再有一个 ACK，接着再有 SEQ，再有 ACK。他们的数值每次 +1，有时候会根据上下行填数字。\n主机 202.38.97.197 是（ ）服务器，其提供服务的端口是（ ）解：因为图中有 FTP 几个字母，所以这是 ftp服务器；提供服务的端口是 21（DNS服务器的端口是 53，邮件服务器的端口是 6）\n该主机执行的命令是（ ）解：填 ftp ftp.pku.edu.cn（网站在图中，前面加 ftp）\n这道题通常就考上面这两种模式，一种有 ICMP 对应 tracert mail.tj.edu.cn 的，一种有 FTP 对应 ftp ftp.pku.edu.cn 的。如果让写 URL 就是 https :// mail.tj.edu.cn 或者 ftp :// ftp.pku.edu.cn（中间都没有空格，我为了格式不自动转换成链接才加的）\n第四道大题也是考点很不稳定的一道。\n3.5 最后一道\n3.5.1 填表部分（12分）\n目的网络/掩码长度输出端口\n\n【1】S0（直接连接）\n\n【2】S1（直接连接）\n|【3】|S0|\n|【4】|S1|\n|【5】|S0|\n|【6】|S1|\n解：图中最上方的 RG 有两个分支，左侧分支是 S0 ，有末段为 129 和 130 的两个地址，进行聚合：所以【1】处填 192.168.6.128/30 ；同理【2】处是 192.168.6.133 和 192.168.6.134 聚合，结果为 192.168.6.132/30。做题实际上只要写出最后那段就行，前面选择题时已经说过了。\n【3】是 RE 下方 192.168.6.65、192.168.6.66、192.168.6.67 三个子网的聚合；【4】是 RF 下方 192.168.6.80、192.168.6.81、192.168.6.82 三个子网的聚合；【5】是 左下方 192.168.64.0/24、192.168.65.0/24、192.168.66.0/24、192.168.67.0/24 四个地址块的聚合；【6】是 右下方 192.168.96.0/24、192.168.97.0/24、192.168.98.0/24、192.168.99.0/24 四个地址块的聚合；\n在【3】【4】两空聚合时往往需要多注意最终答案应为【3】192.168.6.64/29【4】192.168.6.64/27\n【5】192.168.64.0/22\n【6】192.168.96.0/22\n这个填表是必拿分的题。\n3.5.2 中间部分（2~4分）这部分考点很不固定，下面是频率稍高的，考试这几分放弃也可以\n问在某路由器上，最多还可链接的路由器数量是多少。如果所在子网掩码是 /29 就填 3，是 /28 就填 11。\n问串接一种设备能监听路由器之间的流量，写 TAP\n问串接一种设备能提供安全保护，一般是 IPS\n问防火墙访问外网设置，分别填 nat 和 global\n3.5.3 计算子网掩码和 IP 段部分（4~6分）例：将 192.168.66.128/25 划分为三个子网，子网 1 能容纳 50 台主机，子网 2 和 3 能分别容纳 20 台主机……求他们的子网掩码和可用 IP 地址段\n解：题中说多少台主机的具体数字不重要，刚好大于那个数字加 2 后的 2 的 n 次方的数才重要。比如 50 台，就是 64，是 2 的 6 次方。所以子网掩码后 6 位都是 0 （前面全是 1 ），11111111.11111111.11111111.11000000 ，最后填空写 255.255.255.192同理 20 台，就是 32，是 2 的 5次方。所以子网掩码后 5位都是 0，最后填空 2 和 3 的子网掩码都是 255.255.255.224\n可用 IP 地址从题目所给的那个数 +1 开始，本题是 192.168.66.129（因为太乱，下面只写末段数字，反正前面都一样）从 129 开始，因为子网 1 的那个数字是 64 ，所以到 190 结束（129+64-3=190，不用管为什么，结束都是 -3）下一段从 193 开始（190+3=193，不用管为什么，开始都是 +3），因为子网 2 的那个数字是 32 ，所以到 222 结束（193+32-3=222）再下一段从 225 开始（222+3=225），因为子网 3 的那个数字也是 32 ，所以到 254 结束（225+32-3=254）\n写成答案分别为：子网 1 的可用 IP 地址段为 192.168.66.129~192.168.66.190\n子网 2 的可用 IP 地址段为 192.168.66.193~192.168.66.222\n子网 3 的可用 IP 地址段为 192.168.66.225~192.168.66.254\n看起来上面写了一大堆，其实明白了就很简单，这个也是必拿分的题。\n\n总结：得分策略目标是通过考试，也就是 60 分\n选择题部分：前面一共写了 10 个做法固定的“第一类选择题”，还有 19 个“第三类选择题”的高频考点，加上“第二类选择题”。选择题得分在 20 分以上是很保守的估计，没有意外的话选择题应该在 25 分以上。\n大题部分：第一道的 10 分是必得的，最后一道除了中间部分后有 16 分是必得的。从前面写的也能看出第二、三、四道大题的考点不是特别固定，所以尽量写，填对一半就很好了（其实也没有那么难），所以这三道大题 30 分目标是得 15 分。【2018/9/6补充】有时间可以去b站看看正规的大题讲解视频，也许第二、三、四道大题的做法并不难。现在看来我当时的想法还是消极了一些（不过还是一定要先学会固定的题型再说）\n来算一下 20 + 10 + 16 + 15 = 61 分。实际情况当然可能会出现意外，比如三道大题没得到 15 分，但刚才也没算你蒙对的题得分。\n多练习几套题，来回对照着知识点就熟悉了，这个考试题型固定，含金量不高，难度不大，不用害怕。题库软件有很多缺陷，比如大题评分不准、填空题缺少空格，甚至是答案错误。自己要注意核对。这份文档并未涵盖所有知识点，多做一套题就多了一分考过的把握。\n（未来教育题库的第九套题有点特殊，看起来像 13 年考试改革之前的老题，和其他套的题有很大差别，留意一下。）\n完。2017/3/19 初版2017/4/25 修改了前言与总结2017/5/12 修改内容略2017/5/16 刚查到成绩，84分，本来还以为能上90…2017/8/23 补充了备考建议2017/9/12 改正了 2.1.6 IP地址块聚合2017/9/21 增加了 2.3 中近一半的内容，感谢佚名进行的补充2017/12/18 考试获证条件改变，三级不再需要对应的二级科目通过2018/3/24 修正了若干错误，感谢何林刚、张斌、fun、sang_wang 等的帮助2018/6/6 末尾加了收款码2019/2/10 修改两处笔误等\n每次更新编辑会导致分享页面审核，影响同学复习，所以我一般不更新了\n","plink":"https://dxsummer.gitee.io/posts/445a1dcd/"},{"title":"Linux目录结构","date":"2020-07-12T10:17:24.000Z","date_formatted":{"ll":"2020年7月12日","L":"2020/07/12","MM-DD":"07-12"},"updated":"2020-07-12T11:45:14.000Z","content":"一切皆文件\n💎 /bin [重点] (/usr/bin 、 /usr/local/bin)• 是Binary的缩写, 这个目录存放着最经常使用的命令\n💎 /home [重点]• 存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的。\n💎 /root [重点]• 该目录为系统管理员，也称作超级权限者的用户主目录。\n🌱 /sbin (/usr/sbin 、 /usr/local/sbin)• s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序。  \n🌱 /lib• 系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库。\n🌱 /lost+found• 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。\n💎 /etc [重点]• 所有的系统管理所需要的配置文件和子目录 my.conf\n💎 /usr [重点]• 这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录。  \n💎 /boot [重点]• 存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件  \n🌱 /proc• 这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息。  \n🌱 /srv• service缩写，该目录存放一些服务启动之后需要提取的数据。\n🌱 /sys• 这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sy\n🌱 /tmp• 这个目录是用来存放一些临时文件的。  \n🌱 /dev• 类似于windows的设备管理器，把所有的硬件用文件的形式存储。\n💎 /media [重点]• linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后， linux会把识别的设备挂载到这个目录下。\n💎 /mnt [重点]• 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。 d:/myshare  \n🌱 /opt• 这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空。\n💎 /usr/local [重点]• 这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序。  \n💎 /var [重点]• 这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件。  \n🌱 /selinux [security-enhanced linux] 360• SELinux是一种安全子系统,它能控制程序只能访问特定文件。  \n","plink":"https://dxsummer.gitee.io/posts/5e2eb880/"},{"title":"VMware虚拟机的CentOS无法上网的解决方法","date":"2020-07-12T09:25:30.000Z","date_formatted":{"ll":"2020年7月12日","L":"2020/07/12","MM-DD":"07-12"},"updated":"2020-07-12T10:18:42.000Z","content":"流程如下：\n1)点击 VM-&gt;Settings Hardware（虚拟机-设置）选项卡下面\n2)点击Network Adapter （网络适配器）设置如下图所示，首先我们在虚拟机中将网络配置设置成NAT，\n\n3、然后右键点击我们的电脑，进入到管理界面 计算机-&gt; 管理-&gt;服务和应用程序-&gt;服务，找到如下服务进程 VMware DHCP Service, VMware NAT Service。 分别点击右键-&gt;启动\n\n在这里，我们找到VMware NAT service和VMware DHCP service，我们启动它，然后我们进入到CentOS，输入reboot命令重启下系统，在等待了几分钟以后，怀着无比期待的心情点开了CentOS自带的火狐浏览器，输入了google的网站。。。。当看见这个界面时，我不淡定了!!!!\n4)在Centos里面打开终端，输入shutdown -r now\n重启即可上网。\n\n现在心里除了激动还是激动，终于通过一个小手段搞定了在CentOS下上网的问题了!\n","plink":"https://dxsummer.gitee.io/posts/740f0ea7/"},{"title":"英语期末考试","date":"2020-07-02T12:12:49.000Z","date_formatted":{"ll":"2020年7月2日","L":"2020/07/02","MM-DD":"07-02"},"updated":"2020-07-02T13:32:30.000Z","content":"Unit5Explore 1My Mother’s Gift　　母亲的礼物　　I grew up in a small town where the elementary school was a ten-minute walk from my house and in an age, not so long ago , when children could go home for lunch and find their mothers waiting.　　我是在一个小镇上长大的，从镇上的小学校到我家， 只需步行10分钟。离当前不算太太久远的那个时代 ， 小学生可以回家吃午饭，而他们的母亲，则会老早在家等候着。　　At the time, I did not consider this a luxury, although today it certainly would be. I took it for granted that mothers were the sandwich-makers, the finger-painting appreciators and the homework monitors. I never questioned that this ambitious, intelligent woman, who had had a career before I was born and would eventually return to a career, would spend almost every lunch hour throughout my elementary school years just with me.　　这一切对如今的孩子来说，无疑是一种奢望了，可是那时的我，却并不以为然。 我觉得做母亲的给她的孩子制作三明治，鉴赏指画，检查他们的家庭作业，都是理所当然的事。我从来没有想过：像我母亲这样一个颇有抱负又很聪明的女人，在我降生之前，她有一份工作，而且后来她又谋了份差事，可是，在我上小学那几年，她却几乎天天陪着我吃午饭，一同打发午餐时的每一分钟。　　母亲的礼物 My Mother’s Gift　　I only knew that when the noon bell rang, I would race breathlessly home. My mother would be standing1 at the top of the stairs, smiling down at me with a look that suggested I was the only important thing she had on her mind. For this, I am forever grateful.　　只记得，每当午时铃声一响，我就一口气地往家里跑。母亲总是站在门前台阶的最高层，笑盈盈地望着我–那神情分明表示：我便是母亲心目中唯一最重要的东西了。为此，我一辈子都要感谢我的母亲。　　Some sounds bring it all back: the high-pitched squeal2 of my mother’s teakettle, the rumble3 of the washing machine in the basement and the jangle of my dog’s license4 tags as she bounded down the stairs to greet me. Our time together seemed devoid5 of the gerrymandered schedules that now pervade6 my life.　　如今，每当我听到一些声音，像母亲那把茶壶水开时发出的尖叫声，地下室洗衣机的隆隆声，还有， 我那条狗蹦下台阶冲我摇头摆尾时它脖子上那牌照发出的撞击声，便会勾起我对往事的回忆。和母亲在一起的岁月，全然没有充斥于我的生活中的、事先排定的虚情假意的日程表。　　One lunchtime when I was in the third grade will stay with me always. I had been picked to be the princess in the school play, and for weeks my mother had painstakingly7 rehearsed my lines with me. But no matter how easily I delivered them at home, as soon as I stepped onstage, every word disappeared from my head.　　我永远忘不了在我上三年级时的那一顿午饭。在那天之前，我被学校选中，要在一个即将演出的小剧中扮演公主的角色。一连好几个礼拜，母亲总是不辞辛劳地陪着我，一起背诵台词。可是，不管在家里怎么背得滚瓜烂熟，只要一上舞台，我的脑子里就成了一片空白。　　Finally, my teacher took me aside. She explained that she had written a narrator’s part to the play, and asked me to switch roles. Her word, kindly8 delivered, still stung, especially when I saw my part go to another girl.　　终于，老师把我叫到了一边。她说剧中旁白这个角色的台词已写好了，想把我替换下来当旁白。尽管老师这些话说得和和气气，可还是刺痛了我的心，特别是当我发觉自己扮演的公主角色让另外一个女孩顶替时，更是如此。　　I didn’t tell my mother what had happened when I went home for lunch that day. But she sensed my unease, and instead of suggesting we practice my lines, she asked if I wanted to walk in the yard.　　那天回家吃午饭时我没有把这事告诉母亲。然而，母亲见我心神不定，因此没有再提练习背台词的事儿，而是问我愿意不愿意到院子里散散步。　　It was a lovely spring day and the rose vine on the trellis was turning green. Under the huge elm trees, we could see yellow dandelions popping through the grass in bunches, as if a painter had touched our landscape with dabs9 of gold .I watched my mother casually10 bend down by one of the clumps11. “I think I’m going to dig up all these weeds, “she said, yanking a blossom up by its roots.”From now on, we’ll have only roses in this garden.”　　那真是一个可爱的春日，棚架上蔷薇的藤蔓正在转青。在一些高大的榆树下面，我们可以看到，一丛丛黄色的蒲公英冒出草坪，仿佛是一位画家为了给眼前的美景增色而着意加上的点点金色。我看到母亲在一簇花丛旁漫不经心地弯下身来。”我看得把这些野草都拨了，”她说着，一边使劲把一丛蒲公英连根拨出。”往后咱这园子里只让长蔷薇花。”　　“But I like dandelions, “I protested. “All flowers are beautiful-even dandelions. “My mother looked at me seriously.”Yes, every flower gives pleasure in its own way, doesn’t it?” She asked thoughtfully. I nodded, pleased that I had won her over. “And that is true of people too, “she added.” Not everyone can be a princess, but there is no shame in that.”　　可是我喜欢蒲公英，”我不满地说，”凡是花都好看–蒲公英也不例外。”母亲严肃地看着我。”噢，这么说，每朵花都自有它令人赏心悦目的地方喽？”她若有所思地问道。我点了点头，总算说服了母亲，这使我很得意。”可是人也一样呀，”母亲接着又发话，”不见得人人都能当公主，但当不了公主并不丢脸。”　　Relieved that she had guessed my pain, I started to cry as I told her what had happened. She listened and smiled reassuringly12.　　母亲猜到了我的苦恼，这使我的情绪安定下来。我哭了起来，把事情的经过讲给母亲听。母亲专注地听着，脸上带着安详的微笑。　　“But you will be a beautiful narrator, “ she said , reminding me of how much I loved to read stories aloud to her . “The narrator’s part is every bit as important as the part of a princess.　　“但你会成为一名顶呱呱的解说员，”母亲又说。她说平常我是多么喜欢朗诵故事给她听，还说”从哪方面看，旁白这个角色都和公主那个角色一样重要”。　　My Mother’s Gift　　母亲的礼物　　I grew up in a small town where the elementary school was a ten-minute walk from my house and in an age, not so long ago , when children could go home for lunch and find their mothers waiting.　　我是在一个小镇上长大的，从镇上的小学校到我家， 只需步行10分钟。离当前不算太太久远的那个时代 ， 小学生可以回家吃午饭，而他们的母亲，则会老早在家等候着。　　At the time, I did not consider this a luxury, although today it certainly would be. I took it for granted that mothers were the sandwich-makers, the finger-painting appreciators and the homework monitors. I never questioned that this ambitious, intelligent woman, who had had a career before I was born and would eventually return to a career, would spend almost every lunch hour throughout my elementary school years just with me.　　这一切对如今的孩子来说，无疑是一种奢望了，可是那时的我，却并不以为然。 我觉得做母亲的给她的孩子制作三明治，鉴赏指画，检查他们的家庭作业，都是理所当然的事。我从来没有想过：像我母亲这样一个颇有抱负又很聪明的女人，在我降生之前，她有一份工作，而且后来她又谋了份差事，可是，在我上小学那几年，她却几乎天天陪着我吃午饭，一同打发午餐时的每一分钟。　　母亲的礼物 My Mother’s Gift　　I only knew that when the noon bell rang, I would race breathlessly home. My mother would be standing at the top of the stairs, smiling down at me with a look that suggested I was the only important thing she had on her mind. For this, I am forever grateful.　　只记得，每当午时铃声一响，我就一口气地往家里跑。母亲总是站在门前台阶的最高层，笑盈盈地望着我–那神情分明表示：我便是母亲心目中唯一最重要的东西了。为此，我一辈子都要感谢我的母亲。　　Some sounds bring it all back: the high-pitched squeal of my mother’s teakettle, the rumble of the washing machine in the basement and the jangle of my dog’s license tags as she bounded down the stairs to greet me. Our time together seemed devoid of the gerrymandered schedules that now pervade my life.　　如今，每当我听到一些声音，像母亲那把茶壶水开时发出的尖叫声，地下室洗衣机的隆隆声，还有， 我那条狗蹦下台阶冲我摇头摆尾时它脖子上那牌照发出的撞击声，便会勾起我对往事的回忆。和母亲在一起的岁月，全然没有充斥于我的生活中的、事先排定的虚情假意的日程表。　　One lunchtime when I was in the third grade will stay with me always. I had been picked to be the princess in the school play, and for weeks my mother had painstakingly rehearsed my lines with me. But no matter how easily I delivered them at home, as soon as I stepped onstage, every word disappeared from my head.　　我永远忘不了在我上三年级时的那一顿午饭。在那天之前，我被学校选中，要在一个即将演出的小剧中扮演公主的角色。一连好几个礼拜，母亲总是不辞辛劳地陪着我，一起背诵台词。可是，不管在家里怎么背得滚瓜烂熟，只要一上舞台，我的脑子里就成了一片空白。　　Finally, my teacher took me aside. She explained that she had written a narrator’s part to the play, and asked me to switch roles. Her word, kindly delivered, still stung, especially when I saw my part go to another girl.　　终于，老师把我叫到了一边。她说剧中旁白这个角色的台词已写好了，想把我替换下来当旁白。尽管老师这些话说得和和气气，可还是刺痛了我的心，特别是当我发觉自己扮演的公主角色让另外一个女孩顶替时，更是如此。　　I didn’t tell my mother what had happened when I went home for lunch that day. But she sensed my unease, and instead of suggesting we practice my lines, she asked if I wanted to walk in the yard.　　那天回家吃午饭时我没有把这事告诉母亲。然而，母亲见我心神不定，因此没有再提练习背台词的事儿，而是问我愿意不愿意到院子里散散步。　　It was a lovely spring day and the rose vine on the trellis was turning green. Under the huge elm trees, we could see yellow dandelions popping through the grass in bunches, as if a painter had touched our landscape with dabs of gold .I watched my mother casually bend down by one of the clumps. “I think I’m going to dig up all these weeds, “she said, yanking a blossom up by its roots.”From now on, we’ll have only roses in this garden.”　　那真是一个可爱的春日，棚架上蔷薇的藤蔓正在转青。在一些高大的榆树下面，我们可以看到，一丛丛黄色的蒲公英冒出草坪，仿佛是一位画家为了给眼前的美景增色而着意加上的点点金色。我看到母亲在一簇花丛旁漫不经心地弯下身来。”我看得把这些野草都拨了，”她说着，一边使劲把一丛蒲公英连根拨出。”往后咱这园子里只让长蔷薇花。”　　“But I like dandelions, “I protested. “All flowers are beautiful-even dandelions. “My mother looked at me seriously.”Yes, every flower gives pleasure in its own way, doesn’t it?” She asked thoughtfully. I nodded, pleased that I had won her over. “And that is true of people too, “she added.” Not everyone can be a princess, but there is no shame in that.”　　可是我喜欢蒲公英，”我不满地说，”凡是花都好看–蒲公英也不例外。”母亲严肃地看着我。”噢，这么说，每朵花都自有它令人赏心悦目的地方喽？”她若有所思地问道。我点了点头，总算说服了母亲，这使我很得意。”可是人也一样呀，”母亲接着又发话，”不见得人人都能当公主，但当不了公主并不丢脸。”　　Relieved that she had guessed my pain, I started to cry as I told her what had happened. She listened and smiled reassuringly.　　母亲猜到了我的苦恼，这使我的情绪安定下来。我哭了起来，把事情的经过讲给母亲听。母亲专注地听着，脸上带着安详的微笑。　　“But you will be a beautiful narrator, “ she said , reminding me of how much I loved to read stories aloud to her . “The narrator’s part is every bit as important as the part of a princess.　　“但你会成为一名顶呱呱的解说员，”母亲又说。她说平常我是多么喜欢朗诵故事给她听，还说”从哪方面看，旁白这个角色都和公主那个角色一样重要”。　　Over the next few weeks, with her constant encouragement, I learned to take pride in the role. Lunchtimes were spent reading over my lines and talking abut13 what I would wear.　　往后的几个星期，在母亲的一再鼓励下，我渐渐地以担任旁白的角色感到骄傲。利用午饭时间，我们又一起念台词，议论到时候我该穿什么样的演出服装。　　Backstage the night of the performance, I felt nervous. A few minutes before the play, my teacher came over to me. “Your mother asked me to give this to you, “ she said, handing me a dandelion. Its edges were already beginning to curl and it flopped14 lazily from its stem. But just looking at it, knowing my mother was out there and thinking of our lunchtime talk, made me proud.　　到了演出那个晚上，当我登上后台，心里还感到紧张。离演出还有几分钟的时候，老师朝我走了过来。”你母亲让我把这个交给你，”说着她递过来了一朵蒲公英。那花儿四周已开始打蔫，花瓣儿从梗上向下有气无力地耷拉着。可是，只要看一眼，知道母亲就在外面呆着，回想起和母亲用午饭时说的那些话，我就感到胸有成竹。　　After the play, I took home the flower I had stuffed in the apron15 of my costume. My mother pressed it between two sheets of paper toweling in a dictionary, laughing as she did it that we were perhaps the only people who would press such a sorry-looking weed.　　演出结束后，我把塞在演出服围裙里的那朵蒲公英拿回了家。母亲将花接了过去，用两张纸巾将它压平，夹在了一本字典里。她一边忙碌着，一边笑，想到也许只有我们俩会珍藏这么一朵打了蔫的野草花。　　I often look back on our lunchtimes together, bathed in the soft midday light. They were the commas in my childhood, the pauses that told me life is not savored16 in premeasured increment17, but in the sum of daily rituals and small pleasures we casually share with loved ones. Over peanut-butter sandwiches and chocolate-chip cookies, I learned that love, first and foremost, means being there for the little things.　　我常常回想起和母亲在一起度过的那些沐浴在和煦阳光之中的午餐时光。它们是我孩提时代的一个个小插曲，告诉我一个道理：人生的滋味，就在于和我们所爱的人在一起不经意地共度的日常生活、分享的点点滴滴的欢乐，而不在于某种事先测量好的”添加剂”。在享用母亲做的花生酱、三明治和巧克力碎末小甜饼的时候，我懂得了，爱就体现在这些细微这处。　　A few months ago, my mother came to visit. I took off a day from work and treated her to lunch. The restaurant bustled18 with noontime activity as businesspeople made deals and glanced at their watches. In the middle of all this sat my mother, now retired19, and I. From her face I could see that she relished20 the pace of the work world.　　几个月前，母亲又来看我。我特意请了天假，陪母亲吃午饭。中午，饭馆里熙熙壤攘，做生意的人忙不迭地从事交易活动，他们不时地看看手表。如今已经退休的母亲和我就坐在这群人中间。从母亲的表情中，我看得出，母亲打心眼里喜欢上班族这种生活的节奏。　　“Mom, you must have been terribly bored staying at home when I was a child,” I said.”Bored? Housework is boring. But you were never boring. “　　“妈，我小的时候，您老呆在家里一定觉得很烦吧？”我说。”烦？做家务是令人心烦，不过，你从来没使我感到心烦过。　　“I didn’t believe her, so I pressed.”Surely children are not as stimulating21 as a career.”　　我不相信这是实话，于是我又想法子套她的话。”看孩子哪会像工作那样富有刺激性呢？”　　“A career is stimulating,” she said.” I’m glad I had one. But a career is like an open balloon. It remains22 inflated23 only as long as you keep pumping. A child is a seed. You water it. You care for it the best you can. And then it grows all by itself into a beautiful flower.”　　“工作是富有刺激性的，”母亲答道，”很高兴我也有过工作。可是工作好比开了口的气球，你只有不停地充气，它才能鼓着劲。可是一个孩子就是一粒种子，你浇灌了它，全心全意地爱护它，然后，它就会独立自主地开出美丽的花朵来。”　　Just then, looking at her, I could picture us sitting at her kitchen table once again, and I understood why I kept that flaky brown dandelion in our old family dictionary pressed between two crumpled24 bits of paper towel.　　此时此刻，我凝望着我的母亲，脑海里又浮现出儿时的我和母亲一起坐在饭桌旁的情景，也明白了为什么我还珍藏着夹在我们家里那本旧字典中的那朵用两小块皱皱巴巴的纸巾压平的蒲公英。\nIt was 1) a lovely spring day. Under the huge elm trees, we could see 2), yellow dandelions in the grass. My mother 3)_ pulled up dandelions by their roots and said that she was going to 4) dig up all these weeds. 15)_ protested_ and said that even dandelions are beautiful. My mother looked at me 6)_ seriously confirming that every flower 7) gives pleasure in its own way, and so do people. She added that not everyone can be a princess, but there is 8). no shame in that. 9)_ Relieved that she had guessed my pain, I 10)_ started tocry as I told her what had happened. She listened and smiled 11). reassuringly She told me that the narrator’s part is as important as the part of a princess and 12). encouraged me to be a beautiful narrator. I learned to 13) take pride in the role.It was 1) a lovely spring day. Under the huge elm trees, we could see 2), yellow dandelions in the grass. My mother 3) pulled up dandelions by their roots and said that she was going to 4) dig up all these weeds. 15)_ protested_ and said that even dandelions are beautiful. My mother looked at me 6)_ seriously confirming that every flower 7) gives pleasure in its own way, and so do people. She added that not everyone can be a princess, but there is 8). no shame in that. 9)_ Relieved that she had guessed my pain, I 10)_ started tocry as I told her what had happened. She listened and smiled 11). reassuringly She told me that the narrator’s part is as important as the part of a princess and 12). encouraged me to be a beautiful narrator. I learned to 13) take pride in the role.\n1 How do we live a better life? Most people have this question on their mind . 2 My father, takes a week off every year to travel with uS. 3 For college students, the ability of solving problems is_ every bit as_ important as the knowledge they learn in class. 4 The pianist says he _ is grateful_ to his parents for . their encouragement and support. 5 It’s no secret that many children would be happier with their adoptive parents (养父母). That is especially_ true of children who are badly treated by their biological parents. 6 At first they didn’t want to join uS for dinner, but we finally_ won them over 7 The yard was bathed in bright sunshine where my mother grew various kinds of vegetables. 8 When I look back on my childhood, I can barely remember what I did or liked or watched.\n1 Most people would prefer to be cared_ for at home rather than in a hospital. 2 | can well remember how proud I was when my mother was asked to_ deliver_ . a speech at a parent-teacher conference. 3 My parents are now so accustomed to Android (安卓操作系统) that they don’t want to switch_ to iPhone. 4 Excited at his success, I told my cousin that I would treat him to dinner and he could name the restaurant. 5 My mother is quite forgetful. | have to_ remind her of her promise. 6 Parents_ protested_ against the school’s decision to cut down music lessons. 7 My parents take pride in my accomplishments, which are stepping stones to my dreams. 8 As he grew up, his parents were gradually_ relieved of the burden of planning for his future.When the author treats her mother to a lunch, she 1)， remembers again her childhood lunchtimes with her mother. After her birth, her mother 2)_ quit her job and stayed home, taking care of her. Her mother would spend almost every lunch hour with her throughout her elementary school years. She had never 3). guestioned that and took everything for granted. When she grew up, she thought she mattered less than a(n) 4), stimulating career to her mother, but she was wrong. In fact, her mother enjoyed their time together because a child is like a(n) 5) seed_ which grows all by itself into a beautiful flower as long as one cares for it. The pressed dandelion in the family dictionary 6)_ reminds her of the most unforgettable lunchtime with her mother. Being told that she had to 7)_ switch_ roles in a school play, she felt quite uneasy. During the walk in the yard, her mother made her realize everybody has their own existence value just as all flowers give 8) pleasure_ in their own ways. With her mother’s constant 9) encouragement, she learned to take pride in the role and spent the lunchtimes reading over her lines and talking about what she would wear. Her mother’s company during lunchtimes and the dandelion her mother gave her on the night of the performance 10)_ meanmuch to her.\nexplore2In the faint light of the attic, an old man, tall and stooped, bent his great frame and made his way to a stack of boxes that sat near one of the little half-windows. Brushing aside a bit of a spider ‘s web, he pointed the top box toward the light and began to carefully lift out one old photograph album after another. Eyes once bright but now dim searched longingly for the source that had drawn him here. It began with the fond memory of the love of his life, long gone, and somewhere in these albums was a photo of her he hoped to rediscover. Silent as a mouse, he patiently opened the long buried treasures and soon was lost in a sea of memories. Although his world had not stopped spinning when his wife left it, the past was more alive in his heart than his present aloneness. Setting aside one of the dusty albums, he pulled from the box what appeared to be a journal from his grown son’s childhood. He could not recall ever having seen it before, or that his son had ever kept a journal. Why did Elizabeth always save the children’s old junk? He wondered, shaking his white head.Opening the yellowed pages, he glanced over a short reading, and his lips curved in an unconscious smile. Even his eyes brightened as he read the words that spoke clear and sweet to his soul. It was the voice of the little boy who had grown up far too fast in this very house, and whose voice had grown fainter and fainter over the years. In the utter silence of the attic, the words of an innocent six-year-old worked their magic and carried the old man back to a time almost totally forgotten. Entry after entry stirred an emotional hunger in his heart like the longing a gardener feels in the winter for the fragrance of spring flowers. But it was accompanied by the fact that his son’s simple memories of those days were far different from his own. But how different? Reminded that he had kept a daily journal of his business activities over the years, he closed his son’s journal and turned to leave, having forgotten the cherished photo that originally triggered his search. Trying to avoid bumping his head, the old man stepped to the wooden stairs that led to the study. Opening a glass cabinet door, he reached in and pulled out an old business journal. Turning, he sat down at his desk and placed the two journals beside each other. His was leather-bound with his name printed neatly in gold, while his son’s had not been well kept and the name Jimmy had been nearly erased from its surface. He ran a long skinny finger over the letters, as though he could restore what had been worn away with time and use.As he opened his journal, the old man’s eyes fell upon a passage that stood out because it was so brief in comparison to other days’. In his own neat handwriting were these words: Wasted the whole day fishing with Jimmy. Didn’t catch a thing. With a deep sigh and a shaking hand, he took Jimmy’s journal and found the boy’s entry for the same day, June 4. Large letters, pressed deeply into the paper, read: Went fishing with my dad. Best day of my life.\n1 Her grandmother was always insisting that she was tooskinny and was never tiredof trying to force more food on her.2 They switched off all lights and waited for their lttle sister in thefaint___ light ofcandles, hoping to give her a birthday surprise.3 When they were talking about the education of children, his remarks on strict disciplinetriggered_ heated debate.4 Thanks to the _ emotional support from my family, I finally went through the tough timein my freshman year.5 Show your care to people youcherish__ most and let them feel they are important inyour life.6 He seemed so young and__ innocent_ that no one expected he’d have done things like that.\n1 Though upsetting events happened to the family_ one by one_, the family became closer than ever. 2 Water, if it drops continually, will make a stone disappear; this is true of our mind and efforts in front of difficulties. 3 The boy walked slowly to the door to go out, trying not to be noticed by his mother. 4 Feeling tired, he put his pen to one side and read over what he had written. 5 The children went together with their parents and teachers on their field trip on the Children’s Day. 6 She looks very short compared with other children of the same age.1 | had to bury myself in a stack of textbooks before the final exams, while my mother would always get me a glass of milk when I was tred. 2 We parked beneath a clump of trees a hundred meters away from the entrance of the museum. 3 He always brought with him a bunch of flowers for his mother when he came home. 4 In fact, without a clear searching target, you might be drown in a sea of information when surfing online. 5 The couple have an album of stamps from all over the world which make them remember their traveling in their early years. 6 Start budgeting and saving to repay student loans so you won’t face a mountain of debts for years.\n翻译家庭对中国人来说极其重要;随着时代的发展，中国人的家庭观念也在发生着变化。\nThe family is of crucial importance to Chinese people. As time goes on,Chinese people’s attachment to the family has been changing.\n在中国，一个人孝顺自己的父母长辈,不仅仅是个人的道德行为,也是对社会承担的- -份责任。(filial piety; commitment)\nIn China, practicing filial piety toward parents and elders is not only apersonal moral behavior, but also a commitment to society.\n中国人在情感表达方面比较含蓄，但这并不代表我们不真挚，不热烈。(implicit; sincere;enthusiastic)\nChinese people are relatively implicit in expressing their emotions, but thisdoesn’t mean that we are not sincere or enthusiastic.\n年夜饭是中国人重要的情感寄托，吸引着世界各地的中国人回家庆祝春节。(reunion dinner;bear; from all corners)\nThe reunion dinner, important for bearing the emotions of Chinese people,draws them from all corners of the world to return home and celebrate theSpring Festival.\nUnit 7Explore 1Chinese Technology\nWhen I moved to China in 2004,I took a short trip to Zhaoxian County in Hebei Province to see a bridge.A bridge?Yes.This was not just any bridge.It was the Zhaozhou Bridge,completed in AD 605,the earliest and best-preserved open-spandrel stone arch bridge in the world.In 1991,it was designated as the International Historic Civil Engineering Landmark,equally famous as the Eiffel Tower in Paris,the Panama Canal in Central America,and the Pyramids in Egypt.\nThis experience helped shape my view of China as innovative.It informed my work over the next dozen years as a teacher and consultant working with private companies,state-owned enterprises,universities and government agencies.\nAt college,I became familiar with China’s four great inventions:gunpowder,papermaking,printing and the compass.The inventions,in the words of the English philosopher Roger Bacon,changed the whole appearance and status of things in the world.For most Westerners,this is all we learned about China’s technological achievements.But,if we dig a little deeper,we will uncover a rich tradition of technological innovation.We learn that China’s global firsts include paper currency,oil wells,and even the explanation of the camera obscura.The list goes on and on.China was ahead of the time in some fields until the early years of the Qing Dynasty.Chinese discoveries and innovations contributed to the economic development of Asia and Europe.\nThe rise of modern China’s technological achievements should not come as a surprise to anyone.It is built on a long history of innovation.Indeed,its achievements have captured global attention.For example,China’s progress in clean technology drew praise from Steven Chu,former Secretary of the US Department of Energy.He once identified several crucial technologies,mostly in the areas of power generation and transportation,where China is leading.\nHigh voltage transmission\nChina has deployed the world’s first-class ultra-high voltage AC and DC lines—including one capable of delivering 6.4 gigawatt to Shanghai from a plant over 1,900 kilometers away in southwestern China.\nHigh-speed rail\nChina’s high-speed railways have witnessed significant development in recent years.Its highspeed railway technology has reached the world’s advanced level and has been exported to other countries.China also has the world’s greatest high-speed network—22,000 kilometers at the end of 2016,or about 60 percent of the world’s total.\nAdvanced coal technologies\nChina is rapidly deploying supercritical and ultra-supercritical coal combustion plants,which have fewer emissions and are more efficient than conventional coal plants because they burn coal at much higher temperatures and pressures.\nEnergy-saving and new-energy vehicles\nChina has invested a lot in fuel economy,hybrids,and electric and fuel cell vehicles.It’s expected that at least one in every five cars sold in China will be a new-energy model by 2025.\nSupercomputing\nChina’s Sunway TaihuLight,developed by the Chinese National Research Center of Parallel Computer Engineering&amp;Technology,is the world’s fastest supercomputer,according to the TOP500 list of supercomputers released in November 2017.The Sunway TaihuLight was built entirely using processors designed and made in China.\nLikewise,China’s ambitious space program has been progressing at a rapid pace.China has given the world a first glimpse of its design for the space probe and rover which the country plans to use in its first mission to Mars in mid-2020.On August 16,2016,China launched a potentially groundbreaking quantum-enabled satellite,testing new communications technology.In early August 2016,its Jade Rabbit lunar rover shut down after operating on the Moon for 31 months.\nWhere will China go from here?How will the rapid growth of technological innovations be developed and applied?Since 2014,China has been promoting mass entrepreneurship and innovation to cultivate grass-roots entrepreneurship throughout the country.According to the government,science and technology will contribute to 60 percent of the country’s economic growth in the near future.\nIn addition to the top-down goal to upgrade its innovation capacity in order to stay competitive,China’s innovation drive is also being led by bottom-up factors such as the rise of Chinese entrepreneurs who are disrupting traditional industries.Technological influences are helping China leapfrog its innovation process.\nIn my own work with private companies,state-owned enterprises,and government agencies,I have witnessed remarkable changes in the way technology is developed and applied to meet real world challenges.Particularly of importance has been the growing cooperation between private entrepreneurs and the government.From my experience,I am optimistic that China will achieve much in more technologies and that the development of grass-roots entrepreneurship will be successful.\nTo encourage innovation, China 1) has been developing (develop) indigenous (本土的) technicalstandards. One example is the TD-SCDMA, the 3G standard. China initially 2)launched(launch) a national TD-SCDMA network in 2005, but the network only 3) reached(reach)large-scale commercial trials with 60,000 users across eight cities in 2008. On January 7, 2009,China 4)granted (grant) a TD-SCDMA 3G license to China Mobile. China Mobile officially5) announced (announce) on September 21, 2009 that it had had 1 ,327,000 TD-SCDMAusers by the end of August 2009. Critics claim that the standard 6)_ delayed (delay) 3Gintroduction, while supporters argue that it 7)_ increased (increase) technical experience and8)_ enhanced_ (enhance) China’s competitiveness regarding 4G.\n1 A space engineer says we shouldpreserve_ the satellites after they finish their missionsin the same way we__ preserveships, aircraft and trains in museums.2 He works as a(n) _ consultant for Chinese and foreign institutions and gives advice onenvironmental protection.3 China’s space industry has witnessed rapid progress since 2011.4 Jiaozi (交子) first appeared in the Northern Song Dynasty and is the earliest papercurrency in the world.5 If the cost of developing a technology is high, a more efficient way is to buy thetechnology abroad.6As China’s transport and industrial capacities have beenupgraded , China’s directexports and imports have tended to increase more rapidly.7Our products adopt advanced security measures; . _ likewise , our services protect banks’customers from identity theft.8 To make products creative, Steve Jobs encouraged and_ cultivated creativity of his staffin the company.\n1 Future generations will probably be able to atrip around the Earth in private spacecraft. 2 China is developing an advanced new spaceship_ capable_ of both flying in low-Earth orbit and landing on the Moon. 3 Taking into account the creativity and diligence of the Chinese, China’s remarkable development does not come as a surprise. 4 For the next few years, the satellite will travel further in the space and dig_ deeper to find its beauty. 5 China, as is widely recognized, has made great progress in science and technology. 6 This new product will help those who suffer from sleeplessness and view__ sleep as a luxury. 7 People are moving into urban centers at a record pace in search of high-paying jobs.\n1 Thousands of people had gathered along the road, hoping to catch L have L get a glimpse of their heroes. 2 To protect their living environment, the local people opposed the plan to construct one more coal-fired power plant that would undoubtedly bring air pollution. No one can foretell the result of an innovation, but the successful innovation aims from the beginning to become the standard setter, and to determine the direction of a new technology or a new industry. 4 The research group put forward a plan to the board of the company, intending to improve their efficiency of production in the following five years. 5 Product innovation involves the development of new products, changes in design of established products, or use of new materials in the production of established products. 6 He talked about his ambitious goal, but failed to mention any serious steps his company would take to reach L pursue the goal .\nThe four great inventions of ancient China refer to papermaking, gunpowder, printing and the compass. The statement was first 1) put forward by British sinologist (汉学家) Dr. Joseph Edkins and was later widely accepted by Chinese historians. These inventions enormously 2)_ promoted_ the development of China’s economy, politics and culture. The four inventions were introduced to the Western countries through various channels. They changed the appearance and 3)_ status_ of the things in the world. Would the explorer Marco Polo have 4)_ sailed across the ocean in the 13th century without a compass? Most Westerners are familiar 5) with the four inventions. In fact, if people dig a ittle deeper, they will 6)_ uncover a long list of China’s technological achievements, including the first paper currency in the world. That means China was 7) ahead of the time in science and technology in many areas, and that Chinese discoveries and innovations 8) contributed much to the development of world civilization. Today the world has 9) _ witnessed_ China’s greater advances in technology, mostly in the areas of power generation and transportation. It’s safe to say that China’s steady development into an industrial nation does not come as a(n) 10) surprise\nExplore 2We were first introduced to the idea ofvirtual reality (VR) in the 1999 sci-fi film, TheMatrix. In the multimillion-dollar film series,Keanu Reeves’ character, Neo, found himselfliving between two worlds and fighting badguys, generally making the whole concept ofVR seem pretty cool.Entertaining, yes. But realistic?While the 1990s version of VR we werepromised in films like The Matrix and Thelawnmower Man might remain firmly on thesilver screen, VR is the future.And it’s something we need to pay attentionto. As we see, VR isn’t going away. Theclearest sign that VR is the future came inJuly 2014 when Facebook bought OculusVR for a cool $2 billion. VR is growing, andbecoming more accessible by the day. Soon,itll be as commonplace as an iPhone.\nHere are just a few predictions for how VR will change our lives.GamingAs we’ve already touched on the Oculus Rift headset, it makes sense to start withgaming. After all, this is the most obvious - and demonstrated - example of VR in action.Facebook wouldn’t have acquired Oculus had it not seen the potential in VR, anothersign that it’s only going to get bigger.Even before it has gone mainstream, Oculus already supports a vast number of games.And this list is growing all the time. Sony and Samsung are also releasing similar VRheadsets, and the increased competition will force designers to make their games andexperiences more intense, immersive and impressive.Watching films3D films are nothing new, but they’ re not really as exciting and three-dimensional asthe audience were expecting. Just imagine how much the film experience could beenhanced when we throw VR into the mix.We’d be in control of the movie world. We can look around as we want, see the action fromdifferent angles, and choose where to give our full attention. This is all still theoretical atthe moment, but it really could change the way we watch films in the future.\nSeeing the worldWe all get a desire to travel every now and again, but money, responsibilities and dailylife all get in the way of us hopping on a plane and jetting off to sunnier climates.VR could help us see the world, without leaving our living rooms. We could tourmuseums and monuments remotely, take in some amazing scenery, and even just relaxon a “beach” - all without a passport.SurgeryThis is one area where VR is already being used, as it’s safer for trainee surgeons toperfect their techniques in a realistic environment. Fully interactive models can sufferfrom a selection of ailments, and surgeons can learn new techniques and trainees canput theory into practice without an unrealistic plastic model, or the pressure of a real-life situation.Space explorationSpace travel is expensive, not to mention nearly impossible for Joe Bloggs. The chancesof heading off into space are pretty slim even if you’re an astronaut. But VR makes thisexpensive - and sometimes dangerous - exploration, much easier.Scientists can safely explore from ground control, heading out much deeper into spacethan would be humanly possible otherwise. It’s a really exciting way VR could changeour lives.\nTraining and developmentPilots already use flight simulators but, like surgeons, could seriously benefit fromsomething a lot more realistic to help perfect their skills. There are already a wholehost of games where we can develop our skills, but even real pilots could benefit fromthe level of immersion virtual reality has to offer.Improving quality of life Lastly - but by no means least - virtual reality has the potential to transform the livesof those who aren’t capable of living a normal life. It gives them the opportunity toexplore and experience the world - even to do things we take for granted - and that’sthe biggest thing VR has to offer.The possibilities really are endless where virtual reality is concerned. It really doeshave the potential to change our lives and the world we live in. Time will tell whatkind of impact VR has, but one thing’s for sure - there’s so much more to virtual realitythan gaming.\n1 With the DSLR camera (数码单反相机) becoming more and more popular, its video functionhas really broken into the_ mainstream2 Smartphone apps can be brilliant, but | don’t think it___ realistic__ to expect the apps tosolve all our problems.3 As games blend our real and___ virtual_environments, should there be concern thatsome people will be less able to distinguish between the two?4 VR technology allows us to enjoy the___ scenery__ of a place without stepping outof home.5 Facebook is ready to make the application of virtual reality in our lives a(n) commonplace.6 NASA should provide its astronauts with lifetime health care for all ilnesses, even if theirailments_ do not necessarily stem from space.7 Chinese researchers have created a model for the_ prediction_ of cardiovascular (心血管的)disease risk, which will help prevent and manage the disease.8 A___vastnumber of vendors in China use WeChat’s wallet, so even if you buy aroasted sweet potato on the street, you will probably be able to pay with it.\nThough it is a sci-fi movie for children, it is by no means as simple as it may have firstappeared; it runs a strong sense of humor.We should be _ in control of the AI development, reaping its benefits and avoiding itspotential problems.Using technology in the classroom helps teachers satisfy students individually, not to mentionteach them how to find trustworthy sources online.It is said that if airlines saw the benefits of in-flight wi-fi_ in action , they would getplanes equipped faster.For sure__ we can come up with a way for the robot to ask a question when it is notsure of our commands.| resist getting a smartphone because I am afraid it would get in the way of enjoying my life,with all the temptations to waste time in a thousand different ways.\n翻译中国的四大发明，即造纸术、指南针、火药、印刷术，对世界文明的发展产生了巨大影响。( have .an impact on; civilization )\n The four great inventions of China, namely papermaking, the compass,gunpowder and printing, have had a great impact on the development ofthe world civilization.\n高铁给人们带来了极大的便利，也改变着人们的生活方式和工作模式。( pattern )\n High-speed rail has brought much convenience to people, and has alsoaltered people’s lifestyles and work patterns.\n在创新战略的推动下，中国一批具有世界顶尖水平的企业在航天研究、生命科学、金融科技等领域脱颖而出。( world top-level; distinguish )\n Encouraged by the innovation strategy, a number of world top-level Chineseenterprises have distinguished themselves in such fields as space research,life science and financial technologies.\n明代著名医药学家李时珍运用观察和实验、比较和分类、分析和综合的方法，积累了医学研究新经验。( medical expert; classification; synthesis; gather )\nLi Shizhen, the famous medical expert in the Ming Dynasty, adoptedmethods of observation and experiments, comparison and classification, andanalysis and synthesis to gather new experience in medical research.\nUnit 8Explore 1The stereotype of the hard-working Chinese has been around for a long time in theWest. As early as 1894, Arthur Smith, an American who spent 54 years in China, wrotebooks introducing the hard-working Chinese people to the world. In his book ChineseCharacteristics, Smith wrote about the diligence of not just a single group of Chinesepeople, but of all the Chinese: young and old, rich and poor, farmers and scholars.Smith is not the only foreign guest to note that the Chinese are an extremely hard-working people. In 1895, another American in Beiing noted that Chinese people oftenworked from dawn to dusk, seven days a week, tirelessly. Later, in the early 20thcentury, British and American government officials serving in China also commentedthat Chinese people were without rest. Carl Crow, an American newspaperman andbusinessman who opened up the first Western advertising agency in Shanghai, oncesaid:“If it is true that the devil can only find work for idle hands, then China must be aplace of very limited satanic activities.”Chinese literature and folklore have many moral tales about industrious farmers andpeasants. The willingness to work hard and make maximum use of time has beenhighly valued in China since ancient times. There are many stories about farmers whogo to their fields even during holidays, or of peasants who think not only of themselvesand their families, but also of their community and future descendants.The Chinese trait of being unselfish and hard-working continues. Today, unselfishthinking, combined with the willingness to work hard, has given the Chinese a globalreputation of having a stable and industrious workforce. Western employers note thatthe values and beliefs of the Chinese workforce are compelling: The Chinese valueeducation, the virtue of hard work, and self improvement. Whether working in thefields or in the factories, they are willing to do more and go beyond the minimum,\nbecause they assume that their work will benefit them and their families. Because ofthis extended benefit, the Chinese do not complain about working hard.This work ethic is not only for adults. All over China you will find children and youngstudents attending classes outside their regular studies. Students take courses, oftenuntil late at night and during the weekends. Part of these activities may be related tothe intense competition that Chinese students face, but part of them are based upon thedesire to excel academically.Why do Chinese people work so hard, regardless of age or occupation?One answer rests in socialization. Chinese people are socialized differently from召Westerners. They grow up with different values, including a different estimation aboutthe importance of working hard. Hard work is considered a virtue in Chinese culture,as opposed to a necessity in American culture. For youth, Chinese textbooks and socialactivities emphasize this as well.Hard work is also part of the national ethic. The Chinese leadership is committed tobuilding the country into a strong, successful, global nation and the country urges itscitizens to participate in this process. Diligence is part of political awareness. Moreover,this political awareness fits into the economic ethic of Chinese entrepreneurship.\nIn China, an entrepreneur is not just a small-time private business owner. He issomeone who is willing to invest his resources (land, labor, capital) and look towarda long-term goal. The Chinese entrepreneur seeks to improve his life and also thematerial well-being of a group around him - his family, his community, and his nation.True, Chinese entrepreneurs want security. They tend to be conservative and frugal,in opposition to Western risk-takers. They also tend to seek to benefit the group ratherthan themselves alone. This ethic is found not just among businessmen, but in everyoccupation, gender and age. The quest for material gain, a financially secure family,and a peaceful, prosperous nation have been the goals of Chinese people for ages.Today, Chinese culture also has strategies that allow for economic mobility. By diversifyinginvestments and extended study, many Chinese have become not only secure but also verywealthy. Could the Western world learn something from Chinese diligence? CertainlyChina’s current economy reflects cultural values that benefit all people.\na. the truthb. the rainC. cloudsd. friends’ expectationse. enjoying the rainf. spend the afternoon reading and make a pot of teag. damp weather and genuine rainforest\nI’ve got a deep secret few people understand and even fewer will admit to sharing. It’s time totell 1) _ a_ :I love the rain, deeply and more than the sun. At least | live in the rightplace, famous for its 2)_ gGray 3)_ Ccause many people around hereto suffer from emotional disorder. Yet I welcome 4).b_My reason for 5)elies in pure selfishness - when it’s raining outside, | don’t haveto do anything. Ican 6)fMaybe I’ll invite a few friends over to watch an oldmovie or play a board game.7) d (Friends’ expectations) are low and easy to meet.\n1 After graduation, she _ opened up_ a library in the countryside to enrich the local people’scultural life.2 The cultural exchange program will be more effective when combined with lectures andfield trips.3 When he arrived in China, he tried hard to change his habits and customs to___ fit intoChinese culture.4 China is committed to developing a friendly and cooperative relationship with all othercountries in the world.5 The Chinese custom of drinking hot water goes beyond simple preference; hot water isbelieved to lower the body’s temperature and restore the person’s health.6 International students bring differing cultural experiences, expectations, and learning stylesto the classroom thatallow for__ new perspectives to be introduced.7 The real value of this cross-cultural program___ rests in___ teaching our people a realisticatitude toward globalization.\n1 Practicing good corporate social responsibility (企业社会责任) can usuallyqivea company a good_ reputation_.2The Chinese. highly L greatly value_ social harmony and smoothness ofrelationships within the family.3 To protect consumers’ rights and ensure fair competition , the government iscareful to work out the laws about online shopping.4He informed me of the intense competition between students and howthey work hard to hopefully go to a famous university.5For long, the Chinese people have the/ a reputation of being afraid oflosing face or lian in Chinese.6 Ijust can’t stand people who complain loudly / constantly in public places.\nFor a long time, the Chinese trait of being hard-working has been observed in both Western booksand Chinese literature and folklore. The Chinese were described by some Westerners as beingwithout 1)__ rest. Since ancient times, the Chinese have highly valued the virtue of hardwork and making 2)maximum use of time. Today, Chinese work ethic, the 3)_ belief inhard work, continues to win a global respect. The Chinese never 4)_ complain_ about workinghard. Instead, they think of it as a(n) 5)_ virtue__ which benefits them and their families. Thatis why many Western employers nowadays would 6)preferChinese employees. They makeup a(n) 7) stableand industrious workforce. This work ethic is not only for adults. It is acommon phenomenon that children and young students in China attend classes at night or atweekends. They participate in these activities not only because of the intense competition thatthey face, but also because of their desire to 8)___ excel academically. Chinese 9) diligencehas played a vital role in China’s economic development. Thanks to this trait, many Chinese peoplehave become not only financially secure but also 10)_ wealthy\nExplore 2Whether you live in Cambodia or Scotland,Lithuania or America, you have probably heardof dragons. The Eastern dragon, called long inChina, may seem like a completely differentcreature from the Western dragon. Theirbehavior, their symbolism, and what they meanto society are quite different. The East seems tovalue dragons for their magic and beauty andholds them in high respect. However, it is a quitedifferent case in the West where dragons arehistorically viewed as monsters.\n2 In Chinese culture, the dragon is a symbol of virtue. Unlike Western dragons, orientaldragons are usually seen as kind and benevolent. Dragons have long been a symbol inChinese folklore and art. Temples and shrines have been built to honor them. In fact,the Chinese are sometimes referred to as“the descendants of the dragon.”Through the symbol of the dragon, many Chinese see qualities which they desireand value such as heroism, wisdom and power. The dragon is a protector. Legendhas it that the dragon controls the rain, rivers, lakes and the seas; they can protect theinnocent and give them safety. In real life, the Chinese have the Year of the Dragon. Itis said that anyone born in this year will be healthy, wealthy and wise. Historically, thedragon was associated with the emperor of China and used as a symbol to representimperial power. In order to emphasize the association, emperors wore robes with a dragon design, sat on a throne with carved dragons, and had his palace decorated withdragon of various patterns.Dragon idioms are common in China. Chinese idioms are usually made up of fourChinese characters, called chengyu. Many Westerners are familiar with the movieCrouching Tiger, Hidden Dragon, but do not know that this movie title is an idiommeaning “talents in hiding.’Likewise, the Chinese may include the character for dragon (“龙”) when naminga child. The character appears in the names of two famous movie stars that allWesterners know, Jackie Chan (Chenglong, meaning “becoming a dragon”) and BruceLee (Li Xiaolong, implying a “small dragon”).At special festivals, especially the Dragon Boat Festival, also called DuanwuFestival, dragon boat races play an important part. Typically, these are boatspaddled by a team of up to 20 paddlers with a drummer and a steersman. Theboats are generally with decorative dragon heads and tails. Dragon boat racingis also an important part of celebrations by ethnic Chinese outside China. Forexample, the dragon boat races held annually at Echo Park Lake in Los Angeles,California, are very popular.\nWestern dragons have traditionally been a symbol of evil. A typical Western dragonhas wings and sharp claws, and breathes fire. Many legends describe dragons asgreedy, keeping huge amounts of gold and other precious treasure. Dragons aremonsters to be conquered. They are seen to represent the dark side of humanity,including greed, lust, and violence. The conquest of a dragon represents theelimination of those evil instincts.An important English legend is Saint George and the Dragon, a tale of goodovercoming evil. As the story goes, there lived a dragon in a town and it oftenkilled the townspeople. One day when the king’s daughter was offered to thedragon, Saint George happened to travel here. He killed the dragon and rescuedthe princess.But not all Western dragons are considered monsters. To the west of England in Wales,the Red Dragon has long been a national symbol, and is not regarded as evil. TheWelsh myth tells the story of a red dragon that fought a lengthy battle with his foe andwas victorious. The Red Dragon is now depicted on the Welsh national flag.It can be almost impossible to talk about dragons without being influenced by one’scultural heritage. But, regardless of one’s culture, everyone can appreciate the beautyof the Nine Dragon Screen in Beiing’ s Forbidden City.\nFor Chinese people, the Qingming Festival, also known as the Tomb Sweeping Day, is atime to honor ancestors.In the legend of the White Snake, in order torescueher husband Xu Xian, BaiSuzhen used her powers to flood the temple where he was imprisoned.After the_ conquest of the Xiongnu nomads (游牧民), the Han emperor sent Zhang Qianto travel westward on a mission of peace.At some festivals in China, people hang_ decorative_ lanterns outside their doors.The Zhuang ethnic___ minority is China’s largest minority group with a long historyand glorious culture.As the two most-visited cities by foreign tourists, Bejjing and Shanghai boast rich tourismresources and uniqueoriental_charm.\nAs an auspicious (吉祥的) beast, kylin (麒麟) is heldhigh respect in China andis expected to bring harvest, fortune and longevity.You must have heardthe Great Wall in China. Do you know what it wasoriginally used for?Foreigners may know specific Chinese cultural symbols such as panda and green tea, butmore abstract ones like Chinese philosophies and thearts.This set is made uppaper-cut patterns, showing the customs and clothingcharacteristics of different areas in China.The Yellow River is referredas one of the cradles of Chinese civilization, andthe development of the civilization here is closely related to the agricultural production.Ancient Chinese people associated the lion_braveness and strength, andbelieved that the lion could drive away evil and protect humans and farm animals.\n翻译相传屈原投江后，人们划船前去营救，并向江中投放粽子。这就是端午节赛龙舟、吃粽子的由来。( drown )故宫博物院位于北京市中心的天安门广场北侧，建立在明朝和清朝的皇宫紫禁城的基础之.上。( the Palace Museum; the imperial palace )中国是茶叶的原产国，其喝茶的习惯通过古丝绸之路和其他贸易渠道传播到欧洲和很多其他地区。( the Silk Road; channels of trade )中国人讲究吃。吃不仅仅为解渴充饥，更蕴含着中国人认识事物、理解事物的哲理。( beparticular about; satisfy one’s hunger and thirst )\n","plink":"https://dxsummer.gitee.io/posts/30564382/"},{"title":"Step 3　该如何使用进阶的句子？","date":"2020-06-30T12:26:44.000Z","date_formatted":{"ll":"2020年6月30日","L":"2020/06/30","MM-DD":"06-30"},"updated":"2020-07-29T06:10:00.000Z","content":"Day05虚拟语气虚拟语气用来表示说的话不是事实或者是不可能发生的情况，而是一种愿望、建议、假设。虚拟语气有三种基本类型：与现在事实相反，与过去事实相反，与将来事实相反。\n\n\n与现在事实相反\nIf＋一般过去时，主语would＋原形V\n表示与现在事实相反的假设时，句型为“If＋一般过去时，主语＋should / would / might / could＋原形V”\n要特别注意的是，If句中的动词为过去式，如果所使用的是be动词，一律用were。例如：\nIf I were you, I would accept his suggestions.\n（如果我是你，我就会接受他的建议。）\n\n与过去事实相反\nIf＋过去完成时，主语＋would＋have p.p.（过去分词）\n表示与过去的事实相反的假设时，句型为”If＋had＋p.p., 主语＋should / would / might / could＋have＋p.p.“例如：\nIf you had been here yesterday, you would have seen her.\n（如果你昨天在这里，就能见到他了。）\n\n与未来事实相反\n\n几乎不可能发生→If＋一般过去时( did /were to do)，主语would＋原形V\n基本上与与现在事实相反的虚拟语气句型一样，句型为“If＋一般过去时，主语＋should / would / might / could＋原形V”，一样特别注意If句中的be动词，一律用were。例如：\nIf the sun were to disappear, you would win the jackpot.\n（如果太阳消失不见，那你就会赢得大奖。）→太阳不可能不见，所以你不可能赢得大奖\n\n有“万一“的含意→If＋should＋原形V, 主语＋should＋原形V\n如果与未来事实相反的假设句中，带有“万一”或“可能发生”的含意，那么句型请使用“If＋should＋原形V，主要句子用”should (shall) / would (will) / might(may) / could (can)＋原形V”。例如：\nIf Mike would come tomorrow, I will bring him to the best restaurant I have ever been.\n（如果迈克明天来的话，那我就会带他去我去过最好的餐厅。）→迈克明天可能会来，所以我可能会带他去最好的餐厅\nhave been to去过某地have gone to去了某地（没有回来）\n\n延伸用法，事半功倍！Learning Plus!\n虚拟语气的其他形式：\n省略 if 的虚拟语气句型\n句型1 “ Were＋主语，… ”\nWere I young, I would learn English well.\n（如果我还年轻，我要好好学英语。）\n句型2 “ Had＋主语 P. P. , … ”\nHad you been here earlier, you would have seen him.\n（你要是早点到这儿，你就见到他了。）\n句型3（ Should＋主语＋原形V , … ）\nShould that be true, the contract would be canceled.\n（如果那是真的，合约就该取消。）\n\n表示 “ 但愿 ” 的虚拟语气句型\n常使用“ I wish (that) / If only / Would that ” 等开头，\na) 后面接were或者动词过去式，以表示“目前无法实现的愿望”。\nb) 后面接过去完成时，表示“过去不能实现的愿望”。\nI wish that I didn’t have to go to work today.（我今天要能不上班就好了。）\n→目前无法实现的愿望\nWould that she could see her son now!\n（要是她现在能看到她的儿子就好了！）→目前无法实现的愿望\nIf only I knew her address.（我当时要是知道她的地址就好了。）\n→过去无法实现的愿望\nI wish I hadn’t said that.（真希望我当时没有说那些。）\n→过去无法实现的愿望\n\n语法观念例句示范01．If you should happen to see him, please give him my regards.\n如果你万一见到他，请代我向他致敬。\n\n02．If the sun were to disappear, what would the earth be like?\n万一太阳消失了，地球会变成什么样呢？\nwere to do和should do则只表示与将来事实相反，不用来表示和现在事实相反。\nWhat would    将会……样\n\n03．If I were free now, I might to call on him.\n如果我有时间，我可能去看他了。\n\n04．If you were in my shoes, what would you do?\n如果你站在我的立场，你会怎么做？\n\n05．If only she came here earlier.\n如果她当时可以早点来就好了。\n\n06．I could have finished the task if I had had more time.\n如果当时我有多一点时间，我就能完成这项任务。\n\n07．Had he not apologized to her, she would not have forgiven him.\n要不是他道歉，她那时是不会原谅他的。\n\n08．If I had worked hard when young, I would be well off now.\n如果我年轻时多努力一点，现在就能过得舒服些。\n语法观念辨析练习请选出正确的选项。\n01．He described the town as if he________it himself.\nA had seen\nB has seen\nC saw\nD sees\n02．He’s working hard for fear that he________.\nA should fall behind\nB fell behind\nC may fall behind\nD would fall behind\n03．Your advice that________till next week is reasonable.\nA she waits\nB she wait\nC wait she\nD she waited\n04．I’d rather you________anything about it for the time being.\nA do\nB didn’t do\nC don’t\nD didn’t\n05．He was very busy yesterday, otherwise he________to the meeting.\nA would come\nB came\nC would have come\nD had come\n06．If you had told me this information, I________some suggestions for you.\nA might make\nB would made\nC might have made\nD hade made\n07．I hadn’t expected James to apologize but I had hoped________.\nA him calling me\nB that he would call me\nC him to call me\nD that he call me\n08．It’s high time they________this road.\nA mend\nB mended\nC must have mended\nD will mend\n正确答案及题目译文：\n\nDay06被动语态\n英语中有两种语态：主动语态和被动语态。主动语态表示主语是动作的执行者。被动语态表示主语是动作的承受者，即行为动作的物件。\n被动语态的构成及物动词→would be+p.p.\n 英语语法中仅有及物动词有被动形式。其句型结构为“be＋及物动词（或短语）的过去分词”。另外，被动语态可以使用于各种时态，例如：\n 现在式：My mother is not easily deceived.（我妈妈不是容易上当受骗的。）\n 现在式：A new house was built in this town.（有一栋新房子盖在这个城市里。）\n 一般将来时：She will be successed to win this case.（这个案子她将会胜诉。）\n 一般过去将来时：Somebody said that this museum would be built in 5 months.（有人说这栋博物馆五个月内可以盖完。）\n 过去进行时：All the injured visitors were being taken care of by the nurses.（所有受伤的游客都有护士在照顾着。）\n 现在进行时：This subject is being discussed by all the department directors in company now.（所有的公司部门主管都在讨论这个话题。）\n\n“be”动词用于现在进行时表示说话者认为是短暂的、和平常不一样的、甚至是伪装的。He is being foolish. 他在装傻。He is being honest. 他表现得特别老实。She is being rude. 她故意表现粗鲁。I can’t understand why he is being so selfish.我不明白此时他为何如此自私。适合于此种用法的有：foolish愚蠢的，nice好的，kind好心的，careful细心的，patient耐心的，lazy懒惰的，silly傻的，rude粗鲁的，polite礼貌的，impolite无礼的等表示人的特性、性格的形容词。(“be”动词用于现在进行时表示人的行为，纯粹表示心理或生理的状态而不带有行动时或主语不是人时，“be”动词不能用于现在进行时)如： \nI am happy.(表语是纯粹的心理状态，不可用am being) 我很快乐。He’s tired.(表语是纯粹的生理状态，不可用is being) 他很疲倦。It’s hot today.(主语不是人，不可用is being) 今天很热。\n\n 现在完成时：The laundry has been done.（衣服已经都洗好了。）\n\n助动词→助动词＋be＋p.p.\n当句中动词为助动词型态时，转变为被动语态的句型结构为“助动词＋be＋p.p.”，例如：\nAll the players could be found in the gym.（所有的选手都可以在体育馆中被找到。）\n\n双宾语→间接宾语变主语，直接主语变保留宾语\n一个句型结构中，若是存在两个宾语，而需将句中的动词改为被动语态时，通常是将间接宾语往前拉作主语，直接宾语变成了保留宾语。如果主动结构中的直接宾语变为被动结构中的主语，这时在间接宾语前要加介词to（可省去）或for（不可省）。例如：\nThe doctor gave me a prescription.\n＝I was given a prescription by the doctor.\n＝A prescription was given to me by the doctor.\n（医生帮我开了一张处方笺。）\nMickey brought me a gift.\n＝I was brought a gift by Mickey.\n＝A gift was brought for me by Mickey.\n（米奇带了一份礼物给我。）\n\n宾语＋宾语补语→主动结构的宾语变成被动结构的主语，宾语补语不变：\n当句型中含有“宾语和宾语补语”的结构时，要转换为被动语态时，只需将主动结构中的宾语变为被动结构中的主语，宾语补语不变。例如：\nI painted all the wall purple.\n＝All the walls are painted purple by me.（所有的墙壁都被漆成紫色）\n\n被动语态的基本用法动作的执行者没必要提出，可被省略时\nThis plan will be finished next week.（这项计划下周就会完成。）\nFather told us that a swimming pool is being built in our town.\n（爸爸告诉我们镇上正在建造一座游泳池。）\n\n出于礼貌或婉转希望省略执行者时\nJohnny was considered to be a natural leader.\n（强尼被认为是一个天生的领导者。）\nMy brother is said to be a super star in the future.\n（有人说我弟弟日后会成为一个大明星。）\n\n强调动作的承受者时\nAll the desks are cleaned by me this morning.\n（所有的桌子我今天早上都打扫过了。）\nSome of the people in your office are asked to speak with lower voice.\n（你们办公室有些人被要求说话小声一点。）\n\n为了文章通顺\nThe president appeared, and was warmly applauded by the citizens.\n（当总统出现时，市民们给予热烈的掌声。）\n\n正式的通告：\nPassengers are requested to remain seated until the aircraft comes to a complete stop.（飞机停稳前，请乘客不要离开座位。）\n\n语法观念例句示范01．Paper was first made in China.\n纸张首先在中国被制作出来。\n\n02．He was laughed at by all people.\n他被所有人嘲笑。\n\n03．It’s said that this book has been translated into several languages.\n据说这本书被翻译成多种语言。\n\n04．Such questions are settled by us.\n这样的问题被我们解决了。\n\n05．I was frightened by his ghost story.\n我被他的鬼故事吓到了。\n\n06．A new public school will be built up in this town.\n一座新的公立学校将被建在这座城镇里。\n\n07．Plastic bags full of rubbish have been piled in streets.\n人们把装满垃圾的塑料袋堆放在街上。\n\n08．You will be asked a lot of strange questions.\n他们将会问你许多怪问题。\n\n09．It is generally considered impolite to ask one’s age, salary, marriage, etc.\n问别人的年龄、薪水、婚姻状况等通常被认为是不礼貌的。\n\n10．I was given ten minutes to decide whether I should accept the offer.\n我有两分钟来决定是否接受帮助。\n语法观念辨析练习请把下列句子改写成被动语态。\n01．A car knocked him down yesterday.\n\n02．Two doctors and ten nurses make up the medical team.\n\n03．Everybody likes this song.\n\n04．They have sold out all the red lanterns.\n\n05．He made the poor girl work 12 hours a day.\n\n06．Children saw the movie last week.\n\n07．We shouldn’t allow young children to drive.\n\n08．It is thought that he is coming.\n\n09．It is supposed that the ship has been sunk.\n\n10．You mustn’t throw away the old books.\n正确答案及题目译文：\n\n附加问句\n语调附加用句为接在陈述句后的简短问句，用意在加强语意或确认信息内容。\n语调上升→确认讯息→表示发话者不确定信息内容，希望对方给予意见。\n\n   →希望“确认”曼蒂今天“会”过来这里。\n语调下降→强调信息→用于发话者意图强调说明之信息。\n\n   →表示“强调”珊蒂“是”个好女孩。\n否定要缩写附加问句若为否定句（含有not），则通常以缩写形式出现。\nx　Sam is a student, is not he?\no　Sam is a student, isn’t he?\n一致性前后主语需一致\n附加问句的主语需与前面陈述句中的主语一致，且附加问句中的主语需使用与陈述句中相符的人称代名词。\n\n\n前后动词需一致\n附加问句中的时态需与陈述句保持一致。\n陈述句使用be动词，附加问句则使用am / are / is、am not / aren’t / isn’t；\n陈述句使用一般现在时，附加问句则使用do, did, does；\n陈述句使用一般过去时，附加问句则使用did；\n陈述句使用完成时，附加问句则使用have / has、haven’t / hasn’t；\n\n\n\n依目的决定肯定或否定说话者可以依其目的，来决定陈述句为肯定句或否定句。\n肯定（陈述句）＋否定（附加问句）→希望得到肯定答案\nYou love your children, don’t you？你爱你的孩子，不是吗？\nYes, I do．是的，我爱。\n\n否定（陈述句）＋肯定（附加问句）→希望得到否定的答案。\nYour teacher didn’t tell you to cheat, did she?（老师没叫你作弊，对吧？）\nNo, she didn’t.（对的，她没有。）\n\n延伸用法，事半功倍！祈使句\n建议或请求：\nLet’s go to the movies, shall we?（我们一起去看电影，好吗？）\nLet’s not talk about it, all right?（别再谈这件事了，好吗？）\nLet me take a look at this, will you?（让我看看，可以吗？）\nshall we是“我们做某事好吗？”will you是“您允许吗，同意吗？”\nall right (确保对方同意或理解) 如何\n\n命令：\nKeep quiet, will you?（保持安静，好吗？）\n\n邀请：\nHave a seat, won’t you?（坐下来，好吗？）\n\nthere为首的陈述句\nThere are many Japanese restaurants near here, aren’t there?\n（这附近有许多日本餐馆，不是吗？）\n语法观念例句示范01．Steven is the smartest boy in your class, isn’t he?\n史蒂芬是你班上最聪明的男生，对吗？\n\n02．You will not invite him to the party, will you?\n你不会邀请他来派对，对吧？\n\n03．I don’t have to go with you, do I?\n我不必跟你一起去，对吧？\n\n04．Joanna can baby-sit the kids tonight, can’t she?\n乔安娜今晚可以帮忙带小孩，对不对？\n\n05．You have done your homework, haven’t you?\n你们已经把作业做完了，不是吗？\n\n06．Peter was a pilot, wasn’t he?\n彼得曾经是个飞行员，对不对？\n\n07．I am the most beautiful woman in the world, am I not?\n我是世上最美丽的女人，对不对？\n\n08．We must do it by ourselves, mustn’t we?\n我们必须自己做这件事，对吗？\n\n09．Calm down, will you?\n冷静下来，好吗？\n\n10．There isn’t too much water left in the reservoir, is there?\n水库里没有剩下多少水了，是吗？\n语法观念辨析练习请选出题目中附加问句相对应的标准答案。\n01．They hadn’t have chance to talk, had they ?\nA No, they hadn’t.\nB Yes, they did.\n02．You don’t have to work late today, do you ?\nA No, I don’t.\nB Yes, we have.\n03．We have met before, haven’t we ?\nA Yes, we haven’t.\nB Yes, we have.\n04．They didn’t recognize who you are, did they ?\nA No, they didn’t.\nB No, they did.\n05．He will never cheat on me, will he ?\nA No, he won’t.\nB Yes, he won’t.\n06．You are my best friend, aren’t you ?\nA Yes, you are.\nB Yes, I am.\n07．They fell in love with each other at first sight, didn’t they ?\nA Yes, they did.\nB No, they have.\n08．You are invited to Jimmy’s birthday party, aren’t you ?\nA No, I didn’t.\nB Yes, I am.\n09．Mr. and Mrs. Lin have already gone to the airport, haven’t they ?\nA Yes, they have.\nB Yes, they did.\n10．It is a beautiful day, isn’t it ?\nA Yes, it is.\nB Yes, it isn’t.\n正确答案及题目译文：\n\n关系代名词关系代名词是指兼具代名词与连词双重作用的代名词。关系代名词所代表的名词或代名词就做“先行词”，句中该用何种代名词视先行词的种类而定。关系代名词的人称、格、数应该与先行词一致。\n普通关系代名词\n表示人的代名词表示人的关系代名词有who, whom, whose，除了前面有介词的宾格whom之外，who与whom均可用that代替。\n主格→who\n关系代名词who是人的主格，通常后面会直接接一个动作。例如：\n\n\n   （住在公园旁边的那个男孩是我新同学。）\n宾格→whom\n关系代名词whom是人的宾格，通常后面会接主语＋动词，有时会有介词，要视情况而定。例如：\n\n\n   （我不认识你早上在门口遇到的那个人。）\n\n   （和我在教室交谈的那位新同学非常害羞。）\n所有格→whose\n关系代名词whose是人的所有格，通常后面接名词＋动词。\n\n\n   （ 就是那个教授，我这个学期要听他的课。）\n表示物品的代名词表示物的关系代名词有which, whose。其中which可用that代替，但which前面有介词时除外。\n主格→which\n关系代名词which是用来代替没有生命的先行词，如果which后面接的是动词，它就是主格；\n\n\n宾格→which\n如果which后面接的是主语＋动词，它就是宾格。\n\n\n   （我在网上找的那些资讯帮了我很多。）→宾格\n所有格→whose\n关系代名词whose也可以表示物当所有格，whose前面的先行词接事物或动物，后面接名词，可用“of which”代替，但不可用that。\nThe house whose door is red is mine.（门是红色的那栋房子是我的。）\nThe house of which the roof was painted red is my mother’s.（那栋屋顶漆成红色的屋子是我妈妈的。）\n\n表示人和物品的关系代名词－that关系代名词that既可以表示人又可以表示物，可以做主格或宾格，不能为所有格。有些场合关系代名词只能用that，有的场合则不能用that。\n只能用关系代名词that的场合\n先行词同时有人和事物时，例如：\nI know the man and his dog that were dead in the accident.（我认识在事故中失去生命的那个人和他的狗。）\n\n先行词前有限定词，如最高级，序数词，the only, the same, the very, any, no, all, every等。\nThis is the greatest invent that I have ever seen.（这是我见过的最伟大的发明。）\nHe is the first student that goes into the classroom every day.（他是每天第一个到教室的学生。）\nHe is the only student that can answer the question.\n（他是唯一能回答这个问题的学生。）\n\n句首已有疑问词who、which，避免重复。\nWho is the boy that is standing over there?（站在那儿的那个男生是谁？）\n\n不能用关系代名词that的场合介词后面不可使用关系代名词that，例如：\nThis is the house in which he lives.（这是他住的房子。）\n\n逗号后面不可使用关系代名词that，例如：\nMy elder sister, who is in Paris, will come back tomorrow.\n（我那个住在巴黎的姐姐明天就会回来。）→我只有一个姐姐，而且住在巴黎。\n关系代名词与先行词之间有逗号，表示先行词具有唯一性；关系代名词和先行词之间无逗号，表示不止一个。\nMy elder sister who is in Paris will come back tomorrow.（我住在巴黎的姐姐，明天就会回来。）→我不止有一个姐姐，其他姐姐可能在其他地方。\n\n先行词是people, they, those不可使用关系代名词that。例如：\nPeople who can use their time well are happy.（会善用时间的人是快乐的。）\n\n语法观念例句示范01．The toy which belongs to me disappeared.\n那个属于我的玩具不见了。\n\n02．I have a friend whose father is an artist.\n我有一位朋友，他的爸爸是艺术家。\n\n03．The lady whom you talked to is my teacher.\n跟你说话的那位女士是我老师。\n\n04．Amy enjoys the food which her mother cooks.\n艾米喜欢她妈妈做的食物。\n\n05．I like the boy who has short hair.\n我喜欢留短发的那位男孩。\n\n06．The man about whom you were talking is my husband.\n你在谈论的那个人是我的丈夫。\n\n07．The book of which the cover is green is mine.\n那本封面是绿色的书是我的。\n\n08．Take any book that you like.\n碰到喜欢的书，你就带走。\n\n09．He is the first boy that came this morning.\n他是今天早上最先到的男孩。\n\n10．He borrowed a book whose author is a young lady.\n他借的那本书的作者是一位年轻小姐。\n语法观念辨析练习请以适当的关系代名词填入题目空格中。\n01．The kid and his cat________are in the garden are cute.\n02．That is the house in________they live.\n03．Do you know the girl________is crossing the street?\n04．This is the boy________I met at the station yesterday\n05．These are the photographs________I took last month.\n06．I’ve become good friends with several of the people________I met in my English class.\n07．The box________I mailed to my sister was heavy.\n08．The man________answered the phone was polite.\n正确答案及题目译文：\n\nDay07从句（名词从句、形容词从句、副词从句……）\n从句的种类名词从句→可做主语、宾语或补语用\n\n\n形容词从句→用以形容先行词\n\n副词从句→由连词引导的从句。有表示时间、地点、原因等的副词功能。\nAlthough you are young , you still need to show respect to others.\n（就算你还年轻，你还是得尊重别人。）\n\n名词从句的用法以that引导的从句：\n一个完整句子前面加上that使其成为另一个句子的主语、宾语或补语。有以下三种写法。\nthat从句当主语：That he is married is true.（他已婚这件事是真的）\nthat从句当补语：It is true that he is married.\nthat从句当宾语：I found out yesterday that he is married.\n\n以疑问词（who / where / how / when / what）引导的从句：\n通常以动词的宾语形式出现，例如：I’ll tell you where he is.（我会告诉你他在哪里。）→Where is he？作为tell的宾语，以间接问句方式出现。\n\n以if / whether引导的从句：\n也经常以动词的宾语形式出现，例如：\nDo you know if / whether he’s available now?（你知道他现在是否有空吗？）→if / whether… 从句作为know的宾语，以间接问句方式出现。\n\n形容词从句的用法以关系代名词（who / which / that / whom / whose）引导的从句：\nThe woman who is on the phone is my supervisor.（那个讲电话的女人是我的主管。）\n关系代名词who引导出的从句用来修饰前面的名词the woman。\n副词从句的用法以连词引导的具有副词功能的从句：\nWe were shocked when he told us the truth.（当他告诉我们实情时，我们很震惊。）→连词when引导出表示时间的副词从句。\nHe doesn’t like school because he has no friends there.（他因为没有朋友而不喜欢学校。）→连词because引导出表示原因的副词从句。\n语法观念例句示范01．That Jack passed all his exams is unbelievable.\n杰克通过所有的考试真是令人无法相信。\n\n02．I didn’t know that you two are friends.\n我不知道你们两个是朋友。\n\n03．It is exciting that we’re going to have dinner with the super star.\n我们将要和那位巨星共进晚餐，真是令人兴奋。\n\n04．He didn’t tell me whom he will invite to the party.\n他没跟我说会邀请谁来参加派对。\n\n05．I don’t know what you are talking about.\n我不知道你在讲什么。\n\n06．No one cares whether he’s coming or not.\n没人关心他要不要来。\n\n07．The car which he is driving was a gift from his parents.\n他现在开的那辆车是他父母送的礼物。\n语法观念辨析练习依句意填入正确的连词\n（that、which、where、how、what、who、whether、before等）。\n01．____he wants to be a woman terrified his parents.\n02．The man________is talking to Andy is an old friend of mine.\n03．I have no idea________I should believe him or not.\n04．We are all curious to know________Mr. and Mrs. Brown met each other.\n05．The farm________we’re visiting tomorrow is a famous tourist spot here.\n06．It is incredible________a man like him would be the hero of his country.\n07．Please show me the pictures________you took during your trip to London.\n08．You are lucky to find out________he is nothing but a liar before you marry him.\n正确答案及题目译文：\n\n倒装句全部倒装\n英语句子通常有两种语序：一种是自然语序，一种是倒装语序。将谓语的一部分或全部置于主语之前的语序叫做倒装语序。\n句型构成\n将整个谓语提到主语之前。例如：\nYou must on no condition go to Italy alone.\n→On no condition must you go Italy alone.\n（不管怎样你都必须自己去意大利。）\n\n使用时机\n2-1． 以here, there, now, then, out, in, up, down, off, away等方向性副词开头的句子，且句子主语是名词时，句子用完全倒装。例如：\nHere comes the bus.（公共汽车来了。）\n\nTIPS! 但如果主语是代词时，不能用倒装。 例如：Here it is.\n\n2-2． 当表示地点的介词短语放在句首，要倒装。用来强调语气，例如：on the wall, under the tree, in front of the house, in the middle of the room等。\nAt the foot of the hill lies a small river.（山脚下有一条小河。）\n2-3． 主语补语提到句首需用全部倒装。此句型常常是因为主语有较长修饰语，故以倒装呈现。\nAmong the goods are flowers, candies, and toys.（这些商品中有花，糖果，玩具。）\n2-4． 以so, nor, neither开头的句子。以so, nor, neither开头的句子使用倒装，用来表示前句所说的内容也适合另外的人或物。\nHe has been to London, so have I.（他去伦敦了，我也去了。）\n\n部分倒装\n句型构成\n将be动词／使役动词／助动词放在主语之前\nNot until last night did Sammy changed her mind.（直到昨天晚上，珊米才改变了主意。）\n\n使用时机\n2-1． 疑问句：疑问句中，一般须用部分倒装，例如：\nWhat do you think about the movie?（你认为这场电影怎么样？）\n\nTIPS!\n但当对句子的主语提问时，一般不用倒装语序。例如：\nWhat happened last night?\n（昨天晚上发生了什么事？）\n\n2-2． 否定词／半否定词／含有否定意思的短语／频率副词为句首：\n句中若以下列单词或短语为句首时，一般须用部分倒装。\na)否定词，例如：no, none, neither, nor, nobody, nothing, never\n\n","plink":"https://dxsummer.gitee.io/posts/1b9f695a/"},{"title":"Step9 字符串和字符串函数","date":"2020-06-27T06:47:03.000Z","date_formatted":{"ll":"2020年6月27日","L":"2020/06/27","MM-DD":"06-27"},"updated":"2020-07-12T06:09:18.000Z","content":"字符串和字符串函数本章介绍以下内容：\n函数：gets()、gets_s()、fgets()、puts()、fputs()、strcat()、strncat()、strcmp()、strncmp()、strcpy()、strncpy()、sprintf()、strchr()\n创建并使用字符串\n使用C库中的字符和字符串函数，并创建自定义的字符串函数\n使用命令行参数\n字符串是C语言中最有用、最重要的数据类型之一。虽然我们一直在使用字符串，但是要学的东西还很多。C 库提供大量的函数用于读写字符串、拷贝字符串、比较字符串、合并字符串、查找字符串等。通过本章的学习，读者将进一步提高自己的编程水平。\n表示字符串和字符串I/O第4章介绍过，字符串是以空字符（\\0）结尾的char类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过，由于字符串十分常用，所以 C提供了许多专门用于处理字符串的函数。本章将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。\n程序清单11.1演示了在程序中表示字符串的几种方式。\n程序清单11.1 strings1.c程序\n1234567891011121314151617//　 strings1.c#include　&lt;stdio.h&gt;#define　MSG　\"I　am　a　symbolic　string　constant.\"#define　MAXLENGTH　81int main(void)&#123;    char　words[MAXLENGTH]　=　\"I　am　a　string　in　an　array.\";    const char *pt1 = \"Something is pointing at me.\";    puts(\"Here　are　some　strings:\");    puts(MSG);    puts(words);    puts(pt1);    words[8]　=　'p';    puts(words);    return 0;&#125;和printf()函数一样，puts()函数也属于stdio.h系列的输入/输出函数。但是，与printf()不同的是，puts()函数只显示字符串，而且自动在显示的字符串末尾加上换行符。下面是该程序的输出：\n12345Here　are　some　strings:I　am　an　old-fashioned　symbolic　string　constant.I　am　a　string　in　an　array.Something　is　pointing　at　me.I　am　a　spring　in　an　array.我们先分析一下该程序中定义字符串的几种方法，然后再讲解把字符串读入程序涉及的一些操作，最后学习如何输出字符串。\n在程序中定义字符串程序清单11.1中使用了多种方法（即字符串常量、char类型数组、指向char的指针）定义字符串。程序应该确保有足够的空间储存字符串，这一点我们稍后讨论。\n字符串字面量（字符串常量）\n 用双引号括起来的内容称为字符串字面量（string literal），也叫作字符串常量（string constant）。双引号中的字符和编译器自动加入末尾的\\0字符，都作为字符串储存在内存中，所以&quot;I am a symbolic stringconstant.&quot;、&quot;I am a string in an array.&quot;、&quot;Something is pointed at me.&quot;、&quot;Here are some strings:&quot;都是字符串字面量。\n 从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：\n1char　greeting[50]=\"Hello,　and \"\"how　are\"\"　you\" \"　today!\"; 与下面的代码等价：\n1char greeting[50] = \"Hello, and how are you today!\"; 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（\\）：\n1printf(\"\\\"Run, Spot, run!\\\" exclaimed Dick.\\n\"); 输出如下：\n1\"Run, Spot, run!\" exclaimed Dick. 字符串常量属于静态存储类别（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为指向该字符串储存位置的指针。这类似于把数组名作为指向该数组位置的指针。如果确实如此，程序清单11.2中的程序会输出什么？\n 程序清单11.2 strptr.c程序\n12345678/* strptr.c -- 把字符串看作指针 */#include　&lt;stdio.h&gt;int main(void)&#123;    printf(\"%s, %p, %c\\n\", \"We\", \"are\", *\"space farers\");    return 0;&#125; printf()根据%s 转换说明打印 We，根据%p 转换说明打印一个地址。因此，如果”are”代表一个地址，printf()将打印该字符串首字符的地址（如果使用ANSI之前的实现，可能要用%u或%lu代替%p）。最后，*&quot;space farers&quot;表示该字符串所指向地址上储存的值，应该是字符串*&quot;space farers&quot;的首字符。是否真的是这样？下面是该程序的输出：\n1We, 0x100000f61, s\n字符串数组和初始化\n 定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m1：\n1const char m1[40] = \"Limit yourself to one line's worth.\"; const表明不会更改这个字符串。\n 这种形式的初始化比标准的数组初始化形式简单得多：\n1const char m1[40] = &#123; 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l','f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 'n', 'e','\\\",　's',　'　',　'w',　'o',　'r','t',　'h',　'.',　'\\0'&#125;; 注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。\n 在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）。所有未被使用的元素都被自动初始化为0（这里的0指的是char形式的空字符，不是数字字符0），如图11.1所示。\n\n\n通常，让编译器确定数组的大小很方便。回忆一下，省略数组初始化声明中的大小，编译器会自动计算数组的大小：\n\n1const char m2[] = \"If you can't think of anything, fake it.\";\n\n让编译器确定初始化字符数组的大小很合理。因为处理字符串的函数通常都不知道数组的大小，这些函数通过查找字符串末尾的空字符确定字符串在何处结束。\n\n让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式。\n\n12345int n=8;char cookies[1];　　　　// 有效char cakes[2 + 5];\t// 有效，数组大小是整型常量表达式char pies[2*sizeof(long double) + 1]; // 有效char crumbs[n];　　　　 // 在C99标准之前无效，C99标准之后这种数组是变长数组\n\n字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：\n\n1char car[10] = \"Tata\";\n\n那么，以下表达式都为真：\n\n1car == &amp;car[0]、*car == 'T'、*(car+1) == car[1] == 'a'。\n\n还可以使用指针表示法创建字符串。例如，程序清单11.1中使用了下面的声明：\n\n1const char *pt1 = \"Something is pointing at me.\";\n\n该声明和下面的声明几乎相同：\n\n1const char ar1[] = \"Something is pointing at me.\";\n\n以上两个声明表明，`pt1`和`ar1`都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。尽管如此，这两种形式并不完全相同。数组和指针\n 数组形式和指针形式有何不同？以上面的声明为例，数组形式（ar1[]）在计算机的内存中分配为一个内含29个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符&#39;\\0&#39;），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中（第 12 章将详细讲解）。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。\n 此后，编译器便把数组名ar1识别为该数组首元素地址（&amp;ar1[0]）的别名。这里关键要理解，在数组形式中，ar1是地址常量。不能更改ar1，如果改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。\n 指针形式（*pt1）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量pt1留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，++pt1将指向第 2 个字符（o）。\n 字符串字面量被视为const数据。由于pt1指向这个const数据，所以应该把pt1声明为指向const数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为const。\n 总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。程序清单11.3演示了这一点。\n 程序清单11.3 addresses.c程序\n123456789101112131415//　addresses.c　-- 字符串的地址#define　MSG　\"I'm　special\"#include　&lt;stdio.h&gt;int　main()&#123;    char　ar[]　=　MSG;    const char *pt = MSG;    printf(\"address　of　\\\"I'm　special\\\":　%p　\\n\",　\"I'm　special\");    printf(\"　address　ar:　%p\\n\",　ar);    printf(\"　address　pt:　%p\\n\",　pt);    printf(\"　address　of　MSG:　%p\\n\",　MSG);    printf(\"address　of　\\\"I'm　special\\\":　%p　\\n\",　\"I'm　special\");    return　0;&#125; 下面是在我们的系统中运行该程序后的输出：\n12345address　of　\"I'm　special\":　0x100000f10address　ar:　0x7fff5fbff858address　pt:　0x100000f10address　of　MSG:　0x100000f10address　of　\"I'm　special\":　0x100000f10 该程序的输出说明了什么？第一，pt和MSG的地址相同，而ar的地址不同，这与我们前面讨论的内容一致。第二，虽然字符串字面量&quot;I&#39;m special&quot;在程序的两个 printf()函数中出现了两次，但是编译器只使用了一个存储位置，而且与MSG的地址相同。编译器可以把多次使用的相同字面量储存在一处或多处。另一个编译器可能在不同的位置储存3个&quot;I&#39;m special&quot;。第三，静态数据使用的内存与ar使用的动态内存不同。不仅值不同，特定编译器甚至使用不同的位数表示两种内存。\n 数组和指针表示字符串的区别是否很重要？通常不太重要，但是这取决于想用程序做什么。我们来进一步讨论这个主题。\n\n数组和指针的区别\n 初始化字符数组来储存字符串和初始化指针来指向字符串有何区别（“指向字符串”的意思是指向字符串的首字符）？例如，假设有下面两个声明：\n12char heart[] = \"I love Tillie!\";const char *head = \"I love Millie!\"; 两者主要的区别是：数组名heart是常量，而指针名head是变量。那么，实际使用有什么区别？\n 首先，两者都可以使用数组表示法：\n123456for(i　=　0;　i　&lt;　6;　i++)putchar(heart[i]);putchar('\\n');for(i　=　0;　i　&lt;　6;　i++)putchar(head[i]);putchar('\\n'); 上面两段代码的输出是：\n12I　loveI　love 其次，两者都能进行指针加法操作：\n123456for　(i　=　0;　i　&lt;　6;　i++)putchar(*(heart + i));putchar('\\n');for　(i　=　0;　i　&lt;　6;　i++)putchar(*(head + i));putchar('\\n'); 输出如下：\n12I　loveI　love 但是，只有指针表示法可以进行递增操作：\n12while (*(head) != '\\0')　　/* 在字符串末尾处停止*/putchar(*(head++));　　/* 打印字符，指针指向下一个位置 */ 这段代码的输出如下：\n1I love Millie! 假设想让head和heart统一，可以这样做：\n1head = heart;　　 /* head现在指向数组heart */ 这使得head指针指向heart数组的首元素。\n 但是，不能这样做：\n1heart = head;　　 /* 非法构造，不能这样写 */ 这类似于x = 3;和3 = x;的情况。赋值运算符的左侧必须是变量（或概括地说是可修改的左值），如*pt_int。顺带一提，head = heart;不会导致head指向的字符串消失，这样做只是改变了储存在head中的地址。除非已经保存了&quot;I love Millie!&quot;的地址，否则当head指向别处时，就无法再访问该字符串。\n 另外，还可以改变heart数组中元素的信息：\n1heart[7]= 'M';或者 *(heart + 7) = 'M'; 数组的元素是变量（除非数组被声明为const），但是数组名不是变量。\n 我们来看一下未使用const限定符的指针初始化：\n1char *word = \"frame\"; 是否能使用该指针修改这个字符串？\n1word[1] = 'l'; // 是否允许？ 编译器可能允许这样做，但是对当前的C标准而言，这样的行为是未定义的。例如，这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。例如，下面的语句都引用字符串&quot;Klingon&quot;的一个内存位置：\n1234char *p1 = \"Klingon\";p1[0] = 'F'; // ok?printf(\"Klingon\");printf(\": Beware the %ss!\\n\", \"Klingon\"); 也就是说，编译器可以用相同的地址替换每个&quot;Klingon&quot;实例。如果编译器使用这种单次副本表示法，并允许p1[0]修改&#39;F&#39;，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量&quot;Klingon&quot;时实际上显示的是&quot;Flingon&quot;：\n1Flingon: Beware the Flingons! 实际上在过去，一些编译器由于这方面的原因，其行为难以捉摸，而另一些编译器则导致程序异常中断。因此，建议在把指针初始化为字符串字面量时使用const限定符：\n1const char *pl = \"Klingon\";　 // 推荐用法 然而，把非const数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。\n 总之，如果不修改字符串，不要用指针指向字符串字面量。\n\n字符串数组\n 如果创建一个字符数组会很方便，可以通过数组下标访问多个不同的字符串。程序清单11.4演示了两种方法：指向字符串的指针数组和char类型数组的数组。\n 程序清单11.4 arrchar.c程序\n123456789101112131415161718192021222324252627//　arrchar.c -- 指针数组，字符串数组#include　&lt;stdio.h&gt;#define　SLEN　40#define　LIM　5int　main(void)&#123;    const char *mytalents[LIM] = &#123;    \"Adding　numbers　swiftly\",    \"Multiplying　accurately\",　\"Stashing　data\",    \"Following　instructions　to　the　letter\",    \"Understanding　the　C　language\"    &#125;;    char yourtalents[LIM][SLEN]　=　&#123;    \"Walking　in　a　straight　line\",    \"Sleeping\",　\"Watching　television\",    \"Mailing　letters\",　\"Reading　email\"    &#125;;    int i;    puts(\"Let's　compare　talents.\");    printf(\"%-36s　 %-25s\\n\",　\"My　Talents\",　\"Your　Talents\");    for(i　=　0;　i　&lt;　LIM;　i++)    printf(\"%-36s　 %-25s\\n\",　mytalents[i],　yourtalents[i]);    printf(\"\\nsizeof　mytalents:　%zd,　sizeof　yourtalents:　%zd\\n\",    sizeof(mytalents),sizeof(yourtalents));    return　0;&#125; 下面是该程序的输出：\n12345678Let's　compare　talents.My　Talents　　　　　　　　　　　　　　　　　　　　　　　 Your　TalentsAdding　numbers　swiftly　　　　　　　　　　　　　　Walking　in　a　straight　lineMultiplying　accurately　　　　　　　　　　　　　　SleepingStashing　data　　　　　　　　　　　　　　　　　　　　　Watching　televisionFollowing　instructions　to　the　letter　　　Mailing　lettersUnderstanding　the　C　language　　　　　　　　　 Reading　emailsizeof　mytalents:　40,　sizeof　yourtalents:　200 从某些方面来看，mytalents和yourtalents非常相似。两者都代表5个字符串。使用一个下标时都分别表示一个字符串，如mytalents[0]和yourtalents[0]；使用两个下标时都分别表示一个字符，例如 mytalents[1][2]表示 mytalents 数组中第 2 个指针所指向的字符串的第 3 个字符&#39;l&#39;， yourtalents[1][2]表示youttalentes数组的第2个字符串的第3个字符&#39;e&#39;。而且，两者的初始化方式也相同。\n 但是，它们也有区别。mytalents数组是一个内含5个指针的数组，在我们的系统中共占用40字节。而yourtalents是一个内含5个数组的数组，每个数组内含40个char类型的值，共占用200字节。所以，虽然mytalents[0]和yourtalents[0]都分别表示一个字符串，但mytalents和yourtalents的类型并不相同。mytalents中的指针指向初始化时所用的字符串字面量的位置，这些字符串字面量被储存在静态内存中；而 yourtalents 中的数组则储存着字符串字面量的副本，所以每个字符串都被储存了两次。此外，为字符串数组分配内存的使用率较低。yourtalents 中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。\n 我们可以把yourtalents想象成矩形二维数组，每行的长度都是40字节；把mytalents想象成不规则的数组，每行的长度不同。图 11.2 演示了这两种数组的情况（实际上，mytalents 数组的指针元素所指向的字符串不必储存在连续的内存中，图中所示只是为了强调两种数组的不同）。\n\n\n综上所述，如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。mytalents 中的指针指向的字符串字面量不能更改；而yourtalentsde 中的内容可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。\n指针和字符串读者可能已经注意到了，在讨论字符串时或多或少会涉及指针。实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5中的程序。\n程序清单11.5 p_and_s.c程序\n12345678910111213/* p_and_s.c -- 指针和字符串 */#include　&lt;stdio.h&gt;int main(void)&#123;    const char *mesg = \"Don't be a fool!\";    const char *copy;    copy　=　mesg;    printf(\"%s\\n\",copy);    printf(\"mesg　=　%s;　&amp;mesg　=　%p;　value　=　%p\\n\",　mesg,　&amp;mesg,　mesg);    printf(\"copy　=　%s;　&amp;copy　=　%p;　value　=　%p\\n\",　copy,　&amp;copy,　copy);    return 0;&#125;注意\n如果编译器不识别%p，用%u或%lu代替%p。\n你可能认为该程序拷贝了字符串&quot;Don&#39;t be a fool!&quot;，程序的输出似乎也验证了你的猜测：\n123Don't　be　a　fool!mesg　=　Don't　be　a　fool!;　&amp;mesg　=　0x0012ff48;　value　=　0x0040a000copy　=　Don't　be　a　fool!;　&amp;copy　=　0x0012ff44;　value　=　0x0040a000我们来仔细分析最后两个printf()的输出。首先第1项，mesg和copy都以字符串形式输出（%s转换说明）。这里没问题，两个字符串都是&quot;Don&#39;t be a fool!&quot;。\n接着第2项，打印两个指针的地址。如上输出所示，指针mesg和copy分别储存在地址为0x0012ff48和0x0012ff44的内存中。\n注意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。mesg 和 copy 的值都是0x0040a000，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。语句copy = mesg;把mesg的值赋给copy，即让copy也指向mesg指向的字符串。\n为什么要这样做？为何不拷贝整个字符串？假设数组有50个元素，考虑一下哪种方法更效率：拷贝一个地址还是拷贝整个数组？通常，程序要完成某项操作只需要知道地址就可以了。如果确实需要拷贝整个数组，可以使用strcpy()或strncpy()函数，本章稍后介绍这两个函数。\n我们已经讨论了如何在程序中定义字符串，接下来看看如何从键盘输入字符串。\n字符串输入如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。\n分配空间要做的第 1 件事是分配空间，以储存稍后读入的字符串。前面提到过，这意味着必须要为字符串分配足够的空间。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间（计算机不会这样做，除非你编写一个处理这些任务的函数）。假设编写了如下代码：\n12char *name;scanf(\"%s\", name);虽然可能会通过编译（编译器很可能给出警告），但是在读入name时，name可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为scanf()要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，name可能会指向任何地方。大多数程序员都认为出现这种情况很搞笑，但仅限于评价别人的程序时。\n最简单的方法是，在声明时显式指明数组的大小：\n1char name[81];现在name是一个已分配块（81字节）的地址。还有一种方法是使用C库函数来分配内存，第12章将详细介绍。\n为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的函数：scanf()、gets()和fgets()。我们先讨论最常用gets()函数。\n不幸的gets()函数在读取字符串时，scanf()和转换说明%s只能读取一个单词。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。许多年前，gets()函数就用于处理这种情况。gets()函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。它经常和 puts()函数配对使用，该函数用于显示字符串，并在末尾添加换行符。程序清单11.6中演示了这两个函数的用法。\n程序清单11.6 getsputs.c程序\n123456789101112131415/*　getsputs.c　-- 使用 gets() 和 puts() */#include　&lt;stdio.h&gt;#define　STLEN　81int main(void)&#123;    char words[STLEN];    puts(\"Enter　a　string,　please.\");    gets(words);　// 典型用法    printf(\"Your　string　twice:\\n\");    printf(\"%s\\n\",　words);    puts(words);    puts(\"Done.\");    return 0;&#125;下面是该程序在某些编译器（或者至少是旧式编译器）中的运行示例：\n123456Enter　a　string,　please.I　want　to　learn　about　string　theory!Your　string　twice:I　want　to　learn　about　string　theory!I　want　to　learn　about　string　theory!Done.整行输入（除了换行符）都被储存在 words 中，puts(words)和 printf(&quot;%s\\n, words&quot;)的效果相同。\n下面是该程序在另一个编译器中的输出示例：\n1234567Enter　a　string,　please.warning:　this　program　uses　gets(),　which　is　unsafe.Oh,　no!Your　string　twice:Oh,　no!Oh,　no!Done.编译器在输出中插入了一行警告消息。每次运行这个程序，都会显示这行消息。但是，并非所有的编译器都会这样做。其他编译器可能在编译过程中给出警告，但不会引起你的注意。\n这是怎么回事？问题出在 gets()唯一的参数是 words，它无法检查数组是否装得下输入行。上一章介绍过，数组名会被转换成该数组首元素的地址，因此，gets()函数只知道数组的开始处，并不知道数组中有多少个元素。\n如果输入的字符串过长，会导致缓冲区溢出（buffer overflow），即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止；或者还有其他情况。为了让输入的字符串容易溢出，把程序中的STLEN设置为5，程序的输出如下：\n12345678Enter　a　string,　please.warning:　this　program　uses　gets(),　which　is　unsafe.I　think　I'll　be　just　fine.Your　string　twice:I　think　I'll　be　just　fine.I　think　I'll　be　just　fine.Done.Segmentation　fault:　11“Segmentation fault”（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的内存。\nC 提供解决某些编程问题的方法可能会导致陷入另一个尴尬棘手的困境。但是，为什么要特别提到gets()函数？因为该函数的不安全行为造成了安全隐患。过去，有些人通过系统编程，利用gets()插入和运行一些破坏系统安全的代码。\n不久，C 编程社区的许多人都建议在编程时摒弃 gets()。制定 C99 标准的委员会把这些建议放入了标准，承认了gets()的问题并建议不要再使用它。尽管如此，在标准中保留gets()也合情合理，因为现有程序中含有大量使用该函数的代码。而且，只要使用得当，它的确是一个很方便的函数。\n好景不长，C11标准委员会采取了更强硬的态度，直接从标准中废除了gets()函数。既然标准已经发布，那么编译器就必须根据标准来调整支持什么，不支持什么。然而在实际应用中，编译器为了能兼容以前的代码，大部分都继续支持gets()函数。不过，我们使用的编译器，可没那么大方。\ngets()的替代品过去通常用fgets()来代替gets()，fgets()函数稍微复杂些，在处理输入方面与gets()略有不同。C11标准新增的gets_s()函数也可代替gets()。该函数与gets()函数更接近，而且可以替换现有代码中的gets()。但是，它是stdio.h输入/输出函数系列中的可选扩展，所以支持C11的编译器也不一定支持它。\n1.fgets()函数（和fputs()）\nfgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。\nfgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。\n如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。\nfgets()函数的第3 个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。\n因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。程序清单11.7演示了fgets()和fputs()函数的用法。\n程序清单11.7 fgets1.c程序\n/*　fgets1.c　– 使用 fgets() 和 fputs() */\n#include　&lt;stdio.h&gt;\n#define　STLEN　14\nint　main(void)\n{\nchar　words[STLEN];\nputs(“Enter　a　string,　please.”);\nfgets(words,　STLEN,　stdin);\nprintf(“Your　string　twice　(puts(),　then　fputs()):\\n”);\nputs(words);\nfputs(words,　stdout);\nputs(“Enter　another　string,　please.”);\nfgets(words,　STLEN,　stdin);\nprintf(“Your　string　twice　(puts(),　then　fputs()):\\n”);\n","thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/c/Step9fengmian.jpg","plink":"https://dxsummer.gitee.io/posts/9e369547/"},{"title":"台儿庄之旅","date":"2020-06-21T15:19:41.000Z","date_formatted":{"ll":"2020年6月21日","L":"2020/06/21","MM-DD":"06-21"},"updated":"2020-06-25T14:06:40.000Z","content":"您好, 这里需要密码.","thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/note/台儿庄.jpg","plink":"https://dxsummer.gitee.io/posts/1dc37cc8/"},{"title":"Step1 Java程序设计概述","date":"2020-06-14T02:35:40.000Z","date_formatted":{"ll":"2020年6月14日","L":"2020/06/14","MM-DD":"06-14"},"updated":"2020-06-14T03:16:20.000Z","content":"Java程序设计平台本书的第1版是这样描写Java的：“作为一种计算机语言，Java的广告词确实有点夸大其辞。然而，Java的确是一种优秀的程序设计语言。作为一个名副其实的程序设计人员，使用Java无疑是一个好的选择。有人认为：Java将有望成为一种最优秀的程序设计语言，但还需要一个相当长的发展时期。一旦一种语言应用于某个领域，与现存代码的相容性问题就摆在了人们的面前。”\n我们的编辑手中有许多这样的广告词。这是Sun公司高层的某位不愿透露姓名的人士提供的（Sun是原先开发Java的公司）。Java有许多非常优秀的语言特性，本章稍后将会详细地讨论这些特性。由于相容性这个严峻的问题确实存在于现实中，所以，或多或少地还是有一些“累赘”被加到语言中，这就导致Java并不如想象中的那么完美无瑕。\n但是，正像我们在第1版中已经指出的那样，Java并不只是一种语言。在此之前出现的那么多种语言也没有能够引起那么大的轰动。Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。\n作为一名程序设计人员，常常希望能够有一种语言，它具有令人赏心悦目的语法和易于理解的语义（C++不是这样的）。与许多其他的优秀语言一样，Java完全满足了这些要求。有些语言提供了可移植性、垃圾收集等，但是，没有提供一个大型的库。如果想要有奇特的绘图功能、网络连接功能和数据库存取功能就必须自己动手编写代码。Java具备所有这些特性，它是一种功能齐全的出色语言，是一个高质量的执行环境，还提供了一个庞大的库。正是因为它集多种优势于一身，所以对广大的程序设计人员有着不可抗拒的吸引力。\nJava“白皮书”的关键术语Java的设计者已经编写了颇有影响力的“白皮书”，用来解释设计的初衷以及完成的情况，并且发布了一个简短的摘要。这个摘要用下面11个关键术语进行组织：\n1）简单性\n2）面向对象\n3）分布式\n4）健壮性\n5）安全性\n6）体系结构中立\n7）可移植性\n8）解释型\n9）高性能\n10）多线程\n11）动态性\n本节将提供一个小结，给出白皮书中相关的说明，这是Java设计者对各个关键术语的论述，另外还会根据我们对Java当前版本的使用经验，给出对这些术语的理解。\n注释：写这本书时，白皮书可以在www.oracle.com/technetwork/java/langenv-140151.html上找到。对于11个关键术语的论述请参看http://horstmann.com/corejava/java-an-overview/7Gosling.pdf。\n简单性人们希望构建一个无须深奥的专业训练就可以进行编程的系统，并且要符合当今的标准惯例。因此，尽管人们发现C++不太适用，但在设计Java的时候还是尽可能地接近C++，以便系统更易于理解。Java剔除了C++中许多很少使用、难以理解、易混淆的特性。在目前看来，这些特性带来的麻烦远远多于其带来的好处。\n的确，Java语法是C++语法的一个“纯净”版本。这里没有头文件、指针运算（甚至指针语法）、结构、联合、操作符重载、虚基类等（请参阅本书各个章节给出的C++注释，其中比较详细地解释了Java与C++之间的区别）。然而，设计者并没有试图清除C++中所有不适当的特性。例如，switch语句的语法在Java中就没有改变。如果你了解C++就会发现可以轻而易举地转换到Java语法。\nJava发布时，实际上C++并不是最常用的程序设计语言。很多开发人员都在使用Visual Basic和它的拖放式编程环境。这些开发人员并不觉得Java简单。很多年之后Java开发环境才迎头赶上。如今，Java开发环境已经远远超出大多数其他编程语言的开发环境。\n简单的另一个方面是小。Java的目标之一是支持开发能够在小型机器上独立运行的软件。基本的解释器以及类支持大约仅为40KB；再加上基础的标准类库和对线程的支持（基本上是一个自包含的微内核）大约需要增加175KB。\n在当时，这是一个了不起的成就。当然，由于不断的扩展，类库已经相当庞大了。现在有一个独立的具有较小类库的Java微型版（Java Micro Edition），这个版本适用于嵌入式设备。\n面向对象简单地讲，面向对象设计是一种程序设计技术。它将重点放在数据（即对象）和对象的接口上。用木匠打一个比方，一个“面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个“非面向对象的”木匠首先考虑的是所用的工具。在本质上，Java的面向对象能力与C++是一样的。\n开发Java时面向对象技术已经相当成熟。Java的面向对象特性与C++旗鼓相当。Java与C++的主要不同点在于多重继承，在Java中，取而代之的是更简单的接口概念。与C++相比，Java提供了更丰富的运行时自省功能（有关这部分内容将在第5章中讨论）。\n分布式Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。\n如今，这一点已经得到认可，不过在1995年，主要还是从C++或Visual Basic程序连接Web服务器。\n健壮性Java的设计目标之一在于使得Java编写的程序具有多方面的可靠性。Java投入了大量的精力进行早期的问题检测、后期动态的（运行时）检测，并消除了容易出错的情况……Java和C++最大的不同在于Java采用的指针模型可以消除重写内存和损坏数据的可能性。\nJava编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。至于第二点，对于曾经花费几个小时来检查由于指针bug而引起内存冲突的人来说，一定很喜欢Java的这一特性。\n安全性Java适用于网络/分布式环境。为了达到这个目标，在安全方面投入了很大精力。使用Java可以构建防病毒、防篡改的系统。\n从一开始，Java就设计成能够防范各种攻击，其中包括：\n原先，Java对下载代码的态度是“尽管来吧！”。不可信代码在一个沙箱环境中执行，在这里它不会影响主系统。用户可以确信不会发生不好的事情，因为Java代码不论来自哪里，都不能脱离沙箱。\n不过，Java的安全模型很复杂。Java开发包（Java Development Kit，JDK）的第一版发布之后不久，普林斯顿大学的一些安全专家就发现一些小bug会允许不可信的代码攻击主系统。\n最初，安全bug可以快速修复。遗憾的是，经过一段时间之后，黑客已经很擅长找出安全体系结构实现中的小漏洞。Sun以及之后的Oracle为修复bug度过了一段很是艰难的日子。\n遭遇多次高调攻击之后，浏览器开发商和Oracle都越来越谨慎。Java浏览器插件不再信任远程代码，除非代码有数字签名而且用户同意执行这个代码。\n注释：现在看来，尽管Java安全模型没有原先预想的那么成功，但Java在那个时代确实相当超前。微软提供了一种与之竞争的代码传输机制，其安全性完全依赖于数字签名。显然这是不够的，因为微软自身产品的任何用户都可以证实，知名开发商的程序确实会崩溃并对系统产生危害。\n体系结构中立编译器生成一个体系结构中立的目标文件格式，这是一种编译过的代码，只要有Java运行时系统，这些编译后的代码可以在许多处理器上运行。Java编译器通过生成与特定的计算机体系结构无关的字节码指令来实现这一特性。精心设计的字节码不仅可以很容易地在任何机器上解释执行，而且还可以动态地翻译成本地机器代码。\n当时，为“虚拟机”生成代码并不是一个新思路。诸如Lisp、Smalltalk和Pascal等编程语言多年前就已经采用了这种技术。\n当然，解释虚拟机指令肯定会比全速运行机器指令慢很多。然而，虚拟机有一个选项，可以将执行最频繁的字节码序列翻译成机器码，这一过程被称为即时编译。\nJava虚拟机还有一些其他的优点。它可以检测指令序列的行为，从而增强其安全性。\n可移植性与C和C++不同，Java规范中没有“依赖具体实现”的地方。基本数据类型的大小以及有关运算都做了明确的说明。\n例如，Java中的int永远为32位的整数，而在C/C++中，int可能是16位整数、32位整数，也可能是编译器提供商指定的其他大小。唯一的限制只是int类型的大小不能低于short int，并且不能高于long int。在Java中，数据类型具有固定的大小，这消除了代码移植时令人头痛的主要问题。二进制数据以固定的格式进行存储和传输，消除了字节顺序的困扰。字符串是用标准的Unicode格式存储的。\n作为系统组成部分的类库，定义了可移植的接口。例如，有一个抽象的Window类，并给出了在UNIX、Windows和Macintosh环境下的不同实现。\n选择Window类作为例子可能并不太合适。凡是尝试过的人都知道，要编写一个在Windows、Macintosh和10种不同风格的UNIX上看起来都不错的程序有多么困难。Java 1.0就尝试着做了这么一个壮举，发布了一个将常用的用户界面元素映射到不同平台上的简单工具包。遗憾的是，花费了大量的心血，却构建了一个在各个平台上都难以让人接受的库。原先的用户界面工具包已经重写，而且后来又再次重写，不过跨平台的可移植性仍然是个问题。\n不过，除了与用户界面有关的部分外，所有其他Java库都能很好地支持平台独立性。你可以处理文件、正则表达式、XML、日期和时间、数据库、网络连接、线程等，而不用操心底层操作系统。不仅程序是可移植的，Java API往往也比原生API质量更高。\n解释型Java解释器可以在任何移植了解释器的机器上执行Java字节码。由于链接是一个增量式且轻量级的过程，所以，开发过程也变得更加快捷，更加具有探索性。\n这看上去很不错。用过Lisp、Smalltalk、Visual Basic、Python、R或Scala的人都知道“快捷而且具有探索性”的开发过程是怎样的。你可以做些尝试，然后就能立即看到结果。Java开发环境并没有将重点放在这种体验上。\n高性能尽管对解释后的字节码性能已经比较满意，但在有些场合下还需要更加高效的性能。字节码可以（在运行时刻）动态地翻译成对应运行这个应用的特定CPU的机器码。\n使用Java的头几年，许多用户不同意这样的看法：性能就是“适用性更强”。然而，现在的即时编译器已经非常出色，以至于成了传统编译器的竞争对手。在某些情况下，甚至超越了传统编译器，原因是它们含有更多的可用信息。例如，即时编译器可以监控经常执行哪些代码并优化这些代码以提高速度。更为复杂的优化是消除函数调用（即“内联”）。即时编译器知道哪些类已经加载。基于当前加载的类集，如果特定的函数不会被覆盖，就可以使用内联。必要时，还可以撤销优化。\n多线程多线程可以带来更好的交互响应和实时行为。\n如今，我们非常关注并发性，因为摩尔定律行将完结。我们不再追求更快的处理器，而是着眼于获得更多的处理器，而且要让它们一直保持工作。不过，可以看到，大多数编程语言对于这个问题并没有显示出足够的重视。\nJava在当时很超前。它是第一个支持并发程序设计的主流语言。从白皮书中可以看到，它的出发点稍有些不同。当时，多核处理器还很神秘，而Web编程才刚刚起步，处理器要花很长时间等待服务器响应，需要并发程序设计来确保用户界面不会“冻住”。\n并发程序设计绝非易事，不过Java在这方面表现很出色，可以很好地管理这个工作。\n动态性从各种角度看，Java与C或C++相比更加具有动态性。它能够适应不断发展的环境。库中可以自由地添加新方法和实例变量，而对客户端却没有任何影响。在Java中找出运行时类型信息十分简单。\n当需要将某些代码添加到正在运行的程序中时，动态性将是一个非常重要的特性。一个很好的例子是：从Internet下载代码，然后在浏览器上运行。如果使用C或C++，这确实难度很大，不过Java设计者很清楚动态语言可以很容易地实现运行程序的演进。最终，他们将这一特性引入这个主流程序设计语言中。\n注释：Java成功地推出后不久，微软就发布了一个叫做J++的产品，它与Java有几乎相同的编程语言以及虚拟机。现在，微软不再支持J++，取而代之的是另一种名为C#的语言。C#与Java有很多相似之处，然而使用的却是完全不同的虚拟机。本书不准备介绍J++或C#语言。\nJava applet与Internet这里的想法很简单：用户从Internet下载Java字节码，并在自己的机器上运行。在网页中运行的Java程序称为applet。要使用applet，需要启用Java的Web浏览器执行字节码。不需要安装任何软件。任何时候只要访问包含applet的网页都会得到程序的最新版本。最重要的是，要感谢虚拟机的安全性，它让我们不必再担心来自恶意代码的攻击。\n在网页中插入一个applet就如同在网页中嵌入一幅图片。applet会成为页面的一部分。文本环绕着applet所占据的空间周围。关键的一点是这个图片是活动的。它可以对用户命令做出响应，改变外观，在运行它的计算机与提供它的计算机之间传递数据。\n图1-1展示了一个很好的动态网页的例子。Jmol applet显示了分子结构，这将需要相当复杂的计算。在这个网页中，可以利用鼠标进行旋转，调整焦距等操作，以便更好地理解分子结构。用静态网页就无法实现这种直接的操作，而applet却可以达到此目的（可以在http://jmol.sourceforge.net上找到这个applet）。\n![](https://gitee.com/DxSummer/pic/raw/master/img/java/Jmol applet.png “|block”)\n当applet首次出现时，人们欣喜若狂。许多人相信applet的魅力将会导致Java迅速地流行起来。然而，初期的兴奋很快就淡化了。不同版本的Netscape与Internet Explorer运行不同版本的Java，其中有些早已过时。这种糟糕的情况导致更加难于利用Java的最新版本开发applet。实际上，为了在浏览器中得到动态效果，Adobe的Flash技术变得相当流行。后来，Java遭遇了严重的安全问题，浏览器和Java浏览器插件变得限制越来越多。如今，要在浏览器中使用applet，这不仅需要一定的水平，而且要付出努力。例如，如果访问Jmol网站，可能会看到一个消息，警告你要适当地配置浏览器允许运行applet。\nJava发展简史本节将介绍Java的发展简史。这些内容来自很多出版资料（最重要的是SunWorld的在线杂志1995年7月刊上对Java创建者的专访）。\nJava的历史要追溯到1991年，由Patrick Naughton和James Gosling（一个全能的计算机奇才）带领的Sun公司的工程师小组想要设计一种小型的计算机语言，主要用于像有线电视转换盒这类的消费设备。由于这些消费设备的处理能力和内存都很有限，所以语言必须非常小且能够生成非常紧凑的代码。另外，由于不同的厂商会选择不同的中央处理器（CPU），因此这种语言的关键是不与任何特定的体系结构捆绑在一起。这个项目被命名为“Green”。\n代码短小、紧凑且与平台无关，这些要求促使开发团队设计一个可移植的语言，可以为虚拟机生成中间代码。\n不过，Sun公司的人都有UNIX的应用背景。因此，所开发的语言以C++为基础，而不是Lisp、Smalltalk或Pascal。不过，就像Gosling在专访中谈到的：“毕竟，语言只是实现目标的工具，而不是目标本身”。Gosling把这种语言称为“Oak”（这么起名的原因大概是因为他非常喜欢自己办公室外的橡树）。Sun公司的人后来发现Oak是一种已有的计算机语言的名字，于是，将其改名为Java。事实证明这是一个很有灵感的选择。\n1992年，Green项目发布了它的第一个产品，称之为“*7”。这个产品具有非常智能的远程控制。遗憾的是，Sun公司对生产这个产品并不感兴趣，Green项目组的人员必须找出其他的方法来将他们的技术推向市场。然而，没有一个标准消费品电子公司对此感兴趣。于是，Green项目组竞标了一个提供视频点播等新型服务的有线电视盒的项目，但没有成功（有趣的是，得到这个项目的公司的领导恰恰是开创Netscape公司的Jim Clark。Netscape公司后来对Java的成功给予了很大的帮助）。\nGreen项目（这时换了一个新名字——“First Person公司”）花费了1993年一整年以及1994年的上半年，一直在苦苦寻求其技术的买家。然而，一个也没有找到（Patrick Naughton，项目组的创立人之一，也是完成此项目大多数市场工作的人，声称为了销售这项技术，累计飞行了300000英里）。1994年First Person公司解散了。\n当这一切在Sun公司发生的时候，Internet的万维网也在日渐发展壮大。万维网的关键是把超文本页面转换到屏幕上的浏览器。1994年大多数人都在使用Mosaic，这是一个1993年出自伊利诺斯大学超级计算中心的非商业化的Web浏览器（Mosaic的一部分是由Marc Andreessen编写的。当时，他作为一名参加半工半读项目的本科生，编写了这个软件，每小时的薪水只有6.85美元。他后来成了Netscape公司的创始人之一和技术总监，可谓名利双收）。\n在接受SunWorld采访的时候，Gosling说在1994年中期，Java语言的开发者意识到：“我们能够建立一个相当酷的浏览器。我们已经拥有在客户机/服务器主流模型中所需要的体系结构中立、实时、可靠、安全——这些在工作站环境并不太重要，所以，我们决定开发浏览器。”\n实际的浏览器是由Patrick Naughton和Jonathan Payne开发的，并演变为HotJava浏览器。为了炫耀Java语言超强的能力，HotJava浏览器采用Java编写。设计者让HotJava浏览器具有在网页中执行内嵌代码的能力。这一“技术印证”在1995年5月23日的SunWorld上得到展示，同时引发了人们延续至今的对Java的狂热追逐。\n1996年年初，Sun发布了Java的第1个版本。人们很快地意识到Java1.0不能用来进行真正的应用开发。的确，可以使用Java 1.0来实现在画布上随机跳动的神经质的文本applet，但它却没有提供打印功能。坦率地说，Java 1.0的确没有为其黄金时期的到来做好准备。后来的Java 1.1弥补了其中的大多明显的缺陷，大大改进了反射能力，并为GUI编程增加了新的事件处理模型。不过它仍然具有很大的局限性。\n1998年JavaOne会议的头号新闻是即将发布Java 1.2版。这个版本取代了早期玩具式的GUI，并且它的图形工具箱更加精细而具有可伸缩性，更加接近“一次编写，随处运行”的承诺。在1998年12月Java 1.2发布三天之后，Sun公司市场部将其名称改为更加吸引人的“Java 2标准版软件开发工具箱1.2版”。\n除了“标准版”之外，Sun还推出了两个其他的版本：一个是用于手机等嵌入式设备的“微型版”；另一个是用于服务器端处理的“企业版”。本书主要讲述标准版。标准版的1.3和1.4版本对最初的Java 2版本做出了某些改进，扩展了标准类库，提高系统性能。当然，还修正了一些bug。在此期间，Java applet采用低调姿态，并淡化了客户端的应用，但Java却成为服务器端应用的首选平台。\n5.0版是自1.1版以来第一个对Java语言做出重大改进的版本（这一版本原来被命名为1.5版，在2004年的JavaOne会议之后，版本数字升至5.0）。经历了多年的研究，这个版本添加了泛型类型（generic type）（类似于C++的模板），其挑战性在于添加这一特性并没有对虚拟机做出任何修改。另外，还有几个受C#启发的很有用的语言特性：“for each”循环、自动装箱和注解。\n版本6（没有后缀.0）于2006年年末发布。同样，这个版本没有对语言方面再进行改进。但是，改进了其他性能，并增强了类库。\n随着数据中心越来越依赖于商业硬件而不是专用服务器，Sun Microsystems终于沦陷，于2009年被Oracle收购。Java的开发停滞了很长一段时间。直到2011年Oracle发布了Java的一个新版本，Java 7，其中只做了一些简单的改进。\n2014年，Java 8终于发布，在近20年中这个版本有了最大的改变。Java 8提供了一种“函数式”编程方式，可以很容易地表述并发执行的计算。所有编程语言都必须与时俱进，Java在这方面显示出非凡的能力。\n表1-1展示了Java语言以及类库的发展状况。可以看到，应用程序编程接口（API）的规模发生了惊人的变化。\n\n关于Java的常见误解在结束本章之前，我们列出了一些关于Java的常见误解，同时给出了解释。\n1.Java是HTML的扩展\nJava是一种程序设计语言；HTML是一种描述网页结构的方式。除了用于在网页上放置Java applet的HTML扩展之外，两者没有任何共同之处。\n2.使用XML，所以不需要Java\nJava是一种程序设计语言；XML是一种描述数据的方式。可以使用任何一种程序设计语言处理XML数据，而Java API对XML处理提供了很好的支持。此外，许多重要的第三方XML工具采用Java编写。有关这方面更加详细的信息请参看卷Ⅱ。\n3.Java是一种非常容易学习的程序设计语言\n像Java这种功能强大的语言大都不太容易学习。首先，必须将编写玩具式程序的轻松和开发实际项目的艰难区分开来。需要注意的是：本书只用了7章讨论Java语言。在两卷中，其他的章节介绍如何使用Java类库将Java语言应用到实际中去。Java类库包含了数千种类和接口以及数万个函数。幸运的是，并不需要知道它们中的每一个，然而，要想Java解决实际问题，还是需要了解不少内容的。\n4.Java将成为适用于所有平台的通用性编程语言\n从理论上讲，这是完全有可能的。但在实际中，某些领域其他语言有更出色的表现，比如，Objective C和后来的Swift在iOS设备上就有着无可取代的地位。浏览器中的处理几乎完全由JavaScript掌控。Windows程序通常都用C++或C#编写。Java在服务器端编程和跨平台客户端应用领域则很有优势。\n5.Java只不过是另外一种程序设计语言\nJava是一种很好的程序设计语言，很多程序设计人员喜欢Java胜过C、C++或C#。有上百种好的程序设计语言没有广泛地流行，而带有明显缺陷的语言，如：C++和Visual Basic却大行其道。\n这是为什么呢？程序设计语言的成功更多地取决于其支撑系统的能力，而不是优美的语法。人们主要关注：是否提供了易于实现某些功能的易用、便捷和标准的库？是否有开发工具提供商能建立强大的编程和调试环境？语言和工具集是否能够与其他计算基础架构整合在一起？Java的成功源于其类库能够让人们轻松地完成原本有一定难度的事情。例如：联网Web应用和并发。Java减少了指针错误，这是一个额外的好处，因此使用Java编程的效率更高。但这些并不是Java成功的全部原因。\n6.Java是专用的，应该避免使用\n最初创建Java时，Sun为销售者和最终用户提供了免费许可。尽管Sun对Java拥有最终的控制权，不过在语言版本的不断发展和新库的设计过程中还涉及很多其他公司。虚拟机和类库的源代码可以免费获得，不过仅限于查看，而不能修改和再发布。Java是“闭源的，不过可以很好地使用”。\n这种状况在2007年发生了戏剧性的变化，Sun声称Java未来的版本将在General Public License（GPL）下提供。Linux使用的是同一个开放源代码许可。Oracle一直致力于保持Java开源。只有一点美中不足——专利。根据GPL，任何人都可以得到专利许可，允许其使用和修改Java，不过仅限于桌面和服务器平台。如果你想在嵌入式系统中使用Java，就需要另外一个不同的许可，这很可能需要付费。不过，这些专利在未来十年就会到期，那时Java就完全免费了。\n7.Java是解释型的，因此对于关键的应用程序速度太慢了\n早期的Java是解释型的。现在Java虚拟机使用了即时编译器，因此采用Java编写的“热点”代码其运行速度与C++相差无几，有些情况下甚至更快。\n对于Java桌面应用速度慢，人们已经抱怨很多年了。但是，今天的计算机速度远比人们发出抱怨的时候快了很多。一个较慢的Java程序与几年前相当快的C++程序相比还要快一些。\n8.所有的Java程序都是在网页中运行的\n所有的Java applet都是在网页浏览器中运行的。这也恰恰是applet的定义，即一种在浏览器中运行的Java程序。然而，大多数Java程序是运行在Web浏览器之外的独立应用程序。实际上，很多Java程序都在Web服务器上运行并生成用于网页的代码。\n9.Java程序是主要的安全风险\n对于早期的Java，有过关于安全系统失效的报道，曾经一度引起公众哗然。研究人员将这视为一种挑战，即努力找出Java的漏洞，对applet安全模型的强度和复杂度发起挑战。随后，人们很快就解决了引发问题的所有技术因素。后来又发现了更严重的漏洞，而Sun以及后来的Oracle反应却过于迟缓。浏览器制造商则有些反应过度，他们甚至默认禁用了Java。客观地来讲，可以想想针对Windows可执行文件和Word宏有数百万种病毒攻击，并造成了巨大的损害，不过奇怪的是却很少有人批评被攻击平台的脆弱。\n有些系统管理员甚至在公司浏览器中禁用了Java，而同时却允许用户下载可执行文件和Word文档，实际上，这些带来的风险远甚于使用Java。尽管距离Java诞生已经20年之久，与其他常用的执行平台相比，Java还是安全得多。\n10.JavaScript是Java的简易版\nJavaScript是一种在网页中使用的脚本语言，它是由Netscape发明的，原来的名字叫做LiveScript。JavaScript的语法类似Java，除此之外，两者无任何关系。当然，名字有些相像。JavaScript的一个子集已经标准化为ECMA-262。与Java applet相比，JavaScript更紧密地与浏览器集成在一起。特别是JavaScript程序可以修改正在显示的文档，而applet只能在有限的区域内控制外观。\n11.使用Java可以用廉价的Internet设备取代桌面计算机\n当Java刚刚发布的时候，一些人打赌：肯定会有这样的好事情发生。一些公司已经生产出Java网络计算机的原型，不过用户还不打算放弃功能强大而便利的桌面计算机，而去使用没有本地存储而且功能有限的网络设备。当然，如今世界已经发生改变，对于大多数最终用户，常用的平台往往是手机或平板电脑。这些设备大多使用安卓平台，这是Java的衍生产物。学习Java编程肯定也对Android编程很有帮助。\n","plink":"https://dxsummer.gitee.io/posts/1fa13e13/"},{"title":"Step8 数组和指针","date":"2020-06-13T02:39:24.000Z","date_formatted":{"ll":"2020年6月13日","L":"2020/06/13","MM-DD":"06-13"},"updated":"2020-06-27T06:45:36.000Z","content":"本章介绍以下内容：\n关键字：static\n运算符：&amp;、*（一元）\n如何创建并初始化数组\n指针（在已学过的基础上）、指针和数组的关系\n编写处理数组的函数\n二维数组\n人们通常借助计算机完成统计每月的支出、日降雨量、季度销售额等任务。企业借助计算机管理薪资、库存和客户交易记录等。作为程序员，不可避免地要处理大量相关数据。通常，数组能高效便捷地处理这种数据。第 6 章简单地介绍了数组，本章将进一步地学习如何使用数组，着重分析如何编写处理数组的函数。这种函数把模块化编程的优势应用到数组。通过本章的学习，你将明白数组和指针关系密切。\n数组前面介绍过，数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。考虑下面的数组声明：\n123456789/* 一些数组声明*/int main(void)&#123;    float candy[365];　　　 /* 内含365个float类型元素的数组 */    char code[12];　　　　　/*内含12个char类型元素的数组*/    int states[50];　　　　 /*内含50个int类型元素的数组 */    ...&#125;方括号（[]）表明candy、code和states都是数组，方括号中的数字表明数组中的元素个数。\n要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。数组元素的编号从0开始，所以candy[0]表示candy数组的第1个元素，candy[364]表示第365个元素，也就是最后一个元素。读者对这些内容应该比较熟悉，下面我们介绍一些新内容。\n初始化数组数组通常被用来储存程序需要的数据。例如，一个内含12个整数元素的数组可以储存12个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。\n只储存单个值的变量有时也称为标量变量（scalar variable），我们已经很熟悉如何初始化这种变量：\n12int fix　=　1;float flax = PI * 2;代码中的PI已定义为宏。C使用新的语法来初始化数组，如下所示：\n12345int main(void)&#123;    int powers[8] = &#123;1,2,4,6,8,16,32,64&#125;; /* 从ANSI C开始支持这种初始化 */    ...&#125;如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（powers[0]），以此类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关键字static可解决此问题。第12章将详细讨论这个关键字）。\n程序清单10.1演示了一个小程序，打印每个月的天数。\n程序清单10.1 day_mon1.c程序\n123456789101112/* day_mon1.c -- 打印每个月的天数 */#include　&lt;stdio.h&gt;#define　MONTHS　12int　main(void)&#123;    int　days[MONTHS]　=　&#123;　31,　28,　31,　30,　31,　30,　31,　31,　30,　31,　30,　31　&#125;;    int　index;    for　(index　=　0;　index　&lt;　MONTHS;　index++)    \tprintf(\"Month　%2d　has　%2d　days.\\n\",　index　+　1,　days[index]);    return　0;&#125;该程序的输出如下：\n123456789101112Month　1　has　31　days.Month　2　has　28　days.Month　3　has　31　days.Month　4　has　30　days.Month　5　has　31　days.Month　6　has　30　days.Month　7　has　31　days.Month　8　has　31　days.Month　9　has　30　days.Month　10　has　31　days.Month　11　has　30　days.Month　12　has　31　days.这个程序还不够完善，每4年打错一个月份的天数（即，2月份的天数）。该程序用初始化列表初始化days[]，列表（用花括号括起来）中用逗号分隔各值。\n注意该例使用了符号常量 MONTHS 表示数组大小，这是我们推荐且常用的做法。例如，如果要采用一年13个月的记法，只需修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。\n注意 使用const声明数组\n有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用const声明和初始化数组。因此，程序清单10.1中初始化数组应改成：\n1const int days[MONTHS] = &#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 const 数据，因为一旦声明为 const，便不能再给它赋值。明确了这一点，就可以在后面的例子中使用const了。\n如果初始化数组失败怎么办？程序清单10.2演示了这种情况。\n程序清单10.2 no_data.c程序\n12345678910111213/* no_data.c -- 为初始化数组 */#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    int no_data[SIZE];　/* 未初始化数组 */    int　i;    printf(\"%2s%14s\\n\",　　　\"i\",　\"no_data[i]\");    for　(i　=　0;　i　&lt;　SIZE;　i++)    \tprintf(\"%2d%14d\\n\",　i,　no_data[i]);    return　0;&#125;该程序的输出如下（系统不同，输出的结果可能不同）：\n12345i　　　no_data[i]0　　　　　　　　　　01　　　　　 42049372　　　　　 42198543　　　2147348480使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。\n注意 存储类别警告\n数组和其他变量类似，可以把数组创建成不同的存储类别（storage class）。第12章将介绍存储类别的相关内容，现在只需记住：本章描述的数组属于自动存储类别，意思是这些数组在函数内部声明，且声明时未使用关键字static。到目前为止，本书所用的变量和数组都是自动存储类别。\n在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不能把本章的内容推广到其他存储类别。对于一些其他存储类别的变量和数组，如果在声明时未初始化，编译器会自动把它们的值设置为0。\n初始化列表中的项数应与数组的大小一致。如果不一致会怎样？我们还是以上一个程序为例，但初始化列表中缺少两个元素，如程序清单10.3所示：\n程序清单10.3 somedata.c程序\n12345678910111213/* some_data.c -- 部分初始化数组 */#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    int some_data[SIZE]　=　&#123;　1492,　1066　&#125;;    int i;    printf(\"%2s%14s\\n\",　　　\"i\",　\"some_data[i]\");    for(i　=　0;　i　&lt;　SIZE;　i++)    \tprintf(\"%2d%14d\\n\",　i,　some_data[i]);    return 0;&#125;下面是该程序的输出：\n12345i　some_data[i]0　　　　　　　14921　　　　　　　10662　　　　　　　　　03　　　　　　　　　0如上所示，编译器做得很好。当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。\n如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会毫不留情地将其视为错误。但是，没必要因此嘲笑编译器。其实，可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数（见程序清单10.4）\n程序清单10.4 day_mon2.c程序\n1234567891011/* day_mon2.c -- 让编译器计算元素个数 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int days[]　=　&#123;　31,　28,　31,　30,　31,　30,　31,　31,　30,　31　&#125;;    int index;    for(index　=　0;　index　&lt;　sizeof　days　/　sizeof　days[0];　index++)    \tprintf(\"Month　%2d　has　%d　days.\\n\",　index　+　1,　days[index]);    return 0;&#125;在程序清单10.4中，要注意以下两点。\n如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。\n注意for循环中的测试条件。由于人工计算容易出错，所以让计算机来计算数组的大小。sizeof运算符给出它的运算对象的大小（以字节为单位）。所以sizeof days是整个数组的大小（以字节为单位），sizeof day[0]是数组中一个元素的大小（以字节为单位）。整个数组的大小除以单个元素的大小就是数组元素的个数。\n下面是该程序的输出：\n12345678910Month　1　has　31　days.Month　2　has　28　days.Month　3　has　31　days.Month　4　has　30　days.Month　5　has　31　days.Month　6　has　30　days.Month　7　has　31　days.Month　8　has　31　days.Month　9　has　30　days.Month　10　has　31　days.我们的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小。我们初始化时用了10个值，结果就只打印了10个值！这就是自动计数的弊端：无法察觉初始化列表中的项数有误。\n还有一种初始化数组的方法，但这种方法仅限于初始化字符数组。我们在下一章中介绍。\n指定初始化器（C99）C99 增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它：\n1int arr[6] = &#123;0,0,0,0,0,212&#125;; // 传统的语法而C99规定，可以在初始化列表中使用带方括号的下标指明待初始化的元素：\n1int arr[6] = &#123;[5] = 212&#125;; // 把arr[5]初始化为212对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。程序清单10.5中的初始化比较复杂。\n程序清单10.5 designate.c程序\n123456789101112// designate.c -- 使用指定初始化器#include　&lt;stdio.h&gt;#define　MONTHS　12int　main(void)&#123;    int days[MONTHS]　=　&#123;　31,　28,　[4]　=　31,　30,　31,　[1]　=　29　&#125;;    int i;    for(i　=　0;　i　&lt;　MONTHS;　i++)    \tprintf(\"%2d　 %d\\n\",　i　+　1,　days[i]);    return 0;&#125;该程序在支持C99的编译器中输出如下：\n1234567891011121　　 312　　 293　　 04　　 05　　 316　　 307　　 318　　 09　　　010　　 011　　 012　　 0以上输出揭示了指定初始化器的两个重要特性。第一，如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：[4] = 31,30,31，那么后面这些值将被用于初始化指定元素后面的元素。也就是说，在days[4]被初始化为31后，days[5]和days[6]将分别被初始化为30和31。第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清单10.5中，初始化列表开始时把days[1]初始化为28，但是days[1]又被后面的指定初始化[1] = 29初始化为29。\n如果未指定元素大小会怎样？\n12int stuff[] = &#123;1, [6] = 23&#125;;　　　　 //会发生什么？int staff[] = &#123;1, [6] = 4, 9, 10&#125;;　//会发生什么？编译器会把数组的大小设置为足够装得下初始化的值。所以，stuff数组有7个元素，编号为0～6；而staff数组的元素比stuff数组多两个（即有9个元素）。\n给数组元素赋值声明数组后，可以借助数组下标（或索引）给数组元素赋值。例如，下面的程序段给数组的所有元素赋值：\n1234567891011/* 给数组的元素赋值 */#include　&lt;stdio.h&gt;#define　SIZE　50int main(void)&#123;int　counter,　evens[SIZE];for　(counter　=　0;　counter　&lt;　SIZE;　counter++)evens[counter]　=　2　*　counter;...&#125;注意这段代码中使用循环给数组的元素依次赋值。C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。下面的代码段演示了一些错误的赋值形式:\n12345678910/* 一些无效的数组赋值 */#define　SIZE　5int main(void)&#123;int oxen[SIZE] = &#123;5,3,2,8&#125;;　　　　 /* 初始化没问题 */int yaks[SIZE];yaks = oxen;　　　　　　　　　 /* 不允许 */yaks[SIZE] = oxen[SIZE];　　　 /* 数组下标越界 */yaks[SIZE] = &#123;5,3,2,8&#125;;　　　　/* 不起作用 */oxen数组的最后一个元素是oxen[SIZE-1]，所以oxen[SIZE]和yaks[SIZE]都超出了两个数组的末尾。\n数组边界在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明：\n1int doofi[20];那么在使用该数组时，要确保程序中使用的数组下标在0～19的范围内，因为编译器不会检查出这种错误（但是，一些编译器发出警告，然后继续编译程序）。\n考虑程序清单10.6的问题。该程序创建了一个内含4个元素的数组，然后错误地使用了-1～6的下标。\n程序清单10.6 bounds.c程序\n12345678910111213141516171819202122// bounds.c -- 数组下标越界#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    int value1　=　44;    int arr[SIZE];    int value2　=　88;    int i;    printf(\"value1　=　%d,　value2　=　%d\\n\",　value1,　value2);    for(i　=　-1;　i　&lt;=　SIZE;　i++)    \tarr[i] = 2 * i + 1;    for(i　=　-1;　i　&lt;　7;　i++)    \tprintf(\"%2d　%d\\n\",　i,　arr[i]);    printf(\"value1　=　%d,　value2　=　%d\\n\",　value1,　value2);    printf(\"address　of　arr[-1]:　%p\\n\",　&amp;arr[-1]);    printf(\"address　of　arr[4]:　%p\\n\",　&amp;arr[4]);    printf(\"address　of　value1:　%p\\n\",　&amp;value1);    printf(\"address　of　value2:　%p\\n\",　&amp;value2);    return 0;&#125;编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。下面是使用GCC的输出示例：\n1234567891011121314value1　=　44,　value2　=　88-1　-10　11　32　53　74　95　16246784946　32767value1　=　9,　value2　=　-1address　of　arr[-1]:　 0x7fff5fbff8ccaddress　of　arr[4]:　　0x7fff5fbff8e0address　of　value1:　　0x7fff5fbff8e0address　of　value2:　　0x7fff5fbff8cc注意，该编译器似乎把value2储存在数组的前一个位置，把value1储存在数组的后一个位置（其他编译器在内存中储存数据的顺序可能不同）。在上面的输出中，arr[-1]与value2对应的内存地址相同， arr[4]和value1对应的内存地址相同。因此，使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。\nC 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。\n还要记住一点：数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小：\n123456#define　SIZE　4int　main(void)&#123;    int arr[SIZE];    for(i　=　0;　i　&lt;　SIZE;　i++)    \t....这样做能确保整个程序中的数组大小始终一致。\n指定数组的大小本章前面的程序示例都使用整型常量来声明数组：\n123456#define　SIZE　4int　main(void)&#123;    int arr[SIZE];　　　　　// 整数符号常量    double lots[144];　　　 // 整数字面常量    ...在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。sizeof表达式被视为整型常量，但是（与C++不同）const值不是。另外，表达式的值必须大于0：\n1234567891011int n　=　5;int m　=　8;float a1[5];　　　　　　　　 // 可以float a2[5*2 + 1];　　　　 //可以float a3[sizeof(int) + 1]; //可以float a4[-4];　　　　　　　　// 不可以，数组大小必须大于0float a5[0];　　　　　　　　 // 不可以，数组大小必须大于0float a6[2.5];　　　　　　　 // 不可以，数组大小必须是整数float a7[(int)2.5];　　　　 // 可以，已被强制转换为整型常量float a8[n];　　　　　　　　 // C99之前不允许float a9[m];　　　　　　　　 // C99之前不允许上面的注释表明，以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为变长数组（variable-length array）或简称 VLA（C11 放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性）。\nC99引入变长数组主要是为了让C成为更好的数值计算语言。例如，VLA简化了把FORTRAN现有的数值计算例程库转换为C代码的过程。VLA有一些限制，例如，声明VLA时不能进行初始化。在充分了解经典的C数组后，我们再详细介绍VLA。\n多维数组气象研究员Tempest Cloud为完成她的研究项目要分析5年内每个月的降水量数据，她首先要解决的问题是如何表示数据。一个方案是创建60个变量，每个变量储存一个数据项（我们曾经提到过这一笨拙的方案，和以前一样，这个方案并不合适）。使用一个内含60个元素的数组比将建60个变量好，但是如果能把各年的数据分开储存会更好，即创建5个数组，每个数组12个元素。然而，这样做也很麻烦，如果Tempest决定研究50年的降水量，岂不是要创建50个数组。是否能有更好的方案？\n处理这种情况应该使用数组的数组。主数组（master array）有5个元素（每个元素表示一年），每个元素是内含12个元素的数组（每个元素表示一个月）。下面是该数组的声明：\n1float rain[5][12]; // 内含5个数组元素的数组，每个数组元素内含12个float类型的元素理解该声明的一种方法是，先查看中间部分（粗体部分）：\n1float rain[5][12]; // rain是一个内含5个元素的数组这说明数组rain有5个元素，至于每个元素的情况，要查看声明的其余部分（粗体部分）：\n1floatrain[5][12] ; // 一个内含12个float类型元素的数组这说明每个元素的类型是float[12]，也就是说，rain的每个元素本身都是一个内含12个float类型值的数组。\n根据以上分析可知，rain的首元素rain[0]是一个内含12个float类型值的数组。所以，rain[1]、rain[2]等也是如此。如果 rain[0]是一个数组，那么它的首元素就是 rain[0][0]，第 2 个元素是rain[0][1]，以此类推。简而言之，数组rain有5个元素，每个元素都是内含12个float类型元素的数组，rain[0]是内含12个float值的数组，rain[0][0]是一个float类型的值。假设要访问位于2行3列的值，则使用rain[2][3]（记住，数组元素的编号从0开始，所以2行指的是第3行）。\n\n该二维视图有助于帮助读者理解二维数组的两个下标。在计算机内部，这样的数组是按顺序储存的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。\n我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数组很直观，实现这些操作也很容易。程序清单10.7演示了这个程序。\n程序清单10.7 rain.c程序\n123456789101112131415161718192021222324252627282930313233343536373839/* rain.c　-- 计算每年的总降水量、年平均降水量和5年中每月的平均降水量 */#include　&lt;stdio.h&gt;#define MONTHS 12　　　// 一年的月份数#define YEARS　 5　　　 // 年数int main(void)&#123;    // 用2010～2014年的降水量数据初始化数组    const float rain[YEARS][MONTHS]　=    &#123;        &#123;　4.3,　4.3,　4.3,　3.0,　2.0,　1.2,　0.2,　0.2,　0.4,　2.4,　3.5,　6.6　&#125;,        &#123;　8.5,　8.2,　1.2,　1.6,　2.4,　0.0,　5.2,　0.9,　0.3,　0.9,　1.4,　7.3　&#125;,        &#123;　9.1,　8.5,　6.7,　4.3,　2.1,　0.8,　0.2,　0.2,　1.1,　2.3,　6.1,　8.4　&#125;,        &#123;　7.2,　9.9,　8.4,　3.3,　1.2,　0.8,　0.4,　0.0,　0.6,　1.7,　4.3,　6.2　&#125;,        &#123;　7.6,　5.6,　3.8,　2.8,　3.8,　0.2,　0.0,　0.0,　0.0,　1.3,　2.6,　5.2　&#125;    &#125;;    int year,month;    float subtot,total;    printf(\"　YEAR　　 RAINFALL　 (inches)\\n\");    for(year　=　0,　total　=　0;　year　&lt;　YEARS;　year++)    &#123;　　　　　　　　　　　　 // 每一年，各月的降水量总和        for(month　=　0,　subtot　=　0;　month　&lt;　MONTHS;　month++)        subtot+=rain[year][month];        printf(\"%5d　%15.1f\\n\",　2010　+　year,　subtot);        total += subtot;　 // 5年的总降水量    &#125;    printf(\"\\nThe　yearly　average　is　%.1f　inches.\\n\\n\",　total　/　YEARS);    printf(\"MONTHLY　AVERAGES:\\n\\n\");    printf(\"　Jan　 Feb　 Mar　 Apr　 May　 Jun　 Jul　 Aug　 Sep　 Oct　\");    printf(\"　Nov　 Dec\\n\");    for(month　=　0;　month　&lt;　MONTHS;　month++)    &#123;　　　　　　　　　　　　 // 每个月，5年的总降水量        for(year　=　0,　subtot　=　0;　year　&lt;　YEARS;　year++)        \tsubtot　+=　rain[year][month];        printf(\"%4.1f　\",　subtot　/　YEARS);    &#125;    printf(\"\\n\");    return 0;&#125;下面是该程序的输出：\n12345678910YEAR　　　RAINFALL　 (inches)2010　　　　　　　 32.42011　　　　　　　 37.92012　　　　　　　 49.82013　　　　　　　 44.02014　　　　　　　 32.9The　yearly　average　is　39.4　inches.MONTHLY　AVERAGES:Jan　Feb　Mar　Apr　May　Jun　Jul　Aug　Sep　Oct　Nov　Dec7.3　7.3　4.9　3.0　2.3　0.6　1.2　0.3　0.5　1.7　3.6　6.7学习该程序的重点是数组初始化和计算方案。初始化二维数组比较复杂，我们先来看较为简单的计算部分。\n程序使用了两个嵌套for循环。第1个嵌套for循环的内层循环，在year不变的情况下，遍历month计算某年的总降水量；而外层循环，改变year的值，重复遍历month，计算5年的总降水量。这种嵌套循环结构常用于处理二维数组，一个循环处理数组的第1个下标，另一个循环处理数组的第2个下标：\n123456for　(year　=　0,　total　=　0;　year　&lt;　YEARS;　year++)&#123; // 处理每一年的数据    for(month　=　0,　subtot　=　0;　month　&lt;　MONTHS;　month++)    ...// 处理每月的数据    ...//处理每一年的数据&#125;第2个嵌套for循环和第1个的结构相同，但是内层循环遍历year，外层循环遍历month。记住，每执行一次外层循环，就完整遍历一次内层循环。因此，在改变月份之前，先遍历完年，得到某月 5 年间的平均降水量，以此类推：\n123456for　(month　=　0;　month　&lt;　MONTHS;　month++)&#123; // 处理每月的数据    for(year　=　0,　subtot　=0;　year　&lt;　YEARS;　year++)    ...// 处理每年的数据    ...// 处理每月的数据&#125;初始化二维数组初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下：\n1sometype ar1[5] = &#123;val1, val2, val3, val4, val5&#125;;这里，val1、val2等表示sometype类型的值。例如，如果sometype是int，那么val1可能是7；如果sometype是double，那么val1可能是11.34，诸如此类。但是rain是一个内含5个元素的数组，每个元素又是内含12个float类型元素的数组。所以，对rain而言，val1应该包含12个值，用于初始化内含12个float类型元素的一维数组，如下所示：\n1&#123;4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6&#125;也就是说，如果sometype是一个内含12个double类型元素的数组，那么val1就是一个由12个double类型值构成的数值列表。因此，为了初始化二维数组rain，要用逗号分隔5个这样的数值列表：\n12345678const float rain[YEARS][MONTHS]　=&#123;    &#123;4.3,4.3,4.3,3.0,2.0,1.2,0.2,0.2,0.4,2.4,3.5,6.6&#125;,    &#123;8.5,8.2,1.2,1.6,2.4,0.0,5.2,0.9,0.3,0.9,1.4,7.3&#125;,    &#123;9.1,8.5,6.7,4.3,2.1,0.8,0.2,0.2,1.1,2.3,6.1,8.4&#125;,    &#123;7.2,9.9,8.4,3.3,1.2,0.8,0.4,0.0,0.6,1.7,4.3,6.2&#125;,    &#123;7.6,5.6,3.8,2.8,3.8,0.2,0.0,0.0,0.0,1.3,2.6,5.2&#125;&#125;;这个初始化使用了5个数值列表，每个数值列表都用花括号括起来。第1个列表的数据用于初始化数组的第1行，第2个列表的数据用于初始化数组的第2行，以此类推。前面讨论的数据个数和数组大小不匹配的问题同样适用于这里的每一行。也就是说，如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。\n初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。图10.2演示了这种初始化数组的方法。\n\n因为储存在数组rain中的数据不能修改，所以程序使用了const关键字声明该数组。\n其他多维数组前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组：\n1int box[10][20][30];可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组box想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。\n还有一种理解box的方法是，把box看作数组的数组。也就是说，box内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。或者，可以简单地根据所需的下标值去理解数组。\n通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推。在后面的程序示例中，我们只使用二维数组。\n指针和数组第9章介绍过指针，指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。我们很快就会学到，数组表示法其实是在变相地使用指针。\n我们举一个变相使用指针的例子：数组名是数组首元素的地址。也就是说，如果flizny是一个数组，下面的语句成立：\n1flizny == &amp;flizny[0]; // 数组名是该数组首元素的地址flizny 和&amp;flizny[0]都表示数组首元素的内存地址（&amp;是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值，如程序清单10.8所示。注意指针加上一个数时，它的值发生了什么变化（转换说明%p通常以十六进制显示指针的值）。\n程序清单10.8 pnt_add.c程序\n123456789101112131415161718// pnt_add.c -- 指针地址#include　&lt;stdio.h&gt;#define　SIZE　4int main(void)&#123;    short dates[SIZE];    short * pti;    short index;    double bills[SIZE];    double * ptf;    pti = dates;　// 把数组地址赋给指针    ptf　=　bills;    printf(\"%23s　%15s\\n\",　\"short\",　\"double\");    for(index　=　0;　index　&lt;　SIZE;　index++)    \tprintf(\"pointers　+　%d:　%10p　%10p\\n\",　index,　pti　+　index,　ptf　+　index);    return 0;&#125;下面是该例的输出示例：\n12345short　　　　　　　　doublepointers　+　0:　0x7fff5fbff8dc　0x7fff5fbff8a0pointers　+　1:　0x7fff5fbff8de　0x7fff5fbff8a8pointers　+　2:　0x7fff5fbff8e0　0x7fff5fbff8b0pointers　+　3:　0x7fff5fbff8e2　0x7fff5fbff8b8第2行打印的是两个数组开始的地址，下一行打印的是指针加1后的地址，以此类推。注意，地址是十六进制的，因此dd比dc大1，a1比a0大1。但是，显示的地址是怎么回事？\n120x7fff5fbff8dc + 1是否是0x7fff5fbff8de?0x7fff5fbff8a0 + 1是否是0x7fff5fbff8a8?我们的系统中，地址按字节编址，short类型占用2字节，double类型占用8字节。在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使指针指向的是标量变量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值）。\n\n现在可以更清楚地定义指向int的指针、指向float的指针，以及指向其他数据对象的指针。\n指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如double类型的变量）通常是该对象第一个字节的地址。\n在指针前面使用*运算符可以得到该指针所指向对象的值。\n指针加1，指针的值递增它所指向类型的大小（以字节为单位）。\n下面的等式体现了C语言的灵活性：\n123dates + 2 == &amp;date[2]　　　 // 相同的地址*(dates + 2) == dates[2]　 // 相同的值以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义ar[n]的意思是*(ar + n)。可以认为*(ar + n)的意思是“到内存的ar位置，然后移动n个单元，检索储存在那里的值”。\n顺带一提，不要混淆 *(dates+2)和*dates+2。间接运算符（*）的优先级高于+，所以*dates+2相当于(*dates)+2：\n12*(dates + 2)　// dates第3个元素的值*dates + 2　　// dates第1个元素的值加2明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指针表示法。运行程序清单 10.9后输出的结果和程序清单10.1输出的结果相同。\n程序清单10.9 day_mon3.c程序\n12345678910111213/* day_mon3.c -- uses pointer notation */#include　&lt;stdio.h&gt;#define　MONTHS　12int　main(void)&#123;    int days[MONTHS]　=　&#123;　31,　28,　31,　30,　31,　30,　31,　31,　30,　31,　30,　31　&#125;;    int index;    for(index　=　0;　index　&lt;　MONTHS;　index++)    \tprintf(\"Month　%2d　has　%d　days.\\n\",　index　+　1,    *(days + index));　//与 days[index]相同    return 0;&#125;这里，days是数组首元素的地址，days + index是元素days[index]的地址，而*(days + index)则是该元素的值，相当于days[index]。for循环依次引用数组中的每个元素，并打印各元素的内容。\n这样编写程序是否有优势？不一定。编译器编译这两种写法生成的代码相同。程序清单 10.9 要注意的是，指针表示法和数组表示法是两种等效的方法。该例演示了可以用指针表示数组，反过来，也可以用数组表示指针。在使用以数组为参数的函数时要注意这点。\n函数、数组和指针假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为marbles的int类型数组。应该如何调用该函数？也许是下面这样：\n1total = sum(marbles); // 可能的函数调用那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以实际参数marbles是一个储存int类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向int的指针：\n1int sum(int *ar); // 对应的函数原型sum()从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小：\n12345678int sum(int *ar) // 相应的函数定义&#123;    int i;    int total　=　0;    for(i = 0; i &lt; 10; i++)　　// 假设数组有10个元素    \ttotal += ar[i];　　　　// ar[i] 与 *(ar + i) 相同    return total;&#125;既然能使用指针表示数组名，也可以用数组名表示指针。另外，回忆一下，+=运算符把右侧运算对象加到左侧运算对象上。因此，total是当前数组元素之和。\n该函数定义有限制，只能计算10个int类型的元素。另一个比较灵活的方法是把数组大小作为第2个参数：\n12345678int sum(int *ar,int n)　　　 // 更通用的方法&#123;    int i;    int total　=　0;    for(i = 0; i &lt; n; i++)　　 // 使用 n 个元素    total += ar[i];　　　　// ar[i] 和 *(ar + i) 相同    return total;&#125;这里，第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数。\n关于函数的形参，还有一点要注意。只有在函数原型或函数定义头中，才可以用int ar[]代替int * ar：\n1int sum (int ar[], int n);int *ar形式和int ar[]形式都表示ar是一个指向int的指针。但是，int ar[]只能用于声明形式参数。第2种形式（int ar[]）提醒读者指针ar指向的不仅仅一个int类型值，还是一个int类型数组的元素。\n注意 声明数组形参\n因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把int ar[]和int * ar解释成一样。也就是说，ar是指向int的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：\n1234int sum(int *ar, int n);int sum(int *, int);int sum(int　ar[],　int　n);int sum(int　[],　int);但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：\n123456789int sum(int *ar, int n)&#123;\t// 其他代码已省略&#125;int sum(int ar[],　int n);&#123;\t//其他代码已省略&#125;可以使用以上提到的任意一种函数原型和函数定义。\n程序清单 10.10 演示了一个程序，使用 sum()函数。该程序打印原始数组的大小和表示该数组的函数形参的大小（如果你的编译器不支持用转换说明%zd打印sizeof返回值，可以用%u或%lu来代替）。\n程序清单10.10 sum_arr1.c程序\n1234567891011121314151617181920212223242526// sum_arr1.c -- 数组元素之和// 如果编译器不支持 %zd，用 %u 或 %lu 替换它#include　&lt;stdio.h&gt;#define　SIZE　10int sum(int　ar[],　int　n);int main(void)&#123;    int marbles[SIZE]　=　&#123;　20,　10,　5,　39,　4,　16,　19,　26,　31,　20　&#125;;    long answer;    answer　=　sum(marbles,　SIZE);    printf(\"The　total　number　of　marbles　is　%ld.\\n\",　answer);    printf(\"The　size　of　marbles　is　%zd　bytes.\\n\",    sizeof　marbles);    return 0;&#125;int sum(int ar[], int n)　　 // 这个数组的大小是？&#123;    int i;    int total　=　0;    for(i　=　0;　i　&lt;　n;　i++)    \ttotal　+=　ar[i];    printf(\"The　size　of　ar　is　%zd　bytes.\\n\",　sizeof　ar);    return total;&#125;该程序的输出如下：\n123The　size　of　ar　is　8　bytes.The　total　number　of　marbles　is　190.The　size　of　marbles　is　40　bytes.注意，marbles的大小是40字节。这没问题，因为marbles内含10个int类型的值，每个值占4字节，所以整个marbles的大小是40字节。但是，ar才8字节。这是因为ar并不是数组本身，它是一个指向 marbles 数组首元素的指针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8字节（其他系统中地址的大小可能不是8字节）。简而言之，在程序清单10.10中，marbles是一个数组， ar是一个指向marbles数组首元素的指针，利用C中数组和指针的特殊关系，可以用数组表示法来表示指针ar。\n使用指针形参函数要处理数组必须知道何时开始、何时结束。sum()函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。程序清单10.11演示了这种方法，同时该程序也表明了指针形参是变量，这意味着可以用索引表明访问数组中的哪一个元素。\n程序清单10.11 sum_arr2.c程序\n123456789101112131415161718192021222324/* sum_arr2.c -- 数组元素之和 */#include　&lt;stdio.h&gt;#define　SIZE　10int sump(int *start, int *end);int main(void)&#123;    int marbles[SIZE]　=　&#123;　20,　10,　5,　39,　4,　16,　19,　26,　31,　20　&#125;;    long answer;    answer　=　sump(marbles,　marbles　+　SIZE);    printf(\"The　total　number　of　marbles　is　%ld.\\n\",　answer);    return 0;&#125;/* 使用指针算法 */int sump(int * start, int * end)&#123;    int total　=　0;    while(start　&lt;　end)    &#123;        total += *start;　 // 把数组元素的值加起来        start++;　　　　　　// 让指针指向下一个元素    &#125;    return total;&#125;指针start开始指向marbles数组的首元素，所以赋值表达式total += *start把首元素（20）加给total。然后，表达式start++递增指针变量start，使其指向数组的下一个元素。因为start是指向int的指针，start递增1相当于其值递增int类型的大小。\n注意，sump()函数用另一种方法结束加法循环。sum()函数把元素的个数作为第2个参数，并把该参数作为循环测试的一部分：\n1for( i = 0; i &lt; n; i++)而sump()函数则使用第2个指针来结束循环：\n1while (start &lt; end)因为while循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素是end所指向位置的前一个元素。这意味着end指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。这使得 while循环的测试条件是有效的，因为 start在循环中最后的值是end。注意，使用这种“越界”指针的函数调用更为简洁：\n1answer = sump(marbles, marbles + SIZE);因为下标从0开始，所以marbles + SIZE指向数组末尾的下一个位置。如果end指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用下面的代码：\n1answer = sump(marbles, marbles + SIZE - 1);这种写法既不简洁也不好记，很容易导致编程错误。顺带一提，虽然C保证了marbles + SIZE有效，但是对marbles[SIZE]（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。\n还可以把循环体压缩成一行代码：\n1total += *start++;一元运算符*和++的优先级相同，但结合律是从右往左，所以start++先求值，然后才是*start。也就是说，指针start先递增后指向。使用后缀形式（即start++而不是++start）意味着先把指针指向位置上的值加到total上，然后再递增指针。如果使用*++start，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用(*start)++，则先使用start指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然*start++的写法比较常用，但是*(start++)这样写更清楚。程序清单10.12的程序演示了这些优先级的情况。\n程序清单10.12 order.c程序\n123456789101112131415/* order.c -- 指针运算中的优先级 */#include　&lt;stdio.h&gt;int data[2]　=　&#123;　100,　200　&#125;;int moredata[2]　=　&#123;　300,　400　&#125;;int main(void)&#123;    int * p1, *p2, *p3;    p1　=　p2　=　data;    p3　=　moredata;    printf(\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\",*p1, *p2, *p3);    printf(\"*p1++ = %d, *++p2 = %d, (*p3)++ = %d\\n\",*p1++, *++p2, (*p3)++);    printf(\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\",*p1, *p2, *p3);    return 0;&#125;下面是该程序的输出：\n123*p1 = 100,　 *p2 = 100,　　　*p3 = 300*p1++ = 100, *++p2 = 200,　(*p3)++ = 300*p1 = 200,　 *p2 = 200,　　　*p3 = 301只有(*p3)++改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。\n指针表示法和数组表示法从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。如程序清单10.10所示，使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然，如程序清单10.11所示。\n至于C语言，ar[i]和*(ar+1)这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用ar++这样的表达式。\n指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。\n指针操作可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作。为了显示每种操作的结果，该程序打印了指针的值（该指针指向的地址）、储存在指针指向地址上的值，以及指针自己的地址。如果编译器不支持%p 转换说明，可以用%u 或%lu 代替%p；如果编译器不支持用%td转换说明打印地址的差值，可以用%d或%ld来代替。\n程序清单10.13演示了指针变量的 8种基本操作。除了这些操作，还可以使用关系运算符来比较指针。\n程序清单10.13 ptr_ops.c程序\n12345678910111213141516171819202122232425262728293031323334// ptr_ops.c -- 指针操作#include　&lt;stdio.h&gt;int　main(void)&#123;    int　urn[5]　=　&#123;　100,　200,　300,　400,　500　&#125;;    int *ptr1,*ptr2,*ptr3;    ptr1 = urn;　　　　　　　// 把一个地址赋给指针    ptr2 = &amp;urn[2];　　　　 // 把一个地址赋给指针    // 解引用指针，以及获得指针的地址    printf(\"pointer　value,　dereferenced　pointer,　pointer　address:\\n\");    printf(\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\", ptr1, *ptr1, &amp;ptr1);    // 指针加法    ptr3　=　ptr1　+　4;    printf(\"\\nadding　an　int　to　a　pointer:\\n\");    printf(\"ptr1 + 4 = %p, *(ptr1 + 4) = %d\\n\", ptr1 + 4, *(ptr1 + 4));    ptr1++;　　　　　　　　　// 递增指针    printf(\"\\nvalues　after　ptr1++:\\n\");    printf(\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\", ptr1, *ptr1, &amp;ptr1);    ptr2--;　　　　　　　　　// 递减指针    printf(\"\\nvalues　after　--ptr2:\\n\");    printf(\"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\\n\", ptr2, *ptr2, &amp;ptr2);    --ptr1;　　　　　　　　　// 恢复为初始值    ++ptr2;　　　　　　　　　// 恢复为初始值    printf(\"\\nPointers　reset　to　original　values:\\n\");    printf(\"ptr1　=　%p,　ptr2　=　%p\\n\",　ptr1,　ptr2);    // 一个指针减去另一个指针    printf(\"\\nsubtracting　one　pointer　from　another:\\n\");    printf(\"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\\n\",　ptr2,　ptr1,　ptr2　-　ptr1);    // 一个指针减去一个整数    printf(\"\\nsubtracting　an　int　from　a　pointer:\\n\");    printf(\"ptr3　=　%p,　ptr3　-　2　=　%p\\n\",　ptr3,　ptr3　-　2);    return 0;&#125;下面是我们的系统运行该程序后的输出：\n1234567891011121314pointer value, dereferenced pointer, pointer address:ptr1 = 0x7fff5fbff8d0, *ptr1 =100, &amp;ptr1 = 0x7fff5fbff8c8adding an int to a pointer:ptr1 + 4 = 0x7fff5fbff8e0, *(ptr1 + 4) = 500values after ptr1++:ptr1 = 0x7fff5fbff8d4, *ptr1 =200, &amp;ptr1 = 0x7fff5fbff8c8values after --ptr2:ptr2 = 0x7fff5fbff8d4, *ptr2 = 200, &amp;ptr2 = 0x7fff5fbff8c0Pointers reset to original values:ptr1 = 0x7fff5fbff8d0, ptr2 = 0x7fff5fbff8d8subtracting one pointer from another:ptr2 = 0x7fff5fbff8d8, ptr1 = 0x7fff5fbff8d0, ptr2 - ptr1 = 2subtracting an int from a pointer:ptr3 = 0x7fff5fbff8e0, ptr3 - 2 = 0x7fff5fbff8d8下面分别描述了指针变量的基本操作。\n赋值：可以把地址赋给指针。例如，用数组名、带地址运算符（&amp;）的变量名、另一个指针进行赋值。在该例中，把urn数组的首地址赋给了ptr1，该地址的编号恰好是0x7fff5fbff8d0。变量ptr2获得数组urn的第3个元素（urn[2]）的地址。注意，地址应该和指针类型兼容。也就是说，不能把double类型的地址赋给指向int的指针，至少要避免不明智的类型转换。C99/C11已经强制不允许这样做。\n解引用：*运算符给出指针指向地址上储存的值。因此，*ptr1的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。\n取址：和所有变量一样，指针变量也有自己的地址和值。对指针而言，&amp;运算符给出指针本身的地址。本例中，ptr1 储存在内存编号为 0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即urn的地址。因此&amp;ptr1是指向ptr1的指针，而ptr1是指向utn[0]的指针。\n指针与整数相加：可以使用+运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此ptr1 +4与&amp;urn[4]等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。\n递增指针：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，ptr1++相当于把ptr1的值加上4（我们的系统中int为4字节），ptr1指向urn[1]（见图10.4，该图中使用了简化的地址）。现在ptr1的值是0x7fff5fbff8d4（数组的下一个元素的地址），*ptr的值为200（即urn[1]的值）。注意，ptr1本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。\n\n指针减去一个整数：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以ptr3 - 2与&amp;urn[2]等价，因为ptr3指向的是&amp;arn[4]。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。\n递减指针：当然，除了递增指针还可以递减\n递减指针：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素urn[1]。\n指针求差：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，ptr2 - ptr1得2，意思是这两个指针所指向的两个元素相隔两个int，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。\n比较：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。\n注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。\n在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。\n解引用未初始化的指针\n说到注意事项，一定要牢记一点：千万不要解引用未初始化的指针。例如，考虑下面的例子：\n12int *pt;// 未初始化的指针*pt = 5;　　　// 严重的错误为何不行？第2行的意思是把5储存在pt指向的位置。但是pt未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使用第12章将介绍的malloc()函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！\n12345double *pd;　// 未初始化的指针*pd =2.4;　　// 不要这样做假设int urn[3];int *ptr1,*ptr2;下面是一些有效和无效的语句：\n1234有效语句　　　　　　　　　　\t   无效语句ptr1++;　　　　　　　　　　　　  urn++;ptr2　=　ptr1　+　2;　　　　　  ptr2　=　ptr2　+　ptr1;ptr2　=　urn　+　1;　　　　　　 ptr2　=　urn　*　ptr1;基于这些有效的操作，C 程序员创建了指针数组、函数指针、指向指针的指针数组、指向函数的指针数组等。别紧张，接下来我们将根据已学的内容介绍指针的一些基本用法。指针的第 1 个基本用法是在函数间传递信息。前面学过，如果希望在被调函数中改变主调函数的变量，必须使用指针。指针的第 2 个基本用法是用在处理数组的函数中。下面我们再来看一个使用函数和数组的编程示例。\n保护数组中的数据编写一个处理基本类型（如，int）的函数时，要选择是传递int类型的值还是传递指向int的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。\n传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的。例如，下面的函数给数组的每个元素都加上一个相同的值：\n123456void add_to(double ar[],int n,double val)&#123;    int i;    for(i=0;i&lt;n;i++)    \tar[i]+=val;&#125;因此，调用该函数后，prices数组中的每个元素的值都增加了2.5：\n1add_to(prices, 100, 2.50);该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。\n然而，其他函数并不需要修改数据。例如，下面的函数计算数组中所有元素之和，它不用改变数组的数据。但是，由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。例如，下面示例中的ar[i]++会导致数组中每个元素的值都加1：\n12345678int sum(int ar[], int n) // 错误的代码&#123;    int i;    int total=0;    for(i=0;i&lt;n;i++)    \ttotal += ar[i]++;　// 错误递增了每个元素的值    return total;&#125;对形式参数使用const在K&amp;R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字const。例如，sum()函数的原型和定义如下：\n123456789int sum(const int ar[], int n); /* 函数原型 */int sum(const int ar[], int n) /* 函数定义 */&#123;    int i;    int total　=　0;    for(　i　=　0;　i　&lt;　n;　i++)    \ttotal　+=　ar[i];    return total;&#125;以上代码中的const告诉编译器，该函数不能修改ar指向的数组中的内容。如果在函数中不小心使用类似ar[i]++的表达式，编译器会捕获这个错误，并生成一条错误信息。\n这里一定要理解，这样使用const并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用const可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用const；如果编写的函数不用修改数组，那么在声明数组形参时最好使用const。\n程序清单10.14的程序中，一个函数显示数组的内容，另一个函数给数组每个元素都乘以一个给定值。因为第1个函数不用改变数组，所以在声明数组形参时使用了const；而第2个函数需要修改数组元素的值，所以不使用const。\n程序清单10.14 arf.c程序\n12345678910111213141516171819202122232425262728293031/* arf.c -- 处理数组的函数 */#include　&lt;stdio.h&gt;#define　SIZE　5void show_array(const　double　ar[],　int　n);void mult_array(double　ar[],　int　n,　double　mult);int main(void)&#123;    double dip[SIZE]　=　&#123;　20.0,　17.66,　8.2,　15.3,　22.22　&#125;;    printf(\"The　original　dip　array:\\n\");    show_array(dip,　SIZE);    mult_array(dip,　SIZE,　2.5);    printf(\"The　dip　array　after　calling　mult_array():\\n\");    show_array(dip,　SIZE);    return 0;&#125;/* 显示数组的内容 */void show_array(const　double　ar[],　int　n)&#123;    int i;    for(i　=　0;　i　&lt;　n;　i++)    \tprintf(\"%8.3f　\",　ar[i]);    putchar('\\n');&#125;/* 把数组的每个元素都乘以相同的值 */void mult_array(double　ar[],　int　n,　double　mult)&#123;    int i;    for(i　=　0;　i　&lt;　n;　i++)    \tar[i] *= mult;&#125;下面是该程序的输出：\n1234The　original　dip　array:20.000　　17.660　　　8.200　　　15.300　　22.220The　dip　array　after　calling　mult_array():50.000　　44.150　　　20.500　　38.250　　55.550注意该程序中两个函数的返回类型都是void。虽然mult_array()函数更新了dip数组的值，但是并未使用return机制。\nconst的其他内容我们在前面使用const创建过变量：\n1const double PI = 3.14159;虽然用#define指令可以创建类似功能的符号常量，但是const的用法更加灵活。可以创建const数组、const指针和指向const的指针。\n程序清单10.4演示了如何使用const关键字保护数组：\n123#define　MONTHS　12...const int days[MONTHS] =&#123;31,28,31,30,31,30,31,31,30,31,30,31&#125;;如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息：\n1days[9] = 44;　　 /* 编译错误 */指向const的指针不能用于改变值。考虑下面的代码：\n12double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double *pd = rates;　　 // pd指向数组的首元素第2行代码把pd指向的double类型的值声明为const，这表明不能使用pd来更改它所指向的值：\n123*pd = 29.89;　　　// 不允许pd[2] = 222.22;　　//不允许rates[0] = 99.99; // 允许，因为rates未被const限定无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。但是要注意，因为rates并未被声明为const，所以仍然可以通过rates修改元素的值。另外，可以让pd指向别处：\n1pd++; /* 让pd指向rates[1] -- 没问题 */指向 const 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。例如，程序清单 10.14中的show_array()函数原型如下：\n1void show_array(const double *ar, int n);关于指针赋值和const需要注意一些规则。首先，把const数据或非const数据的地址初始化为指向const的指针或为其赋值是合法的：\n12345double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double locked[4]　=　&#123;0.08,　0.075,　0.0725,　0.07&#125;;const double *pc = rates; // 有效pc = locked;　　　　　　　　 //有效pc = &amp;rates[3];　　　　　　　//有效然而，只能把非const数据的地址赋给普通指针：\n12345double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double locked[4]　=　&#123;0.08,　0.075,　0.0725,　0.07&#125;;double *pnc = rates;　// 有效pnc = locked;　　　　　 // 无效pnc = &amp;rates[3];　　　　// 有效这个规则非常合理。否则，通过指针就能改变const数组中的数据。\n应用以上规则的例子，如 show_array()函数可以接受普通数组名和 const 数组名作为参数，因为这两种参数都可以用来初始化指向const的指针：\n12show_array(rates,5);　　　 // 有效show_array(locked,4);　　　// 有效因此，对函数的形参使用const不仅能保护数据，还能让函数处理const数组。\n另外，不应该把const数组名作为实参传递给mult_array()这样的函数：\n12mult_array(rates,5,1.2);　　　// 有效mult_array(locked,4,1.2);　　 // 不要这样做C标准规定，使用非const标识符（如，mult_arry()的形参ar）修改const数据（如，locked）导致的结果是未定义的。\n\nconst还有其他的用法。\n\n例如，可以声明并初始化一个不能指向别处的指针，关键是const的位置：\n1234double rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;double *const pc = rates; // pc指向数组的开始pc = &amp;rates[2];　　　　　　　// 不允许，因为该指针不能指向别处*pc = 92.99;　　　　　　　 // 没问题 -- 更改rates[0]的值可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。\n\n最后，在创建指针时还可以使用const两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值：\n1234double　rates[5]　=　&#123;88.99,　100.12,　59.45,　183.11,　340.5&#125;;const double * const pc = rates;pc = &amp;rates[2];　　//不允许*pc = 92.99;　　　//不允许\n指针和多维数组\n像a[2][3] 这样的数组    a a[0] &amp;a[0][0] 相同    只要未完全说明的数组 像a a[0] a[1]都是地址 无需加&amp;    a[1]+1==&amp;a[1][1] a[0]+1==a[0][1] a==&amp;a[0][0]\n\n\np1  &amp;*p1 是&amp;x的地址    &amp;p1 是指针的地址\n\n指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数组。假设有下面的声明：\n1int zippo[4][2]; /* 内含int数组的数组 */然后数组名zippo是该数组首元素的地址。在本例中，zippo的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。下面，我们从指针的属性进一步分析。\n因为zippo是数组首元素的地址，所以zippo的值和&amp;zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址（即&amp;zippo[0][0]的值）相同。简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo和zippo[0]的值相同。\n给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。\n解引用一个指针（在指针前使用*运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素（zippo[0][0]）的地址，所以*(zippo[0])表示储存在zippo[0][0]上的值（即一个int类型的值）。与此类似，*zippo代表该数组首元素（zippo[0]）的值，但是zippo[0]本身是一个int类型值的地址。该值的地址是&amp;zippo[0][0]，所以*zippo就是&amp;zippo[0][0]。对两个表达式应用解引用运算符表明，**zippo与*&amp;zippo[0][0]等价，这相当于zippo[0][0]，即一个int类型的值。简而言之，zippo是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是双重间接（double indirection）的例子。\n显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否能用所学的知识解释程序清单10.15中的程序。该程序显示了一些地址值和数组的内容。\n程序清单10.15 zippo1.c程序\n12345678910111213141516/* zippo1.c --　zippo的相关信息 */#include　&lt;stdio.h&gt;int main(void)&#123;    int zippo[4][2]=&#123; &#123;2,4&#125;, &#123;6,8&#125;, &#123;1,3&#125;, &#123;5,7&#125;&#125;;    printf(\" zippo=%p, zippo+1=%p\\n\",zippo,zippo+1);    printf(\"zippo[0]=%p,zippo[0]+1=%p\\n\",zippo[0],zippo[0]+1);    printf(\"*zippo = %p,*zippo+1=%p\\n\",*zippo, *zippo + 1);    printf(\"zippo[0][0]　=　%d\\n\",　zippo[0][0]);    printf(\" *zippo[0] = %d\\n\", *zippo[0]);    printf(\" **zippo = %d\\n\", **zippo);    printf(\" zippo[2][1]　=　%d\\n\",　zippo[2][1]);    printf(\"*(*(zippo+2) + 1) = %d\\n\", *(*(zippo + 2) + 1));    return 0;&#125;下面是我们的系统运行该程序后的输出：\n12345678zippo=0x0064fd38,　　　　 zippo+1　=　0x0064fd40zippo[0]=0x0064fd38,　　zippo[0]+1　=　0x0064fd3c*zippo = 0x0064fd38,　　 *zippo+1 = 0x0064fd3czippo[0][0] =2*zippo[0] =2**zippo =2zippo[2][1]　=3*(*(zippo+2) + 1) = 3其他系统显示的地址值和地址形式可能不同，但是地址之间的关系与以上输出相同。该输出显示了二维数组zippo的地址和一维数组zippo[0]的地址相同。它们的地址都是各自数组首元素的地址，因而与&amp;zippo[0][0]的值也相同。\n尽管如此，它们也有差别。在我们的系统中，int是4 字节。前面讨论过，zippo[0]指向一个4 字节的数据对象。zippo[0]加1，其值加4（十六进制中，38+4得3c）。数组名zippo 是一个内含2个int类型值的数组的地址，所以zippo指向一个8字节的数据对象。因此，zippo加1，它所指向的地址加8字节（十六进制中，38+8得40）。\n该程序演示了zippo[0]和*zippo完全相同，实际上确实如此。然后，对二维数组名解引用两次，得到储存在数组中的值。使用两个间接运算符（*）或者使用两对方括号（[]）都能获得该值（还可以使用一个*和一对[]，但是我们暂不讨论这么多情况）。\n要特别注意，与 zippo[2][1]等价的指针表示法是((zippo+2) + 1)。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：\n\n12345678910int zippo[3][3]=&#123;&#123;5,2,3&#125;,&#123;4,5,6&#125;,&#123;7,8,9&#125;&#125;;zippo  : 000000000062FDF0 zippo+2: 000000000062FE08 \t// zippo + 2个 * 3个数 * int大小4B == &amp;zippo[2]    *(zippo+2)\t: 000000000062FE08 //zippo[2]*(zippo+2)+1: 000000000062FE0C   // zippo[2]+1 即&amp;zippo[2][1]*(*(zippo+2)+1): 0000000000000008   // zippo[2][1]*zippo[0]==zippo[0][0]*zippo[0]+1==zippo[0][0]+1以上分析并不是为了说明用指针表示法（*(*(zippo+2) + 1)）代替数组表示法（zippo[2][1]），而是提示读者，如果程序恰巧使用一个指向二维数组的指针，而且要通过该指针获取值时，最好用简单的数组表示法，而不是指针表示法。\n图10.5以另一种视图演示了数组地址、数组内容和指针之间的关系。\n\n指向多维数组的指针如何声明一个指针变量pz指向一个二维数组（如，zippo）？在编写处理类似zippo这样的二维数组时会用到这样的指针。把指针声明为指向int的类型还不够。因为指向int只能与zippo[0]的类型匹配，说明该指针指向一个int类型的值。但是zippo是它首元素的地址，该元素是一个内含两个int类型值的一维数组。因此，pz必须指向一个内含两个int类型值的数组，而不是指向一个int类型值，其声明如下：\n1int (* pz)[2];　　// pz指向一个内含两个int类型值的数组以上代码把pz声明为指向一个数组的指针，该数组内含两个int类型值。\n*先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针\n为什么要在声明中使用圆括号？因为[]的优先级高于*。考虑下面的声明：\n1int *pax[2];　　 // pax是一个内含两个指针元素的数组，每个元素都指向int的指针由于[]优先级高，先与pax结合，所以pax成为一个内含两个元素的数组。然后*表示pax数组内含两个指针。最后，int表示pax数组中的指针都指向int类型的值。因此，这行代码声明了两个指向int的指针。而前面有圆括号的版本，*先与pz结合，因此声明的是一个指向数组（内含两个int类型的值）的指针。程序清单10.16演示了如何使用指向二维数组的指针。\n程序清单10.16 zippo2.c程序\n123456789101112131415161718/* zippo2.c --　通过指针获取zippo的信息 */#include　&lt;stdio.h&gt;int main(void)&#123;    int zippo[4][2]　=　&#123;　&#123;2,4&#125;,　&#123;6,8&#125;,　&#123;1,3&#125;,　&#123;5,7&#125;　&#125;;    int(*pz)[2];    pz　=　zippo;    printf(\"　pz　=　%p,　pz　+　1　=　%p\\n\",pz,　pz　+　1);    printf(\"pz[0]　=　%p,　pz[0]　+　1　=　%p\\n\",　 pz[0],　pz[0]　+　1);    printf(\"　*pz = %p,　 *pz + 1 = %p\\n\",　 *pz, *pz + 1);    printf(\"pz[0][0]　=　%d\\n\",　pz[0][0]);    printf(\"　*pz[0] = %d\\n\", *pz[0]);    printf(\"　**pz = %d\\n\", **pz);    printf(\"　pz[2][1]　=　%d\\n\",　pz[2][1]);    printf(\"*(*(pz+2) + 1) = %d\\n\", *(*(pz + 2) + 1));    return 0;&#125;下面是该程序的输出：\n12345678pz　=　0x0064fd38,\t\tpz　+　1　=　0x0064fd40pz[0]　=　0x0064fd38,\t\tpz[0]　+　1　=　0x0064fd3c*pz = 0x0064fd38,\t\t*pz + 1 = 0x0064fd3cpz[0][0]　=　2*pz[0] = 2**pz = 2pz[2][1]　=　3*(*(pz+2) + 1) = 3系统不同，输出的地址可能不同，但是地址之间的关系相同。如前所述，虽然pz是一个指针，不是数组名，但是也可以使用 pz[2][1]这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：\n12zippo[m][n] == *(*(zippo + m) + n)pz[m][n] == *(*(pz + m) + n)指针的兼容性指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 int 类型的值赋给double类型的变量，但是两个类型的指针不能这样做。\n123456int　n=5;double　x;int *p1=&amp;n;double *pd=&amp;x;x = n;　　　　　　　// 隐式类型转换pd = p1;　　　　　　// 编译时错误更复杂的类型也是如此。假设有如下声明：\n12345int *pt;int (*pa)[3];int ar1[2][3];int ar2[3][2];int **p2; // 一个指向指针的指针有如下的语句：\n12345678pt = &amp;ar1[0][0];　// 都是指向int的指针pt = ar1[0];　　　 // 都是指向int的指针pt = ar1;　　　　　 // 无效pa = ar1;　　　　　 // 都是指向内含3个int类型元素数组的指针pa = ar2;　　　　　 // 无效p2 = &amp;pt;　　　　 // both pointer-to-int **p2 = ar2[0];　　 // 都是指向int的指针p2 = ar2;　　　　　 // 无效 解释加粗注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类型。例如，pt 指向一个 int类型值，而ar1指向一个内含3和int类型元素的数组。类似地，pa指向一个内含2个int类型元素的数组，所以它与ar1的类型兼容，但是ar2指向一个内含2个int类型元素的数组，所以pa与ar2不兼容。\n上面的最后两个例子有些棘手。变量p2是指向指针的指针，它指向的指针指向int，而ar2是指向数组的指针，该数组内含2个int类型的元素。所以，p2和ar2的类型不同，不能把ar2赋给p2。但是，*p2是指向int的指针，与ar2[0]兼容。因为ar2[0]是指向该数组首元素（ar2[0][0]）的指针，所以ar2[0]也是指向int的指针。\n一般而言，多重解引用让人费解。例如，考虑下面的代码：\n12345678int　x=20;const　int　y=23;int *p1 = &amp;x;const int *p2=&amp;y;const int **pp2;p1 = p2;　　　 // 不安全 -- 把const指针赋给非const指针p2 = p1;　　　 // 有效 -- 把非const指针赋给const指针pp2 = &amp;p1;　　// 不安全 –- 嵌套指针类型赋值前面提到过，把const指针赋给非const指针不安全，因为这样可以使用新的指针改变const指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非const指针赋给const指针没问题，前提是只进行一级解引用：\n1p2 = p1; // 有效 -- 把非const指针赋给const指针但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代码：\n123456const int **pp2; //pp2是p1指针的地址&amp;p1, *pp2是p1指向值的地址，即p1 **pp2是*p1的值int *p1;const int n=13;pp2 = &amp;p1;　　// 允许，但是这导致const限定符失效（根据第1行代码，不能通过*pp2修改它所指向的内容）*pp2 = &amp;n;　　// 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修改）*p1 = 10;//有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）发生了什么？如前所示，标准规定了通过非const指针更改const数据是未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编译包含以上代码的小程序，导致n最终的值是13，但是在相同系统下使用clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果都是未定义的。\nC const和C++ const\nC和C++中const的用法很相似，但是并不完全相同。区别之一是，C++允许在声明数组大小时使用const整数，而C却不允许。区别之二是，C++的指针赋值检查更严格：\n1234const int y;const int *p2=&amp;y;int *p1;p1=p2; // C++中不允许这样做，但是C可能只给出警告C++不允许把const指针赋给非const指针。而C则允许这样做，但是如果通过p1更改y，其行为是未定义的。\n函数和多维数组如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。\n下面，我们编写一个处理二维数组的函数。一种方法是，利用for循环把处理一维数组的函数应用到二维数组的每一行。如下所示：\n12345int junk[3][4]　=　&#123;　&#123;2,4,5,8&#125;,　&#123;3,5,6,9&#125;,　&#123;12,10,8,6&#125;　&#125;;int i,j;int total=0;for(i=0;i&lt;3;i++)total += sum(junk[i], 4); // junk[i]是一维数组记住，如果 junk 是二维数组，junk[i]就是一维数组，可将其视为二维数组的一行。这里，sum()函数计算二维数组的每行的总和，然后for循环再把每行的总和加起来。\n然而，这种方法无法记录行和列的信息。用这种方法计算总和，行和列的信息并不重要。但如果每行代表一年，每列代表一个月，就还需要一个函数计算某列的总和。该函数要知道行和列的信息，可以通过声明正确类型的形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组 junk 是一个内含 3个数组元素的数组，每个元素是内含4个int类型值的数组（即junk是一个3行4列的二维数组）。通过前面的讨论可知，这表明junk是一个指向数组（内含4个int类型值）的指针。可以这样声明函数的形参：\n1void somefunction(int (*pt)[4]);另外，如果当且仅当pt是一个函数的形式参数时，可以这样声明：\n1void somefunction(int pt[][4] );注意，第1个方括号是空的。空的方括号表明pt是一个指针。这样的变量稍后可以用作相同方法作为junk。下面的程序示例中就是这样做的，如程序清单10.17所示。注意该程序清单演示了3种等价的原型语法。\n程序清单10.17 array2d.c程序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152// array2d.c -- 处理二维数组的函数#include　&lt;stdio.h&gt;#define　ROWS　3#define　COLS　4void sum_rows(int ar[][COLS],int rows);void sum_cols(int [][COLS],int);　　　　// 省略形参名，没问题int sum2d(int(*ar)[COLS], int rows);　　// 另一种语法int main(void)&#123;    int junk[ROWS][COLS]　=　&#123; &#123;2,4,6,8&#125;,&#123;3,5,7,9&#125;,&#123;12,10,8,6&#125;&#125;;    sum_rows(junk,ROWS);    sum_cols(junk,　ROWS);    printf(\"Sum　of　all　elements　=　%d\\n\",　sum2d(junk,　ROWS));    return 0;&#125;void sum_rows(int ar[][COLS],int rows)&#123;    int r;    int c;    int tot;    for(r=0;r&lt;rows;r++)    &#123;        tot　=　0;        for(c=0;c&lt;COLS;c++)        \ttot+=ar[r][c];        printf(\"row　%d:　sum　=　%d\\n\",r,tot);    &#125;&#125;void sum_cols(int ar[][COLS],int rows)&#123;    int r;    int c;    int tot;    for(c=0;c&lt;COLS;c++)    &#123;        tot=0;        for(r=0;r&lt;rows;r++)        \ttot+=ar[r][c];        printf(\"col　%d:　sum　=　%d\\n\",c,tot);    &#125;&#125;int sum2d(int　ar[][COLS],　int　rows)&#123;    int r;    int c;    int tot　=　0;    for(r=0;r&lt;rows;r++)    \tfor(c=0;c&lt;COLS;c++)    \t\ttot+=ar[r][c];    return tot;&#125;该程序的输出如下：\n12345678row 0: sum = 20row 1: sum = 24row 2: sum = 36col 0: sum = 17col 1: sum = 19col 2: sum = 21col 3: sum = 23Sum of all elements = 80程序清单10.17中的程序把数组名junk（即，指向数组首元素的指针，首元素是子数组）和符号常量ROWS（代表行数3）作为参数传递给函数。每个函数都把ar视为内含数组元素（每个元素是内含4个int类型值的数组）的数组。列数内置在函数体中，但是行数靠函数传递得到。如果传入函数的行数是12，那么函数要处理的是12×4的数组。因为rows是元素的个数，然而，因为每个元素都是数组，或者视为一行，rows也可以看成是行数。\n注意，ar和main()中的junk都使用数组表示法。因为ar和junk的类型相同，它们都是指向内含4个int类型值的数组的指针。\n注意，下面的声明不正确：\n1int sum2(int ar[][], int rows); // 错误的声明前面介绍过，编译器会把数组表示法转换成指针表示法。例如，编译器会把 ar[1]转换成 ar+1。编译器对ar+1求值，要知道ar所指向的对象大小。下面的声明：\n1int sum2(int ar[][4], int rows);　　// 有效声明表示ar指向一个内含4个int类型值的数组（在我们的系统中，ar指向的对象占16字节），所以ar+1的意思是“该地址加上16字节”。如果第2对方括号是空的，编译器就不知道该怎样处理。\n也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：\n1int sum2(int ar[3][4], int rows); // 有效声明，但是3将被忽略与使用typedef（第5章和第14章中讨论）相比，这种形式方便得多：\n12345typedef int arr4[4];　　　　　　　　　// arr4是一个内含 4 个int的数组typedef arr4 arr3x4[3];　　　　　　　 // arr3x4 是一个内含3个 arr4的数组int sum2(arr3x4 ar, int rows);　　　// 与下面的声明相同int sum2(int ar[3][4], int rows);　 // 与下面的声明相同int sum2(int ar[][4], int rows);　　// 标准形式一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值：\n1int sum4d(int ar[][12][20][30],int rows);因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：\n1int sum4d(int (*ar)[12][20][30], int rows); // ar是一个指针这里，ar指向一个12×20×30的int数组。\n变长数组（VLA）读者在学习处理二维数组的函数中可能不太理解，为何只把数组的行数作为函数的形参，而列数却内置在函数体内。例如，函数定义如下：\n1234567891011#define　COLS　4int sum2d(int ar[][COLS],int rows)&#123;    int r;    int c;    int tot=0;    for(r=0;r&lt;rows;r++)    \tfor(c=0;c&lt;COLS;c++)    \t\ttot+=ar[r][c];    return tot;&#125;假设声明了下列数组：\n123int array1[5][4];int array2[100][4];int array3[2][4];可以用sum2d()函数分别计算这些数组的元素之和：\n123tot = sum2d(array1, 5);　　// 5×4 数组的元素之和tot = sum2d(array2, 100);　// 100×4数组的元素之和tot = sum2d(array3, 2);　　// 2×4数组的元素之和sum2d()函数之所以能处理这些数组，是因为这些数组的列数固定为4，而行数被传递给形参rows， rows是一个变量。但是如果要计算6×5的数组（即6行5列），就不能使用这个函数，必须重新创建一个CLOS为5的函数。因为C规定，数组的维数必须是常量，不能用变量来代替COLS。\n要创建一个能处理任意大小二维数组的函数，比较繁琐（必须把数组作为一维数组传递，然后让函数计算每行的开始处）。而且，这种方法不好处理FORTRAN的子例程，这些子例程都允许在函数调用中指定两个维度。虽然 FORTRAN 是比较老的编程语言，但是在过去的几十年里，数值计算领域的专家已经用FORTRAN开发出许多有用的计算库。C正逐渐替代FORTRAN，如果能直接转换现有的FORTRAN库就好了。\n鉴于此，C99新增了变长数组（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：\n123int quarters　=　4;int regions　=　5;double sales[regions][quarters];　　// 一个变长数组（VLA）前面提到过，变长数组有一些限制。变长数组必须是自动存储类别，这意味着无论在函数中声明还是作为函数形参声明，都不能使用static或extern存储类别说明符（第12章介绍）。而且，不能在声明中初始化它们。最终，C11把变长数组作为一个可选特性，而不是必须强制实现的特性。\n注意 变长数组不能改变大小\n变长数组中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：在创建数组时，可以使用变量指定数组的维度。\n由于变长数组是C语言的新特性，目前完全支持这一特性的编译器不多。下面我们来看一个简单的例子：如何编写一个函数，计算int的二维数组所有元素之和。\n首先，要声明一个带二维变长数组参数的函数，如下所示：\n1int sum2d(int rows,int cols,int ar[rows][cols]); // ar是一个变长数组（VLA）注意前两个形参（rows和cols）用作第3个形参二维数组ar的两个维度。因为ar的声明要使用rows和cols，所以在形参列表中必须在声明ar之前先声明这两个形参。因此，下面的原型是错误的：\n1int sum2d(int ar[rows][cols],int rows,int cols); // 无效的顺序C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：\n1int sum2d(int,int,int ar[*][*]); // ar是一个变长数组（VLA），省略了维度形参名其次，该函数的定义如下：\n12345678910int sum2d(int rows,int cols,int ar[rows][cols])&#123;    int r;    int c;    int tot=0;    for(r=0;r&lt;rows;r++)    \tfor(c=0;c&lt;cols;c++)    \t\ttot+=ar[r][c];    return tot;&#125;该函数除函数头与传统的C函数（程序清单10.17）不同外，还把符号常量COLS替换成变量cols。这是因为在函数头中使用了变长数组。由于用变量代表行数和列数，所以新的sum2d()现在可以处理任意大小的二维int数组，如程序清单10.18所示。但是，该程序要求编译器支持变长数组特性。另外，该程序还演示了以变长数组作为形参的函数既可处理传统C数组，也可处理变长数组。\n程序清单10.18 vararr2d.c程序\n123456789101112131415161718192021222324252627282930313233343536//vararr2d.c -- 使用变长数组的函数#include　&lt;stdio.h&gt;#define　ROWS　3#define　COLS　4int sum2d(int　rows,　int　cols,　int　ar[rows][cols]);int main(void)&#123;    int i,j;    int rs=3;    int cs=10;    int junk[ROWS][COLS]=&#123; &#123;2,4,6,8&#125;,&#123;3,5,7,9&#125;,&#123;12,10,8,6&#125;&#125;;    int morejunk[ROWS-1][COLS + 2]=&#123;&#123;20,30,40,50,60,70&#125;,&#123;5,6,7,8,9,10&#125;&#125;;    int varr[rs][cs];　// 变长数组（VLA）    for(i=0;i&lt;rs;i++)    \tfor(j=0;j&lt;cs;j++)    \t\tvarr[i][j] = i * j + j;    printf(\"3x5　array\\n\");    printf(\"Sum　of　all　elements　=　%d\\n\",sum2d(ROWS,COLS,　junk));    printf(\"2x6　array\\n\");    printf(\"Sum　of　all　elements　=　%d\\n\",sum2d(ROWS　-　1,　COLS　+　2,　morejunk));    printf(\"3x10　VLA\\n\");    printf(\"Sum　of　all　elements　=　%d\\n\",　sum2d(rs,　cs,　varr));    return 0;&#125;// 带变长数组形参的函数int sum2d(int rows,int cols,int ar[rows][cols])&#123;    int r;    int c;    int tot　=　0;    for(r　=　0;　r　&lt;　rows;　r++)    \tfor(c　=　0;　c　&lt;　cols;　c++)    \t\ttot　+=　ar[r][c];    return tot;&#125;下面是该程序的输出：\n1234563x5　arraySum　of　all　elements　=　802x6　arraySum　of　all　elements　=　3153x10　VLASum　of　all　elements　=　270需要注意的是，在函数定义的形参列表中声明的变长数组并未实际创建数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。下面的代码段指出指针和实际数组是何时声明的：\n12345678910int thing[10][6];twoset(10,6,thing);...&#125;void twoset (int n, int m, int ar[n][m]) // ar是一个指向数组（内含m个int类型的值）的指针&#123;    int temp[n][m];　　// temp是一个n×m的int数组    temp[0][0] = 2;　　// 设置temp的一个元素为2    ar[0][0] = 2;　　　// 设置thing[0][0]为2&#125;如上代码所示调用twoset()时，ar成为指向thing[0]的指针，temp被创建为10×6的数组。因为ar和thing都是指向thing[0]的指针，ar[0][0]与thing[0][0]访问的数据位置相同。\nconst和数组大小\n是否可以在声明数组时使用const变量？\n123const int SZ　=　80;...double ar[SZ]; // 是否允许？C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如20、sizeof表达式或其他不是const的内容。由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用const，但是这种代码可能无法移植。\nC99/C11 标准允许在声明变长数组时使用 const 变量。所以该数组的定义必须是声明在块中的自动存储类别数组。\n变长数组还允许动态内存分配，这说明可以在程序运行时指定数组的大小。普通 C数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。第12章将详细介绍动态内存分配。\n复合字面量假设给带int类型形参的函数传递一个值，要传递int类型的变量，但是也可以传递int类型常量，如5。在C99 标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99新增了复合字面量（compound literal）。字面量是除符号常量外的常量。例如，5是int类型字面量， 81.3是double类型的字面量，&#39;Y&#39;是char类型的字面量，&quot;elephant&quot;是字符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。\n对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：\n1int diva[2] = &#123;10, 20&#125;;下面的复合字面量创建了一个和diva数组相同的匿名数组，也有两个int类型的值：\n1(int [2])&#123;10, 20&#125;　　　// 复合字面量注意，去掉声明中的数组名，留下的int [2]即是复合字面量的类型名。\n初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：\n1(int [])&#123;50, 20, 90&#125; // 内含3个元素的复合字面量因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。使用指针记录地址就是一种用法。也就是说，可以这样用：\n12int *pt1;pt1 = (int [2]) &#123;10, 20&#125;;注意，该复合字面量的字面常量与上面创建的 diva 数组的字面常量完全相同。与有数组名的数组类似，复合字面量的类型名也代表首元素的地址，所以可以把它赋给指向int的指针。然后便可使用这个指针。例如，本例中*pt1是10，pt1[1]是20。\n还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：\n1234int sum(const int ar[],int n);...int total3;total3 = sum((int [])&#123;4,4,4,5,5,5&#125;, 6);这里，第1个实参是内含6个int类型值的数组，和数组名类似，这同时也是该数组首元素的地址。这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法。\n可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维int数组并储存其地址：\n12int (*pt2)[4];　　 // 声明一个指向二维数组的指针，该数组内含2个数组元素，每个元素是内含4个int类型值的数组pt2　=　(int　[2][4])　&#123;　&#123;1,2,3,-9&#125;,　&#123;4,5,6,-8&#125;　&#125;;如上所示，该复合字面量的类型是int [2][4]，即一个2×4的int数组。\n程序清单10.19把上述例子放进一个完整的程序中。\n程序清单10.19 flc.c程序\n123456789101112131415161718192021222324252627282930313233343536373839// flc.c -- 有趣的常量#include　&lt;stdio.h&gt;#define　COLS　4int sum2d(const int ar[][COLS],int rows);int sum(const int ar[],int n);int main(void)&#123;    int total1,total2,total3;    int * pt1;    int(*pt2)[COLS];    pt1　=　(int[2])　&#123;　10,　20　&#125;;    pt2　=　(int[2][COLS])　&#123;　&#123;1,　2,　3,　-9&#125;,　&#123;　4,　5,　6,　-8　&#125;　&#125;;    total1　=　sum(pt1,　2);    total2　=　sum2d(pt2,　2);    total3　=　sum((int　[])&#123;　4,　4,　4,　5,　5,　5　&#125;,　6);    printf(\"total1　=　%d\\n\",　total1);    printf(\"total2　=　%d\\n\",　total2);    printf(\"total3　=　%d\\n\",　total3);    return 0;&#125;int sum(const　int　ar　[],　int　n)&#123;    int i;    int total　=　0;    for(i　=　0;　i　&lt;　n;　i++)    \ttotal　+=　ar[i];    return total;&#125;int sum2d(const int ar[][COLS],int rows)&#123;    int r;    int c;    int tot　=　0;    for(r　=　0;　r　&lt;　rows;　r++)    \tfor(c　=　0;　c　&lt;　COLS;　c++)    \t\ttot　+=　ar[r][c];    return tot;&#125;要支持C99的编译器才能正常运行该程序示例（目前并不是所有的编译器都支持），其输出如下：\n123total1　=　30total2　=　4total3　=　27记住，复合字面量是提供只临时需要的值的一种手段。复合字面量具有块作用域（第12章将介绍相关内容），这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。\n关键概念数组用于储存相同类型的数据。C 把数组看作是派生类型，因为数组是建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型，如int类型的数组、float类型的数组，或其他类型的数组。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组的数组（或称为二维数组）。\n通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址（因此，函数对应的形式参数是指针）。为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组地址提供了“地址”，“元素个数”可以内置在函数中或作为单独的参数传递。第 2 种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。\n数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。\n对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11新增了变长数组，可以用变量表示数组大小。这意味着变长数组的大小延迟到程序运行时才确定。\n本章小结数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过整数下标（或索引）可以访问各元素。在C中，数组首元素的下标是0，所以对于内含n个元素的数组，其最后一个元素的下标是n-1。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。\n声明一个简单的一维数组形式如下：\n1type name [ size ];这里，type是数组中每个元素的数据类型，name是数组名，size是数组元素的个数。对于传统的C数组，要求size是整型常量表达式。但是C99/C11允许使用整型非常量表达式。这种情况下的数组被称为变长数组。\nC把数组名解释为该数组首元素的地址。换言之，数组名与指向该数组首元素的指针等价。概括地说，数组和指针的关系十分密切。如果ar是一个数组，那么表达式ar[i]和*(ar+i)等价。\n对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字const。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。\n指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果pd指向一个数组的8字节double类型值，那么pd加1意味着其值加8，以便它指向该数组的下一个元素。\n二维数组即是数组的数组。例如，下面声明了一个二维数组：\n1double sales[5][12];该数组名为sales，有5个元素（一维数组），每个元素都是一个内含12个double类型值的数组。第1个一维数组是sales[0]，第2个一维数组是sales[1]，以此类推，每个元素都是内含12个double类型值的数组。使用第2个下标可以访问这些一维数组中的特定元素。例如，sales[2][5]是slaes[2]的第6个元素，而sales[2]是sales的第3个元素。\nC 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。声明这样的指针形参要指定所有的数组维度，除了第1个维度。传递的第1个维度通常作为第2个参数。例如，为了处理前面声明的sales数组，函数原型和函数调用如下：\n123void display(double ar[][12],int rows);...display(sales, 5);变长数组提供第2种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：\n123void display(int rows,int cols,double ar[rows][cols]);...display(5, 12, sales);虽然上述讨论中使用的是int类型的数组和double类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在第11章中详细介绍。\n","plink":"https://dxsummer.gitee.io/posts/87e8ce91/"},{"title":"Inside Front-Matter","date":"2020-06-12T13:08:56.000Z","date_formatted":{"ll":"2020年6月12日","L":"2020/06/12","MM-DD":"06-12"},"updated":"2020-06-13T06:25:08.000Z","content":"Hexo 默认12345678title: 标题date:updated:comments:tags:categories:layout:permalink: 永久链接详见 hexo.io/docs/front-matter。\n主题扩展同时适用于 page 和 post123456789# 当前文章是否显示目录导航，用于覆盖全局设置toc: false# 当前文章是否显示打赏，用于覆盖全局设置reward: false# 当前文章是否显示版权声明信息，用于覆盖全局设置# 支持设置为对象，同 &#x2F;theme-inside&#x2F;docs&#x2F;content addons#copyright。copyright: false适用于 post123456789101112# 设置缩略图thumbnail: landscape.jpg# 设置缩略图底色color: &#39;#111&#39;# 可联合设置，如：thumbnail: &#39;landscape.jpg #111&#39;# post 列表置顶# 优先按 top 值排序（缺省值为 0），其次按 datetop: 1文章加密Post\n12345678910---title: Hello Worldtags:- 作为日记加密date: 2016-03-30 21:12:21password: mikemessiabstract: 有东西被加密了, 请输入密码查看.message: 您好, 这里需要密码.wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.config\n12345678910# Securityencrypt: # hexo-blog-encrypt  abstract: 有东西被加密了, 请输入密码查看.  message: 您好, 这里需要密码.  tags:  - &#123;name: tagName, password: 密码A&#125;  - &#123;name: tagName, password: 密码B&#125;  template: &lt;div id&#x3D;&quot;hexo-blog-encrypt&quot; data-wpm&#x3D;&quot;&#123;&#123;hbeWrongPassMessage&#125;&#125;&quot; data-whm&#x3D;&quot;&#123;&#123;hbeWrongHashMessage&#125;&#125;&quot;&gt;&lt;div class&#x3D;&quot;hbe-input-container&quot;&gt;&lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;hbePass&quot; placeholder&#x3D;&quot;&#123;&#123;hbeMessage&#125;&#125;&quot; &#x2F;&gt;&lt;label&gt;&#123;&#123;hbeMessage&#125;&#125;&lt;&#x2F;label&gt;&lt;div class&#x3D;&quot;bottom-line&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&lt;script id&#x3D;&quot;hbeData&quot; type&#x3D;&quot;hbeData&quot; data-hmacdigest&#x3D;&quot;&#123;&#123;hbeHmacDigest&#125;&#125;&quot;&gt;&#123;&#123;hbeEncryptedData&#125;&#125;&lt;&#x2F;script&gt;&lt;&#x2F;div&gt;  wrong_pass_message: 抱歉, 这个密码看着不太对, 请再试试.  wrong_hash_message: 抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.适用于 page12# 在 page 标题下方显示信息，目前只会显示 date。meta: true折叠选项卡\n  无辣不欢\n   🌶️ 可以直接嚼辣椒\n   🍲 钟情麻辣香锅、四川重庆火锅\n   \n\n  无辣不欢\n   🌶️ 可以直接嚼辣椒\n   🍲 钟情麻辣香锅、四川重庆火锅\n   \n123456&lt;details style=\"padding-left:12px;padding-bottom:10px\"&gt;  &lt;summary&gt;无辣不欢&lt;/summary&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🌶️ 可以直接嚼辣椒&lt;/p&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🍲 钟情麻辣香锅、四川重庆火锅&lt;/p&gt;  &lt;p style=\"line-height:10px\"&gt; &lt;/p&gt;&lt;/details&gt;123456&lt;details style=\"padding-left:12px;padding-bottom:10px\" open=\"\"&gt;  &lt;summary&gt;无辣不欢&lt;/summary&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🌶️ 可以直接嚼辣椒&lt;/p&gt;  &lt;p style=\"font-size:12px; line-height:13px\"&gt; 🍲 钟情麻辣香锅、四川重庆火锅&lt;/p&gt;  &lt;p style=\"line-height:10px\"&gt; &lt;/p&gt;&lt;/details&gt;","plink":"https://dxsummer.gitee.io/posts/5a6efaf9/"},{"title":"动画详解十大经典排序算法（C语言版）","date":"2020-06-12T10:26:57.000Z","date_formatted":{"ll":"2020年6月12日","L":"2020/06/12","MM-DD":"06-12"},"updated":"2020-10-11T14:26:48.000Z","content":"排序算法是程序员必备的基础知识，弄明白它们的原理和实现很有必要。本文中将通过非常细节的动画展示出算法的原理，配合代码更容易理解。\n概述由于待排序的元素数量不同，使得排序过程中涉及的存储器不同，可将排序方法分为两类：一类是内部排序，指的是待排序列存放在计算机随机存储器中进行的排序过程；另一类是外部排序，指的是待排序的元素的数量很大，以致内存一次不能容纳全部记录，在排序过程中尚需对外存进行访问的排序过程。\n我们可以将常见的内部排序算法可以分成两类：\n\n比较类排序：通过比较来决定元素间的相对次序，时间复杂度为 O(nlogn)～O(n²)。属于比较类的有：\n\n排序算法时间复杂度最差情况最好情况空间复杂度排序方式稳定性\n\n冒泡排序O(n²)O(n²)O(n)O(1)In-place✔\n\n快速排序O(nlogn)O(n²)O(nlogn)O(logn)In-place✘\n\n插入排序O(n²)O(n²)O(n)O(1)In-place✔\n\n希尔排序O(nlog²n)O(n²)O(n)O(1)In-place✘\n\n选择排序O(n²)O(n²)O(n²)O(1)In-place✘\n\n堆排序O(nlogn)O(nlogn)O(nlogn)O(1)In-place✘\n\n归并排序O(nlogn)O(nlogn)O(nlogn)O(n)Out-place✔\n非比较类排序：不通过比较来决定元素间的相对次序，其时间复杂度可以突破 O(nlogn)，以线性时间运行。属于非比较类的有：\n\n排序算法时间复杂度最差情况最好情况空间复杂度排序方式稳定性\n\n桶排序O(n+nlog(n/r))O(n²)O(n)O(n+r)Out-place✔\n\n计数排序O(n+r)O(n+r)O(n+r)O(n+r)Out-place✔\n\n基数排序O(d(n+r))O(d(n+r))O(d(n+r))O(n+r)Out-place✔\n名词解释：\n时间/空间复杂度：描述一个算法执行时间/占用空间与数据规模的增长关系\nn：待排序列的个数\nr：“桶”的个数（上面的三种非比较类排序都是基于“桶”的思想实现的）\nd：待排序列的最高位数\nIn-place：原地算法，指的是占用常用内存，不占用额外内存。空间复杂度为 O(1) 的都可以认为是原地算法\nOut-place：非原地算法，占用额外内存\n稳定性：假设待排序列中两元素相等，排序前后这两个相等元素的相对位置不变，则认为是稳定的。\n冒泡排序冒泡排序（Bubble Sort），顾名思义，就是指越小的元素会经由交换慢慢“浮”到数列的顶端。\n算法原理从左到右，依次比较相邻的元素大小，更大的元素交换到右边；\n从第一组相邻元素比较到最后一组相邻元素，这一步结束最后一个元素必然是参与比较的元素中最大的元素；\n按照大的居右原则，重新从左到后比较，前一轮中得到的最后一个元素不参与比较，得出新一轮的最大元素；\n按照上述规则，每一轮结束会减少一个元素参与比较，直到没有任何一组元素需要比较。\n动图演示\n代码实现12345678910void bubble_sort(int arr[], int n) &#123;    int i, j;    for (i = 0; i &lt; n - 1; i++) &#123;        for (j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr, j, j+1);            &#125;        &#125;    &#125;&#125;算法分析冒泡排序属于交换排序，是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n但是我们常看到冒泡排序的最优时间复杂度是 O(n)，那要如何优化呢？\n我们可以用一个 flag 参数记录新一轮的排序中元素是否做过交换，如果没有，说明前面参与比较过的元素已经是正序，那就没必要再从头比较了。代码实现如下：\n12345678910111213void bubble_sort_quicker(int arr[], int n) &#123;    int i, j, flag;    for (i = 0; i &lt; n - 1; i++) &#123;        flag = 0;        for (j = 0; j &lt; n - i - 1; j++) &#123;            if (arr[j] &gt; arr[j + 1]) &#123;                swap(arr, j, j+1);                flag = 1;            &#125;        &#125;        if (!flag) return;    &#125;&#125;快速排序快速排序（Quick Sort），是冒泡排序的改进版，之所以“快速”，是因为使用了分治法。它也属于交换排序，通过元素之间的位置交换来达到排序的目的。\n基本思想在序列中随机挑选一个元素作基准，将小于基准的元素放在基准之前，大于基准的元素放在基准之后，再分别对小数区与大数区进行排序。\n一趟快速排序的具体做法是：\n设两个指针 i 和 j，分别指向序列的头部和尾部；\n先从 j 所指的位置向前搜索，找到第一个比基准小的值，把它与基准交换位置；\n再从 i 所指的位置向后搜索，找到第一个比基准大的值，把它与基准交换位置；\n重复 2、3 两步，直到 i = j。\n仔细研究一下上述算法我们会发现，在排序过程中，对基准的移动其实是多余的，因为只有一趟排序结束时，也就是 i = j 的位置才是基准的最终位置。\n由此可以优化一下算法：\n设两个指针 i 和 j，分别指向序列的头部和尾部；\n先从 j 所指的位置向前搜索，找到第一个比基准小的数值后停下来，再从 i 所指的位置向后搜索，找到第一个比基准大的数值后停下来，把 i 和 j 指向的两个值交换位置；\n重复步骤 2，直到 i = j，最后将相遇点指向的值与基准交换位置。\n动图演示\n代码实现这里取序列的第一个元素为基准。\n123456789101112131415161718192021/* 选取序列的第一个元素作为基准 */int select_pivot(int arr[], int low) &#123;    return arr[low];&#125;void quick_sort(int arr[], int low, int high) &#123;    int i, j, pivot;    if (low &gt;= high) return;    pivot = select_pivot(arr, low);    i = low;    j = high;    while (i != j) &#123;        while (arr[j] &gt;= pivot &amp;&amp; i &lt; j) j--;        while (arr[i] &lt;= pivot &amp;&amp; i &lt; j) i++;        if (i &lt; j) swap(arr, i, j);    &#125;    arr[low] = arr[i];    arr[i] = pivot;    quick_sort(arr, low, i - 1);    quick_sort(arr, i + 1, high);&#125;算法分析快速排序是不稳定排序，它的平均时间复杂度为 O(nlogn)，平均空间复杂度为 O(logn)。\n快速排序中，基准的选取非常重要，它将影响排序的效率。举个例子，假如序列本身顺序随机，快速排序是所有同数量级时间复杂度的排序算法中平均性能最好的，但如果序列本身已经有序或基本有序，直接选取固定位置，例如第一个元素作为基准，会使快速排序就会沦为冒泡排序，时间复杂度为 O(n²)。为了避免发生这种情况，引入下面两种获取基准的方法：\n随机选取\n就是选取序列中的任意一个数为基准的值。\n12345678/* 随机选择基准的位置，区间在 low 和 high 之间 */int select_pivot_random(int arr[], int low, int high) &#123;    srand((unsigned)time(NULL));    int pivot = rand()%(high - low) + low;    swap(arr, pivot, low);        return arr[low];&#125;三者取中\n就是取起始位置、中间位置、末尾位置指向的元素，对这三个元素排序后取中间数作为基准。\n1234567891011/* 取起始位置、中间位置、末尾位置指向的元素三者的中间值作为基准 */int select_pivot_median_of_three(int arr[], int low, int high) &#123;    // 计算数组中间的元素的下标    int mid = low + ((high - low) &gt;&gt; 1);    // 排序，使 arr[mid] &lt;= arr[low] &lt;= arr[high]    if (arr[mid] &gt; arr[high]) swap(arr, mid, high);    if (arr[low] &gt; arr[high]) swap(arr, low, high);    if (arr[mid] &gt; arr[low]) swap(arr, low, mid);    // 使用 low 位置的元素作为基准    return arr[low];&#125;经验证明，三者取中的规则可以大大改善快速排序在最坏情况下的性能。\n插入排序直接插入排序（Straight Insertion Sort），是一种简单直观的排序算法，它的基本操作是不断地将尚未排好序的数插入到已经排好序的部分，好比打扑克牌时一张张抓牌的动作。在冒泡排序中，经过每一轮的排序处理后，序列后端的数是排好序的；而对于插入排序来说，经过每一轮的排序处理后，序列前端的数都是排好序的。\n基本思想先将第一个元素视为一个有序子序列，然后从第二个元素起逐个进行插入，直至整个序列变成元素非递减有序序列为止。如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入大相等元素的后面。整个排序过程进行 n-1 趟插入。\n动图演示\n代码实现123456789void insertion_sort(int arr[], int n) &#123;    int i, j, temp;    for (i = 1; i &lt; n; i++) &#123;        temp = arr[i];        for (j = i; j &gt; 0 &amp;&amp; arr[j - 1] &gt; temp; j--)            arr[j] = arr[j - 1];        arr[j] = temp;    &#125;&#125;算法分析插入排序是稳定排序，平均时间复杂度为 O(n²)，空间复杂度为 O(1)。\n希尔排序希尔排序（Shell’s Sort）是第一个突破 O(n²) 的排序算法，是直接插入排序的改进版，又称“缩小增量排序”（Diminishing Increment Sort）。它与直接插入排序不同之处在于，它会优先比较距离较远的元素。\n基本思想先将整个待排序列分割成若干个字序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行一次直接插入排序。\n子序列的构成不是简单地“逐段分割”，将相隔某个增量的记录组成一个子序列，让增量逐趟缩短，直到增量为 1 为止。\n动图演示\n代码实现增量序列可以有各种取法，例如上面动图所示，增量序列满足 [n / 2, n / 2 / 2, …, 1]，n 是序列本身的长度，这也是一种比较流行的增量序列定义方式。这时希尔排序的算法可以通过下面的代码实现：\n1234567891011void shell_sort_split_half(int arr[], int n) &#123;    int i, j, dk, temp;    for (dk = n &gt;&gt; 1; dk &gt; 0; dk = dk &gt;&gt; 1) &#123;        for (i = dk; i &lt; n; i++) &#123;            temp = arr[i];            for (j = i - dk; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= dk)                arr[j + dk] = arr[j];            arr[j + dk] = temp;        &#125;    &#125;&#125;增量序列也可以有其它的定义方式，那么希尔排序的实现可以归纳成这样：\n1234567891011121314151617181920void shell_insert(int arr[], int n, int dk) &#123;    int i, j, temp;    for (i = dk; i &lt; n; i += dk) &#123;        temp = arr[i];        j = i - dk;        while (j &gt;= 0 &amp;&amp; temp &lt; arr[j]) &#123;            arr[j + dk] = arr[j];            j -= dk;        &#125;        arr[j + dk] = temp;    &#125;&#125;void shell_sort(int arr[], int n, int dlta[], int t) &#123;    int k;    for (k = 0; k &lt; t; ++k) &#123;        // 一趟增量为 dlta[k] 的插入排序        shell_insert(arr, n, dlta[k]);    &#125;&#125;算法分析希尔排序是不稳定排序，它的分析是一个复杂的问题，因为它的运行时间依赖于增量序列的选择，它的平均时间复杂度为 O(n^1.3)，最好情况是 O(n)，最差情况是 O(n²)。空间复杂度为 O(1)。\n选择排序选择排序（Selection Sort）是一种简单直观的排序算法。它的基本思想就是，每一趟 n-i+1(i=1,2,…,n-1) 个记录中选取关键字最小的记录作为有序序列的第 i 个记录。\n算法步骤简单选择排序：\n在未排序序列中找到最小（大）元素，存放到排序序列的起始位置;\n在剩余未排序元素中继续寻找最小（大）元素，放到已排序序列的末尾;\n重复步骤 2，直到所有元素排序完毕。\n动图演示\n代码实现1234567891011void selection_sort(int arr[], int n) &#123;    int i, j;    for (i = 0; i &lt; n - 1; i++) &#123;        int min = i;        for (j = i + 1; j &lt; n; j++) &#123;            if (arr[j] &lt; arr[min])                min = j;        &#125;        swap(arr, min, i);    &#125;&#125;算法分析选择排序是不稳定排序，时间复杂度固定为 O(n²)，因此它不适用于数据规模较大的序列。不过它也有优点，就是不占用额外的内存空间。\n堆排序堆排序（Heap Sort）是指利用堆这种数据结构所设计的一种排序算法。堆的特点：\n一颗完全二叉树（也就是会所生成节点的顺序是：从上往下、从左往右）\n每一个节点必须满足父节点的值不大于/不小于子节点的值\n基本思想实现堆排序需要解决两个问题：\n如何将一个无序序列构建成堆？\n如何在输出堆顶元素后，调整剩余元素成为一个新的堆？\n以升序为例，算法实现的思路为：\n建立一个 build_heap 函数，将数组 tree[0,…n-1] 建立成堆，n 表示数组长度。函数里需要维护的是所有节点的父节点，最后一个子节点下标为 n-1，那么它对应的父节点下标就是 (n-1-1)/2。\n构建完一次堆后，最大元素就会被存放在根节点 tree[0]。将 tree[0] 与最后一个元素交换，每一轮通过这种不断将最大元素后移的方式，来实现排序。\n而交换后新的根节点可能不满足堆的特点了，因此需要一个调整函数 heapify 来对剩余的数组元素进行最大堆性质的维护。如果 tree[i] 表示其中的某个节点，那么 tree[2i+1] 是左孩子，tree[2i+2] 是右孩子，选出三者中的最大元素的下标，存放于 max 值中，若 max 不等于 i，则将最大元素交换到 i 下标的位置。但是，此时以 tree[max] 为根节点的子树可能不满足堆的性质，需要递归调用自身。\n动图演示\n代码实现12345678910111213141516171819202122232425262728293031323334353637void heapify(int tree[], int n, int i) &#123;    // n 表示序列长度，i 表示父节点下标    if (i &gt;= n) return;    // 左侧子节点下标    int left = 2 * i + 1;    // 右侧子节点下标    int right = 2 * i + 2;    int max = i;    if (left &lt; n &amp;&amp; tree[left] &gt; tree[max]) max = left;    if (right &lt; n &amp;&amp; tree[right] &gt; tree[max]) max = right;    if (max != i) &#123;        swap(tree, max, i);        heapify(tree, n, max);    &#125;&#125;void build_heap(int tree[], int n) &#123;    // 树最后一个节点的下标    int last_node = n - 1;    // 最后一个节点对应的父节点下标    int parent = (last_node - 1) / 2;    int i;    for (i = parent; i &gt;= 0; i--) &#123;        heapify(tree, n, i);    &#125;&#125;void heap_sort(int tree[], int n) &#123;    build_heap(tree, n);    int i;    for (i = n - 1; i &gt;= 0; i--) &#123;        // 将堆顶元素与最后一个元素交换        swap(tree, i, 0);        // 调整成大顶堆        heapify(tree, i, 0);    &#125;&#125;算法分析堆排序是不稳定排序，适合数据量较大的序列，它的平均时间复杂度为 Ο(nlogn)，空间复杂度为 O(1)。堆排序仅需一个记录大小供交换用的辅助存储空间。\n归并排序归并排序（Merge Sort）是建立在归并操作上的一种排序算法。它和快速排序一样，采用了分治法。\n基本思想归并的含义是将两个或两个以上的有序表组合成一个新的有序表。也就是说，从几个数据段中逐个选出最小的元素移入新数据段的末尾，使之有序。\n那么归并排序的算法我们可以这样理解：\n假如初始序列含有 n 个记录，则可以看成是 n 个有序的子序列，每个子序列的长度为 1。然后两两归并，得到 n/2 个长度为 2 或 1 的有序子序列；再两两归并，……，如此重复，直到得到一个长度为 n 的有序序列为止，这种排序方法称为 二路归并排序，下文介绍的也是这种排序方式。\n动图演示\n代码实现123456789101112131415161718192021222324252627/* 将 arr[L..M] 和 arr[M+1..R] 归并 */void merge(int arr[], int L, int M, int R) &#123;    int LEFT_SIZE = M - L + 1;    int RIGHT_SIZE = R - M;    int left[LEFT_SIZE];    int right[RIGHT_SIZE];    int i, j, k;    // 以 M 为分割线，把原数组分成左右子数组    for (i = L; i &lt;= M; i++) left[i - L] = arr[i];    for (i = M + 1; i &lt;= R; i++) right[i - M - 1] = arr[i];    // 再合并成一个有序数组（从两个序列中选出最小值依次插入）    i = 0; j = 0; k = L;    while (i &lt; LEFT_SIZE &amp;&amp; j &lt; RIGHT_SIZE) arr[k++] = left[i] &lt; right[j] ? left[i++] : right[j++];    while (i &lt; LEFT_SIZE) arr[k++] = left[i++];    while (j &lt; RIGHT_SIZE) arr[k++] = right[j++];&#125;void merge_sort(int arr[], int L, int R) &#123;    if (L == R) return;    // 将 arr[L..R] 平分为 arr[L..M] 和 arr[M+1..R]    int M = (L + R) / 2;    // 分别递归地将子序列排序为有序数列    merge_sort(arr, L, M);    merge_sort(arr, M + 1, R);    // 将两个排序后的子序列再归并到 arr    merge(arr, L, M, R);&#125;算法分析归并排序是稳定排序，它和选择排序一样，性能不受输入数据的影响，但表现比选择排序更好，它的时间复杂度始终为 O(nlogn)，但它需要额外的内存空间，空间复杂度为 O(n)。\n桶排序桶排序（Bucket sort）是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。\n桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（也有可能是使用别的排序算法或是以递归方式继续用桶排序进行排序）。\n算法步骤设置固定数量的空桶；\n把数据放在对应的桶内；\n分别对每个非空桶内数据进行排序；\n拼接非空的桶内数据，得到最终的结果。\n动图演示\n代码实现123456789101112131415161718192021222324252627282930313233void bucket_sort(int arr[], int n, int r) &#123;    if (arr == NULL || r &lt; 1) return;    // 根据最大/最小元素和桶数量，计算出每个桶对应的元素范围    int max = arr[0], min = arr[0];    int i, j;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    int range = (max - min + 1) / r + 1;    // 建立桶对应的二维数组，一个桶里最多可能出现 n 个元素    int buckets[r][n];    memset(buckets, 0, sizeof(buckets));    int counts[r];    memset(counts, 0, sizeof(counts));    for (i = 0; i &lt; n; i++) &#123;        int k = (arr[i] - min) / range;        buckets[k][counts[k]++] = arr[i];    &#125;    int index = 0;    for (i = 0; i &lt; r; i++) &#123;        // 分别对每个非空桶内数据进行排序，比如计数排序        if (counts[i] == 0) continue;        counting_sort(buckets[i], counts[i]);        // 拼接非空的桶内数据，得到最终的结果        for (j = 0; j &lt; counts[i]; j++) &#123;            arr[index++] = buckets[i][j];        &#125;    &#125;&#125;算法分析桶排序是稳定排序，但仅限于桶排序本身，假如桶内排序采用了快速排序之类的非稳定排序，那么就是不稳定的。\n时间复杂度桶排序的时间复杂度可以这样看：\nn 次循环，每个数据装入桶\nr 次循环，每个桶中的数据进行排序（每个桶中平均有 n/r 个数据）\n假如桶内排序用的是选择排序这类时间复杂度较高的排序，整个桶排序的时间复杂度就是 O(n)+O(n²)，视作 O(n²)，这是最差的情况；\n假如桶内排序用的是比较先进的排序算法，时间复杂度为 O(nlogn)，那么整个桶排序的时间复杂度为 O(n)+O(r(n/r)log(n/r))=O(n+nlog(n/r))。k=nlog(n/r)，桶排序的平均时间复杂度为 O(n+k)。当 r 接近于 n 时，k 趋近于 0，这时桶排序的时间复杂度是最优的，就可以认为是 O(n)。也就是说如果数据被分配到同一个桶中，排序效率最低；但如果数据可以均匀分配到每一个桶中，时间效率最高，可以线性时间运行。但同样地，桶越多，空间就越大。\n空间复杂度占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以桶排序的空间复杂度为 O(n+r)。\n计数排序计数排序（Counting Sort）是一种非比较性质的排序算法，利用了桶的思想。它的核心在于将输入的数据值转化为键存储在额外开辟的辅助空间中，也就是说这个辅助空间的长度取决于待排序列中的数据范围。\n如何转化成桶思想来理解呢？我们设立 r 个桶，桶的键值分别对应从序列最小值升序到最大值的所有数值。接着，按照键值，依次把元素放进对应的桶中，然后统计出每个桶中分别有多少元素，再通过对桶内数据的计算，即可确定每一个元素最终的位置。\n算法步骤找出待排序列中最大值 max 和最小值 min，算出序列的数据范围 r = max - min + 1，申请辅助空间 C[r]；\n遍历待排序列，统计序列中每个值为 i 的元素出现的次数，记录在辅助空间的第 i 位；\n对辅助空间内的数据进行计算（从空间中的第一个元素开始，每一项和前一项相加），以确定值为 i 的元素在数组中出现的位置；\n反向填充目标数组：将每个元素 i 放在目标数组的第 C[i] 位，每放一个元素就将 C[i] 减 1，直到 C 中所有值都是 0\n动图演示\n代码实现1234567891011121314151617181920212223void counting_sort(int arr[], int n) &#123;    if (arr == NULL) return;    // 定义辅助空间并初始化    int max = arr[0], min = arr[0];    int i;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    int r = max - min + 1;    int C[r];    memset(C, 0, sizeof(C));    // 定义目标数组    int R[n];    // 统计每个元素出现的次数    for (i = 0; i &lt; n; i++) C[arr[i] - min]++;    // 对辅助空间内数据进行计算    for (i = 1; i &lt; r; i++) C[i] += C[i - 1];    // 反向填充目标数组    for (i = n - 1; i &gt;= 0; i--) R[--C[arr[i] - min]] = arr[i];    // 目标数组里的结果重新赋值给 arr    for (i = 0; i &lt; n; i++) arr[i] = R[i];&#125;算法分析计数排序属于非交换排序，是稳定排序，适合数据范围不显著大于数据数量的序列。\n时间复杂度它的时间复杂度是线性的，为 O(n+r)，r 表示待排序列中的数据范围，也就是桶的个数。可以这样理解：将 n 个数据依次放进对应的桶中，再从 r 个桶中把数据按顺序取出来。\n空间复杂度占用额外内存，还需要 r 个桶，因此空间复杂度是 O(n+r)，计数排序快于任何比较排序算法，但这是通过牺牲空间换取时间来实现的。\n基数排序基数排序（Radix Sort）是非比较型排序算法，它和计数排序、桶排序一样，利用了“桶”的概念。基数排序不需要进行记录关键字间的比较，是一种借助多关键字排序的思想对单逻辑关键字进行排序的方法。比如数字 100，它的个位、十位、百位就是不同的关键字。\n那么，对于一组乱序的数字，基数排序的实现原理就是将整数按位数（关键字）切割成不同的数字，然后按每个位数分别比较。对于关键字的选择，有最高位优先法（MSD 法）和最低位优先法（LSD 法）两种方式。MSD 必须将序列先逐层分割成若干子序列，然后再对各子序列进行排序；而 LSD 进行排序时，不必分成子序列，对每个关键字都是整个序列参加排序。\n算法步骤以 LSD 法为例：\n将所有待比较数值（非负整数）统一为同样的数位长度，数位不足的数值前面补零\n从最低位（个位）开始，依次进行一次排序\n从最低位排序一直到最高位排序完成以后, 数列就变成一个有序序列\n如果要支持负数参加排序，可以将序列中所有的值加上一个常数，使这些值都成为非负数，排好序后，所有的值再减去这个常数。\n动图演示\n代码实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546// 基数，范围0~9#define RADIX 10void radix_sort(int arr[], int n) &#123;    // 获取最大值和最小值    int max = arr[0], min = arr[0];    int i, j, l;    for (i = 1; i &lt; n; i++) &#123;        if (max &lt; arr[i]) max = arr[i];        if (min &gt; arr[i]) min = arr[i];    &#125;    // 假如序列中有负数，所有数加上一个常数，使序列中所有值变成正数    if (min &lt; 0) &#123;        for (i = 0; i &lt; n; i++) arr[i] -= min;        max -= min;    &#125;    // 获取最大值位数    int d = 0;    while (max &gt; 0) &#123;        max /= RADIX;        d ++;    &#125;    int queue[RADIX][n];    memset(queue, 0, sizeof(queue));    int count[RADIX] = &#123;0&#125;;    for (i = 0; i &lt; d; i++) &#123;        // 分配数据        for (j = 0; j &lt; n; j++) &#123;            int key = arr[j] % (int)pow(RADIX, i + 1) / (int)pow(RADIX, i);            queue[key][count[key]++] = arr[j];        &#125;        // 收集数据        int c = 0;        for (j = 0; j &lt; RADIX; j++) &#123;            for (l = 0; l &lt; count[j]; l++) &#123;                arr[c++] = queue[j][l];                queue[j][l] = 0;            &#125;            count[j] = 0;        &#125;    &#125;    // 假如序列中有负数，收集排序结果时再减去前面加上的常数    if (min &lt; 0) &#123;        for (i = 0; i &lt; n; i++) arr[i] += min;    &#125;&#125;算法分析基数排序是稳定排序，适用于关键字取值范围固定的排序。\n时间复杂度基数排序可以看作是若干次“分配”和“收集”的过程。假设给定 n 个数，它的最高位数是 d，基数（也就是桶的个数）为 r，那么可以这样理解：共进行 d 趟排序，每趟排序都要对 n 个数据进行分配，再从 r 个桶中收集回来。所以算法的时间复杂度为 O(d(n+r))，在整数的排序中，r = 10，因此可以简化成 O(dn)，是线性阶的排序。\n空间复杂度占用额外内存，需要创建 r 个桶的额外空间，以及 n 个元素的额外空间，所以基数排序的空间复杂度为 O(n+r)。\n计数排序 &amp; 桶排序 &amp; 基数排序这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：\n桶排序：每个桶存储一定范围的数值，适用于元素尽可能分布均匀的排序；\n计数排序：每个桶只存储单一键值，适用于最大值和最小值尽可能接近的排序；\n基数排序：根据键值的每位数字来分配桶，适用于非负整数间的排序，且最大值和最小值尽可能接近。\n\n本文关联项目地址\n","thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/c/fm.png","plink":"https://dxsummer.gitee.io/posts/942e5b03/"},{"title":"Step7 函数","date":"2020-06-10T12:21:48.000Z","date_formatted":{"ll":"2020年6月10日","L":"2020/06/10","MM-DD":"06-10"},"updated":"2020-06-12T09:59:08.000Z","content":"本章介绍以下内容：\n关键字：return\n运算符：*（一元）、&amp;（一元）\n函数及其定义方式\n如何使用参数和返回值\n如何把指针变量用作函数参数\n函数类型\nANSI C原型\n递归\n如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C标准库的函数，如printf()、scanf()、getchar()、putchar()和 strlen()。现在要进一步学习如何创建自己的函数。前面章节中已大致介绍了相关过程，本章将巩固以前学过的知识并做进一步的拓展。\n复习函数首先，什么是函数？函数（function）是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如printf()把数据打印到屏幕上；一些函数找出一个值供程序使用，如strlen()把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。\n为什么要使用函数？首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用putchar()一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。例如，假设要编写一个程序完成以下任务：\n读入一系列数字；\n分类这些数字；\n找出这些数字的平均值；\n打印一份柱状图。\n可以使用下面的程序：\n1234567891011#include　&lt;stdio.h&gt;#define　SIZE　50int main(void)&#123;    float list[SIZE];    readlist(list,SIZE);    sort(list,SIZE);    average(list,SIZE);    bargraph(list,SIZE);    returnb 0;&#125;当然，还要编写4个函数readlist()、sort()、average()和bargraph()的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。\n许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用printf()时，只需知道给该函数传入格式字符串或一些参数以及 printf()生成的输出，无需了解 printf()的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。\n如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何建立函数间的通信。我们从一个简单的程序示例开始，帮助读者理清这些内容，然后再详细讲解。\n创建并使用简单函数我们的第1个目标是创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数。如程序清单9.1所示，该程序由main()和starbar()组成。\n程序清单9.1 lethead1.c程序\n1234567891011121314151617181920212223/* lethead1.c */#include　&lt;stdio.h&gt;#define NAME　\"GIGATHINK, INC.\"#define ADDRESS　\"101　Megabuck　Plaza\"#define PLACE　\"Megapolis,　CA　94904\"#define WIDTH　40void starbar(void);　/* 函数原型 */int main(void)&#123;    starbar();    printf(\"%s\\n\",NAME);    printf(\"%s\\n\",ADDRESS);    printf(\"%s\\n\",PLACE);    starbar();　　　/* 使用函数 */    return　0;&#125;void starbar(void)　/* 定义函数　 */&#123;    int　count;    for(count=1;count&lt;=WIDTH;count++)    putchar('*');    putchar('\\n');&#125;该程序的输出如下：\n12345****************************************GIGATHINK,　INC.101　Megabuck　PlazaMegapolis,　CA　94904****************************************分析程序该程序要注意以下几点。\n程序在3处使用了starbar标识符：函数原型（function prototype）告诉编译器函数starbar()的类型；函数调用（function call）表明在此处执行函数；函数定义（function definition）明确地指定了函数要做什么。\n函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。因此，在main()函数定义的前面出现了下面的ANSI C风格的函数原型：\n1void starbar(void);圆括号表明starbar是一个函数名。第1个void是函数类型，void类型表明函数没有返回值。第2个void（在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为starbar()、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。对于不识别ANSI C风格原型的编译器，只需声明函数的类型，如下所示：\n1void starbar();注意，一些老版本的编译器甚至连void都识别不了。如果使用这种编译器，就要把没有返回值的函数声明为int类型。当然，最好还是换一个新的编译器。\n一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该函数的签名（signature）。对于starbar()函数而言，其签名是该函数没有返回值，没有参数。\n程序把 starbar()原型置于 main()的前面。当然，也可以放在 main()里面的声明变量处。放在哪个位置都可以。\n在main()中，执行到下面的语句时调用了starbar()函数：\n1starbar();这是调用void类型函数的一种形式。当计算机执行到starbar();语句时，会找到该函数的定义并执行其中的内容。执行完starbar()中的代码后，计算机返回主调函数（calling function）继续执行下一行（本例中，主调函数是main()），见图9.1（更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码）。\n\n程序中strarbar()和main()的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束（见图9.2）。注意，函数头中的starbar()后面没有分号，告诉编译器这是定义starbar()，而不是调用函数或声明函数原型。\n\n程序把 starbar()和 main()放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把#define 和#include 指令也放入该文件。我们稍后会讨论使用多个文件的情况。现在，先把所有的函数都放在一个文件中。main()的右花括号告诉编译器该函数结束的位置，后面的starbar()函数头告诉编译器starbar()是一个函数。\nstarbar()函数中的变量count是局部变量（local variable），意思是该变量只属于starbar()函数。可以在程序中的其他地方（包括main()中）使用count，这不会引起名称冲突，它们是同名的不同变量。\n如果把starbar()看作是一个黑盒，那么它的行为是打印一行星号。不用给该函数提供任何输入，因为调用它不需要其他信息。而且，它没有返回值，所以也不给 main()提供（或返回）任何信息。简而言之，starbar()不需要与主调函数通信。\n接下来介绍一个函数间需要通信的例子。\n函数参数在程序清单9.1的输出中，如果文字能居中，信头会更加美观。可以通过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号（starbar()函数）类似，只不过现在要打印的是一定数量的空格。虽然这是两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个更通用的函数，可以在两种情况下使用。我们设计一个新的函数show_n_char()（显示一个字符n次）。唯一要改变的是使用内置的值来显示字符和重复的次数，show_n_char()将使用函数参数来传递这些值。\n我们来具体分析。假设可用的空间是40个字符宽。调用show_n_char(&#39;*&#39;, 40)应该正好打印一行40个星号，就像starbar()之前做的那样。第2行GIGATHINK, INT.的空格怎么处理？GIGATHINK, INT.是15个字符宽，所以第1个版本中，文字后面有25个空格。为了让文字居中，文字的左侧应该有12个空格，右侧有13个空格。因此，可以调用show_n_char(&#39;*&#39;, 12)。\nshow_n_char()与starbar()很相似，但是show_n_char()带有参数。从功能上看，前者不会添加换行符，而后者会，因为show_n_char()要把空格和文本打印成一行。程序清单9.2是修改后的版本。为强调参数的工作原理，程序使用了不同的参数形式。\n程序清单9.2 lethead2.c程序\n123456789101112131415161718192021222324252627282930313233/* lethead2.c */#include　&lt;stdio.h&gt;#include &lt;string.h&gt;　　　　　/* 为strlen()提供原型 */#define　NAME　\"GIGATHINK,　INC.\"#define　ADDRESS　\"101　Megabuck　Plaza\"#define　PLACE　\"Megapolis,　CA　94904\"#define　WIDTH　40#define　SPACE　'　'void show_n_char(char　ch,　int　num);int main(void)&#123;    int spaces;    show_n_char('*', WIDTH);　　　　　　　　/* 用符号常量作为参数 */    putchar('\\n');    show_n_char(SPACE, 12);　　　　　　　　 /* 用符号常量作为参数 */    printf(\"%s\\n\",　NAME);    spaces = (WIDTH - strlen(ADDRESS))/2; /* 计算要跳过多少个空格*/    show_n_char(SPACE, spaces);　　　　　　 /* 用一个变量作为参数*/    printf(\"%s\\n\",　ADDRESS);    show_n_char(SPACE,(WIDTH-strlen(PLACE))/2);    printf(\"%s\\n\", PLACE);　　　　　　　　　/* 用一个表达式作为参数　 */    show_n_char('*', WIDTH);    putchar('\\n');    return 0;&#125;/* show_n_char()函数的定义 */void show_n_char(char ch,int num)&#123;    int count;    for(count=1;count&lt;=num;count++)    putchar(ch);&#125;该函数的运行结果如下：\n12345**************************************\t\tGIGATHINK,　INC.\t  101　Megabuck　Plaza\t Megapolis,　CA　94904****************************************下面我们回顾一下如何编写一个带参数的函数，然后介绍这种函数的用法。\n定义带形式参数的函数函数定义从下面的ANSI C风格的函数头开始：\n1void show_n_char(char ch,int num)该行告知编译器show_n_char()使用两个参数ch和num，ch是char类型，num是int类型。这两个变量被称为形式参数（formal argument，但是最近的标准推荐使用formal parameter），简称形参。和定义在函数中变量一样，形式参数也是局部变量，属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。\n注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：\n12void dibs(int x, y, z)　　　　 /* 无效的函数头 */void dubs(int x, int y, int z) /* 有效的函数头 */ANSI C也接受ANSI C之前的形式，但是将其视为废弃不用的形式：\n123void show_n_char(ch,num)char ch;int num;这里，圆括号中只有参数名列表，而参数的类型在后面声明。注意，普通的局部变量在左花括号之后声明，而上面的变量在函数左花括号之前声明。如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：\n12void dibs(x,y,z)int x,y,z;　　　/* 有效 */当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序，但是自己编写程序时应使用现在的标准形式（C99和C11标准继续警告这些过时的用法即将被淘汰）。\n虽然show_n_char()接受来自main()的值，但是它没有返回值。因此，show_n_char()的类型是void。\n下面，我们来学习如何使用函数。\n声明带形式参数函数的原型在使用函数之前，要用ANSI C形式声明函数原型：\n1void show_n_char(char ch, int num);当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：\n1void show_n_char(char, int);在原型中使用变量名并没有实际创建变量，char仅代表了一个char类型的变量，以此类推。再次提醒读者注意，ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：\n1void show_n_char();这种形式最终会从标准中剔除。即使没有被剔除，现在函数原型的设计也更有优势（稍后会介绍）。了解这种形式的写法是为了以后读得懂以前写的代码。\n调用带实际参数的函数在函数调用中，实际参数（actual argument，简称实参）提供了ch和num的值。考虑程序清单9.2中第1次调用show_n_char()：\n1show_n_char(SPACE,12);实际参数是空格字符和12。这两个值被赋给show_n_char()中相应的形式参数：变量ch和num。简而言之，形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。以程序清单 9.2 中最后一次调用show_n_char()为例：\n1show_n_char(SPACE,(WIDTH - strlen(PLACE))/2);构成该函数第2个实际参数的是一个很长的表达式，对该表达式求值为10。然后，10被赋给变量num。被调函数不知道也不关心传入的数值是来自常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋给作为形式参数的变量（见图 9.3）。因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。\n注意 实际参数和形式参数\n\n实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。程序清单 9.2 中，&#39;*&#39;和WIDTH都是第1次调用show_n_char()时的实际参数，而SPACE和11是第2次调用show_n_char()时的实际参数。在函数定义中，ch和num都是该函数的形式参数。\n黑盒视角从黑盒的视角看 show_n_char()，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在 main()中使用该函数。而且，这也可以作为编写该函数的设计说明。\n黑盒方法的核心部分是：ch、num和count都是show_n_char()私有的局部变量。如果在main()中使用同名变量，那么它们相互独立，互不影响。也就是说，如果main()有一个count变量，那么改变它的值不会改变show_n_char()中的count，反之亦然。黑盒里发生了什么对主调函数是不可见的。\n使用return从函数中返回值前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从被调函数传回主调函数。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理int类型的值，所以被命名为imin()。另外，还要创建一个简单的main()，用于检查imin()是否正常工作。这种被设计用于测试函数的程序有时被称为驱动程序（driver），该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。程序清单9.3演示了这个驱动程序和返回最小值的函数。\n程序清单9.3 lesser.c程序\n1234567891011121314151617181920212223242526/* lesser.c -- 找出两个整数中较小的一个 */#include　&lt;stdio.h&gt;int imin(int,int);int main(void)&#123;    int evil1,evil2;    printf(\"Enter　a　pair　of　integers　(q　to　quit):\\n\");    while(scanf(\"%d　%d\",&amp;evil1,&amp;evil2)　==　2)    &#123;        printf(\"The　lesser　of　%d　and　%d　is　%d.\\n\",        evil1,evil2,imin(evil1,evil2));        printf(\"Enter　a　pair　of　integers　(q　to　quit):\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;int imin(int　n,　int　m)&#123;    int min;    if(n　&lt;　m)    \tmin　=　n;    else    \tmin　=　m;    return min;&#125;回忆一下，scanf()返回成功读数据的个数，所以如果输入不是两个整数会导致循环终止。下面是一个运行示例：\n123456789Enter　a　pair　of　integers　(q　to　quit):509　333The　lesser　of　509　and　333　is　333.Enter　a　pair　of　integers　(q　to　quit):-9393　6The　lesser　of　-9393　and　6　is　-9393.Enter　a　pair　of　integers　(q　to　quit):qBye.关键字return后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量min的值。因为min是int类型的变量，所以imin()函数的类型也是int。\n变量min属于imin()函数私有，但是return语句把min的值传回了主调函数。下面这条语句的作用是把min的值赋给lesser:\n1lesser = imin(n,m);是否能像写成下面这样：\n12imin(n,m);lesser = min;不能。因为主调函数甚至不知道min的存在。记住，imin()中的变量是imin()的局部变量。函数调用imin(evil1, evil2)只是把两个变量的值拷贝了一份。\n返回值不仅可以赋给变量，也可以被用作表达式的一部分。例如，可以这样：\n12answer = 2 * imin(z, zstar) + 25;printf(\"%d\\n\", imin(-32 + answer, LIMIT));返回值不一定是变量的值，也可以是任意表达式的值。例如，可以用以下的代码简化程序示例：\n12345/* 返回最小值的函数，第2个版本 */imin(int n,int m)&#123;return (n&lt;m)?n:m;&#125;条件表达式的值是n和m中的较小者，该值要被返回给主调函数。虽然这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。\n如果函数返回值的类型与函数声明的类型不匹配会怎样？\n12345int what_if(int n)&#123;    double z=100.0/(double)n;    return z; // 会发生什么？&#125;实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：\n1result=what_if(64);虽然在what_if()函数中赋给z的值是1.5625，但是return语句返回确实int类型的值1。\n使用 return 语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。因此，可以这样编写imin()：\n123456789/*返回最小值的函数，第3个版本*/imin(int n,int m)&#123;    if(n　&lt;　m)    \treturn　n;    else    \treturn　m;&#125;许多C程序员都认为只在函数末尾使用一次return语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个return语句也没有错。无论如何，对用户而言，这3个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：\n12345678910/*返回最小值的函数，第4个版本*/imin(int　n,int　m)&#123;    if(n&lt;m)    \treturn　n;    else    \treturn　m;    printf(\"Professor　Fleppard　is　like　totally　a　fopdoodle.\\n\");&#125;return语句导致printf()语句永远不会被执行。如果Fleppard教授在自己的程序中使用这个版本的函数，可能永远不知道编写这个函数的学生对他的看法。\n另外，还可以这样使用return：\n1return;这条语句会导致终止函数，并把控制返回给主调函数。因为 return 后面没有任何表达式，所以没有返回值，只有在void函数中才会用到这种形式。\n函数类型声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为void类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是int。这一惯例源于C的早期，那时的函数绝大多数都是int类型。然而，C99标准不再支持int类型函数的这种假定设置。\n类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。例如，下面的函数头定义了一个带两个int类型参数的函数，但是其返回值是double类型。\n1double klink(int a, int b)要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。例如，程序清单 9.3 中的main()函数包含以下几行代码：\n12345#include　&lt;stdio.h&gt;int imin(int,int);int main(void)&#123;    int evil1,evil2,lesser;第2行代码说明imin是一个函数名，有两个int类型的形参，且返回int类型的值。现在，编译器在程序中调用imin()函数时就知道应该如何处理。\n在程序清单9.3中，我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。例如，重写lesser.c（程序清单9.3）的开头部分：\n12345#include　&lt;stdio.h&gt;int main(void)&#123;    int imin(int, int); /* 声明imin()函数的原型*/    int evil1,evil2,lesser;注意在这两种情况中，函数原型都声明在使用函数之前。\nANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，stdio.h 头文件包含了标准 I/O 库函数（如，printf()和scanf()）的声明。math.h头文件包含了各种数学函数的声明。例如，下面的声明：\n1double sqrt(double);告知编译器sqrt()函数有一个double类型的形参，而且返回double类型的值。不要混淆函数的声明和定义。函数声明告知编译器函数的类型，而函数定义则提供实际的代码。在程序中包含 math.h 头文件告知编译器：sqrt()返回double类型，但是sqrt()函数的代码在另一个库函数的文件中。\nANSI C函数原型在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。\n下面是ANSI之前的函数声明，告知编译器imin()返回int类型的值：\n1int imin();然而，以上函数声明并未给出imin()函数的参数个数和类型。因此，如果调用imin()时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。\n问题所在我们看看与imax()函数相关的一些示例，该函数与imin()函数关系密切。程序清单9.4演示了一个程序，用过去声明函数的方式声明了imax()函数，然后错误地使用该函数。\n12345678910111213141516程序清单9.4 misuse.c程序/* misuse.c -- 错误地使用函数 */#include　&lt;stdio.h&gt;int imax();　　 /* 旧式函数声明 */int　main(void)&#123;    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",3,　5,　imax(3));    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",3,　5,　imax(3.0,　5.0));    return 0;&#125;int imax(n,m)int n,m;&#123;\treturn (n&gt;m?n:m);&#125;第1次调用printf()时省略了imax()的一个参数，第2次调用printf()时用两个浮点参数而不是整数参数。尽管有些问题，但程序可以编译和运行。\n下面是使用Xcode 4.6运行的输出示例：\n12The maximum　of　3　and　5　is　1606416656.The　maximum　of　3　and　5　is　3886.使用gcc运行该程序，输出的值是1359379472和1359377160。这两个编译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用函数原型。\n到底是哪里出了问题？由于不同系统的内部机制不同，所以出现问题的具体情况也不同。下面介绍的是使用P C和VA X的情况。主调函数把它的参数储存在被称为栈（stack）的临时存储区，被调函数从栈中读取这些参数。对于该例，这两个过程并未相互协调。主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值。因此，函数调用imax(3)把一个整数放在栈中。当imax()函数开始执行时，它从栈中读取两个整数。而实际上栈中只存放了一个待读取的整数，所以读取的第 2 个值是当时恰好在栈中的其他值。\n第2次使用imax()函数时，它传递的是float类型的值。这次把两个double类型的值放在栈中（回忆一下，当float类型被作为参数传递时会被升级为double类型）。在我们的系统中，两个double类型的值就是两个64位的值，所以128位的数据被放在栈中。当imax()从栈中读取两个int类型的值时，它从栈中读取前64位。在我们的系统中，每个int类型的变量占用32位。这些数据对应两个整数，其中较大的是3886。\nANSI的解决方案针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用函数原型（function prototype）来声明函数的返回类型、参数的数量和每个参数的类型。未标明 imax()函数有两个 int 类型的参数，可以使用下面两种函数原型来声明：\n12int imax(int, int);int imax(int a, int b);第1种形式使用以逗号分隔的类型列表，第2种形式在类型后面添加了变量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。\n有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以 imax()为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，imax(3.0, 5.0)会被转换成imax(3, 5)。我们用函数原型替换程序清单9.4中的函数声明，如程序清单9.5所示。\n程序清单9.5 proto.c程序\n12345678910111213141516/* proto.c -- 使用函数原型 */#include　&lt;stdio.h&gt;int imax(int, int);　　　 /* 函数原型 */int main(void)&#123;    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",    3,　5,　imax(3));    printf(\"The　maximum　of　%d　and　%d　is　%d.\\n\",    3,　5,　imax(3.0,　5.0));    return 0;&#125;int imax(int　n,　int　m)&#123;\treturn (n　&gt;　m　?　n　:　m);&#125;编译程序清单9.5时，我们的编译器给出调用的imax()函数参数太少的错误消息。\n如果是类型不匹配会怎样？为探索这个问题，我们用imax(3, 5)替换imax(3)，然后再次编译该程序。这次编译器没有给出任何错误信息，程序的输出如下：\n12The maximum of 3 and 5 is 5.The maximum of 3 and 5 is 5.如上文所述，第2次调用中的3.0和5.0被转换成3和5，以便函数能正确地处理输入。\n虽然没有错误消息，但是我们的编译器还是给出了警告：double转换成int可能会导致丢失数据。例如，下面的函数调用：\n1imax(3.9, 5.4)相当于:\n1imax(3, 5)错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时的详细程度。\n无参数和未指定参数假设有下面的函数原型：\n1void print_name();一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用void关键字：\n1void print_name(void);支持ANSI C的编译器解释为print_name()不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。\n一些函数接受（如，printf()和scanf()）许多参数。例如对于printf()，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C允许使用部分原型。例如，对于printf()可以使用下面的原型：\n1int printf(const char *, ...);这种原型表明，第1个参数是一个字符串（第11章中将详细介绍），可能还有其他未指定的参数。\nC库通过stdarg.h头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。第16章中详细介绍相关内容。\n函数原型的优点函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不用声明任何形参），但是这样做的弊大于利。\n有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第1次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：\n// 下面这行代码既是函数定义，也是函数原型\n12345678int　imax(int　a,　int　b)　&#123;　return　a　&gt;　b　?　a　:　b;　&#125;int　main()&#123;int　x,　z;...z　=　imax(x,　50);...&#125;递归C允许函数调用它自己，这种调用过程称为递归（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。\n可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。\n演示递归我们通过一个程序示例，来学习什么是递归。程序清单 9.6 中的 main()函数调用 up_and_down()函数，这次调用称为“第1级递归”。然后up_and_down()调用自己，这次调用称为“第2级递归”。接着第2级递归调用第3级递归，以此类推。该程序示例共有4级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量n的值，还显示了储存n的内存地址&amp;n（。本章稍后会详细讨论&amp;运算符，printf()函数使用%p转换说明打印地址，如果你的系统不支持这种格式，请使用%u或%lu代替%p）。\n程序清单9.6 recur.c程序\n12345678910111213141516/* recur.c -- 递归演示 */#include　&lt;stdio.h&gt;void up_and_down(int);int main(void)&#123;    up_and_down(1);    return 0;&#125;void up_and_down(int n)&#123;    printf(\"Level　%d:　n　location　%p\\n\",　n,　&amp;n);　//　#1    if(n　&lt;　4)    up_and_down(n　+　1);    printf(\"LEVEL　%d:　n　location　%p\\n\",　n,　&amp;n);　//　#2&#125;下面是在我们系统中的输出：\n12345678Level　1:　n　location　0x0012ff48Level　2:　n　location　0x0012ff3cLevel　3:　n　location　0x0012ff30Level　4:　n　location　0x0012ff24LEVEL　4:　n　location　0x0012ff24LEVEL　3:　n　location　0x0012ff30LEVEL　2:　n　location　0x0012ff3cLEVEL　1:　n　location　0x0012ff48我们来仔细分析程序中的递归是如何工作的。首先，main()调用了带参数1的up_and_down()函数，执行结果是up_and_down()中的形式参数n的值是1，所以打印语句#1打印Level 1。然后，由于n小于4，up_and_down()（第1级）调用实际参数为n + 1（或2）的up_and_down()（第2级）。于是第2级调用中的n的值是2，打印语句#1打印Level 2。与此类似，下面两次调用打印的分别是Level 3和Level 4。\n当执行到第4级时，n的值是4，所以if测试条件为假。up_and_down()函数不再调用自己。第4级调用接着执行打印语句#2，即打印LEVEL 4，因为n的值是4。此时，第4级调用结束，控制被传回它的主调函数（即第3级调用）。在第3级调用中，执行的最后一条语句是调用if语句中的第4级调用。被调函数（第4级调用）把控制返回在这个位置，因此，第3级调用继续执行后面的代码，打印语句#2打印LEVEL 3。然后第3级调用结束，控制被传回第2级调用，接着打印LEVEL 2，以此类推。\n注意，每级递归的变量 n 都属于本级递归私有。这从程序输出的地址值可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意，Level 1和LEVEL 1的地址相同，Level 2和LEVEL 2的地址相同，等等）。\n如果觉得不好理解，可以假设有一条函数调用链——fun1()调用 fun2()、fun2()调用 fun3()、fun3()调用fun4()。当 fun4()结束时，控制传回fun3()；当fun3()结束时，控制传回 fun2()；当fun2()结束时，控制传回fun1()。递归的情况与此类似，只不过fun1()、fun2()、fun3()和fun4()都是相同的函数。\n递归的基本原理初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程序清单9.6为例讲解几个要点。\n第1，每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各不相同。当程序最终返回 up_and_down()的第1 级调用时，最初的n仍然是它的初值1（见图9.4）。\n\n第2，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级up_and_down()返回上一级的up_and_down()，不能跳级回到main()中的第1级调用。\n第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的顺序：第1级、第2级、第3级和第4级，被执行了4次。\n第4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。\n第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。\n最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。例如，程序清单9.6中的up_and_down(n)调用up_and_down(n+1)。最终，实际参数等于4时，if的测试条件(n &lt; 4)为假。\n尾递归最简单的递归形式是把递归调用置于函数的末尾，即正好在 return 语句之前。这种形式的递归被称为尾递归（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。\n下面要介绍的程序示例中，分别用循环和尾递归计算阶乘。一个正整数的阶乘（factorial）是从1到该整数的所有整数的乘积。例如，3的阶乘（写作3！）是1×2×3。另外，0！等于1，负数没有阶乘。程序清单9.7中，第1个函数使用for循环计算阶乘，第2个函数使用递归计算阶乘。\n程序清单9.7 factor.c程序\n1234567891011121314151617181920212223242526272829303132333435363738394041424344// factor.c -- 使用循环和递归计算阶乘#include　&lt;stdio.h&gt;long fact(int n);long rfact(int n);int main(void)&#123;    int num;    printf(\"This　program　calculates　factorials.\\n\");    printf(\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\");    while　(scanf(\"%d\",　&amp;num)　==　1)    &#123;        if　(num　&lt;　0)        \tprintf(\"No　negative　numbers,　please.\\n\");        else　if　(num　&gt;　12)        \tprintf(\"Keep　input　under　13.\\n\");        else        &#123;            printf(\"loop:　%d　factorial　=　%ld\\n\",            num,　fact(num));            printf(\"recursion:　%d　factorial　=　%ld\\n\",            num,　rfact(num));        &#125;        printf(\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\");        &#125;    printf(\"Bye.\\n\");    return　0;&#125;long fact(int n)　　 // 使用循环的函数&#123;    long ans;    for(ans=1;n&gt;1;n--)    \tans*=n;    return　ans;&#125;long rfact(int n)　　// 使用递归的函数&#123;    long　ans;    if　(n　&gt;　0)    \tans = n * rfact(n - 1);    else    \tans　=　1;    return ans;&#125;测试驱动程序把输入限制在0~12。因为12!已快接近5亿，而13!比62亿还大，已超过我们系统中long类型能表示的范围。要计算超过12的阶乘，必须使用能表示更大范围的类型，如double或long long。\n下面是该程序的运行示例：\n123456789101112This　program　calculates　factorials.Enter　a　value　in　the　range　0-12　(q　to　quit):5loop:　5　factorial　=　120recursion:　5　factorial　=　120Enter　a　value　in　the　range　0-12　(q　to　quit):10loop:　10　factorial　=　3628800recursion:　10　factorial　=　3628800Enter　a　value　in　the　range　0-12　(q　to　quit):qBye.使用循环的函数把ans初始化为1，然后把ans与从n~2的所有递减整数相乘。根据阶乘的公式，还应该乘以1，但是这并不会改变结果。\n现在考虑使用递归的函数。该函数的关键是n! = n×(n-1)!。可以这样做是因为(n-1)!是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。阶乘的这一特性很适合使用递归。如果调用函数rfact()，rfact(n)是 n*rfact(n-1)。因此，通过调用 rfact(n-1)来计算rfact(n)，如程序清单9.7中所示。当然，必须要在满足某条件时结束递归，可以在n等于0时把返回值设为1。\n程序清单9.7中使用递归的输出和使用循环的输出相同。注意，虽然rfact()的递归调用不是函数的最后一行，但是当n&gt;0时，它是该函数执行的最后一条语句，因此它也是尾递归。\n既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以递归使用的内存更多，而且每次递归调用都会把创建的一组新变量放在栈中。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归，因此读者还是要好好理解递归。\n递归和倒序计算递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表示法根据 2 的幂来表示数字。例如，十进制数 234 实际上是2×102+3×101+4×100，所以二进制数101实际上是1×22+0×21+1×20。二进制数由0和1表示。\n我们要设计一个以二进制形式表示整数的方法或算法（algorithm）。例如，如何用二进制表示十进制数5？在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以通过5 % 2即可确定5的二进制数的最后一位是1还是0。一般而言，对于数字n，其二进制的最后一位是n % 2。因此，计算的第一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归函数的递归调用之前计算n % 2，在递归调用之后打印计算结果。这样，计算的第1个值正好是最后一个打印的值。\n要获得下一位数字，必须把原数除以 2。这种计算方法相当于在十进制下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是0；如果是奇数，就是1。例如，5/2得2（整数除法），2是偶数（2%2 得 0），所以下一位二进制数是 0。到目前为止，我们已经获得 01。继续重复这个过程。2/2得1，1%2得1，所以下一位二进制数是1。因此，我们得到5的等价二进制数是101。那么，程序应该何时停止计算？当与2相除的结果小于2时停止计算，因为只要结果大于或等于2，就说明还有二进制位。每次除以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，可以拿十进制数来做类比：628%10得8，因此8就是该数最后一位；而628/10得62，而62%10得2，所以该数的下一位是2，以此类推）。程序清单9.8演示了上述算法。\n程序清单9.8 binary.c程序\n123456789101112131415161718192021222324252627/* binary.c -- 以二进制形式打印制整数 */#include　&lt;stdio.h&gt;void to_binary(unsigned long n);int main(void)&#123;    unsigned long number;    printf(\"Enter　an　integer　(q　to　quit):\\n\");    while(scanf(\"%lu\",&amp;number)　==　1)    &#123;        printf(\"Binary　equivalent:　\");        to_binary(number);        putchar('\\n');        printf(\"Enter　an　integer　(q　to　quit):\\n\");    &#125;    printf(\"Done.\\n\");    return　0;&#125;void to_binary(unsigned long n)　/* 递归函数 */&#123;    int r;    r=n%2;    if(n&gt;=2)    \tto_binary(n/2);    putchar(r==0?'0':'1');    return;&#125;在该程序中，如果r的值是0，to_binary()函数就显示字符’0’；如果r的值是1，to_binary()函数则显示字符’1’。条件表达式r == 0 ? &#39;0&#39; : &#39;1&#39;用于把数值转换成字符。\n下面是该程序的运行示例：\n123456789101112Enter　an　integer　(q　to　quit):9Binary　equivalent:　1001Enter　an　integer　(q　to　quit):255Binary　equivalent:　11111111Enter　an　integer　(q　to　quit):1024Binary　equivalent:　10000000000Enter　an　integer　(q　to　quit):qdone.不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。第 15 章中会介绍一个不用递归实现该算法的例子。\n递归的优缺点递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。我们用一个例子来说明递归的优缺点。\n斐波那契数列的定义如下：第1 个和第2 个数字都是1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数 n，返回相应的斐波那契数值。\n首先，来看递归。递归提供一个简单的定义。如果把函数命名为Fibonacci()，那么如果n是1或2， Fibonacci(n)应返回1；对于其他数值，则应返回Fibonacci(n-1)+Fibonacci(n-2)：\n1234567unsigned　long　Fibonacci(unsigned　n)&#123;    if　(n　&gt;　2)    return　Fibonacci(n-1)　+　Fibonacci(n-2);    else    return　1;&#125;这个递归函数只是重述了数学定义的递归。该函数使用了双递归（double recursion），即函数每一级递归都要调用本身两次。这暴露了一个问题。\n为了说明这个问题，假设调用 Fibonacci(40)。这是第1 级递归调用，将创建一个变量 n。然后在该函数中要调用Fibonacci()两次，在第2级递归中要分别创建两个变量n。这两次调用中的每次调用又会进行两次调用，因而在第3级递归中要创建4个名为n的变量。此时总共创建了7个变量。由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5 章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的值。在本例中，指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃。\n虽然这是个极端的例子，但是该例说明：在程序中使用递归要特别注意，尤其是效率优先的程序。\n所有的C函数皆平等\n程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。\nmain()函数是否与其他函数不同？是的，main()的确有点特殊。当 main()与程序中的其他函数放在一起时，最开始执行的是main()函数中的第1条语句，但是这也是局限之处。main()也可以被自己或其他函数递归调用——尽管很少这样做。\n编译多源代码文件的程序使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明。\nUNIX假定在UNIX系统中安装了UNIX C编译器cc（最初的cc已经停用，但是许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc或clang）。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为a.out的可执行文件：\n1cc file1.c file2.c另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：\n1cc file1.c file2.oUNIX系统的make命令可自动管理多文件程序，但是这超出了本书的讨论范围。\n注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下载命令行编译器（GCC和Clang）。\nLinux假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文件：\n1gcc file1.c file2.c另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：\n1gcc file1.c file2.oDOS命令行编译器绝大多数DOS命令行编译器的工作原理和UNIX的cc命令类似，只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是.obj，而不是.o。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。\nWindows和苹果的IDE编译器Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的。项目（project）描述的是特定程序使用的资源。资源包括源代码文件。这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件（即扩展名为.h的文件），因为项目只管理使用的源代码文件，源代码文件中的#include指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文件。\n使用头文件如果把main()放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把I/O函数原型放在stdio.h中，把数学函数原型放在math.h中。你也可以这样用自定义的函数文件。\n另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些包含#define指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用#define指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了#define 定义的值，就必须在每个文件中修改。更好的做法是，把#define 指令放进头文件，然后在每个源文件中使用#include指令包含该文件即可。\n总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。我们考虑一个例子：假设要管理 4 家酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的房价相同。对于预订住宿多天的客户，第2天的房费是第1天的95%，第3天是第2天的95%，以此类推（暂不考虑这种策略的经济效益）。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。\n程序清单9.9、程序清单9.10和程序清单9.11演示了如何编写这样的程序。第1个程序清单包含main()函数，提供整个程序的组织结构。第 2 个程序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清单9.11列出了一个头文件，包含了该程序所有源文件中使用的自定义符号常量和函数原型。前面介绍过，在UNIX和DOS环境中，#include &quot;hotels.h&quot;指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）。如果使用IDE，需要知道如何把头文件合并成一个项目。\n程序清单9.9 usehotel.c控制模块\n1234567891011121314151617181920212223242526272829303132/* usehotel.c -- 房间费率程序 *//* 与程序清单9.10一起编译　　 */#include　&lt;stdio.h&gt;#include \"hotel.h\" /* 定义符号常量，声明函数 */int main(void)&#123;    int nights;    double hotel_rate;    int code;    while((code　=　menu())　!=　QUIT)    &#123;        switch(code)        &#123;            case　1:　 hotel_rate　=　HOTEL1;            break;            case　2:　 hotel_rate　=　HOTEL2;            break;            case　3:　 hotel_rate　=　HOTEL3;            break;            case　4:　 hotel_rate　=　HOTEL4;            break;            default: hotel_rate　=　0.0;            printf(\"Oops!\\n\");            break;        &#125;        nights　=　getnights();        showprice(hotel_rate,　nights);    &#125;    printf(\"Thank　you　and　goodbye.\\n\");    return 0;&#125;程序清单9.10 hotel.c函数支持模块\n123456789101112131415161718192021222324252627282930313233343536373839404142/* hotel.c -- 酒店管理函数 */#include　&lt;stdio.h&gt;#include　\"hotel.h\"int menu(void)&#123;    int code,status;    printf(\"\\n%s%s\\n\",　STARS,　STARS);    printf(\"Enter　the　number　of　the　desired　hotel:\\n\");    printf(\"1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic\\n\");    printf(\"3)　Chertworthy　Plaza　　　　　4)　The　Stockton\\n\");    printf(\"5)　quit\\n\");    printf(\"%s%s\\n\",　STARS,　STARS);    while((status　=　scanf(\"%d\",&amp;code))　!=　1　||    (code　&lt;　1　||　code　&gt;　5))    &#123;        if　(status　!=　1)            scanf(\"%*s\");　// 处理非整数输入        printf(\"Enter　an　integer　from　1　to　5,　please.\\n\");    &#125;    return code;&#125;int getnights(void)&#123;    int nights;    printf(\"How　many　nights　are　needed?　\");    while(scanf(\"%d\",　&amp;nights)　!=　1)    &#123;        scanf(\"%*s\");　　　// 处理非整数输入        printf(\"Please　enter　an　integer,　such　as　2.\\n\");    &#125;    return　nights;&#125;void showprice(double rate,int nights)&#123;    int　n;    double　total　=　0.0;    double　factor　=　1.0;    for (n = 1; n &lt;= nights; n++, factor *= DISCOUNT)    \ttotal += rate * factor;    printf(\"The　total　cost　will　be　$%0.2f.\\n\",　total);&#125;程序清单9.11 hotel.h头文件\n12345678910111213141516/* hotel.h -- 符号常量和 hotel.c 中所有函数的原型 */#define　QUIT　　　　　5#define　HOTEL1　　180.00#define　HOTEL2　　225.00#define　HOTEL3　　255.00#define　HOTEL4　　355.00#define　DISCOUNT　 0.95#define STARS \"**********************************\"// 显示选择列表int menu(void);// 返回预订天数int getnights(void);// 根据费率、入住天数计算费用// 并显示结果void showprice(double rate,int nights);下面是这个多文件程序的运行示例：\n1234567891011121314151617181920212223242526******************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************3How　many　nights　are　needed?　1The　total　cost　will　be　$255.00.********************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************4How　many　nights　are　needed?　3The　total　cost　will　be　$1012.64.********************************************************************Enter　the　number　of　the　desired　hotel:1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic3)　Chertworthy　Plaza　　　　　 4)　The　Stockton5)　quit********************************************************************5Thank　you　and　goodbye.顺带一提，该程序中有几处编写得很巧妙。尤其是，menu()和getnights()函数通过测试scanf()的返回值来跳过非数值数据，而且调用 scanf(&quot;%*s&quot;)跳至下一个空白字符。注意，menu()函数中是如何检查非数值输入和超出范围的数据：\n1while((status=scanf(\"%d\",&amp;code))!= 1||(code&lt;1||code&gt;5))以上代码段利用了C语言的两个规则：从左往右对逻辑表达式求值；一旦求值结果为假，立即停止求值。在该例中，只有在scanf()成功读入一个整数值后，才会检查code的值。\n用不同的函数处理不同的任务时应检查数据的有效性。当然，首次编写menu()或getnights()函数时可以暂不添加这一功能，只写一个简单的scanf()即可。待基本版本运行正常后，再逐步改善各模块。\n查找地址：&amp;运算符指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的scanf()函数中就使用地址作为参数。概括地说，如果主调函数不使用return返回的值，则必须通过地址才能修改主调函数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元&amp;运算符的用法。\n一元&amp;运算符给出变量的存储地址。如果pooh是变量名，那么&amp;pooh是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：\n1pooh = 24;假设pooh的存储地址是0B76（PC地址通常用十六进制形式表示）。那么，下面的语句：\n1printf(\"%d %p\\n\", pooh, &amp;pooh);将输出如下内容（%p是输出地址的转换说明）：\n124 0B76程序清单9.12中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。\n程序清单9.12 loccheck.c程序\n123456789101112131415161718/* loccheck.c　-- 查看变量被储存在何处　*/#include　&lt;stdio.h&gt;void mikado(int);　　　　　　　/* 函数原型 */int main(void)&#123;    int pooh = 2, bah = 5; /* main()的局部变量 */    printf(\"In　main(),　pooh　=　%d　and　&amp;pooh　=　%p\\n\",　pooh,&amp;pooh);    printf(\"In　main(),　bah　=　%d　and　&amp;bah　=　%p\\n\",　bah,　&amp;bah);    mikado(pooh);    return 0;&#125;void mikado(int bah)　　　　　 /* 定义函数 */&#123;    int pooh = 10;　　　　　　 /* mikado()的局部变量 */    printf(\"In　mikado(),　pooh　=　%d　and　&amp;pooh　=　%p\\n\",　pooh,　&amp;pooh);    printf(\"In　mikado(),　bah　=　%d　and　&amp;bah　=　%p\\n\",　 bah,　&amp;bah);&#125;程序清单9.12中使用ANSI C的%p格式打印地址。我们的系统输出如下：\n1234In　main(),　pooh　=　2　and　&amp;pooh　=　0x7fff5fbff8e8In　main(),　bah　=　5　and　&amp;bah　=　0x7fff5fbff8e4In　mikado(),　pooh　=　10　and　&amp;pooh　=　0x7fff5fbff8b8In　mikado(),　bah　=　2　and　&amp;bah　=　0x7fff5fbff8bc实现不同，%p表示地址的方式也不同。然而，许多实现都如本例所示，以十六进制显示地址。顺带一提，每个十六进制数对应4位，该例显示12个十六进制数，对应48位地址。\n该例的输出说明了什么？首先，两个pooh的地址不同，两个bah的地址也不同。因此，和前面介绍的一样，计算机把它们看成4个独立的变量。其次，函数调用mikado(pooh)把实际参数（main()中的pooh）的值（2）传递给形式参数（mikado()中的bah）。注意，这种传递只传递了值。涉及的两个变量（main()中的pooh和mikado()中的bah）并未改变。\n我们强调第2 点，是因为这并不是在所有语言中都成立。例如，在 FORTRAN中，子例程会影响主调例程的原始变量。子例程的变量名可能与原始变量不同，但是它们的地址相同。但是，在 C语言中不是这样。每个C函数都有自己的变量。这样做更可取，因为这样做可以防止原始变量被被调函数中的副作用意外修改。然而，正如下节所述，这也带来了一些麻烦。\n更改主调函数中的变量有时需要在一个函数中更改其他函数的变量。例如，普通的排序任务中交换两个变量的值。假设要交换两个变量x和y的值。简单的思路是：\n12x　=　y;y　=　x;这完全不起作用，因为执行到第2行时，x的原始值已经被y的原始值替换了。因此，要多写一行代码，储存x的原始值：\n123temp　=　x;x　=　y;y　=　temp;上面这 3 行代码便可实现交换值的功能，可以编写成一个函数并构造一个驱动程序来测试。在程序清单9.13中，为清楚地表明变量属于哪个函数，在main()中使用变量x和y，在intercharge()中使用u和v。\n程序清单9.13 swap1.c程序\n12345678910111213141516171819/* swap1.c -- 第1个版本的交换函数 */#include　&lt;stdio.h&gt;void interchange(int u, int v); /* 声明函数 */int main(void)&#123;    int x　=　5,　y　=　10;    printf(\"Originally　x　=　%d　and　y　=　%d.\\n\",　x,　y);    interchange(x,　y);    printf(\"Now　x　=　%d　and　y　=　%d.\\n\",　x,　y);    return 0;&#125;void interchange(int u, int v)　/* 定义函数　*/&#123;    int temp;    temp=u;    u=v;    v=temp;&#125;运行该程序后，输出如下：\n12Originally　x　=　5　and　y　=　10.Now　x　=　5　and　y　=　10.两个变量的值并未交换！我们在interchange()中添加一些打印语句来检查错误（见程序清单9.14）。\n程序清单9.14 swap2.c程序\n123456789101112131415161718192021/* swap2.c -- 查找swap1.c的问题 */#include　&lt;stdio.h&gt;void interchange(int　u,　int　v);int main(void)&#123;    int x=5,y=10;    printf(\"Originally　x　=　%d　and　y　=　%d.\\n\",　x,　y);    interchange(x,　y);    printf(\"Now　x　=　%d　and　y　=　%d.\\n\",　x,　y);    return 0;&#125;void interchange(int　u,　int　v)&#123;    int temp;    printf(\"Originally　u　=　%d　and　v　=　%d.\\n\",　u,　v);    temp　=　u;    u　=　v;    v　=　temp;    printf(\"Now　u　=　%d　and　v　=　%d.\\n\",　u,　v);&#125;下面是该程序的输出：\n1234Originally　x　=　5　and　y　=　10.Originally　u　=　5　and　v　=　10.Now　u　=　10　and　v　=　5.Now　x　=　5　and　y　=　10.看来，interchange()没有问题，它交换了 u 和 v 的值。问题出在把结果传回 main()时。interchange()使用的变量并不是main()中的变量。因此，交换u和v的值对x和y的值没有影响！是否能用return语句把值传回main()？当然可以，在interchange()的末尾加上下面一行语句：\n1return(u);然后修改main()中的调用：\n1x = interchange(x,y);这只能改变x的值，而y的值依旧没变。用return语句只能把被调函数中的一个值传回主调函数，但是现在要传回两个值。这没问题！不过，要使用指针。\n指针简介指针？什么是指针？从根本上看，指针（pointer）是一个值为内存地址的变量（或数据对象）。正如char类型变量的值是字符，int类型变量的值是整数，指针变量的值是地址。在C语言中，指针有许多用法。本章将介绍如何把指针作为函数参数使用，以及为何要这样用。\n假设一个指针变量名是ptr，可以编写如下语句：\n1ptr=&amp;pooh; // 把pooh的地址赋给ptr对于这条语句，我们说ptr“指向”pooh。ptr和&amp;pooh的区别是ptr是变量，而&amp;pooh是常量。或者，ptr是可修改的左值，而&amp;pooh是右值。还可以把ptr指向别处：\n1ptr = &amp;bah; // 把ptr指向bah，而不是pooh现在ptr的值是bah的地址。\n要创建指针变量，先要声明指针变量的类型。假设想把ptr声明为储存int类型变量地址的指针，就要使用下面介绍的新运算符。\n间接运算符：*假设已知ptr指向bah，如下所示：\n1ptr = &amp;bah;然后使用间接运算符*（indirection operator）找出储存在bah中的值，该运算符有时也称为解引用运算符（dereferencing operator）。不要把间接运算符和二元乘法运算符（*）混淆，虽然它们使用的符号相同，但语法功能不同。\n1val = *ptr; // 找出ptr指向的值语句ptr = &amp;bah;和val = *ptr;放在一起相当于下面的语句：\n1val = bah;由此可见，使用地址和间接运算符可以间接完成上面这条语句的功能，这也是“间接运算符”名称的由来。\n小结：与指针相关的运算符\n地址运算符：&amp;\n一般注解：\n后跟一个变量名时，&amp;给出该变量的地址。\n示例：\n&amp;nurse表示变量nurse的地址。\n地址运算符：*\n一般注解：\n后跟一个指针名或地址时，*给出储存在指针指向地址上的值。\n示例：\n123nurse　=　22;ptr = &amp;nurse; // 指向nurse的指针val = *ptr;　 // 把ptr指向的地址上的值赋给val执行以上3条语句的最终结果是把22赋给val。\n声明指针相信读者已经很熟悉如何声明int类型和其他基本类型的变量，那么如何声明指针变量？你也许认为是这样声明：\n1pointer ptr; // 不能这样声明指针为什么不能这样声明？因为声明指针变量时必须指定指针所指向变量的类型，因为不同的变量类型占用不同的存储空间，一些指针操作要求知道操作对象的大小。另外，程序必须知道储存在指定地址上的数据类型。long和float可能占用相同的存储空间，但是它们储存数字却大相径庭。下面是一些指针的声明示例：\n12345int *pi;　　 // pi是指向int类型变量的指针char *pc;　　　　// pc是指向char类型变量的指针float *pf, *pg; // pf、pg都是指向float类型变量的指针类型说明符表明了指针所指向对象的类型，星号（*）表明声明的变量是一个指针。int *pi;声明的意思是pi是一个指针，*pi是int类型（见图9.5）。\n\n*和指针名之间的空格可有可无。通常，程序员在声明时使用空格，在解引用变量时省略空格。\npc指向的值（*pc）是char类型。pc本身是什么类型？我们描述它的类型是“指向char类型的指针”。pc 的值是一个地址，在大部分系统内部，该地址由一个无符号整数表示。但是，不要把指针认为是整数类型。一些处理整数的操作不能用来处理指针，反之亦然。例如，可以把两个整数相乘，但是不能把两个指针相乘。所以，指针实际上是一个新类型，不是整数类型。因此，如前所述，ANSI C专门为指针提供了%p格式的转换说明。\n使用指针在函数间通信我们才刚刚接触指针，指针的世界丰富多彩。本节着重介绍如何使用指针解决函数间的通信问题。请看程序清单9.15，该程序在interchange()函数中使用了指针参数。稍后我们将对该程序做详细分析。\n程序清单9.15 swap3.c程序\n12345678910111213141516171819/* swap3.c -- 使用指针解决交换函数的问题 */#include　&lt;stdio.h&gt;void interchange(int * u, int * v);int　main(void)&#123;    int　x　=　5,　y　=　10;    printf(\"Originally　x　=　%d　and　y　=　%d.\\n\",　x,　y);    interchange(&amp;x, &amp;y);　 // 把地址发送给函数    printf(\"Now　x　=　%d　and　y　=　%d.\\n\",　x,　y);    return 0;&#125;void interchange(int *u, int *v)&#123;    int　temp;    temp = *u;　　// temp获得 u 所指向对象的值    *u = *v;    *v = temp;&#125;该程序是否能正常运行？下面是程序的输出：\n12Originally　x　=　5　and　y　=　10.Now　x　=　10　and　y　=　5.没问题，一切正常。接下来，我们分析程序清单9.15的运行情况。首先看函数调用：\n1interchange(&amp;x, &amp;y);该函数传递的不是x和y的值，而是它们的地址。这意味着出现在interchange()原型和定义中的形式参数u和v将把地址作为它们的值。因此，应把它们声明为指针。由于x和y是整数，所以u和v是指向整数的指针，其声明如下：\n1void interchange (int *u, int * v)接下来，在函数体中声明了一个交换值时必需的临时变量：\n1int temp;通过下面的语句把x的值储存在temp中：\n1temp = *u;记住，u的值是&amp;x，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。不要写成这样：\n1temp = u; /* 不要这样做 */因为这条语句赋给temp的是x的地址（u的值就是x的地址），而不是x的值。函数要交换的是x和y的值，而不是它们的地址。\n与此类似，把y的值赋给x，要使用下面的语句：\n1*u = *v;这条语句相当于：\n1x = y;我们总结一下该程序示例做了什么。我们需要一个函数交换x和y的值。把x和y的地址传递给函数，我们让interchange()访问这两个函数。使用指针和*运算符，该函数可以访问储存在这些位置的值并改变它们。\n可以省略ANSI C风格的函数原型中的形参名，如下所示：\n1void interchange(int *,int *);一般而言，可以把变量相关的两类信息传递给函数。如果这种形式的函数调用，那么传递的是x的值：\n1function1(x);如果下面形式的函数调用，那么传递的是x的地址：\n1function2(&amp;x);第1种形式要求函数定义中的形式参数必须是一个与x的类型相同的变量：\n1int function1(int num)第2种形式要求函数定义中的形式参数必须是一个指向正确类型的指针：\n1int function2(int *ptr)如果要计算或处理值，那么使用第 1 种形式的函数调用；如果要在被调函数中改变主调函数的变量，则使用第2种形式的函数调用。我们用过的scanf()函数就是这样。当程序要把一个值读入变量时（如本例中的num），调用的是scanf(&quot;%d&quot;, &amp;num)。scanf()读取一个值，然后把该值储存到指定的地址上。\n对本例而言，指针让interchange()函数通过自己的局部变量改变main()中变量的值。\n熟悉Pascal和Modula-2的读者应该看出第1种形式和Pascal的值参数相同，第2种形式和Pascal的变量参数类似。C++程序员可能认为，既然C和C++都使用指针变量，那么C应该也有引用变量。让他们失望了，C没有引用变量。对BASIC程序员而言，可能很难理解整个程序。如果觉得本节的内容晦涩难懂，请多做一些相关的编程练习，你会发现指针非常简单实用（见图9.6）。\n\n变量：名称、地址和值\n通过前面的讨论发现，变量的名称、地址和变量的值之间关系密切。我们来进一步分析。\n编写程序时，可以认为变量有两个属性：名称和值（还有其他性质，如类型，暂不讨论）。计算机编译和加载程序后，认为变量也有两个属性：地址和值。地址就是变量在计算机内部的名称。\n在许多语言中，地址都归计算机管，对程序员隐藏。然而在 C 中，可以通过&amp;运算符访问地址，通过*运算符获得地址上的值。例如，&amp;barn表示变量barn的地址，使用函数名即可获得变量的数值。例如，printf(&quot;%d\\n&quot;, barn)打印barn的值，使用*运算符即可获得储存在地址上的值。如果pbarn=&amp;barn;，那么*pbarn表示的是储存在&amp;barn地址上的值。\n简而言之，普通变量把值作为基本量，把地址作为通过&amp;运算符获得的派生量，而指针变量把地址作为基本量，把值作为通过*运算符获得的派生量。\n虽然打印地址可以满足读者好奇心，但是这并不是&amp;运算符的主要用途。更重要的是使用&amp;、*和指针可以操纵地址和地址上的内容，如swap3.c程序（程序清单9.15）所示。\n小结：函数\n形式：\n典型的ANSI C函数的定义形式为：\n返回类型 名称（形参声明列表）\n函数体\n形参声明列表是用逗号分隔的一系列变量声明。除形参变量外，函数的其他变量均在函数体的花括号之内声明。\n示例：\n123456int diff(int x,int y)　//　ANSI　C&#123; // 函数体开始    int z;　　　　 // 声明局部变量    z=x-y;    return z; // 返回一个值&#125; // 函数体结束传递值：\n实参用于把值从主调函数传递给被调函数。如果变量a和b的值分别是5和2，那么调用：\n1c = diff(a,b);把5和2分别传递给变量x和y。5和2称为实际参数（简称实参），diff()函数定义中的变量x和y称为形式参数（简称形参）。使用关键字return把被调函数中的一个值传回主调函数。本例中， c接受z的值3。被调函数一般不会改变主调函数中的变量，如果要改变，应使用指针作为参数。如果希望把更多的值传回主调函数，必须这么做。\n函数的返回类型：\n函数的返回类型指的是函数返回值的类型。如果返回值的类型与声明的返回类型不匹配，返回值将被转换成函数声明的返回类型。\n函数签名：\n函数的返回类型和形参列表构成了函数签名。因此，函数签名指定了传入函数的值的类型和函数返回值的类型。\n示例：\n123456789101112131415double duff(double, int);　// 函数原型int main(void)&#123;    double　q,　x;    int　n;    ...    q = duff(x,n);　　　　　//函数调用    ...&#125;double duff(double u, int k)　　//函数定义&#123;    double　tor;    ...    return tor;　 //返回double类型的值&#125;关键概念如果想用C编出高效灵活的程序，必须理解函数。把大型程序组织成若干函数非常有用，甚至很关键。如果让一个函数处理一个任务，程序会更好理解，更方便调试。要理解函数是如何把信息从一个函数传递到另一函数，也就是说，要理解函数参数和返回值的工作原理。另外，要明白函数形参和其他局部变量都属于函数私有，因此，声明在不同函数中的同名变量是完全不同的变量。而且，函数无法直接访问其他函数中的变量。这种限制访问保护了数据的完整性。但是，当确实需要在函数中访问另一个函数的数据时，可以把指针作为函数的参数。\n本章小结函数可以作为组成大型程序的构件块。每个函数都应该有一个单独且定义好的功能。使用参数把值传给函数，使用关键字return把值返回函数。如果函数返回的值不是int类型，则必须在函数定义和函数原型中指定函数的类型。如果需要在被调函数中修改主调函数的变量，使用地址或指针作为参数。\nANSI C提供了一个强大的工具——函数原型，允许编译器验证函数调用中使用的参数个数和类型是否正确。\nC 函数可以调用本身，这种调用方式被称为递归。一些编程问题要用递归来解决，但是递归不仅消耗内存多，效率不高，而且费时。\n","plink":"https://dxsummer.gitee.io/posts/71adb096/"},{"title":"Step6 字符输入/输出和输入验证","date":"2020-06-07T09:52:44.000Z","date_formatted":{"ll":"2020年6月7日","L":"2020/06/07","MM-DD":"06-07"},"updated":"2020-06-09T10:13:34.000Z","content":"本章介绍以下内容：\n更详细地介绍输入、输出以及缓冲输入和无缓冲输入的区别\n如何通过键盘模拟文件结尾条件\n如何使用重定向把程序和文件相连接\n创建更友好的用户界面\n在涉及计算机的话题时，我们经常会提到输入（input）和输出（output）。我们谈论输入和输出设备（如键盘、U盘、扫描仪和激光打印机），讲解如何处理输入数据和输出数据，讨论执行输入和输出任务的函数。本章主要介绍用于输入和输出的函数（简称I/O函数）。\nI/O函数（如printf()、scanf()、getchar()、putchar()等）负责把信息传送到程序中。前几章简单介绍过这些函数，本章将详细介绍它们的基本概念。同时，还会介绍如何设计与用户交互的界面。\n最初，输入/输出函数不是C定义的一部分，C把开发这些函数的任务留给编译器的实现者来完成。在实际应用中，UNIX 系统中的 C 实现为这些函数提供了一个模型。ANSI C 库吸取成功的经验，把大量的UNIX I/O函数囊括其中，包括一些我们曾经用过的。由于必须保证这些标准函数在不同的计算机环境中能正常工作，所以它们很少使用某些特殊系统才有的特性。因此，许多C供应商会利用硬件的特性，额外提供一些I/O函数。其他函数或函数系列需要特殊的操作系统支持，如Winsows或Macintosh OS提供的特殊图形界面。这些有针对性、非标准的函数让程序员能更有效地使用特定计算机编写程序。本章只着重讲解所有系统都通用的标准 I/O 函数，用这些函数编写的可移植程序很容易从一个系统移植到另一个系统。处理文件输入/输出的程序也可以使用这些函数。\n许多程序都有输入验证，即判断用户的输入是否与程序期望的输入匹配。本章将演示一些与输入验证相关的问题和解决方案。\n单字符I/O：getchar()和putchar()第 7 章中提到过，getchar()和 putchar()每次只处理一个字符。你可能认为这种方法实在太笨拙了，毕竟与我们的阅读方式相差甚远。但是，这种方法很适合计算机。而且，这是绝大多数文本（即，普通文字）处理程序所用的核心方法。为了帮助读者回忆这些函数的工作方式，请看程序清单8.1。该程序获取从键盘输入的字符，并把这些字符发送到屏幕上。程序使用 while 循环，当读到#字符时停止。\n程序清单8.1 echo.c程序\n12345678910/* echo.c -- 重复输入 */#include　&lt;stdio.h&gt;int　main(void)&#123;    char　ch;    while　((ch　=　getchar())　!=　'#')        putchar(ch);    return　0;&#125;自从ANSI C标准发布以后，C就把stdio.h头文件与使用getchar()和putchar()相关联，这就是为什么程序中要包含这个头文件的原因（其实，getchar()和 putchar()都不是真正的函数，它们被定义为供预处理器使用的宏，我们在第16章中再详细讨论）。运行该程序后，与用户的交互如下：\n1234Hello,　there.　I　would[enter]Hello,　there.　I　wouldlike　a　#3　bag　of　potatoes.[enter]like　a读者可能好奇，为何输入的字符能直接显示在屏幕上？如果用一个特殊字符（如，#）来结束输入，就无法在文本中使用这个字符，是否有更好的方法结束输入？要回答这些问题，首先要了解 C程序如何处理键盘输入，尤其是缓冲和标准输入文件的概念。\n缓冲区如果在老式系统运行程序清单8.1，你输入文本时可能显示如下：\n12HHeelllloo,, tthheerree..II wwoouulldd[enter]lliikkee aa #以上行为是个例外。像这样回显用户输入的字符后立即重复打印该字符是属于无缓冲（或直接）输入，即正在等待的程序可立即使用输入的字符。对于该例，大部分系统在用户按下Enter键之前不会重复打印刚输入的字符，这种输入形式属于缓冲输入。用户输入的字符被收集并储存在一个被称为缓冲区（buffer）的临时存储区，按下Enter键后，程序才可使用用户输入的字符。图8.1比较了这两种输入。\n\n为什么要有缓冲区？首先，把若干字符作为一个块进行传输比逐个发送这些字符节约时间。其次，如果用户打错字符，可以直接通过键盘修正错误。当最后按下Enter键时，传输的是正确的输入。\n虽然缓冲输入好处很多，但是某些交互式程序也需要无缓冲输入。例如，在游戏中，你希望按下一个键就执行相应的指令。因此，缓冲输入和无缓冲输入都有用武之地。\n缓冲分为两类：完全缓冲I/O和行缓冲I/O。完全缓冲输入指的是当缓冲区被填满时才刷新缓冲区（内容被发送至目的地），通常出现在文件输入中。缓冲区的大小取决于系统，常见的大小是 512 字节和 4096字节。行缓冲I/O指的是在出现换行符时刷新缓冲区。键盘输入通常是行缓冲输入，所以在按下Enter键后才刷新缓冲区。\n那么，使用缓冲输入还是无缓冲输入？ANSI C和后续的C标准都规定输入是缓冲的，不过最初K&amp;R把这个决定权交给了编译器的编写者。读者可以运行echo.c程序观察输出的情况，了解所用的输出类型。\nANSI C决定把缓冲输入作为标准的原因是：一些计算机不允许无缓冲输入。如果你的计算机允许无缓冲输入，那么你所用的C编译器很可能会提供一个无缓冲输入的选项。例如，许多IBM PC兼容机的编译器都为支持无缓冲输入提供一系列特殊的函数，其原型都在conio.h头文件中。这些函数包括用于回显无缓冲输入的getche()函数和用于无回显无缓冲输入的getch()函数（回显输入意味着用户输入的字符直接显示在屏幕上，无回显输入意味着击键后对应的字符不显示）。UNIX系统使用另一种不同的方式控制缓冲。在UNIX系统中，可以使用ioctl()函数（该函数属于UNIX库，但是不属于C标准）指定待输入的类型，然后用getchar()执行相应的操作。在ANSI C中，用setbuf()和setvbuf()函数（详见第13章）控制缓冲，但是受限于一些系统的内部设置，这些函数可能不起作用。总之，ANSI没有提供调用无缓冲输入的标准方式，这意味着是否能进行无缓冲输入取决于计算机系统。在这里要对使用无缓冲输入的朋友说声抱歉，本书假设所有的输入都是缓冲输入。\n结束键盘输入在echo.c程序（程序清单8.1）中，只要输入的字符中不含#，那么程序在读到#时才会结束。但是， #也是一个普通的字符，有时不可避免要用到。应该用一个在文本中用不到的字符来标记输入完成，这样的字符不会无意间出现在输入中，在你不希望结束程序的时候终止程序。C 的确提供了这样的字符，不过在此之前，先来了解一下C处理文件的方式。\n文件、流和键盘输入文件（file）是存储器中储存信息的区域。通常，文件都保存在某种永久存储器中（如，硬盘、U盘或DVD等）。毫无疑问，文件对于计算机系统相当重要。例如，你编写的C程序就保存在文件中，用来编译C程序的程序也保存在文件中。后者说明，某些程序需要访问指定的文件。当编译储存在名为 echo.c 文件中的程序时，编译器打开echo.c文件并读取其中的内容。当编译器处理完后，会关闭该文件。其他程序，例如文字处理器，不仅要打开、读取和关闭文件，还要把数据写入文件。\nC 是一门强大、灵活的语言，有许多用于打开、读取、写入和关闭文件的库函数。从较低层面上，C可以使用主机操作系统的基本文件工具直接处理文件，这些直接调用操作系统的函数被称为底层 I/O （low-level I/O）。由于计算机系统各不相同，所以不可能为普通的底层I/O函数创建标准库，ANSI C也不打算这样做。然而从较高层面上，C还可以通过标准I/O包（standard I/O package）来处理文件。这涉及创建用于处理文件的标准模型和一套标准I/O函数。在这一层面上，具体的C实现负责处理不同系统的差异，以便用户使用统一的界面。\n上面讨论的差异指的是什么？例如，不同的系统储存文件的方式不同。有些系统把文件的内容储存在一处，而文件相关的信息储存在另一处；有些系统在文件中创建一份文件描述。在处理文件方面，有些系统使用单个换行符标记行末尾，而其他系统可能使用回车符和换行符的组合来表示行末尾。有些系统用最小字节来衡量文件的大小，有些系统则以字节块的大小来衡量。\n如果使用标准 I/O 包，就不用考虑这些差异。因此，可以用 if (ch ==&#39;\\n&#39;)检查换行符。即使系统实际用的是回车符和换行符的组合来标记行末尾，I/O函数会在两种表示法之间相互转换。\n从概念上看，C程序处理的是流而不是直接处理文件。流（stream）是一个实际输入或输出映射的理想化数据流。这意味着不同属性和不同种类的输入，由属性更统一的流来表示。于是，打开文件的过程就是把流与文件相关联，而且读写都通过流来完成。\n第13章将更详细地讨论文件。本章着重理解C把输入和输出设备视为存储设备上的普通文件，尤其是把键盘和显示设备视为每个C程序自动打开的文件。stdin流表示键盘输入，stdout流表示屏幕输出。getchar()、putchar()、printf()和scanf()函数都是标准I/O包的成员，处理这两个流。\n以上讨论的内容说明，可以用处理文件的方式来处理键盘输入。例如，程序读文件时要能检测文件的末尾才知道应在何处停止。因此，C 的输入函数内置了文件结尾检测器。既然可以把键盘输入视为文件，那么也应该能使用文件结尾检测器结束键盘输入。下面我们从文件开始，学习如何结束文件。\n文件结尾计算机操作系统要以某种方式判断文件的开始和结束。检测文件结尾的一种方法是，在文件末尾放一个特殊的字符标记文件结尾。CP/M、IBM-DOS和MS-DOS的文本文件曾经用过这种方法。如今，这些操作系统可以使用内嵌的Ctrl+Z字符来标记文件结尾。这曾经是操作系统使用的唯一标记，不过现在有一些其他的选择，例如记录文件的大小。所以现代的文本文件不一定有嵌入的Ctrl+Z，但是如果有，该操作系统会将其视为一个文件结尾标记。图8.2演示了这种方法。\n\n操作系统使用的另一种方法是储存文件大小的信息。如果文件有3000字节，程序在读到3000字节时便达到文件的末尾。MS-DOS 及其相关系统使用这种方法处理二进制文件，因为用这种方法可以在文件中储存所有的字符，包括Ctrl+Z。新版的DOS也使用这种方法处理文本文件。UNIX使用这种方法处理所有的文件。\n无论操作系统实际使用何种方法检测文件结尾，在C语言中，用getchar()读取文件检测到文件结尾时将返回一个特殊的值，即EOF（end of file的缩写）。scanf()函数检测到文件结尾时也返回EOF。通常， EOF定义在stdio.h文件中：\n1#define EOF (-1)为什么是-1？因为getchar()函数的返回值通常都介于0～127，这些值对应标准字符集。但是，如果系统能识别扩展字符集，该函数的返回值可能在0～255之间。无论哪种情况，-1都不对应任何字符，所以，该值可用于标记文件结尾。\n某些系统也许把EOF定义为-1以外的值，但是定义的值一定与输入字符所产生的返回值不同。如果包含stdio.h文件，并使用EOF符号，就不必担心EOF值不同的问题。这里关键要理解EOF是一个值，标志着检测到文件结尾，并不是在文件中找得到的符号。\n那么，如何在程序中使用EOF？把getchar()的返回值和EOF作比较。如果两值不同，就说明没有到达文件结尾。也就是说，可以使用下面这样的表达式：\n1while ((ch = getchar()) != EOF)如果正在读取的是键盘输入不是文件会怎样？绝大部分系统（不是全部）都有办法通过键盘模拟文件结尾条件。了解这些以后，读者可以重写程序清单8.1的程序，如程序清单8.2所示。\n程序清单8.2 echo_eof.c程序\n12345678910/* echo_eof.c -- 重复输入，直到文件结尾 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　ch;    while　((ch　=　getchar())　!=　EOF)    putchar(ch);    return　0;&#125;注意下面几点。\n不用定义EOF，因为stdio.h中已经定义过了。\n不用担心EOF的实际值，因为EOF在stdio.h中用#define预处理指令定义，可直接使用，不必再编写代码假定EOF为某值。\n变量ch的类型从char变为int，因为char类型的变量只能表示0～255的无符号整数，但是EOF的值是-1。还好，getchar()函数实际返回值的类型是int，所以它可以读取EOF字符。如果实现使用有符号的char类型，也可以把ch声明为char类型，但最好还是用更通用的形式。\n由于getchar()函数的返回类型是int，如果把getchar()的返回值赋给char类型的变量，一些编译器会警告可能丢失数据。\nch是整数不会影响putchar()，该函数仍然会打印等价的字符。\n使用该程序进行键盘输入，要设法输入EOF字符。不能只输入字符EOF，也不能只输入-1（输入-1会传送两个字符：一个连字符和一个数字1）。正确的方法是，必须找出当前系统的要求。例如，在大多数UNIX和Linux系统中，在一行开始处按下Ctrl+D会传输文件结尾信号。许多微型计算机系统都把一行开始处的Ctrl+Z识别为文件结尾信号，一些系统把任意位置的Ctrl+Z解释成文件结尾信号。\n下面是在UNIX系统下运行echo_eof.c程序的缓冲示例：\n1234567She　walks　in　beauty,　like　the　nightShe　walks　in　beauty,　like　the　nightOf　cloudless　climes　and　starry　skies...Of　cloudless　climes　and　starry　skies...Lord　ByronLord　Byron[Ctrl+D]每次按下Enter键，系统便会处理缓冲区中储存的字符，并在下一行打印该输入行的副本。这个过程一直持续到以UNIX风格模拟文件结尾（按下Ctrl+D）。在PC中，要按下Ctrl+Z。\n我们暂停一会。既然echo_eof.c程序能把用户输入的内容拷贝到屏幕上，那么考虑一下该程序还可以做什么。假设以某种方式把一个文件传送给它，然后它把文件中的内容打印在屏幕上，当到达文件结尾发现EOF信号时停止。或者，假设以某种方式把程序的输出定向到一个文件，然后通过键盘输入数据，用echo_eof.c 来储存在文件中输入的内容。假设同时使用这两种方法：把输入从一个文件定向到echo_eof.c中，并把输出发送至另一个文件，然后便可以使用echo_eof.c来拷贝文件。这个小程序有查看文件内容、创建一个新文件、拷贝文件的潜力，没想到一个小程序竟然如此多才多艺！关键是要控制输入流和输出流，这是我们下一个要讨论的主题。\n注意 模拟EOF和图形界面\n模拟EOF的概念是在使用文本界面的命令行环境中产生的。在这种环境中，用户通过击键与程序交互，由操作系统生成EOF信号。但是在一些实际应用中，却不能很好地转换成图形界面（如Windows和Macintosh），这些用户界面包含更复杂的鼠标移动和按钮点击。程序要模拟EOF的行为依赖于编译器和项目类型。例如，Ctrl+Z可以结束输入或整个程序，这取决于特定的设置。\n重定向和文件输入和输出涉及函数、数据和设备。例如，考虑 echo_eof.c，该程序使用输入函数 getchar()。输出设备（我们假设）是键盘，输入数据流由字符组成。假设你希望输入函数和数据类型不变，仅改变程序查找数据的位置。那么，程序如何知道去哪里查找输入？\n在默认情况下，C程序使用标准I/O包查找标准输入作为输入源。这就是前面介绍过的stdin流，它是把数据读入计算机的常用方式。它可以是一个过时的设备，如磁带、穿孔卡或电传打印机，或者（假设）是键盘，甚至是一些先进技术，如语音输入。然而，现代计算机非常灵活，可以让它到别处查找输入。尤其是，可以让一个程序从文件中查找输入，而不是从键盘。\n程序可以通过两种方式使用文件。第 1 种方法是，显式使用特定的函数打开文件、关闭文件、读取文件、写入文件，诸如此类。我们在第13章中再详细介绍这种方法。第2种方法是，设计能与键盘和屏幕互动的程序，通过不同的渠道重定向输入至文件和从文件输出。换言之，把stdin流重新赋给文件。继续使用getchar()函数从输入流中获取数据，但它并不关心从流的什么位置获取数据。虽然这种重定向的方法在某些方面有些限制，但是用起来比较简单，而且能让读者熟悉普通的文件处理技术。\n重定向的一个主要问题与操作系统有关，与C无关。尽管如此，许多C环境中（包括UNIX、Linux和Windows命令提示模式）都有重定向特性，而且一些C实现还在某些缺乏重定向特性的系统中模拟它。在UNIX上运行苹果OS X，可以用UNIX命令行模式启动Terminal应用程序。接下来我们介绍UNIX、Linux和Windows的重定向。\nUNIX、Linux和DOS重定向UNIX（运行命令行模式时）、Linux（ditto）和Window命令行提示（模仿旧式DOS命令行环境）都能重定向输入、输出。重定向输入让程序使用文件而不是键盘来输入，重定向输出让程序输出至文件而不是屏幕。\n重定向输入\n假设已经编译了echo_eof.c 程序，并把可执行版本放入一个名为echo_eof（或者在Windows系统中名为echo_eof.exe）的文件中。运行该程序，输入可执行文件名：\n1echo_eof该程序的运行情况和前面描述的一样，获取用户从键盘输入的输入。现在，假设你要用该程序处理名为words的文本文件。文本文件（text file）是内含文本的文件，其中储存的数据是我们可识别的字符。文件的内容可以是一篇散文或者C程序。内含机器语言指令的文件（如储存可执行程序的文件）不是文本文件。由于该程序的操作对象是字符，所以要使用文本文件。只需用下面的命令代替上面的命令即可：\n1echo_eof &lt; words&lt;符号是UNIX和DOS/Windows的重定向运算符。该运算符使words文件与stdin流相关联，把文件中的内容导入echo_eof程序。echo_eof程序本身并不知道（或不关心）输入的内容是来自文件还是键盘，它只知道这是需要导入的字符流，所以它读取这些内容并把字符逐个打印在屏幕上，直至读到文件结尾。因为C把文件和I/O设备放在一个层面，所以文件就是现在的I/O设备。试试看！\n注意 重定向\n对于UNIX、Linux和Windows命令提示，&lt;两侧的空格是可选的。一些系统，如AmigaDOS（那些喜欢怀旧的人使用的系统），支持重定向，但是在重定向符号和文件名之间不允许有空格。\n下面是一个特殊的words文件的运行示例，$是UNIX和Linux的标准提示符。在Windows/DOS系统中见到的DOS提示可能是A&gt;或C&gt;。\n123456$　echo_eof　&lt;　wordsThe　world　is　too　much　with　us:　late　and　soon,Getting　and　spending,　we　lay　waste　our　powers:Little　we　see　in　Nature　that　is　ours;We　have　given　our　hearts　away,　a　sordid　boon!$重定向输出\n现在假设要用echo_eof把键盘输入的内容发送到名为mywords的文件中。然后，输入以下命令并开始输入：\n1echo_eof&gt;mywords\\&gt;符号是第2个重定向运算符。它创建了一个名为mywords的新文件，然后把echo_eof的输出（即，你输入字符的副本）重定向至该文件中。重定向把stdout从显示设备（即，显示器）赋给mywords文件。如果已经有一个名为mywords的文件，通常会擦除该文件的内容，然后替换新的内容（但是，许多操作系统有保护现有文件的选项，使其成为只读文件）。所有出现在屏幕的字母都是你刚才输入的，其副本储存在文件中。在下一行的开始处按下Ctrl+D（UNIX）或Ctrl+Z（DOS）即可结束该程序。如果不知道输入什么内容，可参照下面的示例。这里，我们使用UNIX提示符$。记住在每行的末尾单击Enter键，这样才能把缓冲区的内容发送给程序。\n1234567$　echo_eof　&gt;　mywordsYou　should　have　no　problem　recalling　which　redirectionoperator　does　what.　Just　remember　that　each　operator　pointsin　the　direction　the　information　flows.　Think　of　it　asa　funnel.[Ctrl+D]$按下Ctrl+D或Ctrl+Z后，程序会结束，你的系统会提示返回。程序是否起作用了？UNIX的ls命令或Windows命令行提示模式的dir命令可以列出文件名，会显示mywords文件已存在。可以使用UNIX或Linux的cat或DOS的type命令检查文件中的内容，或者再次使用echo_eof，这次把文件重定向到程序：\n123456$　echo_eof　&lt;　mywordsYou　should　have　no　problem　recalling　which　redirectionoperator　does　what.　Just　remember　that　each　operator　pointsin　the　direction　the　information　flows.　Think　of　it　as　afunnel.$组合重定向\n现在，假设你希望制作一份mywords文件的副本，并命名为savewords。只需输入以下命令即可：\n1echo_eof &lt; mywords &gt; savewords下面的命令也起作用，因为命令与重定向运算符的顺序无关：\n1echo_eof &gt; savewords &lt; mywords注意：在一条命令中，输入文件名和输出文件名不能相同。\n1echo_eof &lt; mywords &gt; mywords....&lt;--错误原因是&gt; mywords在输入之前已导致原mywords的长度被截断为0。\n总之，在UNIX、Linux或Windows/DOS系统中使用两个重定向运算符（&lt;和&gt;）时，要遵循以下原则。\n重定向运算符连接一个可执行程序（包括标准操作系统命令）和一个数据文件，不能用于连接一个数据文件和另一个数据文件，也不能用于连接一个程序和另一个程序。\n\n使用重定向运算符不能读取多个文件的输入，也不能把输出定向至多个文件。\n\n通常，文件名和运算符之间的空格不是必须的，除非是偶尔在UNIX shell、Linux shell或Windows命令行提示模式中使用的有特殊含义的字符。例如，我们用过的echo_eof&lt;words。\n以上介绍的都是正确的例子，下面来看一下错误的例子，addup和count是两个可执行程序，fish和beets是两个文本文件：\n1234fish &gt; beets　　　　　　　　←违反第1条规则addup &lt; count　　　　　　　 ←违反第1条规则addup &lt; fish &lt; beets　　　　←违反第2条规则count &gt; beets fish　　　　　←违反第2条规则UNIX、Linux或Windows/DOS 还有&gt;&gt;运算符，该运算符可以把数据添加到现有文件的末尾，而 | 运算符能把一个文件的输出连接到另一个文件的输入。欲了解所有相关运算符的内容，请参阅 UNIX 的相关书籍，如UNIX Primer Plus，Third Edition（Wilson、Pierce和Wessler合著）。\n注释\n重定位让你能使用键盘输入程序文件。要完成这一任务，程序要测试文件的末尾。例如，第 7 章演示的统计单词程序（程序清单7.7），计算单词个数直至遇到第1个|字符。把ch的char类型改成int类型，把循环测试中的|替换成EOF，便可用该程序来计算文本文件中的单词量。\n重定向是一个命令行概念，因为我们要在命令行输入特殊的符号发出指令。如果不使用命令行环境，也可以使用重定向。首先，一些集成开发环境提供了菜单选项，让用户指定重定向。其次，对于 Windows系统，可以打开命令提示窗口，并在命令行运行可执行文件。Microsoft Visual Studio的默认设置是把可执行文件放在项目文件夹的子文件夹，称为Debug。文件名和项目名的基本名相同，文件名的扩展名为.exe。默认情况下，Xcode在给项目命名后才能命名可执行文件，并将其放在Debug文件夹中。在UNIX系统中，可以通过Terminal工具运行可执行文件。从使用上看，Terminal比命令行编译器（GCC或Clang）简单。\n如果用不了重定向，可以用程序直接打开文件。程序清单8.3演示了一个注释较少的示例。我们学到第13章时再详细讲解。待读取的文件应该与可执行文件位于同一目录。\n123456789101112131415161718192021222324程序清单8.3 file_eof.c程序// file_eof.c --打开一个文件并显示该文件#include　&lt;stdio.h&gt;#include &lt;stdlib.h&gt;　　　　　　　// 为了使用exit()int　main()&#123;    int　ch;    FILE * fp;    char fname[50];　　　　　　　// 储存文件名    printf(\"Enter　the　name　of　the　file:　\");    scanf(\"%s\",　fname);    fp = fopen(fname, \"r\");　　 // 打开待读取文件    if (fp == NULL)　　　　　　　// 如果失败    &#123;        printf(\"Failed　to　open　file.　Bye\\n\");        exit(1);　　　　　　　　　// 退出程序    &#125;    // getc(fp)从打开的文件中获取一个字符    while　((ch　=　getc(fp))　!=　EOF)    \tputchar(ch);    fclose(fp);　　　　　　　　　 // 关闭文件    return　0;&#125;小结：如何重定向输入和输出\n绝大部分C系统都可以使用重定向，可以通过操作系统重定向所有程序，或只在C编译器允许的情况下重定向C程序。假设prog是可执行程序名，file1和file2是文件名。\n1234567891011把输出重定向至文件：&gt;prog &gt;file1    把输入重定向至文件：&lt;prog &lt;file2    组合重定向：prog　&lt;file2　&gt;file1prog　&gt;file1　&lt;file2    这两种形式都是把file2作为输入、file1作为输出。留白：\n一些系统要求重定向运算符左侧有一个空格，右侧没有空格。而其他系统（如，UNIX）允许在重定位运算符两侧有空格或没有空格。\n创建更友好的用户界面大部分人偶尔会写一些中看不中用的程序。还好，C提供了大量工具让输入更顺畅，处理过程更顺利。不过，学习这些工具会导致新的问题。本节的目标是，指导读者解决这些问题并创建更友好的用户界面，让交互数据输入更方便，减少错误输入的影响。\n使用缓冲输入缓冲输入用起来比较方便，因为在把输入发送给程序之前，用户可以编辑输入。但是，在使用输入的字符时，它也会给程序员带来麻烦。前面示例中看到的问题是，缓冲输入要求用户按下Enter键发送输入。这一动作也传送了换行符，程序必须妥善处理这个麻烦的换行符。我们以一个猜谜程序为例。用户选择一个数字，程序猜用户选中的数字是多少。该程序使用的方法单调乏味，先不要在意算法，我们关注的重点在输入和输出。查看程序清单8.4，这是猜谜程序的最初版本，后面我们会改进。\n程序清单8.4 guess.c程序\n123456789101112131415/* guess.c -- 一个拖沓且错误的猜数字程序 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　guess　=　1;    printf(\"Pick　an　integer　from　1　to　100.　I　will　try　to　guess　\");    printf(\"it.\\nRespond　with　a　y　if　my　guess　is　right　and　with\");    printf(\"\\nan　n　if　it　is　wrong.\\n\");    printf(\"Uh...is　your　number　%d?\\n\",　guess);    while (getchar() != 'y')　　 /* 获取响应，与 y 做对比 */    \tprintf(\"Well,　then,　is　it　%d?\\n\",　++guess);    printf(\"I　knew　I　could　do　it!\\n\");    return　0;&#125;下面是程序的运行示例：\n123456789101112Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?Well,　then,　is　it　3?nWell,　then,　is　it　4?Well,　then,　is　it　5?yI　knew　I　could　do　it!撇开这个程序糟糕的算法不谈，我们先选择一个数字。注意，每次输入 n 时，程序打印了两条消息。这是由于程序读取n作为用户否定了数字1，然后还读取了一个换行符作为用户否定了数字2。\n一种解决方案是，使用while循环丢弃输入行最后剩余的内容，包括换行符。这种方法的优点是，能把no和no way这样的响应视为简单的n。程序清单8.4的版本会把no当作两个响应。下面用循环修正char response;这个问题：\n123456while (getchar() != 'y')　 /* 获取响应，与 y 做对比*/&#123;    printf(\"Well,　then,　is　it　%d?\\n\",　++guess);    while　(getchar()　!=　'\\n')    \tcontinue;　　　　 /* 跳过剩余的输入行 */&#125;使用以上循环后，该程序的输出示例如下：\n1234567891011121314Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?noWell,　then,　is　it　3?no　sirWell,　then,　is　it　4?forget　itWell,　then,　is　it　5?yI knew I could do it!这的确是解决了换行符的问题。但是，该程序还是会把f被视为n。我们用if语句筛选其他响应。首先，添加一个char类型的变量储存响应：\n修改后的循环如下：\n123456789while ((response = getchar()) != 'y') /* 获取响应 */&#123;    if　(response　==　'n')    \tprintf(\"Well,　then,　is　it　%d?\\n\",　++guess);    else    \tprintf(\"Sorry,　I　understand　only　y　or　n.\\n\");    while　(getchar()　!=　'\\n')    \tcontinue; /* 跳过剩余的输入行 */&#125;现在，程序的运行示例如下：\n12345678910111213141516Pick　an　integer　from　1　to　100.　I　will　try　to　guess　it.Respond　with　a　y　if　my　guess　is　right　and　withan　n　if　it　is　wrong.Uh...is　your　number　1?nWell,　then,　is　it　2?noWell,　then,　is　it　3?no　sirWell,　then,　is　it　4?forget　itSorry,　I　understand　only　y　or　n.nWell,　then,　is　it　5?yI　knew　I　could　do　it!在编写交互式程序时，应该事先预料到用户可能会输入错误，然后设计程序处理用户的错误输入。在用户出错时通知用户再次输入。\n当然，无论你的提示写得多么清楚，总会有人误解，然后抱怨这个程序设计得多么糟糕。\n混合数值和字符输入假设程序要求用 getchar()处理字符输入，用 scanf()处理数值输入，这两个函数都能很好地完成任务，但是不能把它们混用。因为 getchar()读取每个字符，包括空格、制表符和换行符；而 scanf()在读取数字时则会跳过空格、制表符和换行符。\n我们通过程序清单8.5来解释这种情况导致的问题。该程序读入一个字符和两个数字，然后根据输入的两个数字指定的行数和列数打印该字符。\n程序清单8.5 showchar1.c程序\n1234567891011121314151617181920212223242526272829/* showchar1.c -- 有较大 I/O 问题的程序 */#include　&lt;stdio.h&gt;void display(char cr,int lines,int width);int main(void)&#123;    int ch;　　　　　　　　/* 待打印字符　 */    int rows, cols;　　　　/* 行数和列数 */    printf(\"Enter　a　character　and　two　integers:\\n\");    while((ch=getchar())!='\\n')    &#123;        scanf(\"%d　%d\",&amp;rows,&amp;cols);        display(ch,rows,cols);        printf(\"Enter　another　character　and　two　integers;\\n\");        printf(\"Enter　a　newline　to　quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void display(char cr,int lines,int width)&#123;    int row,col;    for(row=1;row&lt;=lines;row++)    &#123;        for(col=1;col&lt;=width;col++)        \tputchar(cr);        putchar('\\n');/* 结束一行并开始新的一行 */    &#125;&#125;注意，该程序以 int 类型读取字符（这样做可以检测 EOF），但是却以 char 类型把字符传递给display()函数。因为char比int小，一些编译器会给出类型转换的警告。可以忽略这些警告，或者用下面的强制类型转换消除警告：\n1display(char(ch), rows, cols);在该程序中，main()负责获取数据，display()函数负责打印数据。下面是该程序的一个运行示例，看看有什么问题：\n1234567Enter　a　character　and　two　integers:c　2　3ccccccEnter　another　character　and　two　integers;Enter　a　newline　to　quit.Bye.该程序开始时运行良好。你输入c 2 3，程序打印c字符2行3列。然后，程序提示输入第2组数据，还没等你输入数据程序就退出了！这是什么情况？又是换行符在捣乱，这次是输入行中紧跟在 3 后面的换行符。scanf()函数把这个换行符留在输入队列中。和 scanf()不同，getchar()不会跳过换行符，所以在进入下一轮迭代时，你还没来得及输入字符，它就读取了换行符，然后将其赋给ch。而ch是换行符正式终止循环的条件。\n要解决这个问题，程序要跳过一轮输入结束与下一轮输入开始之间的所有换行符或空格。另外，如果该程序不在getchar()测试时，而在scanf()阶段终止程序会更好。修改后的版本如程序清单8.6所示。\n程序清单8.6 showchar2.c程序\n1234567891011121314151617181920212223242526272829303132/* showchar2.c -- 按指定的行列打印字符 */#include　&lt;stdio.h&gt;void display(char cr,int lines,int width);int　main(void)&#123;    int ch;　　　　　　　　/* 待打印字符*/    int rows, cols;　　　　/* 行数和列数 */    printf(\"Enter　a　character　and　two　integers:\\n\");    while((ch=getchar())!='\\n')    &#123;        if(scanf(\"%d　%d\",&amp;rows,&amp;cols)!=2)        \tbreak;        display(ch,rows,cols);        while(getchar()!='\\n')        \tcontinue;        printf(\"Enter　another　character　and　two　integers;\\n\");        printf(\"Enter　a　newline　to　quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void display(char cr,int lines,int width)&#123;    int row,col;    for(row　=　1;　row　&lt;=　lines;　row++)    &#123;        for(col　=　1;　col　&lt;=　width;　col++)        putchar(cr);        putchar('\\n');　　/* 结束一行并开始新的一行 */    &#125;&#125;while循环实现了丢弃scanf()输入后面所有字符（包括换行符）的功能，为循环的下一轮读取做好了准备。该程序的运行示例如下：\n123456789101112Enter　a　character　and　two　integers:c　1　2ccEnter　another　character　and　two　integers;Enter　a　newline　to　quit.!　3　6!!!!!!!!!!!!!!!!!!Enter　another　character　and　two　integers;Enter　a　newline　to　quit.Bye.在if语句中使用一个break语句，可以在scanf()的返回值不等于2时终止程序，即如果一个或两个输入值不是整数或者遇到文件结尾就终止程序。\n输入验证在实际应用中，用户不一定会按照程序的指令行事。用户的输入和程序期望的输入不匹配时常发生，这会导致程序运行失败。作为程序员，除了完成编程的本职工作，还要事先预料一些可能的输入错误，这样才能编写出能检测并处理这些问题的程序。\n例如，假设你编写了一个处理非负数整数的循环，但是用户很可能输入一个负数。你可以使用关系表达式来排除这种情况：\n1234567long　n;scanf(\"%ld\", &amp;n);　　　// 获取第1个值while (n &gt;= 0)　　　　　// 检测不在范围内的值&#123;    // 处理n    scanf(\"%ld\", &amp;n);　// 获取下一个值&#125;另一类潜在的陷阱是，用户可能输入错误类型的值，如字符 q。排除这种情况的一种方法是，检查scanf()的返回值。回忆一下，scanf()返回成功读取项的个数。因此，下面的表达式当且仅当用户输入一个整数时才为真：\n1scanf(\"%ld\",　&amp;n)　==　1结合上面的while循环，可改进为：\n12345long　n;while(scanf(\"%ld\",&amp;n)==1&amp;&amp;n&gt;=0)&#123;//处理n&#125;while循环条件可以描述为“当输入是一个整数且该整数为正时”。\n对于最后的例子，当用户输入错误类型的值时，程序结束。然而，也可以让程序友好些，提示用户再次输入正确类型的值。在这种情况下，要处理有问题的输入。如果scanf()没有成功读取，就会将其留在输入队列中。这里要明确，输入实际上是字符流。可以使用getchar()函数逐字符地读取输入，甚至可以把这些想法都结合在一个函数中，如下所示：\n12345678910111213long get_long(void)&#123;    long input;    char ch;    while(scanf(\"%ld\",&amp;input)!=1)    &#123;        while((ch=getchar())!='\\n')        \tputchar(ch); // 处理错误的输入        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;    return input;&#125;该函数要把一个int类型的值读入变量input中。如果读取失败，函数则进入外层while循环体。然后内层循环逐字符地读取错误的输入。注意，该函数丢弃该输入行的所有剩余内容。还有一个方法是，只丢弃下一个字符或单词，然后该函数提示用户再次输入。外层循环重复运行，直到用户成功输入整数，此时scanf()的返回值为1。\n在用户输入整数后，程序可以检查该值是否有效。考虑一个例子，要求用户输入一个上限和一个下限来定义值的范围。在该例中，你可能希望程序检查第1个值是否大于第2个值（通常假设第1个值是较小的那个值），除此之外还要检查这些值是否在允许的范围内。例如，当前的档案查找一般不会接受 1958 年以前和2014年以后的查询任务。这个限制可以在一个函数中实现。\n假设程序中包含了stdbool.h 头文件。如果当前系统不允许使用_Bool，把bool替换成int，把true 替换成 1，把 false 替换成 0 即可。注意，如果输入无效，该函数返回 true，所以函数名为bad_limits()：\n1234567891011121314151617181920bool bad_limits(long begin,long end,long low,long high)&#123;    bool not_good=false;    if (begin&gt;end)    &#123;        printf(\"%ld　isn't　smaller　than　%ld.\\n\",　begin,　end);        not_good=true;    &#125;    if(begin&lt;low||end&lt;low)    &#123;        printf(\"Values　must　be　%ld　or　greater.\\n\",　low);        not_good=true;    &#125;    if(begin&gt;high||end&gt;high)    &#123;        printf(\"Values　must　be　%ld　or　less.\\n\",　high);        not_good=true;    &#125;    return not_good;&#125;程序清单8.7使用了上面的两个函数为一个进行算术运算的函数提供整数，该函数计算特定范围内所有整数的平方和。程序限制了范围的上限是10000000，下限是-10000000。\n程序清单8.7 checking.c程序\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788// checking.c -- 输入验证#include　&lt;stdio.h&gt;#include　&lt;stdbool.h&gt;// 验证输入是一个整数long get_long(void);// 验证范围的上下限是否有效bool bad_limits(long　begin,　long　end,long low,long high);// 计算a～b之间的整数平方和double sum_squares(long a,long b);int　main(void)&#123;    const long MIN=-10000000L;　　// 范围的下限    const long MAX=+10000000L;　　// 范围的上限    long start;　　　　　　　　　　　　// 用户指定的范围最小值    long stop;　　　　　　　　　　　　 // 用户指定的范围最大值    double　answer;    printf(\"This　program　computes　the　sum　of　the　squares　of　\"    \"integers　in　a　range.\\nThe　lower　bound　should　not　\"    \"be　less　than　-10000000　and\\nthe　upper　bound　\"    \"should　not　be　more　than　+10000000.\\nEnter　the　\"    \"limits　(enter　0　for　both　limits　to　quit):\\n\"    \"lower　limit:　\");    start=get_long();    printf(\"upper　limit:　\");    stop=get_long();    while(start!=0||stop!=0)    &#123;        if(bad_limits(start,stop,MIN,MAX))        \tprintf(\"Please　try　again.\\n\");        else        &#123;            answer=sum_squares(start,stop);            printf(\"The　sum　of　the　squares　of　the　integers　\");            printf(\"from　%ld　to　%ld　is　%g\\n\",            start,stop,answer);        &#125;        printf(\"Enter　the　limits　(enter　0　for　both　\"        \"limits　to　quit):\\n\");        printf(\"lower　limit:　\");        start=get_long();        printf(\"upper　limit:　\");        stop=get_long();\t&#125;\tprintf(\"Done.\\n\");\treturn　0;&#125;long get_long(void)&#123;    long input;    char ch;    while(scanf(\"%ld\",&amp;input)!=1)    &#123;        while((ch=getchar())!='\\n')        \tputchar(ch);　　　　　　 // 处理错误输入        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;\treturn input;&#125;double sum_squares(long a,long b)&#123;    double total=0;    long i;    for(i=a;i&lt;=b;i++)    \ttotal+=(double)i*(double) i;    return total;&#125;bool bad_limits(long begin,long end,long low,long high)&#123;    bool not_good=false;    if(begin&gt;end)    &#123;        printf(\"%ld　isn't　smaller　than　%ld.\\n\",　begin,　end);        not_good=true;    &#125;    if(begin&lt;low||end&lt;low)    &#123;        printf(\"Values　must　be　%ld　or　greater.\\n\",　low);        not_good=true;    &#125;    if(begin&gt;high||end&gt;high)    &#123;        printf(\"Values　must　be　%ld　or　less.\\n\",　high);        not_good=true;    &#125;    return not_good;&#125;下面是该程序的输出示例：\n1234567891011121314151617181920This　program　computes　the　sum　of　the　squares　of　integers　in　a　range.The　lower　bound　should　not　be　less　than　-10000000　andthe　upper　bound　should　not　be　more　than　+10000000.Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　lowlow　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　3upper　limit:　a　big　numbera　big　number　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　12The　sum　of　the　squares　of　the　integers　from　3　to　12　is　645Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　80upper　limit:　1080　isn't　smaller　than　10.Please　try　again.Enter　the　limits　(enter　0　for　both　limits　to　quit):lower　limit:　0upper　limit:　0Done.分析程序虽然checking.c程序的核心计算部分（sum_squares()函数）很短，但是输入验证部分比以往程序示例要复杂。接下来分析其中的一些要素，先着重讨论程序的整体结构。\n程序遵循模块化的编程思想，使用独立函数（模块）来验证输入和管理显示。程序越大，使用模块化编程就越重要。\nmain()函数管理程序流，为其他函数委派任务。它使用 get_long()获取值、while 循环处理值、badlimits()函数检查值是否有效、sum_squres()函数处理实际的计算：\n1234567891011121314151617181920start=get_long();printf(\"upper　limit:　\");stop=get_long();while(start!=0||stop!=0)&#123;    if　(bad_limits(start,　stop,　MIN,　MAX))    \tprintf(\"Please　try　again.\\n\");    else    &#123;        answer　=　sum_squares(start,　stop);        printf(\"The　sum　of　the　squares　of　the　integers　\");        printf(\"from　%ld　to　%ld　is　%g\\n\",　start,　stop,　answer);    &#125;    printf(\"Enter　the　limits　(enter　0　for　both　\"    \"limits　to　quit):\\n\");    printf(\"lower　limit:　\");    start=get_long();    printf(\"upper　limit:　\");    stop=get_long();&#125;输入流和数字在编写处理错误输入的代码时（如程序清单8.7），应该很清楚C是如何处理输入的。考虑下面的输入：\n1is 28 12.4在我们眼中，这就像是一个由字符、整数和浮点数组成的字符串。但是对 C程序而言，这是一个字节流。第1个字节是字母i的字符编码，第2个字节是字母s的字符编码，第3个字节是空格字符的字符编码，第4个字节是数字2的字符编码，等等。所以，如果get_long()函数处理这一行输入，第1个字符是非数字，那么整行输入都会被丢弃，包括其中的数字，因为这些数字只是该输入行中的其他字符：\n12while ((ch=getchar())!='\\n')putchar(ch); // 处理错误的输入虽然输入流由字符组成，但是也可以设置scanf()函数把它们转换成数值。例如，考虑下面的输入：\n142如果在scanf()函数中使用%c转换说明，它只会读取字符4并将其储存在char类型的变量中。如果使用%s转换说明，它会读取字符4和字符2这两个字符，并将其储存在字符数组中。如果使用%d转换说明，scanf()同样会读取两个字符，但是随后会计算出它们对应的整数值：4×10+2，即42，然后将表示该整数的二进制数储存在 int 类型的变量中。如果使用%f 转换说明，scanf()也会读取两个字符，计算出它们对应的数值42.0，用内部的浮点表示法表示该值，并将结果储存在float类型的变量中。\n简而言之，输入由字符组成，但是scanf()可以把输入转换成整数值或浮点数值。使用转换说明（如%d或%f）限制了可接受输入的字符类型，而getchar()和使用%c的scanf()接受所有的字符。\n菜单浏览许多计算机程序都把菜单作为用户界面的一部分。菜单给用户提供方便的同时，却给程序员带来了一些麻烦。我们看看其中涉及了哪些问题。\n菜单给用户提供了一份响应程序的选项。假设有下面一个例子：\n123Enter　the　letter　of　your　choice:a.　advice　　　　　　　b.　bellc.　count　　　　　　　　q.　quit理想状态是，用户输入程序所列选项之一，然后程序根据用户所选项完成任务。作为一名程序员，自然希望这一过程能顺利进行。因此，第1个目标是：当用户遵循指令时程序顺利运行；第2个目标是：当用户没有遵循指令时，程序也能顺利运行。显而易见，要实现第 2 个目标难度较大，因为很难预料用户在使用程序时的所有错误情况。\n现在的应用程序通常使用图形界面，可以点击按钮、查看对话框、触摸图标，而不是我们示例中的命令行模式。但是，两者的处理过程大致相同：给用户提供选项、检查并执行用户的响应、保护程序不受误操作的影响。除了界面不同，它们底层的程序结构也几乎相同。但是，使用图形界面更容易通过限制选项控制输入。\n任务我们来更具体地分析一个菜单程序需要执行哪些任务。它要获取用户的响应，根据响应选择要执行的动作。另外，程序应该提供返回菜单的选项。C 的 switch 语句是根据选项决定行为的好工具，用户的每个选择都可以对应一个特定的case标签。使用while语句可以实现重复访问菜单的功能。因此，我们写出以下伪代码：\n1234获取选项当选项不是'q'时转至相应的选项并执行获取下一个选项使执行更顺利当你决定实现这个程序时，就要开始考虑如何让程序顺利运行（顺利运行指的是，处理正确输入和错误输入时都能顺利运行）。例如，你能做的是让“获取选项”部分的代码筛选掉不合适的响应，只把正确的响应传入switch。这表明需要为输入过程提供一个只返回正确响应的函数。结合while循环和switch语句，其程序结构如下：\n12345678910111213141516171819202122#include　&lt;stdio.h&gt;char　get_choice(void);void　count(void);int　main(void)&#123;    int choice;    while((choice　=　get_choice())　!=　'q')    &#123;        switch　(choice)        &#123;            case 'a':　printf(\"Buy　low,　sell　high.\\n\");            \tbreak;            case 'b': putchar('\\a'); /* ANSI */            \tbreak;            case 'c':　count();            \tbreak;            default:　 printf(\"Program　error!\\n\");            \tbreak;    \t&#125;    &#125;    return　0;&#125;定义get_choice()函数只能返回&#39;a&#39;、&#39;b&#39;、&#39;c&#39;和&#39;q&#39;。get_choice()的用法和getchar()相同，两个函数都是获取一个值，并与终止值（该例中是&#39;q&#39;）作比较。我们尽量简化实际的菜单选项，以便读者把注意力集中在程序结构上。稍后再讨论 count()函数。default 语句可以方便调试。如果get_choice()函数没能把返回值限制为菜单指定的几个选项值，default语句有助于发现问题所在。\nget_choice()函数\n下面的伪代码是设计这个函数的一种方案：\n显示选项\n获取用户的响应\n当响应不合适时\n提示用户再次输入\n获取用户的响应\n下面是一个简单而笨拙的实现：\n1234567891011121314char　get_choice(void)&#123;    int　ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　　b.　bell\\n\");    printf(\"c.　count　　　　　　　　 q.　quit\\n\");    ch=getchar();    while　((ch　&lt;　'a'　||　ch　&gt;　'c')　&amp;&amp;　ch　!=　'q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=getchar();    &#125;    return　ch;&#125;缓冲输入依旧带来些麻烦，程序把用户每次按下 Return 键产生的换行符视为错误响应。为了让程序的界面更流畅，该函数应该跳过这些换行符。\n这类问题有多种解决方案。一种是用名为get_first()的新函数替换getchar()函数，读取一行的第1个字符并丢弃剩余的字符。这种方法的优点是，把类似act这样的输入视为简单的a，而不是继续把act中的c作为选项c的一个有效的响应。我们重写输入函数如下：\n12345678910111213141516171819202122char get_choice(void)&#123;    int ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　　 b.　bell\\n\");    printf(\"c.　count　　　　　　　　　 q.　quit\\n\");    ch=get_first();    while((ch&lt;'a'||ch&gt;'c')&amp;&amp;ch!='q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=getfirst();    &#125;    return　ch;&#125;char get_first(void)&#123;    int ch;    ch=getchar();　 /* 读取下一个字符 */    while(getchar()!='\\n')    continue; /* 跳过该行剩下的内容 */    return　ch;&#125;混合字符和数值输入前面分析过混合字符和数值输入会产生一些问题，创建菜单也有这样的问题。例如，假设count()函数（选择c）的代码如下：\n12345678void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    scanf(\"%d\",&amp;n);    for(i=1;i&lt;=n;i++)    \tprintf(\"%d\\n\",i);&#125;如果输入3作为响应，scanf()会读取3并把换行符留在输入队列中。下次调用 get_choice()将导致get_first()返回这个换行符，从而导致我们不希望出现的行为。\n重写 get_first()，使其返回下一个非空白字符而不仅仅是下一个字符，即可修复这个问题。我们把这个任务留给读者作为练习。另一种方法是，在count()函数中清理换行符，如下所示：\n12345678910void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    n=get_int();    for(i=1;i&lt;=n;i++)    \tprintf(\"%d\\n\",i);    while(getchar()!='\\n')    \tcontinue;&#125;该函数借鉴了程序清单8.7中的get_long()函数，将其改为get_int()获取int类型的数据而不是long类型的数据。回忆一下，原来的get_long()函数如何检查有效输入和让用户重新输入。程序清单8.8演示了菜单程序的最终版本。\n程序清单8.8 menuette.c程序\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/* menuette.c -- 菜单程序 */#include　&lt;stdio.h&gt;char　get_choice(void);char　get_first(void);int　get_int(void);void　count(void);int　main(void)&#123;    int choice;    void count(void);    while((choice　=　get_choice())　!=　'q')    &#123;        switch(choice)        &#123;            case 'a':　printf(\"Buy　low,　sell　high.\\n\");            \tbreak;            case 'b':　putchar('\\a');　 /* ANSI */            \tbreak;            case 'c':　count();            \tbreak;            default:　　printf(\"Program　error!\\n\");            \tbreak;        &#125;    &#125;    printf(\"Bye.\\n\");    return　0;&#125;void count(void)&#123;    int n,i;    printf(\"Count　how　far?　Enter　an　integer:\\n\");    n=get_int();    for(i　=　1;　i　&lt;=　n;　i++)    \tprintf(\"%d\\n\",　i);    while(getchar()　!=　'\\n')    \tcontinue;&#125;char get_choice(void)&#123;    int ch;    printf(\"Enter　the　letter　of　your　choice:\\n\");    printf(\"a.　advice　　　　　　　b.　bell\\n\");    printf(\"c.　count　　　　　　　　q.　quit\\n\");    ch=get_first();    while((ch　&lt;　'a'　||　ch　&gt;　'c')　&amp;&amp;　ch　!=　'q')    &#123;        printf(\"Please　respond　with　a,　b,　c,　or　q.\\n\");        ch=get_first();    &#125;    return ch;&#125;char get_first(void)&#123;    int　ch;    ch=getchar();    while　(getchar()　!=　'\\n')    continue;&#125;int get_int(void)&#123;    int input;    char ch;    while(scanf(\"%d\",　&amp;input)　!=　1)    &#123;        while　((ch　=　getchar())　!=　'\\n')        putchar(ch);　// 处理错误输出        printf(\"　is　not　an　integer.\\nPlease　enter　an　\");        printf(\"integer　value,　such　as　25,　-178,　or　3:　\");    &#125;    return input;&#125;下面是该程序的一个运行示例：\n123456789101112131415161718192021222324Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitaBuy　low,　sell　high.Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitcountCount　how　far?　Enter　an　integer:twotwo　is　not　an　integer.Please　enter　an　integer　value,　such　as　25,　-178,　or　3:　512345Enter　the　letter　of　your　choice:a.　advice　　　　　　　　 b.　bellc.　count　　　　　　　　　q.　quitdPlease　respond　with　a,　b,　c,　or　q.q要写出一个自己十分满意的菜单界面并不容易。但是，在开发了一种可行的方案后，可以在其他情况下复用这个菜单界面。\n学完以上程序示例后，还要注意在处理较复杂的任务时，如何让函数把任务委派给另一个函数。这样让程序更模块化。\n关键概念C程序把输入作为传入的字节流。getchar()函数把每个字符解释成一个字符编码。scanf()函数以同样的方式看待输入，但是根据转换说明，它可以把字符输入转换成数值。许多操作系统都提供重定向，允许用文件代替键盘输入，用文件代替显示器输出。\n程序通常接受特殊形式的输入。可以在设计程序时考虑用户在输入时可能犯的错误，在输入验证部分处理这些错误情况，让程序更强健更友好。\n对于一个小型程序，输入验证可能是代码中最复杂的部分。处理这类问题有多种方案。例如，如果用户输入错误类型的信息，可以终止程序，也可以给用户提供有限次或无限次机会重新输入。\n本章小结许多程序使用 getchar()逐字符读取输入。通常，系统使用行缓冲输入，即当用户按下 Enter 键后输入才被传送给程序。按下Enter键也传送了一个换行符，编程时要注意处理这个换行符。ANSI C把缓冲输入作为标准。\n通过标准I/O包中的一系列函数，以统一的方式处理不同系统中的不同文件形式，是C语言的特性之一。getchar()和 scanf()函数也属于这一系列。当检测到文件结尾时，这两个函数都返回 EOF（被定义在stdio.h头文件中）。在不同系统中模拟文件结尾条件的方式稍有不同。在UNIX系统中，在一行开始处按下Ctrl+D可以模拟文件结尾条件；而在DOS系统中则使用Ctrl+Z。\n许多操作系统（包括UNIX和DOS）都有重定向的特性，因此可以用文件代替键盘和屏幕进行输入和输出。读到EOF即停止读取的程序可用于键盘输入和模拟文件结尾信号，或者用于重定向文件。\n混合使用 getchar()和 scanf()时，如果在调用 getchar()之前，scanf()在输入行留下一个换行符，会导致一些问题。不过，意识到这个问题就可以在程序中妥善处理。\n编写程序时，要认真设计用户界面。事先预料一些用户可能会犯的错误，然后设计程序妥善处理这些错误情况。\n","plink":"https://dxsummer.gitee.io/posts/86602531/"},{"title":"Step5 C控制语句：分支和跳转","date":"2020-06-06T02:30:50.000Z","date_formatted":{"ll":"2020年6月6日","L":"2020/06/06","MM-DD":"06-06"},"updated":"2020-06-08T01:44:18.000Z","content":"本章介绍以下内容：\n关键字：if、else、switch、continue、break、case、default、goto\n运算符：&amp;&amp;、||、?、:\n函数：getchar()、putchar()、ctype.h系列\n如何使用if和if else语句，如何嵌套它们\n在更复杂的测试表达式中用逻辑运算符组合关系表达式\nC的条件运算符\nswitch语句\nbreak、continue和goto语句\n使用C的字符I/O函数：getchar()和putchar()\nctype.h头文件提供的字符分析函数系列\n随着越来越熟悉C，可以尝试用C程序解决一些更复杂的问题。这时候，需要一些方法来控制和组织程序，为此C提供了一些工具。前面已经学过如何在程序中用循环重复执行任务。本章将介绍分支结构（如， if和switch），让程序根据测试条件执行相应的行为。另外，还将介绍C语言的逻辑运算符，使用逻辑运算符能在 while 或 if 的条件中测试更多关系。此外，本章还将介绍跳转语句，它将程序流转换到程序的其他部分。学完本章后，读者就可以设计按自己期望方式运行的程序。\nif语句我们从一个有if语句的简单示例开始学习，请看程序清单7.1。该程序读取一列数据，每个数据都表示每日的最低温度（℃），然后打印统计的总天数和最低温度在0℃以下的天数占总天数的百分比。程序中的循环通过scanf()读入温度值。while循环每迭代一次，就递增计数器增加天数，其中的if语句负责判断0℃以下的温度并单独统计相应的天数。\n程序清单7.1 colddays.c程序\n123456789101112131415161718192021222324// colddays.c -- 找出0℃以下的天数占总天数的百分比#include &lt;stdio.h&gt;int main(void)&#123;    const int FREEZING=0;    float temperature;    int cold_days=0;    int all_days=0;    printf(\"Enter the list of daily low temperatures.\\n\");    printf(\"Use Celsius, and enter q to quit.\\n\");    while(scanf(\"%f\",&amp;temperature)==1)    &#123;        all_days++;        if(temperature&lt;FREEZING)        cold_days++;    &#125;    if (all_days!=0)   \t\tprintf(\"%d days total: %.1f%% were below freezing.\\n\",  \t\tall_days,100.0*(float)cold_days/all_days);    if (all_days==0) \t   printf(\"No data entered!\\n\");    return 0;&#125;下面是该程序的输出示例：\n1234Enter the list of daily low temperatures.Use Celsius, and enter q to quit.12 5 -2.5 0 6 8 -3 -10 5 10 q10 days total: 30.0% were below freezing.while循环的测试条件利用scanf()的返回值来结束循环，因为scanf()在读到非数字字符时会返回0。temperature的类型是float而不是int，这样程序既可以接受-2.5这样的值，也可以接受8这样的值。\nwhile循环中的新语句如下：\n12if(temperature&lt;FREEZING)cold_days++;if 语句指示计算机，如果刚读取的值（remperature）小于 0，就把 cold_days 递增 1；如果temperature不小于0，就跳过cold_days++;语句，while循环继续读取下一个温度值。\n接着，该程序又使用了两次if语句控制程序的输出。如果有数据，就打印结果；如果没有数据，就打印一条消息（稍后将介绍一种更好的方法来处理这种情况）。\n为避免整数除法，该程序示例把计算后的百分比强制转换为 float类型。其实，也不必使用强制类型转换，因为在表达式100.0 * cold_days / all_days中，将首先对表达式100.0 * cold_days求值，由于C的自动转换类型规则，乘积会被强制转换成浮点数。但是，使用强制类型转换可以明确表达转换类型的意图，保护程序免受不同版本编译器的影响。if语句被称为分支语句（branching statement）或选择语句（selection statement），因为它相当于一个交叉点，程序要在两条分支中选择一条执行。if语句的通用形式如下：\n12if(expression)statement如果对expression求值为真（非0），则执行statement；否则，跳过statement。与while循环一样，statement可以是一条简单语句或复合语句。if语句的结构和while语句很相似，它们的主要区别是：如果满足条件可执行的话，if语句只能测试和执行一次，而while语句可以测试和执行多次。\n通常，expression 是关系表达式，即比较两个量的大小（如，表达式 x &gt; y 或 c == 6）。如果expression为真（即x大于y，或c == 6），则执行statement。否则，忽略statement。概括地说，可以使用任意表达式，表达式的值为0则为假。\nstatement部分可以是一条简单语句，如本例所示，或者是一条用花括号括起来的复合语句（或块）：\n1234567if (score &gt; big)    printf(\"Jackpot!\\n\");　// 简单语句if (joe &gt; ron)&#123;　　　　　　　　　　　　　 // 复合语句    joecash++;    printf(\"You lose, Ron.\\n\");&#125;注意，即使if语句由复合语句构成，整个if语句仍被视为一条语句。\nif else语句简单形式的if语句可以让程序选择执行一条语句，或者跳过这条语句。C还提供了if else形式，可以在两条语句之间作选择。我们用if else形式修正程序清单7.1中的程序段。\n12345if (all_days != 0)\tprintf(\"%d days total: %.1f%% were below freezing.\\n\",\tall_days, 100.0 * (float) cold_days / all_days);if (all_days == 0)\tprintf(\"No data entered!\\n\");如果程序发现all_days不等于0，那么它应该知道另一种情况一定是all_days等于0。用if else形式只需测试一次。重写上面的程序段如下：\n12345if (all_days!= 0)    printf(\"%d days total: %.1f%% were below freezing.\\n\",    all_days, 100.0 * (float) cold_days / all_days);else    printf(\"No data entered!\\n\");如果if语句的测试表达式为真，就打印温度数据；如果为假，就打印警告消息。\n注意，if else语句的通用形式是：\n1234if ( expression )statement1elsestatement2如果expression为真（非0），则执行statement1；如果expression为假或0，则执行else后面的statement2。statement1和statement2可以是一条简单语句或复合语句。C并不要求一定要缩进，但这是标准风格。缩进让根据测试条件的求值结果来判断执行哪部分语句一目了然。\n如果要在if和else之间执行多条语句，必须用花括号把这些语句括起来成为一个块。下面的代码结构违反了C语法，因为在if和else之间只允许有一条语句（简单语句或复合语句）：\n12345if (x &gt; 0)\tprintf(\"Incrementing x:\\n\");x++;else　　　// 将产生一个错误\tprintf(\"x &lt;= 0 \\n\");编译器把printf()语句视为if语句的一部分，而把x++;看作一条单独的语句，它不是if语句的一部分。然后，编译器发现else并没有所属的if，这是错误的。上面的代码应该这样写：\n1234567if (x &gt; 0)&#123;    printf(\"Incrementing x:\\n\");    x++;&#125;else    printf(\"x &lt;= 0 \\n\");if语句用于选择是否执行一个行为，而else if语句用于在两个行为之间选择。图7.1比较了这两种语句。\n\n另一个示例：介绍getchar()和putchar()到目前为止，学过的大多数程序示例都要求输入数值。接下来，我们看看输入字符的示例。相信读者已经熟悉了如何用 scanf()和 printf()根据%c 转换说明读写字符，我们马上要讲解的示例中要用到一对字符输入/输出函数：getchar()和putchar()。\ngetchar()函数不带任何参数，它从输入队列中返回下一个字符。例如，下面的语句读取下一个字符输入，并把该字符的值赋给变量ch：\n1ch = getchar();该语句与下面的语句效果相同：\n1scanf(\"%c\", &amp;ch);putchar()函数打印它的参数。例如，下面的语句把之前赋给ch的值作为字符打印出来：\n1putchar(ch);该语句与下面的语句效果相同：\n1printf(\"%c\", ch);由于这些函数只处理字符，所以它们比更通用的scanf()和printf()函数更快、更简洁。而且，注意 getchar()和 putchar()不需要转换说明，因为它们只处理字符。这两个函数通常定义在 stdio.h头文件中（而且，它们通常是预处理宏，而不是真正的函数，第16章会讨论类似函数的宏）。\n接下来，我们编写一个程序来说明这两个函数是如何工作的。该程序把一行输入重新打印出来，但是每个非空格都被替换成原字符在ASCII序列中的下一个字符，空格不变。这一过程可描述为“如果字符是空白，原样打印；否则，打印原字符在ASCII序列中的下一个字符”。\nC代码看上去和上面的描述很相似，请看程序清单7.2。\n1234567891011121314151617181920程序清单7.2 cypher1.c程序// cypher1.c -- 更改输入，空格不变#include &lt;stdio.h&gt;#define SPACE ' '　　　　　　　 // SPACE表示单引号-空格-单引号int main(void)&#123;    char ch;    ch = getchar();　　　　　　 // 读取一个字符    while (ch != '\\n')　　　　 // 当一行未结束时    &#123;        if (ch == SPACE)　　　 // 留下空格     \t   putchar(ch);　　　 // 该字符不变        else     \t   putchar(ch + 1);　 // 改变其他字符        ch = getchar();　　　　// 获取下一个字符    &#125;    putchar(ch);　　　　　　　　// 打印换行符    return 0;&#125;（如果编译器警告因转换可能导致数据丢失，不用担心。第8章在讲到EOF时再解释。）\n下面是该程序的输入示例：\n12CALL ME HAL.DBMM NF IBM/把程序清单7.1中的循环和该例中的循环作比较。前者使用scanf()返回的状态值判断是否结束循环，而后者使用输入项的值来判断是否结束循环。这使得两程序所用的循环结构略有不同：程序清单7.1中在循环前面有一条“读取语句”，程序清单7.2中在每次迭代的末尾有一条“读取语句”。不过，C的语法比较灵活，读者也可以模仿程序清单7.1，把读取和测试合并成一个表达式。也就是说，可以把这种形式的循环：\n123456ch = getchar();　　　 /* 读取一个字符 */while (ch != '\\n')　　/* 当一行未结束时 */&#123;    ...　　　　　　　/* 处理字符 */    ch = getchar();　 /* 获取下一个字符 */&#125;替换成下面形式的循环：\n1234while ((ch = getchar()) != '\\n')&#123;\t...　　　　　　　/* 处理字符 */&#125;关键的一行代码是：\n1while ((ch = getchar()) != '\\n')这体现了C特有的编程风格——把两个行为合并成一个表达式。C对代码的格式要求宽松，这样写让其中的每个行为更加清晰：\n123while ((ch = getchar())　　　　　　 // 给ch赋一个值!= '\\n')　 // 把ch和\\n作比较以上执行的行为是赋值给ch和把ch的值与换行符作比较。表达式ch = getchar()两侧的圆括号使之成为!=运算符的左侧运算对象。要对该表达式求值，必须先调用getchar()函数，然后把该函数的返回值赋给 ch。因为赋值表达式的值是赋值运算符左侧运算对象的值，所以 ch = getchar()的值就是 ch 的新值，因此，读取ch的值后，测试条件相当于是ch != &#39;\\n&#39;（即，ch不是换行符）。\n这种独特的写法在C编程中很常见，应该多熟悉它。还要记住合理使用圆括号组合子表达式。上面例子中的圆括号都必不可少。假设省略ch = getchar()两侧的圆括号：\n1while (ch = getchar() != '\\n')!=运算符的优先级比=高，所以先对表达式getchar() != &#39;\\n&#39;求值。由于这是关系表达式，所以其值不是1就是0（真或假）。然后，把该值赋给ch。省略圆括号意味着赋给ch的值是0或1，而不是 getchar()的返回值。这不是我们的初衷。\n下面的语句：\n1putchar(ch + 1); /* 改变其他字符 */再次演示了字符实际上是作为整数储存的。为方便计算，表达式ch + 1中的ch被转换成int类型，然后int类型的计算结果被传递给接受一个int类型参数的putchar()，该函数只根据最后一个字节确定显示哪个字符。\nctype.h系列的字符函数注意到程序清单7.2的输出中，最后输入的点号（.）被转换成斜杠（/），这是因为斜杠字符对应的ASCII码比点号的 ASCII 码多 1。如果程序只转换字母，保留所有的非字母字符（不只是空格）会更好。本章稍后讨论的逻辑运算符可用来测试字符是否不是空格、不是逗号等，但是列出所有的可能性太繁琐。C 有一系列专门处理字符的函数，ctype.h头文件包含了这些函数的原型。这些函数接受一个字符作为参数，如果该字符属于某特殊的类别，就返回一个非零值（真）；否则，返回0（假）。例如，如果isalpha()函数的参数是一个字母，则返回一个非零值。程序清单7.3在程序清单7.2的基础上使用了这个函数，还使用了刚才精简后的循环。\n123456789101112131415161718程序清单7.3 cypher2.c程序// cypher2.c -- 替换输入的字母，非字母字符保持不变#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;　　　　　　　// 包含isalpha()的函数原型int main(void)&#123;    char ch;    while ((ch = getchar()) != '\\n')    &#123;        if (isalpha(ch))　　　 // 如果是一个字符，\t\t\tputchar(ch + 1);　 // 显示该字符的下一个字符        else　　　　　　　　　　// 否则，\t\t\tputchar(ch);　　　 // 原样显示    &#125;    putchar(ch);　　　　　　　 // 显示换行符    return 0;&#125;下面是该程序的一个输出示例，注意大小写字母都被替换了，除了空格和标点符号：\n12Look! It's a programmer!Mppl! Ju't b qsphsbnnfs!表7.1和表7.2列出了ctype.h头文件中的一些函数。有些函数涉及本地化，指的是为适应特定区域的使用习惯修改或扩展 C 基本用法的工具（例如，许多国家在书写小数点时，用逗号代替点号，于是特殊的本地化可以指定C编译器使用逗号以相同的方式输出浮点数，这样123.45可以显示为123,45）。注意，字符映射函数不会修改原始的参数，这些函数只会返回已修改的值。也就是说，下面的语句不改变ch的值：\n1tolower(ch); // 不影响ch的值这样做才会改变ch的值：\n1ch = tolower(ch); // 把ch转换成小写字母\nctype.h头文件中的字符测试函数\n\n\n\nctype.h头文件中的字符映射函数\n\n\n多重选择else if现实生活中我们经常有多种选择。在程序中也可以用else if扩展if else结构模拟这种情况。来看一个特殊的例子。电力公司通常根据客户的总用电量来决定电费。下面是某电力公司的电费清单，单位是千瓦时（kWh）：\n1234首 360kWh:　　　　 $0.13230/kWh续 108kWh:　　　　 $0.15040/kWh续 252kWh:　　　　 $0.30025/kWh超过 720kWh:　　　 $0.34025/kWh如果对用电管理感兴趣，可以编写一个计算电费的程序。程序清单7.4是完成这一任务的第1步。\n程序清单7.4 electric.c程序\n123456789101112131415161718192021222324252627282930313233// electric.c -- 计算电费#include &lt;stdio.h&gt;#define RATE1　 0.13230　　　　　　　// 首次使用 360 kwh 的费率#define RATE2　 0.15040　　　　　　　// 接着再使用 108 kwh 的费率#define RATE3　 0.30025　　　　　　　// 接着再使用 252 kwh 的费率#define RATE4　 0.34025　　　　　　　// 使用超过 720kwh 的费率#define BREAK1　360.0　　　　　　　　// 费率的第1个分界点#define BREAK2　468.0　　　　　　　　// 费率的第2个分界点#define BREAK3　720.0　　　　　　　　// 费率的第3个分界点#define BASE1　(RATE1 * BREAK1)// 使用360kwh的费用#define BASE2 (BASE1 + (RATE2 * (BREAK2 - BREAK1)))// 使用468kwh的费用#define BASE3　(BASE1 + BASE2 + (RATE3 *(BREAK3 - BREAK2)))// 使用720kwh的费用int main(void)&#123;    double kwh;　　　　　　　　　　 // 使用的千瓦时    double bill;　　　　　　　　　　// 电费    printf(\"Please enter the kwh used.\\n\");    scanf(\"%lf\", &amp;kwh);　　　　　　 // %lf对应double类型    if (kwh &lt;= BREAK1)\t\tbill = RATE1 * kwh;    else if (kwh &lt;= BREAK2)　　　　 // 360～468 kwh\t\tbill = BASE1 + (RATE2 * (kwh - BREAK1));    else if (kwh &lt;= BREAK3)　　　　 // 468～720 kwh\t\tbill = BASE2 + (RATE3 * (kwh - BREAK2));    else　　　　　　　　　　　　　　// 超过 720 kwh\t\tbill = BASE3 + (RATE4 * (kwh - BREAK3));    printf(\"The charge for %.1f kwh is $%1.2f.\\n\", kwh, bill);    return 0;&#125;该程序的输出示例如下：\n123Please enter the kwh used.580The charge for 580.0 kwh is $97.50.程序清单 7.4 用符号常量表示不同的费率和费率分界点，以便把常量统一放在一处。这样，电力公司在更改费率以及费率分界点时，更新数据非常方便。BASE1和BASE2根据费率和费率分界点来表示。一旦费率或分界点发生了变化，它们也会自动更新。预处理器是不进行计算的。程序中出现BASE1的地方都会被替换成 0.13230*360.0。不用担心，编译器会对该表达式求值得到一个数值（47.628），以便最终的程序代码使用的是47.628而不是一个计算式。\n程序流简单明了。该程序根据kwh的值在3个公式之间选择一个。特别要注意的是，如果kwh大于或等于360，程序只会到达第1个else。因此，else if(kwh&lt;=BREAK2)这行相当于要求kwh在360～482之间，如程序注释所示。类似地，只有当kwh的值超过720时，才会执行最后的else。最后，注意BASE1、BASE2和BASE3分别代表360、468和720千瓦时的总费用。因此，当电量超过这些值时，只需要加上额外的费用即可。\n实际上，else if 是已学过的 if else 语句的变式。例如，该程序的核心部分只不过是下面代码的另一种写法：\n12345678910if (kwh &lt;= BREAK1)\tbill=RATE1*kwh;else\tif (kwh &lt;= BREAK2)　　　　 // 360～468 kwh\t\tbill = BASE1 + (RATE2 * (kwh - BREAK1));\telse\t\tif (kwh &lt;= BREAK3)　　 // 468～720 kwh\t\t\tbill = BASE2 + (RATE3 * (kwh - BREAK2));\t\telse　　　　　　　　　　// 超过720 kwh\t\t\tbill = BASE3 + (RATE4 * (kwh - BREAK3));也就是说，该程序由一个if else语句组成，else部分包含另一个if else语句，该if else语句的else部分又包含另一个if else语句。第2个if else语句嵌套在第 1个if else语句中，第3个if else语句嵌套在第2个if else语句中。回忆一下，整个if else语句被视为一条语句，因此不必把嵌套的if else语句用花括号括起来。当然，花括号可以更清楚地表明这种特殊格式的含义。\n这两种形式完全等价。唯一不同的是使用空格和换行的位置不同，不过编译器会忽略这些。尽管如此，第1种形式还是好些，因为这种形式更清楚地显示了有4种选择。在浏览程序时，这种形式让读者更容易看清楚各项选择。在需要时要缩进嵌套的部分，例如，必须测试两个单独的量时。本例中，仅在夏季对用电量超过720kWh的用户加收10%的电费，就属于这种情况。\n可以把多个else if语句连成一串使用，如下所示（当然，要在编译器的限制范围内）：\n12345678910if (score &lt; 1000)\tbonus = 0;else if (score &lt; 1500)\tbonus = 1;else if (score &lt; 2000)\tbonus = 2;else if (score &lt; 2500)\tbonus = 4;else\tbonus = 6;（这可能是一个游戏程序的一部分，bonus表示下一局游戏获得的光子炸弹或补给。）\n对于编译器的限制范围，C99标准要求编译器最少支持127层套嵌。\nelse与if配对如果程序中有许多if和else，编译器如何知道哪个if对应哪个else？例如，考虑下面的程序段：\n12345if (number &gt; 6)\tif (number &lt; 12)\t\tprintf(\"You're close!\\n\");\telse\t\tprintf(\"Sorry, you lose a turn!\\n\");何时打印Sorry, you lose a turn!？当number小于或等于6时，还是number大于12时？换言之，else与第1个if还是第2个if匹配？答案是，else与第2个if匹配。也就是说，输入的数字和匹配的响应如下：\n1234数字　　　 响应5　　　　 None10　　　　You’re close!15　　　　Sorry, you lose a turn!规则是，如果没有花括号，else与离它最近的if匹配，除非最近的if被花括号括起来（见图7.2）。\n\n第1个例子的缩进使得else看上去与第1个if相匹配，但是记住，编译器是忽略缩进的。如果希望else与第1个if匹配，应该这样写：\n1234567if (number &gt; 6)&#123;    if (number &lt; 12)    printf(\"You're close!\\n\");&#125;else\tprintf(\"Sorry, you lose a turn!\\n\");这样改动后，响应如下：\n1234数字　　　 响应5　　　　 Sorry, you lose a turn!10　　　　You’re close!15　　　　None多层嵌套的if语句前面介绍的if...else if...else序列是嵌套if的一种形式，从一系列选项中选择一个执行。有时，选择一个特定选项后又引出其他选择，这种情况可以使用另一种嵌套 if。例如，程序可以使用 if else选择男女，if else的每个分支里又包含另一个if else来区分不同收入的群体。\n我们把这种形式的嵌套if应用在下面的程序中。给定一个整数，显示所有能整除它的约数。如果没有约数，则报告该数是一个素数。\n在编写程序的代码之前要先规划好。首先，要总体设计一下程序。为方便起见，程序应该使用一个循环让用户能连续输入待测试的数。这样，测试一个新的数字时不必每次都要重新运行程序。下面是我们为这种循环开发的一个模型（伪代码）：\n1234提示用户输入数字当scanf()返回值为1分析该数并报告结果提示用户继续输入回忆一下在测试条件中使用scanf()，把读取数字和判断测试条件确定是否结束循环合并在一起。\n下一步，设计如何找出约数。也许最直接的方法是：\n123for (div = 2; div &lt; num; div++)if (num % div == 0)printf(\"%d is divisible by %d\\n\", num, div);该循环检查2～num之间的所有数字，测试它们是否能被num整除。但是，这个方法有点浪费时间。我们可以改进一下。例如，考虑如果144%2得0，说明2是144的约数；如果144除以2得72，那么72也是144的一个约数。所以，num % div测试成功可以获得两个约数。为了弄清其中的原理，我们分析一下循环中得到的成对约数：2和72、2和48、4和36、6和24、8和18、9和16、12和12、16和9、18和8，等等。在得到12和12这对约数后，又开始得到已找到的相同约数（次序相反）。因此，不用循环到143，在达到12以后就可以停止循环。这大大地节省了循环时间！\n分析后发现，必须测试的数只要到num的平方根就可以了，不用到num。对于9这样的数字，不会节约很多时间，但是对于10000这样的数，使用哪一种方法求约数差别很大。不过，我们不用在程序中计算平方根，可以这样编写测试条件：\n123for (div = 2; (div * div) &lt;= num; div++)\tif (num % div == 0)\t\tprintf(\"%d is divisible by %d and %d.\\n\",num, div, num / div);如果num是144，当div = 12时停止循环。如果num是145，当div = 13时停止循环。\n不使用平方根而用这样的测试条件，有两个原因。其一，整数乘法比求平方根快。其二，我们还没有正式介绍平方根函数。\n还要解决两个问题才能准备编程。第1个问题，如果待测试的数是一个完全平方数怎么办？报告144可以被12和12整除显得有点傻。可以使用嵌套if语句测试div是否等于num /div。如果是，程序只打印一个约数：\n12345678910for (div = 2; (div * div) &lt;= num; div++)&#123;    if (num % div == 0)    &#123;        if (div * div != num)        \tprintf(\"%d is divisible by %d and %d.\\n\",num, div, num / div);        else        \tprintf(\"%d is divisible by %d.\\n\", num, div);    &#125;&#125;注意\n从技术角度看，if else语句作为一条单独的语句，不必使用花括号。外层if也是一条单独的语句，也不必使用花括号。但是，当语句太长时，使用花括号能提高代码的可读性，而且还可防止今后在if循环中添加其他语句时忘记加花括号。\n第2个问题，如何知道一个数字是素数？如果num是素数，程序流不会进入if语句。要解决这个问题，可以在外层循环把一个变量设置为某个值（如，1），然后在if语句中把该变量重新设置为0。循环完成后，检查该变量是否是1，如果是，说明没有进入if语句，那么该数就是素数。这样的变量通常称为标记（flag）。\n一直以来，C都习惯用int作为标记的类型，其实新增的_Bool类型更合适。另外，如果在程序中包含了stdbool.h头文件，便可用bool代替_Bool类型，用true和false分别代替1和0。\n程序清单7.5体现了以上分析的思路。为扩大该程序的应用范围，程序用long类型而不是int类型（如果系统不支持_Bool类型，可以把isPrime的类型改为int，并用1和0分别替换程序中的true和false）。\n程序清单7.5 divisors.c程序\n12345678910111213141516171819202122232425262728293031323334// divisors.c -- 使用嵌套if语句显示一个数的约数#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;int main(void)&#123;    unsigned long num;　　　　 // 待测试的数    unsigned long div;　　　　 // 可能的约数    bool isPrime;　　　　　　　// 素数标记    printf(\"Please enter an integer for analysis; \");    printf(\"Enter q to quit.\\n\");    while (scanf(\"%lu\", &amp;num) == 1)    &#123;    \tfor (div = 2, isPrime = true; (div * div) &lt;= num; div++)        &#123;            if (num % div == 0)            &#123;                if ((div * div) != num)                    printf(\"%lu is divisible by %lu and %lu.\\n\",                    num, div, num / div);                else                    printf(\"%lu is divisible by %lu.\\n\",                    num, div);                isPrime = false;　 // 该数不是素数            &#125;    \t&#125;        if (isPrime)            printf(\"%lu is prime.\\n\", num);        printf(\"Please enter another integer for analysis; \");        printf(\"Enter q to quit.\\n\");    &#125;    printf(\"Bye.\\n\");    return 0;&#125;注意，该程序在for循环的测试表达式中使用了逗号运算符，这样每次输入新值时都可以把isPrime设置为true。\n下面是该程序的一个输出示例：\n123456789101112131415161718Please enter an integer for analysis; Enter q to quit.123456789123456789 is divisible by 3 and 41152263.123456789 is divisible by 9 and 13717421.123456789 is divisible by 3607 and 34227.123456789 is divisible by 3803 and 32463.123456789 is divisible by 10821 and 11409.Please enter another integer for analysis; Enter q to quit.149149 is prime.Please enter another integer for analysis; Enter q to quit.20132013 is divisible by 3 and 671.2013 is divisible by 11 and 183.2013 is divisible by 33 and 61.Please enter another integer for analysis; Enter q to quit.qBye.该程序会把1认为是素数，其实它不是。下一节将要介绍的逻辑运算符可以排除这种特殊的情况。\n小结：用if语句进行选择\n关键字：if、else\n一般注解：\n下面各形式中，statement可以是一条简单语句或复合语句。表达式为真说明其值是非零值。\n形式1：\n123if (expression)statement如果expression为真，则执行statement部分。形式2：\n12345if (expression)statement1elsestatement2如果expression为真，执行statement1部分；否则，执行statement2部分。形式3：\n123456if (expression1)statement1else if (expression2)statement2elsestatement3如果expression1为真，执行statement1部分；如果expression2为真，执行statement2部分；否则，执行statement3部分。\n示例：\n123456789if (legs == 4)\tprintf(\"It might be a horse.\\n\");else if (legs &gt; 4)\tprintf(\"It is not a horse.\\n\");else　　 /* 如果legs &lt; 4 */&#123;\tlegs++;\tprintf(\"Now it has one more leg.\\n\");&#125;逻辑运算符读者已经很熟悉了，if 语句和 while 语句通常使用关系表达式作为测试条件。有时，把多个关系表达式组合起来会很有用。例如，要编写一个程序，计算输入的一行句子中除单引号和双引号以外其他字符的数量。这种情况下可以使用逻辑运算符，并使用句点（.）标识句子的末尾。程序清单7.6用一个简短的程序进行演示。\n程序清单7.6 chcount.c程序\n12345678910111213141516// chcount.c　-- 使用逻辑与运算符#include &lt;stdio.h&gt;#define PERIOD '.'int main(void)&#123;    char ch;    int charcount = 0;    while((ch = getchar()) != PERIOD)    &#123;        if (ch != '\"' &amp;&amp; ch != '\\'')        \tcharcount++;    &#125;    printf(\"There are %d non-quote characters.\\n\", charcount);    return 0;&#125;下面是该程序的一个输出示例：\n12I didn't read the \"I'm a Programming Fool\" best seller.There are 50 non-quote characters.程序首先读入一个字符，并检查它是否是一个句点，因为句点标志一个句子的结束。接下来，if语句的测试条件中使用了逻辑与运算符&amp;&amp;。该 if 语句翻译成文字是“如果待测试的字符不是双引号，并且它也不是单引号，那么charcount递增1”。\n逻辑运算符两侧的条件必须都为真，整个表达式才为真。逻辑运算符的优先级比关系运算符低，所以不必在子表达式两侧加圆括号。\nC有3种逻辑运算符，见表7.3。\n\n假设exp1和exp2是两个简单的关系表达式（如car &gt; rat或debt == 1000），那么：\n当且仅当exp1和exp2都为真时，exp1 &amp;&amp; exp2才为真；\n如果exp1或exp2为真，则exp1 || exp2为真；\n如果exp1为假，则!exp1为真；如果exp1为真，则!exp1为假。\n下面是一些具体的例子：\n5 &gt; 2 &amp;&amp; 4 &gt; 7为假，因为只有一个子表达式为真；\n5 &gt; 2 || 4 &gt; 7为真，因为有一个子表达式为真；\n!(4 &gt; 7)为真，因为4不大于7。\n顺带一提，最后一个表达式与下面的表达式等价：\n14 &lt;= 7如果不熟悉逻辑运算符或者觉得很别扭，请记住：(练习&amp;&amp;时间)== 完美。\n备选拼写：iso646.h头文件C 是在美国用标准美式键盘开发的语言。但是在世界各地，并非所有的键盘都有和美式键盘一样的符号。因此，C99标准新增了可代替逻辑运算符的拼写，它们被定义在ios646.h头文件中。如果在程序中包含该头文件，便可用and代替&amp;&amp;、or代替||、not代替!。例如，可以把下面的代码：\n12if (ch != '\"' &amp;&amp; ch != '\\'')charcount++;改写为：\n12if (ch != '\"' and ch != '\\'')charcount++;表7.4列出了逻辑运算符对应的拼写，很容易记。读者也许很好奇，为何C不直接使用and、or和not？因为C一直坚持尽量保持较少的关键字。参考资料V“新增C99和C11的标准ANSI C库”列出了一些运算符的备选拼写，有些我们还没见过。\n优先级\n算数运算符&gt;关系运算符&gt;赋值运算符\n\n!运算符的优先级很高，比乘法运算符还高，与递增运算符的优先级相同，只比圆括号的优先级低。&amp;&amp;运算符的优先级比||运算符高，但是两者的优先级都比关系运算符低，比赋值运算符高。因此，表达式a&gt;b &amp;&amp; b&gt;c || b&gt;d相当于((a&gt;b) &amp;&amp; (b&gt;c)) || (b&gt;d)。\n也就是说，b介于a和c之间，或者b大于d。\n尽管对于该例没必要使用圆括号，但是许多程序员更喜欢使用带圆括号的第 2 种写法。这样做即使不记得逻辑运算符的优先级，表达式的含义也很清楚。\n求值顺序除了两个运算符共享一个运算对象的情况外，C 通常不保证先对复杂表达式中哪部分求值。例如，下面的语句，可能先对表达式5 + 3求值，也可能先对表达式9 + 6求值：\n1apples = (5 + 3) * (9 + 6);C 把先计算哪部分的决定权留给编译器的设计者，以便针对特定系统优化设计。但是，对于逻辑运算符是个例外，C保证逻辑表达式的求值顺序是从左往右。&amp;&amp;和||运算符都是序列点，所以程序在从一个运算对象执行到下一个运算对象之前，所有的副作用都会生效。而且，C 保证一旦发现某个元素让整个表达式无效，便立即停止求值。正是由于有这些规定，才能写出这样结构的代码：\n1while((c = getchar()) != ' ' &amp;&amp; c != '\\n')如上代码所示，读取字符直至遇到第1 个空格或换行符。第1 个子表达式把读取的值赋给c，后面的子表达式会用到c的值。如果没有求值循序的保证，编译器可能在给c赋值之前先对后面的表达式求值。\n这里还有一个例子：\n12if (number != 0 &amp;&amp; 12/number == 2)\tprintf(\"The number is 5 or 6.\\n\");如果number的值是0，那么第1个子表达式为假，且不再对关系表达式求值。这样避免了把0作为除数。许多语言都没有这种特性，知道number为0后，仍继续检查后面的条件。\n最后，考虑这个例子：\n1while ( x++ &lt; 10 &amp;&amp; x + y &lt; 20)实际上，&amp;&amp;是一个序列点，这保证了在对&amp;&amp;右侧的表达式求值之前，已经递增了x。\n小结：逻辑运算符和表达式\n逻辑运算符：\n逻辑运算符的运算对象通常是关系表达式。!运算符只需要一个运算对象，其他两个逻辑运算符都需要两个运算对象，左侧一个，右侧一个。\n\n逻辑表达式：\n当且仅当expression1和expression2都为真，expression1 &amp;&amp; expression2才为真。如果 expression1 或 expression2 为真，expression1 || expression2 为真。如果expression为假，!expression则为真，反之亦然。\n求值顺序：\n逻辑表达式的求值顺序是从左往右。一旦发现有使整个表达式为假的因素，立即停止求值。\n示例：\n1236 &gt; 2 &amp;&amp; 3 == 3　　　　 真!(6 &gt; 2 &amp;&amp; 3 == 3)　　　假x != 0 &amp;&amp; (20 / x) &lt; 5 只有当x不等于0时，才会对第2个表达式求值范围&amp;&amp;运算符可用于测试范围。例如，要测试score是否在90～100的范围内，可以这样写：\n12if (range &gt;= 90 &amp;&amp; range &lt;= 100)\tprintf(\"Good show!\\n\");千万不要模仿数学上的写法：\n12if (90 &lt;= range &lt;= 100)　　// 千万不要这样写！\tprintf(\"Good show!\\n\");这样写的问题是代码有语义错误，而不是语法错误，所以编译器不会捕获这样的问题（虽然可能会给出警告）。由于&lt;=运算符的求值顺序是从左往右，所以编译器把测试表达式解释为：\n1(90 &lt;= range) &lt;= 100子表达式90 &lt;= range的值要么是1（为真），要么是0（为假）。这两个值都小于100，所以不管range的值是多少，整个表达式都恒为真。因此，在范围测试中要使用&amp;&amp;。\n许多代码都用范围测试来确定一个字符是否是小写字母。例如，假设ch是char类型的变量：\n12if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z')printf(\"That's a lowercase character.\\n\");该方法仅对于像ASCII这样的字符编码有效，这些编码中相邻字母与相邻数字一一对应。但是，对于像EBCDIC这样的代码就没用了。相应的可移植方法是，用ctype.h系列中的islower()函数（参见表7.1）：\n12if (islower(ch))printf(\"That's a lowercase character.\\n\");无论使用哪种特定的字符编码，islower()函数都能正常运行（不过，一些早期的编译器没有ctype.h系列）。\n一个统计单词的程序现在，我们可以编写一个统计单词数量的程序（即，该程序读取并报告单词的数量）。该程序还可以计算字符数和行数。先来看看编写这样的程序要涉及那些内容。\n首先，该程序要逐个字符读取输入，知道何时停止读取。然后，该程序能识别并计算这些内容：字符、行数和单词。据此我们编写的伪代码如下：\n1234567891011读取一个字符当有更多输入时递增字符计数如果读完一行，递增行数计数如果读完一个单词，递增单词计数读取下一个字符前面有一个输入循环的模型：while ((ch = getchar()) != STOP)&#123;...&#125;这里，STOP表示能标识输入末尾的某个值。以前我们用过换行符和句点标记输入的末尾，但是对于一个通用的统计单词程序，它们都不合适。我们暂时选用一个文本中不常用的字符（如，|）作为输入的末尾标记。第8章中会介绍更好的方法，以便程序既能处理文本文件，又能处理键盘输入。\n现在，我们考虑循环体。因为该程序使用getchar()进行输入，所以每次迭代都要通过递增计数器来计数。为了统计行数，程序要能检查换行字符。如果输入的字符是一个换行符，该程序应该递增行数计数器。这里要注意 STOP 字符位于一行的中间的情况。是否递增行数计数？我们可以作为特殊行计数，即没有换行符的一行字符。可以通过记录之前读取的字符识别这种情况，即如果读取时发现 STOP 字符的上一个字符不是换行符，那么这行就是特殊行。\n最棘手的部分是识别单词。首先，必须定义什么是该程序识别的单词。我们用一个相对简单的方法，把一个单词定义为一个不含空白（即，没有空格、制表符或换行符）的字符序列。因此，“glymxck”和“r2d2”都算是一个单词。程序读取的第 1 个非空白字符即是一个单词的开始，当读到空白字符时结束。判断非空白字符最直接的测试表达式是：\n1c != ' ' &amp;&amp; c != '\\n' &amp;&amp; c != '\\t' /* 如果c不是空白字符，该表达式为真*/检测空白字符最直接的测试表达式是：\n1c == ' ' || c == '\\n' || c == '\\t' /*如果c是空白字符，该表达式为真*/然而，使用ctype.h头文件中的函数isspace()更简单，如果该函数的参数是空白字符，则返回真。所以，如果c是空白字符，isspace(c)为真；如果c不是空白字符，!isspace(c)为真。\n要查找一个单词里是否有某个字符，可以在程序读入单词的首字符时把一个标记（名为 inword）设置为1。也可以在此时递增单词计数。然后，只要inword为1（或true），后续的非空白字符都不记为单词的开始。下一个空白字符，必须重置标记为0（或false），然后程序就准备好读取下一个单词。我们把以上分析写成伪代码：\n1234如果c不是空白字符，且inword为假设置inword为真，并给单词计数如果c是空白字符，且inword为真设置inword为假这种方法在读到每个单词的开头时把inword设置为1（真），在读到每个单词的末尾时把inword设置为0（假）。只有在标记从0设置为1时，递增单词计数。如果能使用_Bool类型，可以在程序中包含stdbool.h头文件，把inword的类型设置为bool，其值用true和false表示。如果编译器不支持这种用法，就把inword的类型设置为int，其值用1和0表示。\n如果使用布尔类型的变量，通常习惯把变量自身作为测试条件。如下所示：\n12用if (inword)代替if (inword == true)用if (!inword)代替if (inword == false)可以这样做的原因是，如果 inword为true，则表达式 inword == true为true；如果 inword为false，则表达式inword == true为false。所以，还不如直接用inword作为测试条件。类似地，!inword的值与表达式inword == false的值相同（非真即false，非假即true）。\n程序清单7.7把上述思路（识别行、识别不完整的行和识别单词）翻译了成C代码。\n程序清单7.7 wordcnt.c程序\n1234567891011121314151617181920212223242526272829303132333435363738// wordcnt.c -- 统计字符数、单词数、行数#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;　　　　 // 为isspace()函数提供原型#include &lt;stdbool.h&gt;　　　 // 为bool、true、false提供定义#define STOP '|'int main(void)&#123;    char c;　　　　　　　　// 读入字符    char prev;　　　　　　 // 读入的前一个字符    long n_chars = 0L;// 字符数    int n_lines = 0;　　　 // 行数    int n_words = 0;　　　 // 单词数    int p_lines = 0;　　　 // 不完整的行数    bool inword = false;　 // 如果c在单词中，inword 等于 true    printf(\"Enter text to be analyzed (| to terminate):\\n\");    prev = '\\n';　　　　　 // 用于识别完整的行    while ((c = getchar()) != STOP)    &#123;        n_chars++;　　　　 // 统计字符        if (c == '\\n')        \tn_lines++;　　 // 统计行        if (!isspace(c) &amp;&amp; !inword)        &#123;            inword = true;// 开始一个新的单词            n_words++;　　 // 统计单词    \t&#125;        if (isspace(c) &amp;&amp; inword)\t\t\tinword = false;　　// 打到单词的末尾        prev = c;　　　　　// 保存字符的值    &#125;    if (prev != '\\n')\t\tp_lines = 1;    printf(\"characters = %ld, words = %d, lines = %d, \",    n_chars, n_words, n_lines);    printf(\"partial lines = %d\\n\", p_lines);    return 0;&#125;下面是运行该程序后的一个输出示例：\n123456Enter text to be analyzed (| to terminate):Reason is apowerful servant butan inadequate master.|characters = 55, words = 9, lines = 3, partial lines = 0该程序使用逻辑运算符把伪代码翻译成C代码。例如，把下面的伪代码：\n如果c不是空白字符，且inword为假\n翻译成如下C代码：\n1if (!isspace(c) &amp;&amp;!inword)再次提醒读者注意，!inword 与 inword == false 等价。上面的整个测试条件比单独判断每个空白字符的可读性高：\n1if (c != ' ' &amp;&amp; c != '\\n' &amp;&amp; c != '\\t' &amp;&amp; !inword)上面的两种形式都表示“如果c不是空白字符，且如果c不在单词里”。如果两个条件都满足，则一定是一个新单词的开头，所以要递增n_words。如果位于单词中，满足第1个条件，但是inword为true，就不递增 n_word。当读到下一个空白字符时，inword 被再次设置为 false。检查代码，查看一下如果单词之间有多个空格时，程序是否能正常运行。第 8 章讲解了如何修正这个问题，让该程序能统计文件中的单词量。\n条件运算符：?:C提供条件表达式（conditional expression）作为表达if else语句的一种便捷方式，该表达式使用?:条件运算符。该运算符分为两部分，需要 3 个运算对象。回忆一下，带一个运算对象的运算符称为一元运算符，带两个运算对象的运算符称为二元运算符。以此类推，带 3 个运算对象的运算符称为三元运算符。条件运算符是C语言中唯一的三元运算符。下面的代码得到一个数的绝对值：\n1x = (y &lt; 0) ? -y : y;在=和;之间的内容就是条件表达式，该语句的意思是“如果y小于0，那么x = -y;否则，x = y”。用if else可以这样表达：\n1234if (y &lt; 0)\tx = -y;else\tx = y;条件表达式的通用形式如下：\n1expression1 ? expression2 : expression3如果 expression1 为真（非 0），那么整个条件表达式的值与 expression2 的值相同；如果expression1为假（0），那么整个条件表达式的值与expression3的值相同。\n需要把两个值中的一个赋给变量时，就可以用条件表达式。典型的例子是，把两个值中的最大值赋给变量：\n1max = (a &gt; b) ? a : b;如果a大于b，那么将max设置为a；否则，设置为b。\n通常，条件运算符完成的任务用 if else 语句也可以完成。但是，使用条件运算符的代码更简洁，而且编译器可以生成更紧凑的程序代码。\n我们来看程序清单7.8中的油漆程序，该程序计算刷给定平方英尺的面积需要多少罐油漆。基本算法很简单：用平方英尺数除以每罐油漆能刷的面积。但是，商店只卖整罐油漆，不会拆分来卖，所以如果计算结果是1.7罐，就需要两罐。因此，该程序计算得到带小数的结果时应该进1。条件运算符常用于处理这种情况，而且还要根据单复数分别打印can和cans。\n程序清单7.8 paint.c程序\n12345678910111213141516171819/* paint.c -- 使用条件运算符 */#include &lt;stdio.h&gt;#define COVERAGE 350　　　// 每罐油漆可刷的面积（单位：平方英尺）int main(void)&#123;    int sq_feet;    int cans;    printf(\"Enter number of square feet to be painted:\\n\");    while (scanf(\"%d\", &amp;sq_feet) == 1)    &#123;        cans = sq_feet / COVERAGE;        cans += ((sq_feet % COVERAGE == 0)) ? 0 : 1;        printf(\"You need %d %s of paint.\\n\", cans,        cans == 1 ? \"can\" : \"cans\");        printf(\"Enter next value (q to quit):\\n\");    &#125;    return 0;&#125;下面是该程序的运行示例：\n12345678Enter number of square feet to be painted:349You need 1 can of paint.Enter next value (q to quit):351You need 2 cans of paint.Enter next value (q to quit):q该程序使用的变量都是int类型，除法的计算结果（sq_feet / COVERAGE）会被截断。也就是说， 351/350得1。所以，cans被截断成整数部分。如果sq_feet % COVERAGE得0，说明sq_feet被COVERAGE整除，cans的值不变；否则，肯定有余数，就要给cans加1。这由下面的语句完成：\n1cans += ((sq_feet % COVERAGE == 0)) ? 0 : 1;该语句把+=右侧表达式的值加上cans，再赋给cans。右侧表达式是一个条件表达式，根据sq_feet是否能被COVERAGE整除，其值为0或1。\nprintf()函数中的参数也是一个条件表达式：\n1cans == 1 ? \"can\" : \"cans\");如果cans的值是1，则打印can；否则，打印cans。这也说明了条件运算符的第2个和第3个运算对象可以是字符串。\n小结：条件运算符\n条件运算符：?:\n一般注解：\n条件运算符需要3个运算对象，每个运算对象都是一个表达式。其通用形式如下：\n1expression1 ? expression2 : expression3如果expression1为真，整个条件表达式的值是expression2的值；否则，是expression3的值。\n示例：\n123(5 &gt; 3) ? 1 : 2 值为1(3 &gt; 5) ? 1 : 2 值为2(a &gt; b) ? a : b 如果a &gt;b，则取较大的值循环辅助：continue和break一般而言，程序进入循环后，在下一次循环测试之前会执行完循环体中的所有语句。continue 和break语句可以根据循环体中的测试结果来忽略一部分循环内容，甚至结束循环。\ncontinue语句3种循环都可以使用continue语句。执行到该语句时，会跳过本次迭代的剩余部分，并开始下一轮迭代。如果continue语句在嵌套循环内，则只会影响包含该语句的内层循环。程序清单7.9中的简短程序演示了如何使用continue。\n程序清单7.9 skippart.c程序\n123456789101112131415161718192021222324252627282930313233343536/* skippart.c -- 使用continue跳过部分循环 */#include &lt;stdio.h&gt;int main(void)&#123;    const float MIN = 0.0f;    const float MAX = 100.0f;    float score;    float total = 0.0f;    int n = 0;    float min = MAX;    float max = MIN;    printf(\"Enter the first score (q to quit): \");    while (scanf(\"%f\", &amp;score) == 1)    &#123;        if (score &lt; MIN || score &gt; MAX)        &#123;            printf(\"%0.1f is an invalid value.Try again: \",score);            continue;　 // 跳转至while循环的测试条件    \t&#125;        printf(\"Accepting %0.1f:\\n\", score);        min = (score &lt; min) ? score : min;        max = (score &gt; max) ? score : max;        total += score;        n++;        printf(\"Enter next score (q to quit): \");    &#125;    if (n &gt; 0)    &#123;        printf(\"Average of %d scores is %0.1f.\\n\", n, total / n);        printf(\"Low = %0.1f, high = %0.1f\\n\", min, max);    &#125;    else\t\tprintf(\"No valid scores were entered.\\n\");    return 0;&#125;在程序清单7.9中，while循环读取输入，直至用户输入非数值数据。循环中的if语句筛选出无效的分数。假设输入 188，程序会报告：188 is an invalid value。在本例中，continue 语句让程序跳过处理有效输入部分的代码。程序开始下一轮循环，准备读取下一个输入值。\n注意，有两种方法可以避免使用continue，一是省略continue，把剩余部分放在一个else块中：\n123456if (score &lt; 0 || score &gt; 100)\t/* printf()语句 */else&#123;\t/* 语句*/&#125;另一种方法是，用以下格式来代替：\n1234if (score &gt;= 0 &amp;&amp; score &lt;= 100)&#123;/* 语句 */&#125;这种情况下，使用continue的好处是减少主语句组中的一级缩进。当语句很长或嵌套较多时，紧凑简洁的格式提高了代码的可读性。\ncontinue还可用作占位符。例如，下面的循环读取并丢弃输入的数据，直至读到行末尾：\n12while (getchar() != '\\n');当程序已经读取一行中的某些内容，要跳至下一行开始处时，这种用法很方便。问题是，一般很难注意到一个单独的分号。如果使用continue，可读性会更高：\n12while (getchar() != '\\n')continue;如果用了continue没有简化代码反而让代码更复杂，就不要使用continue。例如，考虑下面的程序段：\n123456while ((ch = getchar() ) != '\\n')&#123;    if (ch == '\\t')\t\tcontinue;    putchar(ch);&#125;该循环跳过制表符，并在读到换行符时退出循环。以上代码这样表示更简洁：\n123while ((ch = getchar()) != '\\n')if (ch != '\\t')putchar(ch);通常，在这种情况下，把if的测试条件的关系反过来便可避免使用continue。\n以上介绍了continue语句让程序跳过循环体的余下部分。那么，从何处开始继续循环？对于while和 do while 循环，执行 continue 语句后的下一个行为是对循环的测试表达式求值。考虑下面的循环：\n123456789count = 0;while (count &lt; 10)&#123;    ch = getchar();    if (ch == '\\n')\t\tcontinue;    putchar(ch);    count++;&#125;该循环读取10个字符（除换行符外，因为当ch是换行符时，程序会跳过count++;语句）并重新显示它们，其中不包括换行符。执行continue后，下一个被求值的表达式是循环测试条件。\n对于for循环，执行continue后的下一个行为是对更新表达式求值，然后是对循环测试表达式求值。例如，考虑下面的循环：\n1234567for (count = 0; count &lt; 10; count++)&#123;    ch = getchar();    if (ch == '\\n')\t\tcontinue;    putchar(ch);&#125;该例中，执行完continue后，首先递增count，然后将递增后的值和10作比较。因此，该循环与上面while循环的例子稍有不同。while循环的例子中，除了换行符，其余字符都显示；而本例中，换行符也计算在内，所以读取的10个字符中包含换行符。\nbreak语句程序执行到循环中的break语句时，会终止包含它的循环，并继续执行下一阶段。把程序清单7.9中的continue替换成break，在输入188时，不是跳至执行下一轮循环，而是导致退出当前循环。图7.3比较了break和continue。如果break语句位于嵌套循环内，它只会影响包含它的当前循环。\n\nbreak还可用于因其他原因退出循环的情况。程序清单7.10用一个循环计算矩形的面积。如果用户输入非数字作为矩形的长或宽，则终止循环。\n程序清单7.10 break.c程序\n1234567891011121314151617181920/* break.c -- 使用 break 退出循环 */#include &lt;stdio.h&gt;int main(void)&#123;    float length, width;    printf(\"Enter the length of the rectangle:\\n\");    while (scanf(\"%f\", &amp;length) == 1)    &#123;        printf(\"Length = %0.2f:\\n\", length);        printf(\"Enter its width:\\n\");        if (scanf(\"%f\", &amp;width) != 1)        \tbreak;        printf(\"Width = %0.2f:\\n\", width);        printf(\"Area = %0.2f:\\n\", length * width);        printf(\"Enter the length of the rectangle:\\n\");    &#125;    printf(\"Done.\\n\");    return 0;&#125;可以这样控制循环：\n1while (scanf(\"%f %f\", &amp;length, &amp;width) == 2)但是，用break可以方便显示用户输入的值。\n和continue一样，如果用了break代码反而更复杂，就不要使用break。例如，考虑下面的循环：\n123456while ((ch = getchar()) != '\\n')&#123;    if (ch == '\\t')        break;    putchar(ch);&#125;如果把两个测试条件放在一起，逻辑就更清晰了：\n12while ((ch = getchar() ) != '\\n' &amp;&amp; ch != '\\t')\tputchar(ch);break语句对于稍后讨论的switch语句而言至关重要。\n在for循环中的break和continue的情况不同，执行完break语句后会直接执行循环后面的第1条语句，连更新部分也跳过。嵌套循环内层的break只会让程序跳出包含它的当前循环，要跳出外层循环还需要一个break：\n1234567891011121314151617int p, q;scanf(\"%d\", &amp;p);while (p &gt; 0)&#123;    printf(\"%d\\n\", p);    scanf(\"%d\", &amp;q);    while (q &gt; 0)    &#123;        printf(\"%d\\n\", p*q);        if (q &gt; 100)\t\t\tbreak; // 跳出内层循环        scanf(\"%d\", &amp;q);    &#125;    if (q &gt; 100)  \t  break; // 跳出外层循环    scanf(\"%d\", &amp;p);&#125;多重选择：switch和break使用条件运算符和 if else 语句很容易编写二选一的程序。然而，有时程序需要在多个选项中进行选择。可以用if else  if...else来完成。但是，大多数情况下使用switch语句更方便。程序清单7.11演示了如何使用switch语句。该程序读入一个字母，然后打印出与该字母开头的动物名。\n程序清单7.11 animals.c程序\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/* animals.c -- 使用switch语句 */#include &lt;stdio.h&gt;#include &lt;ctype.h&gt;int main(void)&#123;    char ch;    printf(\"Give me a letter of the alphabet, and I will give \");    printf(\"an animal name\\nbeginning with that letter.\\n\");    printf(\"Please type in a letter; type # to end my act.\\n\");    while ((ch = getchar()) != '#')    &#123;        if ('\\n' == ch)        \tcontinue;        if (islower(ch))　　/* 只接受小写字母*/            switch (ch)            &#123;                case 'a':                \tprintf(\"argali, a wild sheep of Asia\\n\");                \tbreak;                case 'b':                \tprintf(\"babirusa, a wild pig of Malay\\n\");                \tbreak;                case 'c':                \tprintf(\"coati, racoonlike mammal\\n\");                \tbreak;                case 'd':                \tprintf(\"desman, aquatic, molelike critter\\n\");               \t\tbreak;                case 'e':                \tprintf(\"echidna, the spiny anteater\\n\");                \tbreak;                case 'f':                \tprintf(\"fisher, brownish marten\\n\");                \tbreak;                default:                \tprintf(\"That's a stumper!\\n\");            &#125;　　　　　　　　/* switch结束　　　　*/        else        \tprintf(\"I recognize only lowercase letters.\\n\");        while (getchar() != '\\n')        \tcontinue;　　 /* 跳过输入行的剩余部分　*/        printf(\"Please type another letter or a #.\\n\");    &#125;　　　　　　　　　 /* while循环结束　　　*/    printf(\"Bye!\\n\");    return 0;&#125;篇幅有限，我们只编到f，后面的字母以此类推。在进一步解释该程序之前，先看看输出示例：\n1234567891011121314151617Give me a letter of the alphabet, and I will give an animal namebeginning with that letter.Please type in a letter; type # to end my act.a [enter]argali, a wild sheep of AsiaPlease type another letter or a #.dab [enter]desman, aquatic, molelike critterPlease type another letter or a #.r [enter]That's a stumper!Please type another letter or a #.Q [enter]I recognize only lowercase letters.Please type another letter or a #.# [enter]Bye!该程序的两个主要特点是：使用了switch语句和它对输出的处理。我们先分析switch的工作原理。\nswitch语句要对紧跟在关键字 switch 后圆括号中的表达式求值。在程序清单 7.11 中，该表达式是刚输入给 ch的值。然后程序扫描标签（这里指，case &#39;a&#39; :、case &#39;b&#39; :等）列表，直到发现一个匹配的值为止。然后程序跳转至那一行。如果没有匹配的标签怎么办？如果有default :标签行，就跳转至该行；否则，程序继续执行在switch后面的语句。\nbreak语句在其中起什么作用？它让程序离开switch语句，跳至switch语句后面的下一条语句（见图7.4）。如果没有break语句，就会从匹配标签开始执行到switch末尾。例如，如果删除该程序中的所有break语句，运行程序后输入d，其交互的输出结果如下：\n\n1234567891011Give me a letter of the alphabet, and I will give an animal namebeginning with that letter.Please type in a letter; type # to end my act.d [enter]desman, aquatic, molelike critterechidna, the spiny anteaterfisher, a brownish martenThat's a stumper!Please type another letter or a #.\\# [enter]Bye!如上所示，执行了从case &#39;d&#39;:到switch语句末尾的所有语句。\n顺带一提，break语句可用于循环和switch语句中，但是continue只能用于循环中。尽管如此，如果switch语句在一个循环中，continue便可作为switch语句的一部分。这种情况下，就像在其他循环中一样，continue让程序跳出循环的剩余部分，包括switch语句的其他部分。\n如果读者熟悉Pascal，会发现switch语句和Pascal的case语句类似。它们最大的区别在于，如果只希望处理某个带标签的语句，就必须在switch语句中使用break语句。另外，C语言的case一般都指定一个值，不能使用一个范围。\nswitch在圆括号中的测试表达式的值应该是一个整数值（包括char类型）。case标签必须是整数类型（包括char类型）的常量或整型常量表达式（即，表达式中只包含整型常量）。不能用变量作为case标签。switch的构造如下：\n123456789switch ( 整型表达式)&#123;    case 常量1:    \t语句　　　&lt;--可选    case 常量2:    \t语句　　　&lt;--可选    default :　　 &lt;--可选    \t语句　　　&lt;--可选&#125;只读每行的首字符animals.c（程序清单7.11）的另一个独特之处是它读取输入的方式。运行程序时读者可能注意到了，当输入dab时，只处理了第1个字符。这种丢弃一行中其他字符的行为，经常出现在响应单字符的交互程序中。可以用下面的代码实现这样的行为：\n12while (getchar() != '\\n')\tcontinue;　　　　/* 跳过输入行的其余部分 */循环从输入中读取字符，包括按下Enter键产生的换行符。注意，函数的返回值并没有赋给ch，以上代码所做的只是读取并丢弃字符。由于最后丢弃的字符是换行符，所以下一个被读取的字符是下一行的首字母。在外层的while循环中，getchar()读取首字母并赋给ch。\n假设用户一开始就按下Enter键，那么程序读到的首个字符就是换行符。下面的代码处理这种情况：\n12if (ch == '\\n')\tcontinue;多重标签如程序清单7.12所示，可以在switch语句中使用多重case标签。\n123456789101112131415161718192021222324252627282930313233343536程序清单7.12 vowels.c程序// vowels.c -- 使用多重标签#include &lt;stdio.h&gt;int main(void)&#123;    char ch;    int a_ct, e_ct, i_ct, o_ct, u_ct;    a_ct = e_ct = i_ct = o_ct = u_ct = 0;    printf(\"Enter some text; enter # to quit.\\n\");    while ((ch = getchar()) != '#')    &#123;        switch (ch)        &#123;            case 'a':            case 'A':　a_ct++;            \tbreak;            case 'e':            case 'E':　e_ct++;            \tbreak;            case 'i':            case 'I':　i_ct++;            \tbreak;            case 'o':            case 'O':　o_ct++;            \tbreak;            case 'u':            case 'U':　u_ct++;            \tbreak;            default:　 break;        &#125;　　　　　　　　　// switch结束    &#125;　　　　　　　　　　　 // while循环结束    printf(\"number of vowels:　 A　 E　 I　 O　 U\\n\");    printf(\"%4d %4d %4d %4d %4d\\n\",a_ct, e_ct, i_ct, o_ct, u_ct);    return 0;&#125;假设如果ch是字母i，switch语句会定位到标签为case &#39;i&#39; :的位置。由于该标签没有关联break语句，所以程序流直接执行下一条语句，即i_ct++;。如果 ch是字母I，程序流会直接定位到case &#39;I&#39; :。本质上，两个标签都指的是相同的语句。\n严格地说，case &#39;U&#39;的 break 语句并不需要。因为即使删除这条 break 语句，程序流会接着执行switch中的下一条语句，即default : break;。所以，可以把case &#39;U&#39;的break语句去掉以缩短代码。但是从另一方面看，保留这条break语句可以防止以后在添加新的case（例如，把y作为元音）时遗漏break语句。\n下面是该程序的运行示例：\n1234Enter some text; enter # to quit.I see under the overseer.#number of vowels:　　 A　 E　 I　 O　 U0　　7　 1　 1　 1在该例中，如果使用ctype.h系列的toupper()函数（参见表7.2）可以避免使用多重标签，在进行测试之前就把字母转换成大写字母：\n123456789101112131415161718while ((ch = getchar()) != '#')&#123;    ch = toupper(ch);    switch (ch)    &#123;        case 'A': a_ct++;        \tbreak;        case 'E': e_ct++;        \tbreak;        case 'I': i_ct++;        \tbreak;        case 'O': o_ct++;        \tbreak;        case 'U': u_ct++;        \tbreak;        default: break;    &#125; // switch结束&#125; // while循环结束或者，也可以先不转换ch，把toupper(ch)放进switch的测试条件中：switch(toupper(ch))。\n小结：带多重选择的switch语句\n关键字：switch\n一般注解：\n程序根据expression的值跳转至相应的case标签处。然后，执行剩下的所有语句，除非执行到break语句进行重定向。expression和case标签都必须是整数值（包括char类型），标签必须是常量或完全由常量组成的表达式。如果没有case标签与expression的值匹配，控制则转至标有default的语句（如果有的话）；否则，将转至执行紧跟在switch语句后面的语句。\n形式：\n123456switch ( expression )&#123;    case label1 : statement1//使用break跳出switch    case label2 : statement2    default　　 : statement3&#125;可以有多个标签语句，default语句可选。\n示例：\n12345678switch (choice)&#123;    case 1 :    case 2 : printf(\"Darn tootin'!\\n\"); break;    case 3 : printf(\"Quite right!\\n\");    case 4 : printf(\"Good show!\\n\"); break;    default: printf(\"Have a nice day.\\n\");&#125;如果choice的值是1或2，打印第1条消息；如果choice的值是3，打印第2条和第3条消息（程序继续执行后续的语句，因为case 3后面没有break语句）；如果choice的值是4，则打印第3条消息；如果choice的值是其他值只打印最后一条消息。\nswitch和if else何时使用switch？何时使用if else？你经常会别无选择。如果是根据浮点类型的变量或表达式来选择，就无法使用 switch。如果根据变量在某范围内决定程序流的去向，使用 switch 就很麻烦，这种情况用if就很方便：\n1if (integer &lt; 1000 &amp;&amp; integer &gt; 2)使用switch要涵盖以上范围，需要为每个整数（3～999）设置case标签。但是，如果使用switch，程序通常运行快一些，生成的代码少一些。\ngoto语句早期版本的BASIC和FORTRAN所依赖的goto语句，在C中仍然可用。但是C和其他两种语言不同，没有goto语句C程序也能运行良好。Kernighan和Ritchie提到goto语句“易被滥用”，并建议“谨慎使用，或者根本不用”。首先，介绍一下如何使用goto语句；然后，讲解为什么通常不需要它。\ngoto语句有两部分：goto和标签名。标签的命名遵循变量命名规则，如下所示：\n1goto part2;要让这条语句正常工作，函数还必须包含另一条标为part2的语句，该语句以标签名后紧跟一个冒号开始：\n1part2: printf(\"Refined analysis:\\n\");避免使用goto原则上，根本不用在C程序中使用goto语句。但是，如果你曾经学过FORTRAN或BASIC（goto对这两种语言而言都必不可少），可能还会依赖用goto来编程。为了帮助你克服这个习惯，我们先概述一些使用goto的常见情况，然后再介绍C的解决方案。\n处理包含多条语句的if语句：\n123456if (size &gt; 12)\tgoto a;goto b;a: cost = cost * 1.05;flag = 2;b: bill = cost * flag;对于以前的BASIC和FORTRAN，只有直接跟在if条件后面的一条语句才属于if，不能使用块或复合语句。我们把以上模式转换成等价的C代码，标准C用复合语句或块来处理这种情况：\n123456if (size &gt; 12)&#123;    cost = cost * 1.05;    flag = 2;&#125;bill = cost * flag;二选一：\n123456if (ibex &gt; 14)\tgoto a;sheds = 2;goto b;a: sheds= 3;b: help = 2 * sheds;C通过if else表达二选一更清楚：\n12345if (ibex &gt; 14)sheds = 3;elsesheds = 2;help = 2 * sheds;实际上，新版的BASIC和FORTRAN已经把else纳入新的语法中。\n创建不确定循环：\n123456readin: scanf(\"%d\", &amp;score);if (score &lt; O)\tgoto stage2;lots of statementsgoto readin;stage2: more stuff;C用while循环代替：\n1234567scanf(\"%d\", &amp;score);while (score &lt;= 0)&#123;    lots of statements    scanf(\"%d\", &amp;score);&#125;more stuff;跳转至循环末尾，并开始下一轮迭代。C使用continue语句代替。\n跳出循环。C使用break语句。实际上，break和continue是goto的特殊形式。使用break和 continue 的好处是：其名称已经表明它们的用法，而且这些语句不使用标签，所以不用担心把标签放错位置导致的危险。\n胡乱跳转至程序的不同部分。简而言之，不要这样做！\n但是，C程序员可以接受一种goto的用法——出现问题时从一组嵌套循环中跳出（一条break语句只能跳出当前循环）：\n1234567891011121314151617while (funct &gt; 0)&#123;    for (i = 1, i &lt;= 100; i++)    &#123;        for (j = 1; j &lt;= 50; j++)        &#123;            其他语句            if (问题)            goto help;        \t其他语句        &#125;        其他语句    &#125;    其他语句&#125;其他语句help: 语句从其他例子中也能看出，程序中使用其他形式比使用goto的条理更清晰。当多种情况混在一起时，这种差异更加明显。哪些goto语句可以帮助if语句？哪些可以模仿if else？哪些控制循环？哪些是因为程序无路可走才不得已放在那里？过度地使用 goto 语句，会让程序错综复杂。如果不熟悉goto语句，就不要使用它。如果已经习惯使用goto语句，试着改掉这个毛病。讽刺地是，虽然C根本不需要goto，但是它的goto比其他语言的goto好用，因为C允许在标签中使用描述性的单词而不是数字。\n小结：程序跳转\n关键字：break、continue、goto\n一般注解：\n这3种语句都能使程序流从程序的一处跳转至另一处。\nbreak语句：\n所有的循环和switch语句都可以使用break语句。它使程序控制跳出当前循环或switch语句的剩余部分，并继续执行跟在循环或switch后面的语句。\n示例：\n12345678switch (number)&#123;    case 4: printf(\"That's a good choice.\\n\");    \tbreak;    case 5: printf(\"That's a fair choice.\\n\");    \tbreak;    default: printf(\"That's a poor choice.\\n\");&#125;continue语句：\n所有的循环都可以使用continue语句，但是switch语句不行。continue语句使程序控制跳出循环的剩余部分。对于while或for循环，程序执行到continue语句后会开始进入下一轮迭代。对于do while循环，对出口条件求值后，如有必要会进入下一轮迭代。\n示例：\n1234567while ((ch = getchar()) != '\\n')&#123;    if (ch == ' ')    \tcontinue;    putchar(ch);    chcount++;&#125;以上程序段把用户输入的字符再次显示在屏幕上，并统计非空格字符。\ngoto语句：\ngoto语句使程序控制跳转至相应标签语句。冒号用于分隔标签和标签语句。标签名遵循变量命名规则。标签语句可以出现在goto的前面或后面。\n形式：\n12goto label;label: statement示例：\n123top: ch=getchar();if (ch!='y')goto top;关键概念智能的一个方面是，根据情况做出相应的响应。所以，选择语句是开发具有智能行为程序的基础。C语言通过if、if else和switch语句，以及条件运算符（?:）可以实现智能选择。\nif 和 if else 语句使用测试条件来判断执行哪些语句。所有非零值都被视为 true，零被视为false。测试通常涉及关系表达式（比较两个值）、逻辑表达式（用逻辑运算符组合或更改其他表达式）。\n要记住一个通用原则，如果要测试两个条件，应该使用逻辑运算符把两个完整的测试表达式组合起来。例如，下面这些是错误的：\n1234if (a &lt; x &lt; z)　　　　　　 // 错误，没有使用逻辑运算符…if (ch != 'q' &amp;&amp; != 'Q')　 // 错误，缺少完整的测试表达式…正确的方式是用逻辑运算符连接两个关系表达式：\n1234if (a &lt; x &amp;&amp; x &lt; z)　　　　　　 // 使用&amp;&amp;组合两个表达式…if (ch != 'q' &amp;&amp; ch != 'Q')　　// 使用&amp;&amp;组合两个表达式…对比这两章和前几章的程序示例可以发现：使用第6章、第7章介绍的语句，可以写出功能更强大、更有趣的程序。\n本章小结本章介绍了很多内容，我们来总结一下。if语句使用测试条件控制程序是否执行测试条件后面的一条简单语句或复合语句。如果测试表达式的值是非零值，则执行语句；如果测试表达式的值是零，则不执行语句。if else语句可用于二选一的情况。如果测试条件是非零，则执行else前面的语句；如果测试表达式的值是零，则执行else后面的语句。在else后面使用另一个if语句形成else if，可构造多选一的结构。\n测试条件通常都是关系表达式，即用一个关系运算符（如，&lt;或==）的表达式。使用C的逻辑运算符，可以把关系表达式组合成更复杂的测试条件。\n在多数情况下，用条件运算符（?:）写成的表达式比if else语句更简洁。\nctype.h系列的字符函数（如，issapce()和isalpha()）为创建以分类字符为基础的测试表达式提供了便捷的工具。\nswitch 语句可以在一系列以整数作为标签的语句中进行选择。如果紧跟在 switch 关键字后的测试条件的整数值与某标签匹配，程序就转至执行匹配的标签语句，然后在遇到break之前，继续执行标签语句后面的语句。\nbreak、continue和goto语句都是跳转语句，使程序流跳转至程序的另一处。break语句使程序跳转至紧跟在包含break语句的循环或switch末尾的下一条语句。continue语句使程序跳出当前循环的剩余部分，并开始下一轮迭代。\n","plink":"https://dxsummer.gitee.io/posts/3e5d0fae/"},{"title":"emoji符号大全","date":"2020-06-05T04:14:30.000Z","date_formatted":{"ll":"2020年6月5日","L":"2020/06/05","MM-DD":"06-05"},"updated":"2020-06-13T06:58:26.000Z","content":"emoji符号大全🌹🍀🍎💰📱🌙🍁🍂🍃🌷💎🔪🔫🏀⚽⚡👄👍🔥\nemoji表情😀😁😂😃😄😅😆😉😊😋😎😍😘😗😙😚☺😇😐😑😶😏😣😥😮😯😪😫😴😌😛😜😝😒😓😔😕😲😷😖😞😟😤😢😭😦😧😨😬😰😱😳😵😡😠\nemoji人物👦👧👨👩👴👵👶👱👮👲👳👷👸💂🎅👰👼💆💇🙍🙎🙅🙆💁🙋🙇🙌🙏👤👥🚶🏃👯💃👫👬👭💏💑👪\nemoji手势💪👈👉☝👆👇✌✋👌👍👎✊👊👋👏👐✍\nemoji日常👣👀👂👃👅👄💋👓👔👕👖👗👘👙👚👛👜👝🎒💼👞👟👠👡👢👑👒🎩🎓💄💅💍🌂\nemoji手机📱📲📶📳📴☎📞📟📠\nemoji公共♻🏧🚮🚰♿🚹🚺🚻🚼🚾⚠🚸⛔🚫🚳🚭🚯🚱🚷🔞💈\nemoji动物🙈🙉🙊🐵🐒🐶🐕🐩🐺🐱😺😸😹😻😼😽🙀😿😾🐈🐯🐅🐆🐴🐎🐮🐂🐃🐄🦏🐷🐖🐗🐽🐏🐑🐐🐪🐫🐘🐭🐁🐀🐹🐰🐇🐻🐨🐼🐾🐔🐓🐣🐤🐥🐦🐧🐸🐊🐢🐍🐲🐉🐳🐋🐬🐟🐠🐡🐙🐚🐌🐛🐜🐝🐞🦋\nemoji植物💐🌸💮🌹🌺🌻🌼🌷🌱🌲🌳🌴🌵🌾🌿🍀🍁🍂🍃\nemoji自然🌍🌎🌏🌐🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜☀🌝🌞⭐🌟🌠☁⛅☔⚡❄🔥💧🌊\nemoji饮食🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓🍅🍆🌽🍄🌰🍞🍖🍗🍔🍟🍕🍳🍲🍱🍘🍙🍚🍛🍜🍝🍠🍢🍣🍤🍥🍡🍦🍧🍨🍩🍪🎂🍰🍫🍬🍭🍮🍯🍼☕🍵🍶🍷🍸🍹🍺🍻🍴\nemoji文体🎪🎭🎨🎰🚣🛀🎫🏆⚽⚾🏀🏈🏉🎾🎱🎳⛳🎣🎽🎿🏂🏄🏇🏊🚴🚵🎯🎮🎲🎷🎸🎺🎻🎬\nemoji恐怖😈👿👹👺💀☠👻👽👾💣\nemoji旅游🌋🗻🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪⛲🌁🌃🌆🌇🌉🌌🎠🎡🎢🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚤🚢✈💺🚁🚟🚠🚡🚀🎑🗿🛂🛃🛄🛅\nemoji物品💌💎🔪💈🚪🚽🚿🛁⌛⏳⌚⏰🎈🎉🎊🎎🎏🎐🎀🎁📯📻📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡💡🔦🏮📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💰💴💵💶💷💸💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑🔨🔫🔧🔩🔗💉💊🚬🔮🚩🎌💦💨\nemoji标志♠♥♦♣🀄🎴🔇🔈🔉🔊📢📣💤💢💬💭♨🌀🔔🔕✡✝🔯📛🔰🔱⭕✅☑✔✖❌❎➕➖➗➰➿〽✳✴❇‼⁉❓❔❕❗©®™🎦🔅🔆💯🔠🔡🔢🔣🔤🅰🆎🅱🆑🆒🆓ℹ🆔Ⓜ🆕🆖🅾🆗🅿🆘🆙🆚🈁🈂🈷🈶🈯🉐🈹🈚🈲🉑🈸🈴🈳㊗㊙🈺🈵▪▫◻◼◽◾⬛⬜🔶🔷🔸🔹🔺🔻💠🔲🔳⚪⚫🔴🔵\nemoji生肖🐁🐂🐅🐇🐉🐍🐎🐐🐒🐓🐕🐖\nemoji星座♈♉♊♋♌♍♎♏♐♑♒♓⛎\nemoji钟表🕛🕧🕐🕜🕑🕝🕒🕞🕓🕟🕔🕠🕕🕡🕖🕢🕗🕣🕘🕤🕙🕥🕚🕦⌛⏳⌚⏰⏱⏲🕰\nemoji心形💘❤💓💔💕💖💗💙💚💛💜💝💞💟❣\nemoji花草💐🌸💮🌹🌺🌻🌼🌷🌱🌿🍀\nemoji树叶🌿🍀🍁🍂🍃\nemoji月亮🌑🌒🌓🌔🌕🌖🌗🌘🌙🌚🌛🌜🌝\nemoji水果🍇🍈🍉🍊🍋🍌🍍🍎🍏🍐🍑🍒🍓\nemoji钱币💴💵💶💷💰💸💳\nemoji交通🚂🚃🚄🚅🚆🚇🚈🚉🚊🚝🚞🚋🚌🚍🚎🚏🚐🚑🚒🚓🚔🚕🚖🚗🚘🚚🚛🚜🚲⛽🚨🚥🚦🚧⚓⛵🚣🚤🚢✈💺🚁🚟🚠🚡🚀\nemoji建筑🏠🏡🏢🏣🏤🏥🏦🏨🏩🏪🏫🏬🏭🏯🏰💒🗼🗽⛪🌆🌇🌉\nemoji办公📱📲☎📞📟📠🔋🔌💻💽💾💿📀🎥📺📷📹📼🔍🔎🔬🔭📡📔📕📖📗📘📙📚📓📃📜📄📰📑🔖💳✉📧📨📩📤📥📦📫📪📬📭📮✏✒📝📁📂📅📆📇📈📉📊📋📌📍📎📏📐✂🔒🔓🔏🔐🔑\nemoji箭头⬆↗➡↘⬇↙⬅↖↕↔↩↪⤴⤵🔃🔄🔙🔚🔛🔜🔝\n","plink":"https://dxsummer.gitee.io/posts/e193db5d/"},{"title":"疫情期间基层党员如何发挥先锋模范作用","date":"2020-06-03T08:01:38.000Z","date_formatted":{"ll":"2020年6月3日","L":"2020/06/03","MM-DD":"06-03"},"updated":"2020-06-08T01:55:56.000Z","content":"参与调查问卷 即可参与抽奖，领取一下其一🍎微信10元红包\n🍖微信20元红包\n🍼安慕希酸奶6瓶\n🍬200元中小学名师课\n🍺感谢参与\n","plink":"https://dxsummer.gitee.io/posts/91d5787c/"},{"title":"Step4 C控制语句：循环","date":"2020-06-03T04:33:48.000Z","date_formatted":{"ll":"2020年6月3日","L":"2020/06/03","MM-DD":"06-03"},"updated":"2020-06-08T01:44:32.000Z","content":"C控制语句：循环本章介绍以下内容：\n关键字：for、while、do while\n运算符：&lt;、&gt;、&gt;=、&lt;=、!=、==、+=、*=、-=、/=、%=\n函数：fabs()\nC语言有3种循环：for、while、do while\n使用关系运算符构建控制循环的表达式\n其他运算符\n循环常用的数组\n编写有返回值的函数\n大多数人都希望自己是体格强健、天资聪颖、多才多艺的能人。虽然有时事与愿违，但至少我们用 C能写出这样的程序。诀窍是控制程序流。对于计算机科学（是研究计算机，不是用计算机做研究）而言，一门语言应该提供以下3种形式的程序流：\n执行语句序列；\n如果满足某些条件就重复执行语句序列（循环通过测试选择执行哪一个语句序列（分支）。\n读者对第一种形式应该很熟悉，前面学过的程序中大部分都是由语句序列组成。while循环属于第二种形式。本章将详细讲解while循环和其他两种循环：for和do while。第三种形式用于在不同的执行方案之间进行选择，让程序更“智能”，且极大地提高了计算机的用途。不过，要等到下一章才介绍这部分的内容。本章还将介绍数组，可以把新学的知识应用在数组上。另外，本章还将继续介绍函数的相关内容。首先，我们从while循环开始学习。\n再探while循环经过上一章的学习，读者已经熟悉了 while 循环。这里，我们用一个程序来回顾一下，程序清单 6.1根据用户从键盘输入的整数进行求和。程序利用了scanf()的返回值来结束循环。\n程序清单6.1 summing.c程序\n1234567891011121314151617181920/* summing.c -- 根据用户键入的整数求和 */#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;　　　　 /* 把sum初始化为0　*/    int status;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    status=scanf(\"%ld\",&amp;num);    while (status == 1)　　/* == 的意思是“等于”　*/    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        status=scanf(\"%ld\",&amp;num);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;该程序使用long类型以储存更大的整数。尽管C编译器会把0自动转换为合适的类型，但是为了保持程序的一致性，我们把sum初始化为0L（long类型的0），而不是0（int类型的0）。\n该程序的运行示例如下：\n123456Please　enter　an　integer　to　be　summed　(q　to　quit):　44Please　enter　next　integer　(q　to　quit):　33Please　enter　next　integer　(q　to　quit):　88Please　enter　next　integer　(q　to　quit):　121Please　enter　next　integer　(q　to　quit):　qThose　integers　sum　to　286.程序注释先看while循环，该循环的测试条件是如下表达式：\n1status==1==运算符是C的相等运算符（equality operator），该表达式判断status是否等于1。不要把status== 1与status = 1混淆，后者是把1赋给status。根据测试条件status == 1，只要status等于1，循环就会重复。每次循环，num的当前值都被加到sum上，这样sum的值始终是当前整数之和。当status的值不为1时，循环结束。然后程序打印sum的最终值。\n要让程序正常运行，每次循环都要获取num的一个新值，并重置status。程序利用scanf()的两个不同的特性来完成。首先，使用scanf()读取num的一个新值；然后，检查scanf()的返回值判断是否成功获取值。第4章中介绍过，scanf()返回成功读取项的数量。如果scanf()成功读取一个整数，就把该数存入num并返回1，随后返回值将被赋给status（注意，用户输入的值储存在num中，不是status中）。这样做同时更新了num和status的值，while循环进入下一次迭代。如果用户输入的不是数字（如， q），scanf()会读取失败并返回0。此时，status的值就是0，循环结束。因为输入的字符q不是数字，所以它会被放回输入队列中（实际上，不仅仅是 q，任何非数值的数据都会导致循环终止，但是提示用户输入q退出程序比提示用户输入一个非数字字符要简单）。\n如果 scanf()在转换值之前出了问题（例如，检测到文件结尾或遇到硬件问题），会返回一个特殊值EOF（其值通常被定义为-1）。这个值也会引起循环终止。\n如何告诉循环何时停止？该程序利用 scanf()的双重特性避免了在循环中交互输入时的这个棘手的问题。例如，假设scanf()没有返回值，那么每次循环只会改变num的值。虽然可以使用num的值来结束循环，比如把num &gt; 0（num大于0）或num ！= 0（num不等于0）作为测试条件，但是这样用户就不能输入某些值，如-3或0。也可以在循环中添加代码，例如每次循环时询问用户“是否继续循环？&lt;y/n&gt;”，然后判断用户是否输入y。这个方法有些笨拙，而且还减慢了输入的速度。使用scanf()的返回值，轻松地避免了这些问题。\n现在，我们来看看该程序的结构。总结如下：\n把sum初始化为0\n\n提示用户输入数据\n\n读取用户输入的数据\n\n当输入的数据为整数时，\n\n输入添加给sum，\n\n提示用户进行输入，\n\n然后读取下一个输入\n\n输入完成后，打印sum的值\n\n顺带一提，这叫作伪代码（pseudocode），是一种用简单的句子表示程序思路的方法，它与计算机语言的形式相对应。伪代码有助于设计程序的逻辑。确定程序的逻辑无误之后，再把伪代码翻译成实际的编程代码。使用伪代码的好处之一是，可以把注意力集中在程序的组织和逻辑上，不用在设计程序时还要分心如何用编程语言来表达自己的想法。例如，可以用缩进来代表一块代码，不用考虑C的语法要用花括号把这部分代码括起来。\n总之，因为while循环是入口条件循环，程序在进入循环体之前必须获取输入的数据并检查status的值，所以在 while 前面要有一个 scanf()。要让循环继续执行，在循环内需要一个读取数据的语句，这样程序才能获取下一个status的值，所以在while循环末尾还要有一个scanf()，它为下一次迭代做好了准备。可以把下面的伪代码作为while循环的标准格式：\n获得第1个用于测试的值\n当测试为真时\n处理值\n获取下一个值\nC风格读取循环根据伪代码的设计思路，程序清单6.1可以用Pascal、BASIC或FORTRAN来编写。但是C更为简洁，下面的代码：\n1234567891011status=scanf(\"%ld\",　&amp;num);while(status　==　1)&#123;/* 循环行为 */status　=　scanf(\"%ld\",　&amp;num);&#125;可以用这些代码替换：while(scanf(\"%ld\",&amp;num)==1)&#123;/*循环行为*/&#125;第二种形式同时使用scanf()的两种不同的特性。首先，如果函数调用成功，scanf()会把一个值存入num。然后，利用scanf()的返回值（0或1，不是num的值）控制while循环。因为每次迭代都会判断循环的条件，所以每次迭代都要调用scanf()读取新的num值来做判断。换句话说，C的语法特性让你可以用下面的精简版本替换标准版本：\n当获取值和判断值都成功\n处理该值\n接下来，我们正式地学习while语句。\nwhile语句while循环的通用形式如下：\n12while(expression)statementstatement部分可以是以分号结尾的简单语句，也可以是用花括号括起来的复合语句。\n到目前为止，程序示例中的expression部分都使用关系表达式。也就是说，expression是值之间的比较，可以使用任何表达式。如果expression为真（或者更一般地说，非零），执行 statement部分一次，然后再次判断expression。在expression为假（0）之前，循环的判断和执行一直重复进行。每次循环都被称为一次迭代（iteration），如图6.1所示。\n\n终止while循环while循环有一点非常重要：在构建while循环时，必须让测试表达式的值有变化，表达式最终要为假。否则，循环就不会终止（实际上，可以使用break和if语句来终止循环，但是你尚未学到）。考虑下面的例子：\n123index=1;while(index&lt;5)printf(\"Good　morning!\\n\");上面的程序段将打印无数次Good　morning!。为什么？因为循环中index的值一直都是原来的值1，不曾变过。\n现在，考虑下面的程序段：\n123index=1;while(--index&lt;5)printf(\"Good　morning!\\n\");这段程序也好不到哪里去。虽然改变了index的值，但是改错了！不过，这个版本至少在index减少到其类型到可容纳的最小负值并变成最大正值时会终止循环（第3章3.4.2节中的toobig.c程序解释过，最大正值加1一般会得到一个负值；类似地，最小负值减1一般会得到最大正值）。\n何时终止循环要明确一点：只有在对测试条件求值时，才决定是终止还是继续循环。例如，考虑程序清单6.2中的程序。\n程序清单6.2 when.c程序\n123456789101112131415// when.c -- 何时退出循环#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=5;    while (n&lt;7)　　　　　　　　　　　// 第7行    &#123;        printf(\"n=%d\\n\",n);        n++;　　　　　　　　　　　　　 // 第10行        printf(\"Now n=%d\\n\", n); // 第11行    &#125;    printf(\"The　loop　has　finished.\\n\");    return　0;&#125;运行程序清单6.2，输出如下：\n12345n = 5Now n = 6n = 6Now n = 7The loop has finished.在第2次循环时，变量n在第10行首次获得值7。但是，此时程序并未退出，它结束本次循环（第11行），并在对第7行的测试条件求值时才退出循环（变量n在第1次判断时为5，第2次判断时为6）。\nwhile：入口条件循环while循环是使用入口条件的有条件循环。所谓“有条件”指的是语句部分的执行取决于测试表达式描述的条件，如(index &lt; 5)。该表达式是一个入口条件（entry condition），因为必须满足条件才能进入循环体。在下面的情况中，就不会进入循环体，因为条件一开始就为假：\n123index=10;while(index++&lt;5)printf(\"Have　a　fair　day　or　better.\\n\");把第1行改为：\n1index = 3;就可以运行这个循环了。\n语法要点使用while时，要牢记一点：只有在测试条件后面的单独语句（简单语句或复合语句）才是循环部分。程序清单6.3演示了忽略这点的后果。缩进是为了让读者阅读方便，不是计算机的要求。\n1234567891011121314程序清单6.3 while1.c程序/* while1.c -- 注意花括号的使用 *//* 糟糕的代码创建了一个无限循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=0;    while(n&lt;3)        printf(\"n　is　%d\\n\",　n);    n++;    printf(\"That's　all　this　program　does\\n\");    return　0;&#125;该程序的输出如下：\n123456n　is　0n　is　0n　is　0n　is　0n　is　0...屏幕上会一直输出以上内容，除非强行关闭这个程序。\n虽然程序中缩进了n++;这条语句，但是并未把它和上一条语句括在花括号内。因此，只有直接跟在测试条件后面的一条语句是循环的一部分。变量n的值不会改变，条件n&lt;3一直为真。该循环会一直打印n is 0，除非强行关闭程序。这是一个无限循环（infinite loop）的例子，没有外部干涉就不会退出。\n记住，即使while语句本身使用复合语句，在语句构成上，它也是一条单独的语句。该语句从while开始执行，到第1个分号结束。在使用了复合语句的情况下，到右花括号结束。\n要注意放置分号的位置。例如，考虑程序清单6.4。\n123456789101112程序清单6.4 while2.c程序/* while2.c -- 注意分号的位置 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=0;    while(n++&lt;3);　　　　　 /* 第7行 */    printf(\"n is %d\\n\", n); /* 第8行 */    printf(\"That's　all　this　program　does.\\n\");    return　0;&#125;该程序的输出如下：\n12n is 4That's all this program does.如前所述，循环在执行完测试条件后面的第 1 条语句（简单语句或复合语句）后进入下一轮迭代，直到测试条件为假才会结束。该程序中第7行的测试条件后面直接跟着一个分号，循环在此进入下一轮迭代，因为单独一个分号被视为一条语句。虽然n的值在每次循环时都递增1，但是第8行的语句不是循环的一部分，因此只会打印一次循环结束后的n值。\n在该例中，测试条件后面的单独分号是空语句（null statement），它什么也不做。在C语言中，单独的分号表示空语句。有时，程序员会故意使用带空语句的while语句，因为所有的任务都在测试条件中完成了，不需要在循环体中做什么。例如，假设你想跳过输入到第1个非空白字符或数字，可以这样写：\n12while(scanf(\"%d\",&amp;num)==1); /* 跳过整数输入 */只要scanf()读取一个整数，就会返回1，循环继续执行。注意，为了提高代码的可读性，应该让这个分号独占一行，不要直接把它放在测试表达式同行。这样做一方面让读者更容易看到空语句，一方面也提醒自己和读者空语句是有意而为之。处理这种情况更好的方法是使用下一章介绍的continue语句。\n用关系运算符和表达式比较大小while循环经常依赖测试表达式作比较，这样的表达式被称为关系表达式（relational expression），出现在关系表达式中间的运算符叫做关系运算符（relational operator）。前面的示例中已经用过一些关系运算符，表 6.1 列出了 C 语言的所有关系运算符。该表也涵盖了所有的数值关系（数字之间的关系再复杂也没有人与人之间的关系复杂）。\n\n关系运算符常用于构造while语句和其他C语句（稍后讨论）中用到的关系表达式。这些语句都会检查关系表达式为真还是为假。下面有3个互不相关的while语句，其中都包含关系表达式。\n123456789101112while(number&lt;6)&#123;    printf(\"Your　number　is　too　small.\\n\");    scanf(\"%d\",　&amp;number);&#125;while(ch!='$')&#123;    count++;    scanf(\"%c\",　&amp;ch);&#125;while(scanf(\"%f\",&amp;num)==1)sum=sum+num;注意，第2个while语句的关系表达式还可用于比较字符。比较时使用的是机器字符码（假定为ASCII）。但是，不能用关系运算符比较字符串。第11章将介绍如何比较字符串。\n虽然关系运算符也可用来比较浮点数，但是要注意：比较浮点数时，尽量只使用&lt;和&gt;。因为浮点数的舍入误差会导致在逻辑上应该相等的两数却不相等。例如，3乘以1/3的积是1.0。如果用把1/3表示成小数点后面6位数字，乘积则是.999999，不等于1。使用fabs()函数（声明在math.h头文件中）可以方便地比较浮点数，该函数返回一个浮点值的绝对值（即，没有代数符号的值）。\n例如，可以用类似程序清单6.5的方法来判断一个数是否接近预期结果。\n12345678910111213141516171819程序清单6.5 cmpflt.c程序// cmpflt.c -- 浮点数比较#include　&lt;math.h&gt;#include　&lt;stdio.h&gt;int　main(void)&#123;    const　double　ANSWER　=　3.14159;    double　response;    printf(\"What　is　the　value　of　pi?\\n\");    scanf(\"%lf\",&amp;response);    while(fabs(response-ANSWER)&gt;0.0001)    &#123;        printf(\"Try　again!\\n\");        scanf(\"%lf\",&amp;response);    &#125;    printf(\"Close　enough!\\n\");    return　0;&#125;循环会一直提示用户继续输入，除非用户输入的值与正确值之间相差0.0001：\n12345What　is　the　value　of　pi?3.14Try　again!3.1416Close enough!什么是真这是一个古老的问题，但是对C而言还不算难。在C中，表达式一定有一个值，关系表达式也不例外。程序清单6.6中的程序用于打印两个关系表达式的值，一个为真，一个为假。\n程序清单6.6 t_and_f.c程序\n/* t_and_f.c – C中的真和假的值 */\n#include　&lt;stdio.h&gt;\nint　main(void)\n{\nint　true_val,　false_val;\ntrue_val = (10 &gt; 2);　　　　// 关系为真的值\nfalse_val = (10 == 2); // 关系为假的值\nprintf(“true　=　%d;　false　=　%d　\\n”,　true_val,　false_val);\nreturn　0;\n}\n程序清单6.6把两个关系表达式的值分别赋给两个变量，即把表达式为真的值赋给true_val，表达式为假的值赋给false_val。运行该程序后输出如下：\ntrue = 1; false = 0\n原来如此！对C而言，表达式为真的值是1，表达式为假的值是0。一些C程序使用下面的循环结构，由于1为真，所以循环会一直进行。\nwhile　(1)\n{\n…\n}\n其他真值既然1或0可以作为while语句的测试表达式，是否还可以使用其他数字？如果可以，会发生什么？我们用程序清单6.7来做个实验。\n12345678910111213141516程序清单6.7 truth.c程序// truth.c -- 哪些值为真#include　&lt;stdio.h&gt;int　main(void)&#123;    int n=3;    while(n)        printf(\"%2d　is　true\\n\",　n--);    printf(\"%2d　is　false\\n\",　n);    n=-3;    while(n)        printf(\"%2d　is　true\\n\",　n++);    printf(\"%2d　is　false\\n\",　n);    return　0;&#125;该程序的输出如下：\n123456783　is　true2　is　true1　is　true0　is　false-3　is　true-2　is　true-1　is　true0　is　false执行第1个循环时，n分别是3、2、1，当n等于0时，第1个循环结束。与此类似，执行第2个循环时，n分别是-3、-2和-1，当n等于0时，第2个循环结束。一般而言，所有的非零值都视为真，只有0被视为假。在C中，真的概念还真宽！\n也可以说，只要测试条件的值为非零，就会执行 while 循环。这是从数值方面而不是从真/假方面来看测试条件。要牢记：关系表达式为真，求值得1；关系表达式为假，求值得0。因此，这些表达式实际上相当于数值。\n许多C程序员都会很好地利用测试条件的这一特性。例如，用while (goats)替换while (goats !=0)，因为表达式goats != 0和goats都只有在goats的值为0时才为0或假。第1种形式（while (goats != 0)）对初学者而言可能比较清楚，但是第2种形式（while (goats)）才是C程序员最常用的。要想成为一名C程序员，应该多熟悉while (goats)这种形式。\n真值的问题C对真的概念约束太少会带来一些麻烦。例如，我们稍微修改一下程序清单6.1，修改后的程序如程序清单6.8所示。\n123456789101112131415161718192021程序清单6.8 trouble.c程序// trouble.c -- 误用=会导致无限循环#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;    int status;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    status=scanf(\"%ld\",&amp;num);    while(status=1)    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        status　=　scanf(\"%ld\",　&amp;num);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;运行该程序，其输出如下：\n12345678Please　enter　an　integer　to　be　summed　(q　to　quit):　20Please　enter　next　integer　(q　to　quit):　5Please　enter　next　integer　(q　to　quit):　30Please　enter　next　integer　(q　to　quit):　qPlease　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):Please　enter　next　integer　(q　to　quit):（„„屏幕上会一直显示最后的提示内容，除非强行关闭程序。也许你根本不想运行这个示例。）\n这个麻烦的程序示例改动了while循环的测试条件，把status == 1替换成status = 1。后者是一个赋值表达式语句，所以 status 的值为 1。而且，整个赋值表达式的值就是赋值运算符左侧的值，所以status = 1的值也是1。这里，while (status = 1)实际上相当于while (1)，也就是说，循环不会退出。虽然用户输入q，status被设置为0，但是循环的测试条件把status又重置为1，进入了下一次迭代。\n读者可能不太理解，程序的循环一直运行着，用户在输入q后完全没机会继续输入。如果scanf()读取指定形式的输入失败，就把无法读取的输入留在输入队列中，供下次读取。当scanf()把q作为整数读取时失败了，它把 q 留下。在下次循环时，scanf()从上次读取失败的地方（q）开始读取，scanf()把q作为整数读取，又失败了。因此，这样修改后不仅创建了一个无限循环，还创建了一个无限失败的循环，真让人沮丧。好在计算机觉察不出来。对计算机而言，无限地执行这些愚蠢的指令比成功预测未来10年的股市行情没什么两样。\n不要在本应使用==的地方使用=。一些计算机语言（如，BASIC）用相同的符号表示赋值运算符和关系相等运算符，但是这两个运算符完全不同（见图 6.2）。赋值运算符把一个值赋给它左侧的变量；而关系相等运算符检查它左侧和右侧的值是否相等，不会改变左侧变量的值（如果左侧是一个变量）。\n\n示例如下：\n12canoes=5\t\t←把5赋给canoescanoes==5\t\t←检查canoes的值是否为5要注意使用正确的运算符。编译器不会检查出你使用了错误的形式，得出也不是预期的结果（误用=的人实在太多了，以至于现在大多数编译器都会给出警告，提醒用户是否要这样做）。如果待比较的一个值是常量，可以把该常量放在左侧有助于编译器捕获错误：\n125=canoes\t←语法错误5==canoes\t←检查canoes的值是否为5可以这样做是因为C语言不允许给常量赋值，编译器会把赋值运算符的这种用法作为语法错误标记出来。许多经验丰富的程序员在构建比较是否相等的表达式时，都习惯把常量放在左侧。\n总之，关系运算符用于构成关系表达式。关系表达式为真时值为1，为假时值为0。通常用关系表达式作为测试条件的语句（如while和if）可以使用任何表达式作为测试条件，非零为真，零为假。\n新的_Bool类型在C语言中，一直用int类型的变量表示真/假值。C99专门针对这种类型的变量新增了_Bool类型。该类型是以英国数学家George Boole的名字命名的，他开发了用代数表示逻辑和解决逻辑问题。在编程中，表示真或假的变量被称为布尔变量（Boolean variable），所以_Bool是C语言中布尔变量的类型名。_Bool类型的变量只能储存1（真）或0（假）。如果把其他非零数值赋给_Bool类型的变量，该变量会被设置为1。这反映了C把所有的非零值都视为真。\n程序清单6.9修改了程序清单6.8中的测试条件，把int类型的变量status替换为_Bool类型的变量input_is_good。给布尔变量取一个能表示真或假值的变量名是一种常见的做法。\n123456789101112131415161718192021程序清单6.9 boolean.c程序// boolean.c -- 使用_Bool类型的变量 variable#include　&lt;stdio.h&gt;int　main(void)&#123;    long num;    long sum=0L;    _Bool input_is_good;    printf(\"Please　enter　an　integer　to　be　summed　\");    printf(\"(q　to　quit):　\");    input_is_good=(scanf(\"%ld\",&amp;num)==1);    while(input_is_good)    &#123;        sum=sum+num;        printf(\"Please　enter　next　integer　(q　to　quit):　\");        input_is_good=(scanf(\"%ld\",&amp;num)==1);    &#125;    printf(\"Those　integers　sum　to　%ld.\\n\",　sum);    return　0;&#125;注意程序中把比较的结果赋值给_Bool类型的变量input_is_good：\n1input_is_good=(scanf(\"%ld\", &amp;num) == 1);这样做没问题，因为==运算符返回的值不是1就是0。顺带一提，从优先级方面考虑的话，并不需要用圆括号把scanf(&quot;%ld&quot;,&amp;num)==1括起来。但是，这样做可以提高代码可读性。还要注意，如何为变量命名才能让while循环的测试简单易懂：\n1while (input_is_good)C99提供了stdbool.h头文件，该头文件让bool成为_Bool的别名，而且还把true和false分别定义为1和0的符号常量。包含该头文件后，写出的代码可以与C++兼容，因为C++把bool、true和false定义为关键字。\n如果系统不支持_Bool类型，导致无法运行该程序，可以把_Bool替换成int即可。\n优先级和关系运算符关系运算符的优先级比算术运算符低（包括+和-），比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。\n关系运算符比赋值运算符的优先级高，因此，x_bigger=x&gt;y;相当于x_bigger=(x &gt; y);。\n关系运算符之间有两种不同的优先级。\n高优先级组： &lt;&lt;= &gt;&gt;=\n低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：\nex!=wye==zee与(ex != wye) == zee相同\n首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。\n表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算符”中列出了全部运算符的完整优先级表。\n\n小结：while语句\n关键字：while\n一般注解：\nwhile语句创建了一个循环，重复执行直到测试表达式为假或0。while语句是一种入口条件循环，也就是说，在执行多次循环之前已决定是否执行循环。因此，循环有可能不被执行。循环体可以是简单语句，也可以是复合语句。\n形式：\n12while(expression)statement在expression部分为假或0之前，重复执行statement部分。\n示例：\n1234567while(n++&lt;100)printf(\" %d %d\\n\",n,2*n+1); // 简单语句while(fargo&lt;1000)&#123; // 复合语句    fargo=fargo+step;    step=2*step;&#125;小结：关系运算符和表达式\n关系运算符：\n每个关系运算符都把它左侧的值和右侧的值进行比较。\n123456&lt;　　　　　小于&lt;=　　　　 小于或等于==　　　　 等于&gt;=　　　　 大于或等于&gt;　　　　　大于!=　　　　 不等于关系表达式：\n简单的关系表达式由关系运算符及其运算对象组成。如果关系为真，关系表达式的值为 1；如果关系为假，关系表达式的值为0。\n示例：\n5 &gt; 2为真，关系表达式的值为1\n(2 + a) == a 为假，关系表达式的值为0\n不确定循环和计数循环一些while循环是不确定循环（indefinite loop）。所谓不确定循环，指在测试表达式为假之前，预先不知道要执行多少次循环。例如，程序清单6.1通过与用户交互获得数据来计算整数之和。我们事先并不知道用户会输入什么整数。另外，还有一类是计数循环（counting loop）。这类循环在执行循环之前就知道要重复执行多少次。程序清单6.10就是一个简单的计数循环。\n123456789101112131415程序清单6.10 sweetie1.c程序// sweetie1.c -- 一个计数循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const　int　NUMBER　=　22;    int count = 1;　　　　　　　　　　　　　// 初始化    while(count&lt;=NUMBER)　　　　　　　 // 测试    &#123;        printf(\"Be my Valentine!\\n\");　 // 行为        count++;　　　　　　　　　　　　　　// 更新计数    &#125;    return　0;&#125;虽然程序清单6.10运行情况良好，但是定义循环的行为并未组织在一起，程序的编排并不是很理想。我们来仔细分析一下。\n在创建一个重复执行固定次数的循环中涉及了3个行为：\n必须初始化计数器；\n\n计数器与有限的值作比较；\n\n每次循环时递增计数器。\n\nwhile循环的测试条件执行比较，递增运算符执行递增。程序清单6.10中，递增发生在循环的末尾，这可以防止不小心漏掉递增。因此，这样做比将测试和更新组合放在一起（即使用count++ &lt;= NUMBER）要好，但是计数器的初始化放在循环外，就有可能忘记初始化。实践告诉我们可能会发生的事情终究会发生，所以我们来学习另一种控制语句，可以避免这些问题。\nfor循环for循环把上述3个行为（初始化、测试和更新）组合在一处。程序清单6.11使用for循环修改了程序清单6.10的程序。\n123456789101112程序清单6.11 sweetie2.c程序// sweetie2.c -- 使用for循环的计数循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const int NUMBER=22;    int count;    for(count=1;count&lt;=NUMBER;count++)        printf(\"Be　my　Valentine!\\n\");    return　0;&#125;关键字for后面的圆括号中有3个表达式，分别用两个分号隔开。\n第1个表达式是初始化，只会在for循环开始时执行一次。\n第 2 个表达式是测试条件，在执行循环之前对表达式求值。如果表达式为假（本例中，count大于NUMBER时），循环结束。\n第3个表达式执行更新，在每次循环结束时求值。程序清单6.10用这个表达式递增count 的值，更新计数。\n完整的for语句还包括后面的简单语句或复合语句。for圆括号中的表达式也叫做控制表达式，它们都是完整表达式，所以每个表达式的副作用（如，递增变量）都发生在对下一个表达式求值之前。图6.3演示了for循环的结构。\n\n程序清单6.12 for_cube.c程序\n1234567891011/* for_cube.c -- 使用for循环创建一个立方表 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int num;    printf(\"n　　n　cubed\\n\");    for(num=1;num&lt;=6;num++)        printf(\"%5d %5d\\n\",num,num*num*num);    return　0;&#125;程序清单6.12打印整数1～6及其对应的立方，该程序的输出如下：\n1234567n　　　 n　cubed1　　　　　　　12　　　　　　　83　　　　　　 274　　　　　　 645　　　　　 1256　　　　　 216for循环的第1行包含了循环所需的所有信息：num的初值，num的终值和每次循环num的增量。\n利用for的灵活性虽然for循环看上去和FORTRAN的DO循环、Pascal的FOR循环、BASIC的FOR...NEXT循环类似，但是for循环比这些循环灵活。这些灵活性源于如何使用for循环中的3个表达式。以前面程序示例中的for循环为例，第1个表达式给计数器赋初值，第2个表达式表示计数器的范围，第3个表达式递增计数器。这样使用for循环确实很像其他语言的循环。除此之外，for循环还有其他9种用法。\n可以使用递减运算符来递减计数器：\n1234567891011/* for_down.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int secs;    for(secs=5;secs&gt;0;secs--)        printf(\"%d　seconds!\\n\",secs);    printf(\"We　have　ignition!\\n\");    return　0;&#125;该程序输出如下：\n1234565 seconds!4 seconds!3 seconds!2 seconds!1 seconds!We have ignition!可以让计数器递增2、10等：\n12345678910/* for_13s.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int n; // 从2开始，每次递增13    for　(n=2;n&lt;60;n=n+13)        printf(\"%d　\\n\",　n);    return　0;&#125;每次循环n递增13，程序的输出如下：\n12345215284154可以用字符代替数字计数：\n12345678910/* for_char.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    char ch;    for(ch='a';ch&lt;='z';ch++)    printf(\"The　ASCII　value　for　%c　is　%d.\\n\",　ch,　ch);    return　0;&#125;该程序假定系统用ASCII码表示字符。由于篇幅有限，省略了大部分输出：\n123456The　ASCII　value　for　a　is　97.The　ASCII　value　for　b　is　98....The　ASCII　value　for　x　is　120.The　ASCII　value　for　y　is　121.The　ASCII　value　for　z　is　122.该程序能正常运行是因为字符在内部是以整数形式储存的，因此该循环实际上仍是用整数来计数。\n除了测试迭代次数外，还可以测试其他条件。在for_cube程序中，可以把：\n1for(num=1;num&lt;=6;num++)替换成：\n1for(num=1;num*num*num&lt;=216;num++)如果与控制循环次数相比，你更关心限制立方的大小，就可以使用这样的测试条件。\n可以让递增的量几何增长，而不是算术增长。也就是说，每次都乘上而不是加上一个固定的量：\n12345678910/* for_geo.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    double　debt;    for (debt = 100.0; debt &lt; 150.0; debt = debt * 1.1)\t    printf(\"Your　debt　is　now　$%.2f.\\n\",　debt);    return　0;&#125;该程序中，每次循环都把debt乘以1.1，即debt的值每次都增加10%，其输出如下：\n12345Your　debt　is　now　$100.00.Your　debt　is　now　$110.00.Your　debt　is　now　$121.00.Your　debt　is　now　$133.10.Your　debt　is　now　$146.41.第3个表达式可以使用任意合法的表达式。无论是什么表达式，每次迭代都会更新该表达式的值。\n1234567891011/* for_wild.c */#include　&lt;stdio.h&gt;int main(void)&#123;    int x;    int y=55;    for(x=1;y&lt;=75;y=(++x*5)+50)        printf(\"%10d　%10d\\n\",　x,　y);    return　0;&#125;该循环打印x的值和表达式++x * 5 + 50的值，程序的输出如下：\n123451　　　　　 552　　　　　 603　　　　　 654　　　　　 705　　　　　 75注意，测试涉及y，而不是x。for循环中的3个表达式可以是不同的变量（注意，虽然该例可以正常运行，但是编程风格不太好。如果不在更新部分加入代数计算，程序会更加清楚）。\n可以省略一个或多个表达式（但是不能省略分号），只要在循环中包含能结束循环的语句即可。\n123456789101112/* for_none.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int ans,n;    ans=2;    for(n=3;ans&lt;=25;)\t\tans=ans*n;    printf(\"n　=　%d;　ans　=　%d.\\n\",　n,　ans);    return　0;&#125;该程序的输出如下：\n1n=3;ans=54.该循环保持n的值为3。变量ans开始的值为2，然后递增到6和18，最终是54（18比25小，所以for循环进入下一次迭代，18乘以3得54）。顺带一提，省略第2个表达式被视为真，所以下面的循环会一直运行：\n12for　(;　;　)printf(\"I　want　some　action\\n\");第1个表达式不一定是给变量赋初值，也可以使用printf()。记住，在执行循环的其他部分之前，只对第1个表达式求值一次或执行一次。\n1234567891011/* for_show.c */#include　&lt;stdio.h&gt;int　main(void)&#123;    int num　=　0;    for(printf(\"Keep　entering　numbers!\\n\");num!=6;)  \t  scanf(\"%d\",　&amp;num);    printf(\"That's　the　one　I　want!\\n\");    return　0;&#125;该程序打印第1行的句子一次，在用户输入6之前不断接受数字：\n123456Keep　entering　numbers!3586That's the one I want!循环体中的行为可以改变循环头中的表达式。例如，假设创建了下面的循环：\n1for(n=1;n&lt;10000;n=n+delta)如果程序经过几次迭代后发现delta太小或太大，循环中的if语句（详见第7章）可以改变delta的大小。在交互式程序中，用户可以在循环运行时才改变 delta 的值。这样做也有危险的一面，例如，把delta设置为0就没用了。\n总而言之，可以自己决定如何使用for循环头中的表达式，这使得在执行固定次数的循环外，还可以做更多的事情。接下来，我们将简要讨论一些运算符，使for循环更加有用。\n小结：for语句\n关键字：for\n一般注解：\nfor语句使用3个表达式控制循环过程，分别用分号隔开。initialize表达式在执行for语句之前只执行一次；然后对test表达式求值，如果表达式为真（或非零），执行循环一次；接着对update表达式求值，并再次检查test表达式。for语句是一种入口条件循环，即在执行循环之前就决定了是否执行循环。因此，for循环可能一次都不执行。statement部分可以是一条简单语句或复合语句。\n形式：\n12for(initialize;test;update　)statement在test为假或0之前，重复执行statement部分。\n示例：\n12for(n=0;n&lt;10;n++)printf(\" %d %d\\n\", n, 2 * n + 1);其他赋值运算符：+=、-=、*=、/=、%=C有许多赋值运算符。最基本、最常用的是=，它把右侧表达式的值赋给左侧的变量。其他赋值运算符都用于更新变量，其用法都是左侧是一个变量名，右侧是一个表达式。赋给变量的新值是根据右侧表达式的值调整后的值。确切的调整方案取决于具体的运算符。例如：\n12345scores+=20\t\t与\t\tscores=scores+20\t\t相同dimes-=2\t\t与\t\tdimes=dimes-2\t\t\t相同bunnies*=2\t\t与\t\tbunnies=bunnies*2\t\t相同time/=2.73\t\t与\t\ttime=time/2.73\t\t\t相同reduce%=3\t\t与\t\treduce=reduce%3\t\t\t相同上述所列的运算符右侧都使用了简单的数，还可以使用更复杂的表达式，例如：\n1x*=3*y+12\t与\tx=x*(3*y+12) \t相同以上提到的赋值运算符与=的优先级相同，即比+或*优先级低。上面最后一个例子也反映了赋值运算符的优先级，3 *y先与12相加，再把计算结果与x相乘，最后再把乘积赋给x。\n并非一定要使用这些组合形式的赋值运算符。但是，它们让代码更紧凑，而且与一般形式相比，组合形式的赋值运算符生成的机器代码更高效。当需要在for循环中塞进一些复杂的表达式时，这些组合的赋值运算符特别有用。\n逗号运算符逗号运算符扩展了for循环的灵活性，以便在循环头中包含更多的表达式。例如，程序清单6.13演示了一个打印一类邮件资费（first-class postage rate）的程序（在撰写本书时，邮资为首重40美分/盎司，续重20美分/盎司，可以在互联网上查看当前邮资）。\n程序清单6.13 postage.c程序\n12345678910111213// postage.c -- 一类邮资#include　&lt;stdio.h&gt;int　main(void)&#123;const int FIRST_OZ = 46;　　// 2013邮资const int NEXT_OZ = 20;　　 // 2013邮资int ounces,　cost;printf(\"　ounces　 cost\\n\");for(ounces=1,cost=FIRST_OZ;ounces&lt;=16;ounces++,cost+=NEXT_OZ)\tprintf(\"%5d　　$%4.2f\\n\",　ounces,　cost　/　100.0);return　0;&#125;该程序的前5行输出如下：\n12345ounces　\tcost1　　　　 $0.462　　　　 $0.663　　　　 $0.864　　　　 $1.06该程序在初始化表达式和更新表达式中使用了逗号运算符。初始化表达式中的逗号使ounces和cost都进行了初始化，更新表达式中的逗号使每次迭代ounces递增1、cost递增20（NEXT_Z的值是20）。绝大多数计算都在for循环头中进行（见图6.4）。\n\n逗号运算符并不局限于在for循环中使用，但是这是它最常用的地方。逗号运算符有两个其他性质。首先，它保证了被它分隔的表达式从左往右求值（换言之，逗号是一个序列点，所以逗号左侧项的所有副作用都在程序执行逗号右侧项之前发生）。因此，ounces在cost之前被初始化。在该例中，顺序并不重要，但是如果cost的表达式中包含了ounces时，顺序就很重要。例如，假设有下面的表达式：\n1ounces++,cost=ounces*FIRST_OZ在该表达式中，先递增ounce，然后在第2个子表达式中使用ounce的新值。作为序列点的逗号保证了左侧子表达式的副作用在对右侧子表达式求值之前发生。\n其次，整个逗号表达式的值是右侧项的值。例如，下面语句\n1x=(y=3,(z=++y+2)+5);的效果是：先把3赋给y，递增y为4，然后把4加2之和（6）赋给z，接着加上5，最后把结果11赋给 x。至于为什么有人编写这样的代码，在此不做评价。另一方面，假设在写数字时不小心输入了逗号：\n1houseprice=249,500;这不是语法错误，C 编译器会将其解释为一个逗号表达式，即 houseprice = 249 是逗号左侧的子表达式，500 是右侧的子表达式。因此，整个逗号表达式的值是逗号右侧表达式的值，而且左侧的赋值表达式把249赋给变量houseprice。因此，这与下面代码的效果相同：\n1houseprice　=　249;500;记住，任何表达式后面加上一个分号就成了表达式语句。所以，500;也是一条语句，但是什么也不做。\n另外，下面的语句\n1houseprice &#x3D; (249,500);赋给houseprice的值是逗号右侧子表达式的值，即500。\n逗号也可用作分隔符。在下面语句中的逗号都是分隔符，不是逗号运算符：\n12char ch, date;printf(\"%d %d\\n\", chimps, chumps);小结：新的运算符\n赋值运算符：\n下面的运算符用右侧的值，根据指定的操作更新左侧的变量：\n12345+=\t\t\t把右侧的值加到左侧的变量上-=\t\t\t从左侧的变量中减去右侧的值*=\t\t\t把左侧的变量乘以右侧的值/=\t\t\t把左侧的变量除以右侧的值%=\t\t\t左侧变量除以右侧值得到的余数示例：\n1rabbits*=1.6;\t与\trabbits=rabbits*1.6;\t相同这些组合赋值运算符与普通赋值运算符的优先级相同，都比算术运算符的优先级低。因此，\n1contents*=old_rate+1.2;最终的效果与下面的语句相同：\n1contents = contents * (old_rate + 1.2);逗号运算符：\n逗号运算符把两个表达式连接成一个表达式，并保证最左边的表达式最先求值。逗号运算符通常在for循环头的表达式中用于包含更多的信息。整个逗号表达式的值是逗号右侧表达式的值。\n示例：\n12for(step = 2, fargo = 0;fargo&lt;1000;step*=2)fargo+=step;当Zeno遇到for循环接下来，我们看看 for 循环和逗号运算符如何解决古老的悖论。希腊哲学家 Zeno 曾经提出箭永远不会达到它的目标。首先，他认为箭要到达目标距离的一半，然后再达到剩余距离的一半，然后继续到达剩余距离的一半，这样就无穷无尽。Zeno认为箭的飞行过程有无数个部分，所以要花费无数时间才能结束这一过程。不过，我们怀疑Zeno是自愿甘做靶子才会得出这样的结论。\n我们采用一种定量的方法，假设箭用1秒钟走完一半的路程，然后用1/2秒走完剩余距离的一半，然后用1/4秒再走完剩余距离的一半，等等。可以用下面的无限序列来表示总时间：\n11 + 1/2 + 1/4 + 1/8 + 1/16 +....程序清单6.14中的程序求出了序列前几项的和。变量power_of_two的值分别是1.0、2.0、4.0、8.0等。\n程序清单6.14 zeno.c程序\n1234567891011121314151617/* zeno.c -- 求序列的和 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int t_ct;　　　 // 项计数    double time,power_of_2;    int limit;    printf(\"Enter　the　number　of　terms　you　want:　\");    scanf(\"%d\",&amp;limit);    for(time=0,power_of_2=1,t_ct=1;t_ct&lt;=limit;t_ct++,power_of_2*=2.0)    &#123;        time+=1.0/power_of_2;        printf(\"time=%f　when　terms　=　%d.\\n\",time,t_ct);    &#125;    return　0;&#125;下面是序列前15项的和：\n12345678910111213141516Enter　the　number　of　terms　you　want:　15time　=　1.000000　when　terms　=　1.time　=　1.500000　when　terms　=　2.time　=　1.750000　when　terms　=　3.time　=　1.875000　when　terms　=　4.time　=　1.937500　when　terms　=　5.time　=　1.968750　when　terms　=　6.time　=　1.984375　when　terms　=　7.time　=　1.992188　when　terms　=　8.time　=　1.996094　when　terms　=　9.time　=　1.998047　when　terms　=　10.time　=　1.999023　when　terms　=　11.time　=　1.999512　when　terms　=　12.time　=　1.999756　when　terms　=　13.time　=　1.999878　when　terms　=　14.time　=　1.999939　when　terms　=　15.不难看出，尽管不断添加新的项，但是总和看起来变化不大。就像程序输出显示的那样，数学家的确证明了当项的数目接近无穷时，总和无限接近2.0。假设S表示总和，下面我们用数学的方法来证明一下：\n1S = 1 + 1/2 + 1/4 + 1/8 + ...这里的省略号表示“等等”。把S除以2得：\n1S/2 = 1/2 + 1/4 + 1/8 + 1/16 + ...第1个式子减去第2个式子得：\n1S - S/2 = 1 +1/2 -1/2 + 1/4 -1/4 +...除了第1个值为1，其他的值都是一正一负地成对出现，所以这些项都可以消去。只留下：\n1S/2 = 1然后，两侧同乘以2，得：\n1S = 2从这个示例中得到的启示是，在进行复杂的计算之前，先看看数学上是否有简单的方法可用。\n程序本身是否有需要注意的地方？该程序演示了在表达式中可以使用多个逗号运算符，在for循环中，初始化了time、power_of_2和count。构建完循环条件之后，程序本身就很简短了。\n出口条件循环：do whilewhile循环和for循环都是入口条件循环，即在循环的每次迭代之前检查测试条件，所以有可能根本不执行循环体中的内容。C语言还有出口条件循环（exit-condition loop），即在循环的每次迭代之后检查测试条件，这保证了至少执行循环体中的内容一次。这种循环被称为 do while循环。程序清单6.15 演示了一个示例。\n程序清单6.15 do_while.c程序\n12345678910111213141516/* do_while.c -- 出口条件循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int secret_code=13;    int code_entered;    do    &#123;        printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");        printf(\"please　enter　the　secret　code　number:　\");        scanf(\"%d\",&amp;code_entered);    &#125;while(code_entered!=secret_code);    printf(\"Congratulations!　You　are　cured!\\n\");    return　0;&#125;程序清单6.15在用户输入13之前不断提示用户输入数字。下面是一个运行示例：\n1234567To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　12To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　14To　enter　the　triskaidekaphobia　therapy　club,please　enter　the　secret　code　number:　13Congratulations!　You　are　cured!使用while循环也能写出等价的程序，但是长一些，如程序清单6.16所示。\n程序清单6.16 entry.c程序\n12345678910111213141516171819/* entry.c -- 出口条件循环 */#include　&lt;stdio.h&gt;int　main(void)&#123;    const int secret_code=13;    int code_entered;    printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");    printf(\"please　enter　the　secret　code　number:　\");    scanf(\"%d\",　&amp;code_entered);    while(code_entered!=secret_code)    &#123;        printf(\"To　enter　the　triskaidekaphobia　therapy　club,\\n\");        printf(\"please　enter　the　secret　code　number:　\");        scanf(\"%d\",&amp;code_entered);    &#125;    printf(\"Congratulations!　You　are　cured!\\n\");    return　0;&#125;下面是do while循环的通用形式：\n123dostatementwhile(expression);statement可以是一条简单语句或复合语句。注意，do while循环以分号结尾，其结构见图6.5。\n\ndo while循环在执行完循环体后才执行测试条件，所以至少执行循环体一次；而for循环或while循环都是在执行循环体之前先执行测试条件。do while循环适用于那些至少要迭代一次的循环。例如，下面是一个包含do while循环的密码程序伪代码：\n123456789101112do&#123;提示用户输入密码读取用户输入的密码&#125; while (用户输入的密码不等于密码);避免使用这种形式的do　while结构：do&#123;询问用户是否继续其他行为&#125; while (回答是yes);这样的结构导致用户在回答“no”之后，仍然执行“其他行为”部分，因为测试条件执行晚了。\n小结：do while语句\n关键字：do while\n一般注解：\ndo while 语句创建一个循环，在 expression 为假或 0 之前重复执行循环体中的内容。do while语句是一种出口条件循环，即在执行完循环体后才根据测试条件决定是否再次执行循环。因此，该循环至少必须执行一次。statement部分可是一条简单语句或复合语句。\n形式：\n123dostatementwhile(expression);在test为假或0之前，重复执行statement部分。\n示例：\n123doscanf(\"%d\",&amp;number);while　(number!=20);如何选择循环如何选择使用哪一种循环？首先，确定是需要入口条件循环还是出口条件循环。通常，入口条件循环用得比较多，有几个原因。其一，一般原则是在执行循环之前测试条件比较好。其二，测试放在循环的开头，程序的可读性更高。另外，在许多应用中，要求在一开始不满足测试条件时就直接跳过整个循环。\n那么，假设需要一个入口条件循环，用for循环还是while循环？这取决于个人喜好，因为二者皆可。要让for循环看起来像while循环，可以省略第1个和第3个表达式。例如：\n1for ( ; test ; )与下面的while效果相同：\n1while ( test )要让while循环看起来像for循环，可以在while循环的前面初始化变量，并在while循环体中包含更新语句。例如：\n初始化;\n12345while ( 测试 )&#123;    其他语句    更新语句&#125;与下面的for循环效果相同：\n12for ( 初始化 ;测试 ; 更新 )其他语句一般而言，当循环涉及初始化和更新变量时，用for循环比较合适，而在其他情况下用while循环更好。对于下面这种条件，用while循环就很合适：\n1while (scanf(\"%ld\", &amp;num) == 1)对于涉及索引计数的循环，用for循环更适合。例如：\n1for (count = 1; count &lt;= 100; count++)嵌套循环嵌套循环（nested loop）指在一个循环内包含另一个循环。嵌套循环常用于按行和列显示数据，也就是说，一个循环处理一行中的所有列，另一个循环处理所有的行。程序清单6.17演示了一个简单的示例。\n程序清单6.17 rows1.c程序\n1234567891011121314151617/* rows1.c -- 使用嵌套循环 */#include　&lt;stdio.h&gt;#define ROWS 6#define　CHARS　10int　main(void)&#123;    int row;    char ch;    for(row=0;row&lt;ROWS;row++)　　　　　　　　 /* 第10行 */    &#123;        for (ch='A';ch&lt;('A'+CHARS);ch++)　　 /* 第12行 */        \tprintf(\"%c\",ch);        printf(\"\\n\");    &#125;    return　0;&#125;运行该程序后，输出如下：\n123456ABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJABCDEFGHIJ程序分析第10行开始的for循环被称为外层循环（outer loop），第12行开始的for循环被称为内层循环（inner loop）。外层循环从row为0开始循环，到row为6时结束。因此，外层循环要执行6次，row的值从0变为5。每次迭代要执行的第1条语句是内层的for循环，该循环要执行10次，在同一行打印字符A～J；第2条语句是外层循环的printf(&quot;\\n&quot;);，该语句的效果是另起一行，这样在下一次运行内层循环时，将在下一行打印的字符。\n注意，嵌套循环中的内层循环在每次外层循环迭代时都执行完所有的循环。在程序清单6.17中，内层循环一行打印10个字符，外层循环创建6行。\n嵌套变式上一个实例中，内层循环和外层循环所做的事情相同。可以通过外层循环控制内层循环，在每次外层循环迭代时内层循环完成不同的任务。把程序清单6.17稍微修改后，如程序清单6.18所示。内层循环开始打印的字符取决于外层循环的迭代次数。该程序的第 1 行使用了新的注释风格，而且用 const 关键字代替#define，有助于读者熟悉这两种方法。\n程序清单6.18 rows2.c程序\n1234567891011121314151617// rows2.c -- 依赖外部循环的嵌套循环#include　&lt;stdio.h&gt;int　main(void)&#123;    const　int　ROWS　=　6;    const　int　CHARS　=　6;    int　row;    char　ch;    for(row　=　0;　row　&lt;　ROWS;　row++)    &#123;        for(ch　=　('A'　+　row);　ch　&lt;　('A'　+　CHARS);　ch++)        printf(\"%c\",　ch);        printf(\"\\n\");    &#125;    return　0;&#125;该程序的输出如下：\n123456ABCDEFBCDEFCDEFDEFEFF因为每次迭代都要把row的值与‘A’相加，所以ch在每一行都被初始化为不同的字符。然而，测试条件并没有改变，所以每行依然是以F结尾，这使得每一行打印的字符都比上一行少一个。\n数组简介在许多程序中，数组很重要。数组可以作为一种储存多个相关项的便利方式。我们在第10章中将详细介绍数组，但是由于循环经常用到数组，所以在这里先简要地介绍一下。\n数组（array）是按顺序储存的一系列类型相同的值，如10个char类型的字符或15个int类型的值。整个数组有一个数组名，通过整数下标访问数组中单独的项或元素（element）。例如，以下声明：\n1float debts[20];声明debts是一个内含20个元素的数组，每个元素都可以储存float类型的值。数组的第1个元素是debts[0]，第2个元素是debts[1]，以此类推，直到debts[19]。注意，数组元素的编号从0开始，不是从1开始。可以给每个元素赋float类型的值。例如，可以这样写：\n12debts[5] = 32.54;debts[6] = 1.2e+21;实际上，使用数组元素和使用同类型的变量一样。例如，可以这样把值读入指定的元素中：\n1scanf(\"%f\", &amp;debts[4]); // 把一个值读入数组的第5个元素这里要注意一个潜在的陷阱：考虑到影响执行的速度，C 编译器不会检查数组的下标是否正确。下面的代码，都不正确：\n12debts[20] = 88.32;　　 // 该数组元素不存在debts[33] = 828.12;　　// 该数组元素不存在编译器不会查找这样的错误。当运行程序时，这会导致数据被放置在已被其他数据占用的地方，可能会破坏程序的结果甚至导致程序异常中断。\n数组的类型可以是任意数据类型。\n123int nannies[22];　/* 可储存22个int类型整数的数组 */char actors[26];　/* 可储存26个字符的数组 */long big[500];　　/* 可储存500个long类型整数的数组 */我们在第4章中讨论过字符串，可以把字符串储存在char类型的数组中（一般而言，char类型数组的所有元素都储存char类型的值）。如果char类型的数组末尾包含一个表示字符串末尾的空字符\\0，则该数组中的内容就构成了一个字符串（见图6.6）。\n\n用于识别数组元素的数字被称为下标（subscript）、索引（indice）或偏移量（offset）。下标必须是整数，而且要从0开始计数。数组的元素被依次储存在内存中相邻的位置，如图6.7所示。\n\n在for循环中使用数组程序中有许多地方要用到数组，程序清单6.19是一个较为简单的例子。该程序读取10个高尔夫分数，稍后进行处理。使用数组，就不用创建10个不同的变量来储存10个高尔夫分数。而且，还可以用for循环来读取数据。程序打印总分、平均分、差点（handicap，它是平均分与标准分的差值）。\n程序清单6.19 scores_in.c程序\n123456789101112131415161718192021222324// scores_in.c -- 使用循环处理数组#include　&lt;stdio.h&gt;#define　SIZE　10#define　PAR　72int　main(void)&#123;    int index,score[SIZE];    int sum=0;    float average;    printf(\"Enter　%d　golf　scores:\\n\",SIZE);    for(index=0;index&lt;SIZE;index++)        scanf(\"%d\",&amp;score[index]);　　 // 读取10个分数    printf(\"The　scores　read　in　are　as　follows:\\n\");    for(index=0;index&lt;SIZE;index++)   \t\t printf(\"%5d\", score[index]);　　// 验证输入    printf(\"\\n\");    for(index=0;index&lt;SIZE;index++)   \t\t sum+=score[index];　　　　　　　// 求总分数    average=(float) sum/SIZE;　　　　// 求平均分    printf(\"Sum　of　scores　=　%d,　average　=　%.2f\\n\",　sum,　average);    printf(\"That's　a　handicap　of　%.0f.\\n\",　average　-　PAR);    return　0;&#125;先看看程序清单6.19是否能正常工作，接下来再做一些解释。下面是程序的输出：\n1234567Enter　10　golf　scores:99　95　109　105　10096　98　93　99　97　98The　scores　read　in　are　as　follows:99　95　109　105　100　96　98　93　99　97Sum　of　scores　=　991,　average　=　99.10That's　a　handicap　of　27.程序运行没问题，我们来仔细分析一下。首先，注意程序示例虽然打印了11个数字，但是只读入了10个数字，因为循环只读了10个值。由于scanf()会跳过空白字符，所以可以在一行输入10个数字，也可以每行只输入一个数字，或者像本例这样混合使用空格和换行符隔开每个数字（因为输入是缓冲的，只有当用户键入Enter键后数字才会被发送给程序）。\n然后，程序使用数组和循环处理数据，这比使用10个单独的scanf()语句和10个单独的printf()语句读取10个分数方便得多。for循环提供了一个简单直接的方法来使用数组下标。注意，int类型数组元素的用法与int类型变量的用法类似。要读取int类型变量fue，应这样写 scanf(&quot;&amp;d&quot;,&amp;fue)。程序清单6.19中要读取int类型的元素 score[index]，所以这样写scanf(&quot;%d&quot;,&amp;score[index]。\n该程序示例演示了一些较好的编程风格。第一，用#define 指令创建的明示常量（SIZE）来指定数组的大小。这样就可以在定义数组和设置循环边界时使用该明示常量。如果以后要扩展程序处理20个分数，只需简单地把SIZE重新定义为20即可，不用逐一修改程序中使用了数组大小的每一处。\n第二，下面的代码可以很方便地处理一个大小为SIZE的数组：\n1for(index=0;index&lt;SIZE;index++)设置正确的数组边界很重要。第1个元素的下标是0，因此循环开始时把index设置为0。因为从0开始编号，所以数组中最后一个元素的下标是SIZE - 1。也就是说，第10个元素是score[9]。通过测试条件index &lt; SIZE来控制循环中使用的最后一个index的值是SIZE - 1。\n第三，程序能重复显示刚读入的数据。这是很好的编程习惯，有助于确保程序处理的数据与期望相符。\n最后，注意该程序使用了3个独立的for循环。这是否必要？是否可以将其合并成一个循环？当然可以，读者可以动手试试，合并后的程序显得更加紧凑。但是，调整时要注意遵循模块化（modularity）的原则。模块化隐含的思想是：应该把程序划分为一些独立的单元，每个单元执行一个任务。这样做提高了程序的可读性。也许更重要的是，模块化使程序的不同部分彼此独立，方便后续更新或修改程序。在掌握如何使用函数后，可以把每个执行任务的单元放进函数中，提高程序的模块化。\n使用函数返回值的循环示例本章最后一个程序示例要用一个函数计算数的整数次幂（math.h库提供了一个更强大幂函数pow()，可以使用浮点指数）。该示例有3个主要任务：设计算法、在函数中表示算法并返回计算结果、提供一个测试函数的便利方法。\n首先分析算法。为简化函数，我们规定该函数只处理正整数的幂。这样，把n与n相乘p次便可计算n的p次幂。这里自然会用到循环。先把变量pow设置为1，然后将其反复乘以n：\n12for(i=1;i&lt;=p;i++)pow*=n;回忆一下，*=运算符把左侧的项乘以右侧的项，再把乘积赋给左侧的项。第1次循环后，pow的值是1乘以n，即n；第2次循环后，pow的值是上一次的值（n）乘以n，即n的平方；以此类推。这种情况使用for循环很合适，因为在执行循环之前已预先知道了迭代的次数（已知p）。\n现在算法已确定，接下来要决定使用何种数据类型。指数p是整数，其类型应该是int。为了扩大n及其幂的范围，n和pow的类型都是double。\n接下来，考虑如何把以上内容用函数来实现。要使用两个参数（分别是double类型和int类型）才能把所需的信息传递给函数，并指定求哪个数的多少次幂。而且，函数要返回一个值。如何把函数的返回值返回给主调函数？编写一个有返回值的函数，要完成以下内容：\n定义函数时，确定函数的返回类型；\n\n使用关键字return表明待返回的值。\n\n例如，可以这样写：\n12345678double power(double n,int p) // 返回一个double类型的值&#123;    double pow=1;    int i;    for(i=1;i&lt;=p;i++)    pow*=n;    return pow; // 返回pow的值&#125;要声明函数的返回类型，在函数名前写出类型即可，就像声明一个变量那样。关键字 return 表明该函数将把它后面的值返回给主调函数。根据上面的代码，函数返回一个变量的值。返回值也可以是表达式的值，如下所示：\n1return 2*x+b;函数将计算表达式的值，并返回该值。在主调函数中，可以把返回值赋给另一个变量、作为表达式中的值、作为另一个函数的参数（如，printf(&quot;%f&quot;,power(6.28,3)），或者忽略它。\n现在，我们在一个程序中使用这个函数。要测试一个函数很简单，只需给它提供几个值，看它是如何响应的。这种情况下可以创建一个输入循环，选择 while 循环很合适。可以使用 scanf()函数一次读取两个值。如果成功读取两个值，scanf()则返回2，所以可以把scanf()的返回值与2作比较来控制循环。还要注意，必须先声明power()函数（即写出函数原型）才能在程序中使用它，就像先声明变量再使用一样。程序清单6.20演示了这个程序。\n程序清单6.20 powwer.c程序\n12345678910111213141516171819202122232425262728// power.c -- 计算数的整数幂#include　&lt;stdio.h&gt;double power(double n,int p); // ANSI函数原型int main(void)&#123;    double x,xpow;    int exp;    printf(\"Enter　a　number　and　the　positive　integer　power\");    printf(\"　to　which\\n the　number　will　be　raised.　Enter　q\");    printf(\"　to　quit.\\n\");    while(scanf(\"%lf%d\",&amp;x,&amp;exp)==2)    &#123;        xpow=power(x,exp);　// 函数调用        printf(\"%.3g　to　the　power　%d　is　%.5g\\n\",　x,　exp,　xpow);        printf(\"Enter　next　pair　of　numbers　or　q　to　quit.\\n\");    &#125;    printf(\"Hope　you　enjoyed　this　power　trip　--　bye!\\n\");    return　0;&#125;double power(double n,int p)　 // 函数定义&#123;    double pow=1;    int i;    for(i=1;i&lt;=p;i++)    pow*=n;    return pow;　　　　　　　　　 // 返回pow的值&#125;运行该程序后，输出示例如下：\n1234567891011Enter　a　number　and　the　positive　integer　power　to　whichthe　number　will　be　raised.　Enter　q　to　quit.1.2　121.2　to　the　power　12　is　8.9161Enter　next　pair　of　numbers　or　q　to　quit.2162　to　the　power　16　is　65536Enter　next　pair　of　numbers　or　q　to　quit.qHope　you　enjoyed　this　power　trip　--　bye!程序分析该程序示例中的main()是一个驱动程序（driver），即被设计用来测试函数的小程序。\n该例的while循环是前面讨论过的一般形式。输入1.2  12，scanf()成功读取两值，并返回2，循环继续。因为scanf()跳过空白，所以可以像输出示例那样，分多行输入。但是输入q会使scanf()的返回值为0，因为q与scanf()中的转换说明%1f不匹配。scanf()将返回0，循环结束。类似地，输入2.8 q会使scanf()的返回值为1，循环也会结束。\n现在分析一下与函数相关的内容。power()函数在程序中出现了3次。首次出现是：\n1double power(double n,int p); // ANSI函数原型这是power()函数的原型，它声明程序将使用一个名为power()的函数。开头的关键字double表明power()函数返回一个double类型的值。编译器要知道power()函数返回值的类型，才能知道有多少字节的数据，以及如何解释它们。这就是为什么必须声明函数的原因。圆括号中的 double n,int p表示power()函数的两个参数。第1个参数应该是double类型的值，第2个参数应该是int类型的值。\n第2次出现是：\n1xpow=power(x,exp); // 函数调用程序调用power()，把两个值传递给它。该函数计算x的exp次幂，并把计算结果返回给主调函数。在主调函数中，返回值将被赋给变量xpow。\n第3次出现是：\n1double power(double n, int p) // 函数定义这里，power()有两个形参，一个是double类型，一个是int类型，分别由变量n和变量p表示。注意，函数定义的末尾没有分号，而函数原型的末尾有分号。在函数头后面花括号中的内容，就是power()完成任务的代码。\npower()函数用for循环计算n的p次幂，并把计算结果赋给pow，然后返回pow的值，如下所示：\n1return pow; //返回pow的值使用带返回值的函数声明函数、调用函数、定义函数、使用关键字return，都是定义和使用带返回值函数的基本要素。\n这里，读者可能有一些问题。例如，既然在使用函数返回值之前要声明函数，那么为什么在使用scanf()的返回值之前没有声明scanf()？为什么在定义中说明了power()的返回类型为double，还要单独声明这个函数？\n我们先回答第2 个问题。编译器在程序中首次遇到power()时，需要知道power()的返回类型。此时，编译器尚未执行到power()的定义，并不知道函数定义中的返回类型是double。因此，必须通过前置声明（forward declaration）预先说明函数的返回类型。前置声明告诉编译器，power()定义在别处，其返回类型为double。如果把power()函数的定义置于main()的文件顶部，就可以省略前置声明，因为编译器在执行到main()之前已经知道power()的所有信息。但是，这不是C的标准风格。因为main()通常只提供整个程序的框架，最好把 main()放在所有函数定义的前面。另外，通常把函数放在其他文件中，所以前置声明必不可少。\n接下来，为什么不用声明 scanf()函数就可以使用它？其实，你已经声明了。stdio.h 头文件中包含了scanf()、printf()和其他I/O函数的原型。scanf()函数的原型表明，它返回的类型是int。\n关键概念循环是一个强大的编程工具。在创建循环时，要特别注意以下3个方面：\n注意循环的测试条件要能使循环结束；\n确保循环测试中的值在首次使用之前已初始化；\n确保循环在每次迭代都更新测试的值。\nC通过求值来处理测试条件，结果为0表示假，非0表示真。带关系运算符的表达式常用于循环测试，它们有些特殊。如果关系表达式为真，其值为1；如果为假，其值为0。这与新类型_Bool的值保持一致。\n数组由相邻的内存位置组成，只储存相同类型的数据。记住，数组元素的编号从 0 开始，所有数组最后一个元素的下标一定比元素数目少1。C编译器不会检查数组下标值是否有效，自己要多留心。\n使用函数涉及3个步骤：\n通过函数原型声明函数；\n在程序中通过函数调用使用函数；\n定义函数。\n函数原型是为了方便编译器查看程序中使用的函数是否正确，函数定义描述了函数如何工作。现代的编程习惯是把程序要素分为接口部分和实现部分，例如函数原型和函数定义。接口部分描述了如何使用一个特性，也就是函数原型所做的；实现部分描述了具体的行为，这正是函数定义所做的。\n本章小结本章的主题是程序控制。C语言为实现结构化的程序提供了许多工具。while语句和for语句提供了入口条件循环。for语句特别适用于需要初始化和更新的循环。使用逗号运算符可以在for循环中初始化和更新多个变量。有些场合也需要使用出口条件循环，C为此提供了do while语句。\n典型的while循环设计的伪代码如下：\n12345678910/*获得初值*/while(值满足测试条件)&#123;    处理该值    获取下一个值&#125;/*for循环也可以完成相同的任务：*/for(获得初值; 值满足测试条件; 获得下一个值)处理该值这些循环都使用测试条件来判断是否继续执行下一次迭代。一般而言，如果对测试表达式求值为非0，则继续执行循环；否则，结束循环。通常，测试条件都是关系表达式（由关系运算符和表达式构成）。表达式的关系为真，则表达式的值为1；如果关系为假，则表达式的值为0。C99新增了_Bool类型，该类型的变量只能储存1或0，分别表示真或假。\n除了关系运算符，本章还介绍了其他的组合赋值运算符，如+=或*=。这些运算符通过对其左侧运算对象执行算术运算来修改它的值。\n接下来还简单地介绍了数组。声明数组时，方括号中的值指明了该数组的元素个数。数组的第 1 个元素编号为0，第2个元素编号为1，以此类推。例如，以下声明：\n1double hippos[20];创建了一个有20个元素的数组hippos，其元素从hippos[0]～hippos[19]。利用循环可以很方便地操控数组的下标。\n最后，本章演示了如何编写和使用带返回值的函数。\n","plink":"https://dxsummer.gitee.io/posts/287f677b/"},{"title":"Step3 运算符、表达式和语句","date":"2020-05-30T08:10:08.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"updated":"2020-06-08T01:44:44.000Z","content":"[运算符、表达式和语句]本章介绍以下内容：\n关键字：while、typedef\n运算符：=、-、*、/、%、++、--、(类型名)\nC语言的各种运算符，包括用于普通数学运算的运算符\n运算符优先级以及语句、表达式的含义\nwhile循环\n复合语句、自动类型转换和强制类型转换\n如何编写带有参数的函数\n现在，读者已经熟悉了如何表示数据，接下来我们学习如何处理数据。C 语言为处理数据提供了大量的操作，可以在程序中进行算术运算、比较值的大小、修改变量、逻辑地组合关系等。我们先从基本的算术运算（加、减、乘、除）开始。\n组织程序是处理数据的另一个方面，让程序按正确的顺序执行各个步骤。C 有许多语言特性，帮助你完成组织程序的任务。循环就是其中一个特性，本章中你将窥其大概。循环能重复执行行为，让程序更有趣、更强大。\n循环简介程序清单5.1是一个简单的程序示例，该程序进行了简单的运算，计算穿9码男鞋的脚长（单位：英寸）。为了让读者体会循环的好处，程序的第1个版本演示了不使用循环编程的局限性。\n123456789101112131415程序清单5.1 shoes1.c程序/* shoes1.c -- 把鞋码转换成英寸 */#include　&lt;stdio.h&gt;#define ADJUST 7.31　　　　　　　　　　// 字符常量int　main(void)&#123;    const double SCALE = 0.333;// const变量    double　shoe,　foot;    shoe　=　9.0;    foot = SCALE * shoe + ADJUST;    printf(\"Shoe　size　(men's)　　 foot　length\\n\");    printf(\"%10.1f　%15.2f　inches\\n\",　shoe,　foot);    return　0;&#125;该程序的输出如下：\n12Shoe　size　(men's)　foot　length\t9.0　　　　10.31　inches该程序演示了用#define 指令创建符号常量和用 const 限定符创建在程序运行过程中不可更改的变量。程序使用了乘法和加法，假定用户穿9码的鞋，以英寸为单位打印用户的脚长。你可能会说：“这太简单了，我用笔算比敲程序还要快。”说得没错。写出来的程序只使用一次（本例即只根据一只鞋的尺码计算一次脚长），实在是浪费时间和精力。如果写成交互式程序会更有用，但是仍无法利用计算机的优势。\n应该让计算机做一些重复计算的工作。毕竟，需要重复计算是使用计算机的主要原因。C 提供多种方法做重复计算，我们在这里简单介绍一种——while循环。它能让你对运算符做更有趣地探索。程序清单5.2演示了用循环改进后的程序。\n程序清单5.2 shoes2.c程序\n12345678910111213141516171819/* shoes2.c -- 计算多个不同鞋码对应的脚长 */#include　&lt;stdio.h&gt;#define ADJUST 7.31　　　　　　　　　　// 字符常量int　main(void)&#123;    const double SCALE = 0.333;// const变量    double　shoe,　foot;    printf(\"Shoe size (men's) foot length\\n\");    shoe　=　3.0;    while (shoe &lt; 18.5)　　　　　　/* while循环开始 */    &#123;　　　　　　　　　　　　　　　/* 块开始　*/        foot = SCALE * shoe + ADJUST;        printf(\"%10.1f　%15.2f　inches\\n\",　shoe,　foot);        shoe　=　shoe　+　1.0;    &#125;　　　　　　　　　　　　　　　/* 块结束　　　 */    printf(\"If　the　shoe　fits,　wear　it.\\n\");    return　0;&#125;下面是shoes2.c程序的输出（…表示并未显示完整，有删节）：\n12345678910Shoe　size　(men's)　foot　length3.0　　　　　　 8.31　inches4.0　　　　　　 8.64　inches5.0　　　　　　 8.97　inches6.0　　　　　　 9.31　inches...16.0　　　　　12.64　inches17.0　　　　　12.97　inches18.0　　　　　13.30　inchesIf　the　shoe　fits,　wear　it.（如果读者对此颇有研究，应该知道该程序不符合实际情况。程序中假定了一个统一的鞋码系统。）\n下面解释一下while循环的原理。当程序第1次到达while循环时，会检查圆括号中的条件是否为真。该程序中，条件表达式如下：\n1shoe &lt; 18.5符号&lt;的意思是小于。变量shoe被初始化为3.0，显然小于18.5。因此，该条件为真，程序进入块中继续执行，把尺码转换成英寸。然后打印计算的结果。下一条语句把 shoe增加1.0，使shoe的值为4.0：\n1shoe = shoe + 1.0;此时，程序返回while入口部分检查条件。为何要返回while的入口部分？因为上面这条语句的下面是右花括号（}），代码使用一对花括号（{}）来标出while循环的范围。花括号之间的内容就是要被重复执行的内容。花括号以及被花括号括起来的部分被称为块（block）。现在，回到程序中。因为4小于18.5，所以要重复执行被花括号括起来的所有内容（用计算机术语来说就是，程序循环这些语句）。该循环过程一直持续到shoe的值为19.0。此时，由于19.0小于18.5，所以该条件为假：\n1shoe &lt; 18.5出现这种情况后，控制转到紧跟while循环后面的第1条语句。该例中，是最后的printf()语句。\n可以很方便地修改该程序用于其他转换。例如，把SCALE设置成1.8、ADJUST设置成32.0，该程序便可把摄氏温度转换成华氏温度；把SCALE设置成0.6214、ADJUST设置成0，该程序便可把公里转换成英里。注意，修改了设置后，还要更改打印的消息，以免前后表述不一。\n通过while循环能便捷灵活地控制程序。现在，我们来学习程序中会用到的基本运算符。\n基本运算符C用运算符（operator）表示算术运算。例如，+运算符使在它两侧的值加在一起。如果你觉得术语“运算符”很奇怪，那么请记住东西总得有个名称。与其叫“那些东西”或“运算处理符”，还不如叫“运算符”。现在，我们介绍一下用于基本算术运算的运算符：=、+、-、*和/（C 没有指数运算符。不过，C 的标准数学库提供了一个pow()函数用于指数运算。例如，pow(3.5, 2.2)返回3.5的2.2次幂）。\n赋值运算符：=在C语言中，=并不意味着“相等”，而是一个赋值运算符。下面的赋值表达式语句：\n1bmw = 2002;把值2002赋给变量bmw。也就是说，=号左侧是一个变量名，右侧是赋给该变量的值。符号=被称为赋值运算符。另外，上面的语句不读作“bmw等于2002”，而读作“把值2002赋给变量bmw”。赋值行为从右往左进行。\n也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用的语句：\n1i = i + 1;对数学而言，这完全行不通。如果给一个有限的数加上 1，它不可能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句的意思是：找出变量 i 的值，把该值加 1，然后把新值赋值变量i（见图5.1）。\n\n在C语言中，类似这样的语句没有意义（实际上是无效的）：\n12002 = bmw;因为在这种情况下，2002 被称为右值（rvale），只能是字面常量。不能给常量赋值，常量本身就是它的值。因此，在编写代码时要记住，=号左侧的项必须是一个变量名。实际上，赋值运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。不过，后面章节还会介绍“指针”，可用于指向一个存储位置。概括地说，C 使用可修改的左值（modifiable lvalue）标记那些可赋值的实体。也许“可修改的左值”不太好懂，我们再来看一些定义。\n几个术语：数据对象、左值、右值和运算符\n赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为数据对象（data object）。C 标准只有在提到这个概念时才会用到对象这个术语。使用变量名是标识对象的一种方法。除此之外，还有其他方法，但是要在后面的章节中才学到。例如，可以指定数组的元素、结构的成员，或者使用指针表达式（指针中储存的是它所指向对象的地址）。左值（lvalue）是 C 语言的术语，用于标识特定数据对象的名称或表达式。因此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。\n对于早期的C语言，提到左值意味着：\n1.它指定一个对象，所以引用内存中的地址；\n2.它可用在赋值运算符的左侧，左值（lvalue）中的l源自left。\n但是后来，标准中新增了const限定符。用const创建的变量不可修改。因此，const标识符满足上面的第1项，但是不满足第2项。一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧。有些左值不能用于赋值运算符的左侧。此时，标准对左值的定义已经不能满足当前的状况。\n为此，C标准新增了一个术语：可修改的左值（modifiable lvalue），用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语对象定位值（object locator value）更好。\n右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。例如，考虑下面的语句：\n1bmw = 2002;这里，bmw是可修改的左值，2002是右值。读者也许猜到了，右值中的r源自right。右值可以是常量、变量或其他可求值的表达式（如，函数调用）。实际上，当前标准在描述这一概念时使用的是表达式的值（value of an expression），而不是右值。\n我们看几个简单的示例：\n1234567int　ex;int　why;int　zee;const　int　TWO　=　2;why　=　42;zee = why;ex = TWO * (why + zee);这里，ex、why和zee都是可修改的左值（或对象定位值），它们可用于赋值运算符的左侧和右侧。TWO是不可改变的左值，它只能用于赋值运算符的右侧（在该例中，TWO被初始化为2，这里的=运算符表示初始化而不是赋值，因此并未违反规则）。同时，42 是右值，它不能引用某指定内存位置。另外，why和 zee 是可修改的左值，表达式(why + zee)是右值，该表达式不能表示特定内存位置，而且也不能给它赋值。它只是程序计算的一个临时值，在计算完毕后便会被丢弃。\n在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是运算对象（operand）。运算对象是运算符操作的对象。例如，可以把吃汉堡描述为：“吃”运算符操作“汉堡”运算对象。类似地可以说，=运算符的左侧运算对象应该是可修改的左值。\nC的基本赋值运算符有些与众不同，请看程序清单5.3。\n123456789101112程序清单5.3 golf.c程序/* golf.c -- 高尔夫锦标赛记分卡 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　jane,　tarzan,　cheeta;    cheeta=tarzan=jane=68;    printf(\"cheeta　　tarzan　　 jane\\n\");    printf(\"First　round　score　%4d　%8d　%8d\\n\",　cheeta,　tarzan,　jane);    return　0;&#125;许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值的顺序是从右往左：首先把68赋给jane，然后再赋给tarzan，最后赋给cheeta。因此，程序的输出如下：\n12cheetah　　tarzan　　　　janeFirst　round　score　　68　　　　　　68　　　　　　68加法运算符：+加法运算符（addition operator）用于加法运算，使其两侧的值相加。例如，语句：\n1printf(\"%d\", 4 + 20);打印的是24，而不是表达式\n14 + 20相加的值（运算对象）可以是变量，也可以是常量。因此，执行下面的语句：\n1income = salary + bribes;计算机会查看加法运算符右侧的两个变量，把它们相加，然后把和赋给变量income。\n在此提醒读者注意，income、salary和bribes都是可修改的左值。因为每个变量都标识了一个可被赋值的数据对象。但是，表达式salary + brives是一个右值。\n减法运算符：-减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。例如，下面的语句把200.0赋给takehome：\n1takehome = 224.00 – 24.00;+和-运算符都被称为二元运算符（binary operator），即这些运算符需要两个运算对象才能完成操作。\n符号运算符：-和+减号还可用于标明或改变一个值的代数符号。例如，执行下面的语句后，smokey的值为12：\n12rocky = –12;smokey = –rocky;以这种方式使用的负号被称为一元运算符（unary operator）。一元运算符只需要一个运算对象（见图5.2）。\nC90标准新增了一元+运算符，它不会改变运算对象的值或符号，只能这样使用：\n1dozen &#x3D; +12;编译器不会报错。但是在以前，这样做是不允许的。\n乘法运算符：*符号*表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm：\n1cm = 2.54 * inch;C没有平方函数，如果要打印一个平方表，怎么办？如程序清单5.4所示，可以使用乘法来计算平方。\n程序清单5.4 squares.c程序\n12345678910111213/* squares.c -- 计算1～20的平方 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　num　=　1;    while　(num　&lt;　21)    &#123;        printf(\"%4d %6d\\n\", num, num * num);        num　=　num　+　1;    &#125;    return　0;&#125;该程序打印数字1～20及其平方。接下来，我们再看一个更有趣的例子。\n指数增长读者可能听过这样一个故事，一位强大的统治者想奖励做出突出贡献的学者。他问这位学者想要什么，学者指着棋盘说，在第1个方格里放1粒小麦、第2个方格里放2粒小麦、第3个方格里放4粒小麦，第4个方格里放 8 粒小麦，以此类推。这位统治者不熟悉数学，很惊讶学者竟然提出如此谦虚的要求。因为他原本准备奖励给学者一大笔财产。如果程序清单5.5运行的结果正确，这显然是跟统治者开了一个玩笑。程序计算出每个方格应放多少小麦，并计算了总数。可能大多数人对小麦的产量不熟悉，该程序以谷粒数为单位，把计算的小麦总数与粗略估计的世界小麦年产量进行了比较。\n程序清单5.5 wheat.c程序\n12345678910111213141516171819202122232425/* wheat.c -- 指数增长 */#include　&lt;stdio.h&gt;#define SQUARES 64　　　　　　 // 棋盘中的方格数int　main(void)&#123;    const double CROP = 2E16;　// 世界小麦年产谷粒数    double current,total;    int count=1;    printf(\"square　grains　total \");    printf(\"fraction　of　\\n\");    printf(\"　　added　　grains　　 \");    printf(\"world　total\\n\");    total=current=1.0;　　 /* 从1颗谷粒开始　*/    printf(\"%4d　%13.2e　%12.2e　%12.2e\\n\",count,　current,total,total/CROP);    while(count&lt;SQUARES)    &#123;        count=count+1;        current=2.0*current;　 /* 下一个方格谷粒翻倍 */        total=total+current;　 /* 更新总数 */        printf(\"%4d　%13.2e　%12.2e　%12.2e\\n\",count,　current,total,total/CROP);    &#125;    printf(\"That's　all.\\n\");    return　0;&#125;程序的输出结果如下：\n1234567891011121314151617181920212223square　　　　　　grains　　　　　 total　　　　　　 fraction　ofadded　　　　　　 grains　　　　　 world　total1　　　　　　　 1.00e+00　　　　1.00e+00　　　　5.00e-172　　　　　　　 2.00e+00　　　　3.00e+00　　　　1.50e-163　　　　　　　 4.00e+00　　　　7.00e+00　　　　3.50e-164　　　　　　　 8.00e+00　　　　1.50e+01　　　　7.50e-165　　　　　　　 1.60e+01　　　　3.10e+01　　　　1.55e-156　　　　　　　 3.20e+01　　　　6.30e+01　　　　3.15e-157　　　　　　　 6.40e+01　　　　1.27e+02　　　　6.35e-158　　　　　　　 1.28e+02　　　　2.55e+02　　　　1.27e-149　　　　　　　 2.56e+02　　　　5.11e+02　　　　2.55e-1410　　　　　　　5.12e+02　　　　1.02e+03　　　　5.12e-1410个方格以后，该学者得到的小麦仅超过了1000粒。但是，看看55个方格的小麦数是多少：\n155　　　　　 1.80e+16　　　　3.60e+16　　　　1.80e+00总量已超过了世界年产量！不妨自己动手运行该程序，看看第64个方格有多少小麦。\n这个程序示例演示了指数增长的现象。世界人口增长和我们使用的能源都遵循相同的模式。\n除法运算符：/C使用符号/来表示除法。/左侧的值是被除数，右侧的值是除数。例如，下面four的值是4.0：\n1four = 12.0/3.0;整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。整数是没有小数部分的数。这使得5除以3很让人头痛，因为实际结果有小数部分。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断（truncation）。\n运行程序清单5.6中的程序，看看截断的情况，体会整数除法和浮点数除法的区别。\n程序清单5.6 divide.c程序\n12345678910111213/* divide.c -- 演示除法 */#include　&lt;stdio.h&gt;int　main(void)&#123;    printf(\"integer　division:　5/4　is　%d　\\n\",5/4);    printf(\"integer　division:　6/3　is　%d　\\n\",6/3);    printf(\"integer　division:　7/4　is　%d　\\n\",7/4);    printf(\"floating　division:　7./4. is　%1.2f　\\n\",7./4.);    printf(\"mixed　division:　7./4　is　%1.2f　\\n\",7./4);    return　0;&#125;程序清单5.6中包含一个“混合类型”的示例，即浮点值除以整型值。C相对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是要避免使用混合类型。该程序的输出如下：\n12345integer　division:　 5/4　　 is　1integer　division:　 6/3　　 is　2integer　division:　 7/4　　 is　1floating　division:　7./4.　is　1.75mixed　division:　　　7./4　 is　1.75注意，整数除法会截断计算结果的小数部分（丢弃整个小数部分），不会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。本例中，在进行除法运算前，整数会被转换成浮点数。\nC99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8 会怎样？该方法建议四舍五入为-4，因为-4 小于-3.8.但是，另一种舍入方法是直接丢弃小数部分。这种方法被称为“趋零截断”，即把-3.8转换成-3。在C99以前，不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8转换成-3。\n运算符优先级考虑下面的代码：\n1butter=25.0+60.0*n/SCALE;这条语句中有加法、乘法和除法运算。先算哪一个？是25.0加上60.0，然后把计算的和85.0乘以n，再把结果除以SCALE？还是60.0乘以n，然后把计算的结果加上25.0，最后再把结果除以SCALE？还是其他运算顺序？假设n是6.0，SCALE是2.0，带入语句中计算会发现，第1种顺序得到的结果是255，第2种顺序得到的结果是192.5。C程序一定是采用了其他的运算顺序，因为程序运行该语句后，butter的值是205.0。\n显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过运算符优先级来解决操作顺序的问题。每个运算符都有自己的优先级。正如普通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法和除法。如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对象，则根据它们在语句中出现的顺序来执行。对大多数运算符而言，这种情况都是按从左到右的顺序进行（=运算符除外）。因此，语句：\n1butter=25.0+60.0*n/SCALE;的运算顺序是：\n12360.0*n　　　　　/*首先计算表达式中的*或/（假设n的值是6，所以60.0*n得360.0）*/360.0/SCALE　　 /*然后计算表达式中第2个*或*/25.0+180　　　　　/*最后计算表达式里第1个+或-，结果为205.0（假设SCALE的值是2.0）许多人喜欢用表达式树（expression tree）来表示求值的顺序，如图5.3所示。该图演示了如何从最初的表达式逐步简化为一个值。\n\n如何让加法运算在乘法运算之前执行？可以这样做：\n1flour=(25.0+60.0*n)/SCALE;最先执行圆括号中的部分。圆括号内部按正常的规则执行。该例中，先执行乘法运算，再执行加法运算。执行完圆括号内的表达式后，用运算结果除以SCALE。\n表5.1总结了到目前为止学过的运算符优先级。\n\n注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中用除号左侧的运算对象除以右侧的运算对象。\n优先级和求值顺序运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：\n1y=6*12+5*20;当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语句中，12是和+运算符的运算对象。根据运算符的优先级，乘法的优先级比加法高，所以先进行乘法运算。类似地，先对 5 进行乘法运算而不是加法运算。简而言之，先进行两个乘法运算6 * 12和5 * 20，再进行加法运算。但是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用哪种方案，表达式都会简化为 72 + 100，所以这并不影响最终的结果。但是，读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边的乘法。结合律只适用于共享同一运算对象运算符。例如，在表达式12 / 3 * 2中，/和运算符的优先级相同，共享运算对象3。因此，从左往右的结合律在这种情况起作用。表达式简化为4 * 2，即8（如果从右往左计算，会得到12/6，即2，这种情况下计算的先后顺序会影响最终的计算结果）。在该例中，两个*运算符并没有共享同一个运算对象，因此从左往右的结合律不适用于这种情况。\n学以致用\n接下来，我们在更复杂的示例中使用以上规则，请看程序清单5.7。\n1234567891011程序清单5.7 rules.c程序/* rules.c -- 优先级测试 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int　top,　score;    top = score = -(2 + 5) * 6 + (4 + 3 * (2 + 3));    printf(\"top　=　%d,　score　=　%d\\n\",　top,　score);    return　0;&#125;该程序会打印什么值？先根据代码推测一下，再运行程序或阅读下面的分析来检查你的答案。\n首先，圆括号的优先级最高。先计算-(2 + 5) * 6中的圆括号部分，还是先计算(4 + 3 * (2 + 3))中的圆括号部分取决于具体的实现。圆括号的最高优先级意味着，在子表达式-(2 + 5) * 6中，先计算(2 + 5)的值，得7。然后，把一元负号应用在7上，得-7。现在，表达式是：\n1top = score = -7 * 6 + (4 + 3 * (2 + 3))下一步，计算2 + 3的值。表达式变成：\n1top = score = -7 * 6 + (4 + 3 * 5)接下来，因为圆括号中的*比+优先级高，所以表达式变成：\n1top = score = -7 * 6 + (4 + 15)然后，表达式为：\n1top = score = -7 * 6 + 19-7乘以6后，得到下面的表达式：\n1top = score = -42 + 19然后进行加法运算，得到：\n1top = score = -23现在，-23被赋值给score，最终top的值也是-23。记住，=运算符的结合律是从右往左。\n其他运算符C语言有大约40个运算符，有些运算符比其他运算符常用得多。前面讨论的是最常用的，本节再介绍4个比较有用的运算符。\nsizeof运算符和size_t类型读者在第3章就见过sizeof运算符。回顾一下，sizeof运算符以字节为单位返回运算对象的大小（在C中，1字节定义为char类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节）。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，float），则必须用圆括号将其括起来。程序清单5.8演示了这两种用法。\n1234567891011121314程序清单5.8 sizeof.c程序// sizeof.c -- 使用sizeof运算符// 使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu#include &lt;stdio.h&gt;int　main(void)&#123;    int　n=0;    size_t intsize;    intsize=sizeof(int);    printf(\"n=%d,　n　has　%zd　bytes;　all　ints　have　%zd　bytes.\\n\",n,sizeof　n,intsize);    return　0;&#125;C 语言规定，sizeof 返回 size_t 类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，size_t是语言定义的标准类型。C有一个typedef机制（第14章再详细介绍），允许程序员为现有类型创建别名。例如，\n1typedef double real;这样，real就是double的别名。现在，可以声明一个real类型的变量：\n1real deal; // 使用typedef编译器查看real时会发现，在typedef声明中real已成为double的别名，于是把deal创建为double 类型的变量。类似地，C 头文件系统可以使用 typedef 把 size_t 作为 unsigned int 或unsigned long的别名。这样，在使用size_t类型时，编译器会根据不同的系统替换标准类型。\nC99 做了进一步调整，新增了%zd 转换说明用于 printf()显示 size_t 类型的值。如果系统不支持%zd，可使用%u或%lu代替%zd。\n求模运算符：%求模运算符（modulus operator）用于整数运算。求模运算符给出其左侧整数除以右侧整数的余数（remainder）。例如，13 % 5（读作“13求模5”）得3，因为13比5的两倍多3，即13除以5的余数是3。求模运算符只能用于整数，不能用于浮点数。\n乍一看会认为求模运算符像是数学家使用的深奥符号，但是实际上它非常有用。求模运算符常用于控制程序流。例如，假设你正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用。这种情况可以在程序中对月份求模3（即，month % 3），并检查结果是否为0。如果为0，便加进额外的费用。等学到第7章的if语句后，读者会更明白。\n程序清单5.9演示了%运算符的另一种用途。同时，该程序也演示了while循环的另一种用法。\n1234567891011121314151617181920212223程序清单5.9 min_sec.c程序// min_sec.c -- 把秒数转换成分和秒#include　&lt;stdio.h&gt;#define SEC_PER_MIN 60　　　　　 // 1分钟60秒int　main(void)&#123;    int sec,min,left;    printf(\"Convert　seconds　to　minutes　and　seconds!\\n\");    printf(\"Enter　the　number　of　seconds　(&lt;=0　to　quit):\\n\");    scanf(\"%d\",&amp;sec);　　　　　 // 读取秒数    while(sec&gt;0)    &#123;        min=sec/SEC_PER_MIN;　　// 截断分钟数        left=sec%SEC_PER_MIN;　 // 剩下的秒数        printf(\"%d　seconds　is　%d　minutes,　%d　seconds.\\n\",sec,        min,left);        printf(\"Enter　next　value　(&lt;=0　to　quit):\\n\");        scanf(\"%d\",&amp;sec);    &#125;    printf(\"Done!\\n\");    return　0;&#125;该程序的输出如下：\n\n程序清单5.2使用一个计数器来控制while循环。当计数器超出给定的大小时，循环终止。而程序清单5.9则通过scanf()为变量sec获取一个新值。只要该值为正，循环就继续。当用户输入一个0或负值时，循环退出。这两种情况设计的要点是，每次循环都会修改被测试的变量值。\n负数求模如何进行？C99规定“趋零截断”之前，该问题的处理方法很多。但自从有了这条规则之后，如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数：\n123411/5\t得2，\t\t11 % 5\t\t得111/-5\t得-2，\t11 % -2\t\t得1-11/-5\t得2，\t\t-11 % -5\t得-1-11/5\t得-2，\t-11 % 5\t\t得-1如果当前系统不支持C99标准，会显示不同的结果。实际上，标准规定：无论何种情况，只要a和b都是整数值，便可通过a - (a/b)*b来计算a%b。例如，可以这样计算-11%5：\n1-11-(-11/5)*5=-11-(-2)*5=-11-(-10)=-1递增运算符：++递增运算符（increment operator）执行简单的任务，将其运算对象递增1。该运算符以两种方式出现。第1种方式，++出现在其作用的变量前面，这是前缀模式；第2种方式，++出现在其作用的变量后面，这是后缀模式。两种模式的区别在于递增行为发生的时间不同。我们先解释它们的相似之处，再分析它们不同之处。程序清单5.10中的程序示例演示了递增运算符是如何工作的。\n程序清单5.10 add_one.c程序\n1234567891011121314/* add_one.c -- 递增：前缀和后缀 */#include　&lt;stdio.h&gt;int　main(void)&#123;    int ultra=0,super=0;    while(super&lt;5)    &#123;        super++;        ++ultra;        printf(\"super=%d,ultra=%d\\n\",super,ultra);    &#125;    return　0;&#125;运行该程序后，其输出如下：\n12345super　=　1,　ultra　=　1super　=　2,　ultra　=　2super　=　3,　ultra　=　3super　=　4,　ultra　=　4super　=　5,　ultra　=　5该程序两次同时计数到5。用下面两条语句分别代替程序中的两条递增语句，程序的输出相同：\n12super　=　super　+　1;ultra　=　ultra　+　1;这些都是很简单的语句，为何还要创建两个缩写形式？原因之一是，紧凑结构的代码让程序更为简洁，可读性更高。这些运算符让程序看起来很美观。例如，可重写程序清单5.2（shoes2.c）中的一部分代码：\n1234567shoe=3.0;while(shoe&lt;18.5)&#123;    foot=SCALE*size+ADJUST;    printf(\"%10.1f　%20.2f　inches\\n\",shoe,foot);    ++shoe;&#125;但是，这样做也没有充分利用递增运算符的优势。还可以这样缩短这段程序：\n123456shoe　=　2.0;while　(++shoe&lt;18.5)&#123;    foot = SCALE*shoe + ADJUST;    printf(\"%10.1f　%20.2f　inches\\n\",　shoe,　foot);&#125;如上代码所示，把变量的递增过程放入while循环的条件中。这种结构在C语言中很普遍，我们来仔细分析一下。\n首先，这样的while循环是如何工作的？很简单。shoe的值递增1，然后和18.5作比较。如果递增后的值小于18.5，则执行花括号内的语句一次。然后，shoe的值再递增1，重复刚才的步骤，直到shoe的值不小于18.5为止。注意，我们把shoe的初始值从3.0改为2.0，因为在对foot第1次求值之前， shoe已经递增了1（见图5.4）。\n\n其次，这样做有什么好处？它使得程序更加简洁。更重要的是，它把控制循环的两个过程集中在一个地方。该循环的主要过程是判断是否继续循环（本例中，要检查鞋子的尺码是否小于 18.5），次要过程是改变待测试的元素（本例中是递增鞋子的尺码）。\n如果忘记改变鞋子的尺码，shoe的值会一直小于18.5，循环不会停止。计算机将陷入无限循环（infinite loop）中，生成无数相同的行。最后，只能强行关闭这个程序。把循环测试和更新循环放在一处，就不会忘记更新循环。\n但是，把两个操作合并在一个表达式中，降低了代码的可读性，让代码难以理解。而且，还容易产生计数错误。\n递增运算符的另一个优点是，通常它生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越来越智能，这一优势可能会消失。一个智能的编译器可以把x = x + 1当作++x对待。\n最后，递增运算符还有一个在某些场合特别有用的特性。我们通过程序清单5.11来说明。\n1234567891011121314程序清单5.11 post_pre.c程序/* post_pre.c -- 前缀和后缀 */#include &lt;stdio.h&gt;int main(void)&#123;    int a=1,b=1;    int a_post,　pre_b;    a_post=a++;　// 后缀递增    pre_b=++b;　 // 前缀递增    printf(\"a　 a_post　　b　　pre_b　\\n\");    printf(\"%1d　%5d　%5d　%5d\\n\",　a,　a_post,　b,　pre_b);    return　0;&#125;如果你的编译器没问题，那么程序的输出应该是：\n12a\ta_post\tb\t\tpre_b2\t1\t\t2　　　　2a和b都递增了1，但是，a_post是a递增之前的值，而b_pre是b递增之后的值。这就是++的前缀形式和后缀形式的区别（见图5.5）。\n\n12a_post = a++;　　　// 后缀：使用a的值乊后，递增ab_pre= ++b;　　　　// 前缀：使用b的值乊前，递增b单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使用前缀或后缀的效果不同。例如，我们曾经建议用下面的代码：\n1while (++shoe &lt; 18.5)该测试条件相当于提供了一个鞋子尺码到18的表。如果使用shoe++而不是++shoes，尺码表会增至19。因为shoe会在与18.5进行比较之后才递增，而不是先递增再比较。\n当然，使用下面这种形式也没错：\n1shoe = shoe + 1;只不过，有人会怀疑你是否是真正的C程序员。\n在学习本书的过程中，应多留意使用递增运算符的例子。自己思考是否能互换使用前缀和后缀形式，或者当前环境是否只能使用某种形式。\n如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智的是不要那样使用它们。例如，不要使用下面的语句：\n1234b=++i; // 如果使用i++，会得到不同的结果应该使用下列语句：++i;　　　// 第1行b=i; // 如果第1行使用的是i++，幵不会影响b的值尽管如此，有时小心翼翼地使用会更有意思。所以，本书会根据实际情况，采用不同的写法。\n递减运算符：–每种形式的递增运算符都有一个递减运算符（decrement operator）与之对应，用–代替++即可：\n12--count; // 前缀形式的递减运算符count--; // 后缀形式的递减运算符程序清单5.12演示了计算机可以是位出色的填词家。\n程序清单5.12 bottles.c程序\n1234567891011121314#include　&lt;stdio.h&gt;#define　MAX　100int　main(void)&#123;    int　count　=　MAX　+　1;    while(--count&gt;0)　    &#123;        printf(\"%d　bottles　of　spring　water　on　the　wall,\"\"%d　bottles　of　spring　water!\\n\",　count,　count);        printf(\"Take　one　down　and　pass　it　around,\\n\");        printf(\"%d　bottles　of　spring　water!\\n\\n\",　count　-　1);    &#125;    return　0;&#125;该程序的输出如下（篇幅有限，省略了中间大部分输出）：\n12345678910100　bottles　of　spring　water　on　the　wall,　100　bottles　of　spring　water!Take　one　down　and　pass　it　around,99　bottles　of　spring　water!99　bottles　of　spring　water　on　the　wall,　99　bottles　of　spring　water!Take　one　down　and　pass　it　around,98　bottles　of　spring　water!...1 bottles of spring water on the wall, 1 bottles of spring water!Take one down and pass it around,0 bottles of spring water!显然，这位填词家在复数的表达上有点问题。在学完第7章中的条件运算符后，可以解决这个问题。\n顺带一提，&gt;运算符表示“大于”，&lt;运算符表示“小于”，它们都是关系运算符（relational operator）。我们将在第6章中详细介绍关系运算符。\n优先级递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，x*y++表示的是(x)*(y++)，而不是(x*y)++。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。\n不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句：\n123y=2;n=3;nextnum=(y+n++)*6;nextnum的值是多少？把y和n的值带入上面的第3条语句得：\n1nextnum = (2 + 3)*6 = 5*6 = 30n的值只有在被使用之后才会递增为4。根据优先级的规定，++只作用于n，不作用与y + n。除此之外，根据优先级可以判断何时使用n的值对表达式求值，而递增运算符的性质决定了何时递增n的值。\n如果n++是表达式的一部分，可将其视为“先使用n，再递增”；而++n则表示“先递增n，再使用”。\n不要自作聪明如果一次用太多递增运算符，自己都会糊涂。例如，利用递增运算符改进 squares.c 程序（程序清单5.4），用下面的while循环替换原程序中的while循环：\n1234while　(num&lt;21)&#123;    printf(\"%10d %10d\\n\", num, num*num++);&#125;这个想法看上去不错。打印num，然后计算num*num得到平方值，最后把num递增1。但事实上，修改后的程序只能在某些系统上能正常运行。该程序的问题是：当 printf()获取待打印的值时，可能先对最后一个参数（ ）求值，这样在获取其他参数的值之前就递增了num。所以，本应打印：\n15　　　　　　 25却打印成：\n16　　　　　　 25它甚至可能从右往左执行，对最右边的num（++作用的num）使用5，对第2个num和最左边的num使用6，结果打印出：\n16　　　　　　 30在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。\n类似这样的语句，也会导致一些麻烦：\n1ans = num/2 + 5*(1 + num++);同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能认为，先计算第1项（num/2），接着计算第2项（5*(1 + num++)）。但是，编译器可能先计算第2项，递增num，然后在num/2中使用num递增后的新值。因此，无法保证编译器到底先计算哪一项。\n还有一种情况，也不确定：\n12n=3;y=n++ + n++;可以肯定的是，执行完这两条语句后，n的值会比旧值大2。但是，y的值不确定。在对y求值时，编译器可以使用n的旧值（3）两次，然后把n递增1两次，这使得y的值为6，n的值为5。或者，编译器使用n的旧值（3）一次，立即递增n，再对表达式中的第2个n使用递增后的新值，然后再递增n，这使得 y 的值为 7，n 的值为 5。两种方案都可行。对于这种情况更精确地说，结果是未定义的，这意味着 C标准并未定义结果应该是什么。\n遵循以下规则，很容易避免类似的问题：\n如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；\n如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。\n另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面的“副作用和序列点”中学到序列点时再来讨论这部分内容。\n表达式和语句在前几章中，我们已经多次使用了术语表达式（expression）和语句（statement）。现在，我们来进一步学习它们。C的基本程序步骤由语句组成，而大多数语句都由表达式构成。因此，我们先学习表达式。\n表达式表达式（expression）由运算符和运算对象组成（前面介绍过，运算对象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。下面是一些表达式：\n12345674-64+21a*(b+c/d)/20q=5*2x=++q%3q&gt;3如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子表达式（subexpression）组成（子表达式即较小的表达式）。例如，c/d是上面例子中a*(b + c/d)/20的子表达式。\n每个表达式都有一个值\nC 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达式中，前几个都很清晰明了。但是，有赋值运算符（=）的表达式的值是什么？这些表达式的值与赋值运算符左侧变量的值相同。因此，表达式q = 5*2作为一个整体的值是10。那么，表达式q &gt; 3的值是多少？这种关系表达式的值不是0就是1，如果条件为真，表达式的值为1；如果条件为假，表达式的值为0。表5.2列出了一些表达式及其值：\n\n虽然最后一个表达式看上去很奇怪，但是在C中完全合法（但不建议使用），因为它是两个子表达式的和，每个子表达式都有一个值。\n语句语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。因此，\n1legs = 4只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码则是一条语句：\n1legs = 4;最简单的语句是空语句：\n1;　　 //空语句C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语句）。因此，像下面这样写也没问题：\n128;3 + 4;但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切地说，语句可以改变值或调用函数：\n123x = 25;++x;y = sqrt(x);虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，但并不是所有的指令都是语句。考虑下面的语句：\n1x = 6 + (y = 5);该语句中的子表达式y = 5是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，简单语句）。\n到目前为止，读者已经见过多种语句（不包括空语句）。程序清单5.13演示了一些常见的语句。\n1234567891011121314程序清单5.13 addemup.c程序/* addemup.c -- 几种常见的语句 */#include　&lt;stdio.h&gt;int main(void)　　　　　　　　 /* 计算前20个整数的和　 */&#123;    int count, sum;　　　　　/* 声明[[1\\]](part0010.xhtml#annot17)　　　　　　 */    count = 0;　　　　　　　　 /* 表达式语句　　　　　 */    sum = 0;　　　　　　　　　 /* 表达式语句　　　　　 */    while (count++ &lt; 20)　　　 /* 迭代语句　　　　　　*/    sum　=　sum　+　count;    printf(\"sum = %d\\n\", sum); /* 表达式语句[[2\\]](part0010.xhtml#annot18)　　　 */    return 0;　　　　　　　/* 跳转语句　　　　　　　　 */&#125;下面我们讨论程序清单 5.13。到目前为止，相信读者已经很熟悉声明了。尽管如此，我们还是要提醒读者：声明创建了名称和类型，并为其分配内存位置。注意，声明不是表达式语句。也就是说，如果删除声明后面的分号，剩下的部分不是一个表达式，也没有值：\n1int port /* 不是表达式，没有值 */赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾。注意，在while循环中有一个赋值表达式语句。赋值表达式语句是表达式语句的一个示例。\n函数表达式语句会引起函数调用。在该例中，调用printf()函数打印结果。while语句有3个不同的部分（见图5.6）。首先是关键字while；然后，圆括号中是待测试的条件；最后如果测试条件为真，则执行while循环体中的语句。该例的while循环中只有一条语句。可以是本例那样的一条语句，不需要用花括号括起来，也可以像其他例子中那样包含多条语句。多条语句需要用花括号括起来。这种语句是复合语句，稍后马上介绍。\n\nwhile语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂。在后面的章节里，我们会遇到许多这样的语句。\n副作用和序列点\n我们再讨论一个C语言的术语副作用（side effect）。副作用是对数据对象或文件的修改。例如，语句：\n1states = 50;它的副作用是将变量的值设置为50。副作用？这似乎更像是主要目的！但是从C语言的角度看，主要目的是对表达式求值。给出表达式4 + 6，C会对其求值得10；给出表达式states = 50，C会对其求值得50。对该表达式求值的副作用是把变量states的值改为50。跟赋值运算符一样，递增和递减运算符也有副作用，使用它们的主要目的就是使用其副作用。\n类似地，调用 printf()函数时，它显示的信息其实是副作用（printf()的返回值是待显示字符的个数）。\n序列点（sequence point）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符也有序列点。另外，任何一个完整表达式的结束也是一个序列点。\n什么是完整表达式？所谓完整表达式（full expression），就是指这个表达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和while循环中的作为测试条件的表达式，都是完整表达式。\n序列点有助于分析后缀递增何时发生。例如，考虑下面的代码：\n12while(guests++&lt;10)printf(\"%d　\\n\",guests);对于该例，C语言的初学者认为“先使用值，再递增它”的意思是，在printf()语句中先使用guests，再递增它。但是，表达式guests++ &lt; 10是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。因此，C 保证了在程序转至执行 printf()之前发生副作用（即，递增guests）。同时，使用后缀形式保证了guests在完成与10的比较后才进行递增。\n现在，考虑下面这条语句：\n1y=(4+x++)+(6+x++);表达式4+x++不是一个完整的表达式，所以C无法保证x在子表达式4+x++求值后立即递增x。这里，完整表达式是整个赋值表达式语句，分号标记了序列点。所以，C 保证程序在执行下一条语句之前递增x两次。C并未指明是在对子表达式求值以后递增x，还是对所有表达式求值后再递增x。因此，要尽量避免编写类似的语句。\n复合语句（块）复合语句（compound statement）是用花括号括起来的一条或多条语句，复合语句也称为块（block）。shoes2.c程序使用块让while语句包含多条语句。比较下面两个程序段：\n12345678910111213/* 程序段 1 */index　=　0;while(index++&lt;10)sam = 10 * index + 2;printf(\"sam　=　%d\\n\",　sam);/* 程序段 2 */index　=　0;while(index++&lt;10)&#123;    sam = 10 * index + 2;    printf(\"sam　=　%d\\n\",　sam);&#125;程序段1，while循环中只有一条赋值表达式语句。没有花括号，while语句从while这行运行至下一个分号。循环结束后，printf()函数只会被调用一次。\n程序段2，花括号确保两条语句都是while循环的一部分，每执行一次循环就调用一次printf()函数。根据while语句的结构，整个复合语句被视为一条语句（见图5.7）。\n\n提示 风格提示\n再看一下前面的两个while程序段，注意循环体中的缩进。缩进对编译器不起作用，编译器通过花括号和while循环的结构来识别和解释指令。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。\n程序段2中，块或复合语句放置花括号的位置是一种常见的风格。另一种常用的风格是：\n1234while(index++&lt;10)&#123;    sam = 10*index + 2;    printf(\"sam　=　%d　\\n\",　sam);&#125;这种风格突出了块附属于while循环，而前一种风格则强调语句形成一个块。对编译器而言，这两种风格完全相同。\n总而言之，使用缩进可以为读者指明程序的结构。\n总结 表达式和语句\n表达式：\n表达式由运算符和运算对象组成。最简单的表达式是不带运算符的一个常量或变量（如，22 或beebop）。更复杂的例子是55 + 22和vap = 2 * (vip + (vup = 4))。\n语句：\n到目前为止，读者接触到的语句可分为简单语句和复合语句。简单语句以一个分号结尾。如下所示：\n赋值表达式语句:　　　toes = 12;\n函数表达式语句:　　　printf(&quot;%d\\n&quot;, toes);\n空语句:　　　　　\n1　;　 /* 什么也不做 */复合语句（或块）由花括号括起来的一条或多条语句组成。如下面的while语句所示：\n123456while(years&lt;100)&#123;    wisdom=wisdom * 1.05;    printf(\"%d　%d\\n\",　years,　wisdom);    years=　years　+　1;&#125;类型转换通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 不会像 Pascal那样停在那里死掉，而是采用一套规则进行自动类型转换。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使用类型的情况下（许多UNIX系统都使用lint程序检查类型“冲突”。如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题）。最好先了解一些基本的类型转换规则。\n1.当类型转换出现在表达式时，无论是unsigned还是signed的char和short都会被自动转换成int，如有必要会被转换成unsigned int（如果short与int的大小相同，unsigned short就比int大。这种情况下，unsigned short会被转换成unsigned int）。在K&amp;R那时的C中，float会被自动转换成double（目前的C不是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为升级（promotion）。\n2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。\n3.类型的级别从高至低依次是long double、double、float、unsignedlong long、long long、unsigned long、long、unsigned int、int。例外的情况是，当 long 和 int 的大小相同时，unsigned int比long的级别高。之所以short和char类型没有列出，是因为它们已经被升级到int或unsigned int。\n4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。\n5.当作为函数参数传递时，char和short被转换成int，float被转换成double。第9章将介绍，函数原型会覆盖自动升级。\n类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原因很简单：较低类型可能放不下整个数字。\n例如，一个8位的char类型变量储存整数101没问题，但是存不下22334。\n如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下。\n1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位unsigned char，待赋的值是原始值求模256。\n2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。\n3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。\n如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类型时，原来的浮点值会被截断。例如，23.12和23.99都会被截断为23，-23.5会被截断为-23。\n程序清单5.14演示了这些规则。\n程序清单5.14 convert.c程序\n1234567891011121314151617181920/* convert.c -- 自动类型转换 */#include　&lt;stdio.h&gt;int　main(void)&#123;    char ch;    int i;    float　fl;    fl=i=ch='C';　　　　　　　　　　　　　　　　　 /* 第9行　*/    printf(\"ch = %c, i = %d, fl = %2.2f\\n\", ch, i, fl);　/* 第10行 */    ch=ch+1;　　　　　　　　　　　　　　　　　　　　 /* 第11行 */    i=fl+2 * ch;　　　　　　　　　　　　　　　　　　 /* 第12行 */    fl=2.0 * ch + i;　　　　　　　　　　　　　　　　　 /* 第13行 */    printf(\"ch = %c, i = %d, fl = %2.2f\\n\", ch, i, fl);　/* 第14行 */    ch= 1107;　　　　　　　　　　　　　　　　　　　　　 /* 第15行 */    printf(\"Now ch = %c\\n\", ch);　　　　　　　　　　　　 /* 第16行 */    ch= 80.89;　　　　　　　　　　　　　　　　　　　　　/* 第17行 */    printf(\"Now ch = %c\\n\", ch);　　　　　　　　　　　　 /* 第18行 */    return　0;&#125;运行convert.c后输出如下：\n1234ch=C,　i=67,fl=67.00ch=D,　i=203,fl=339.00Now ch=SNow　ch=P在我们的系统中，char是8位，int是32位。程序的分析如下。\n第9行和第10行：字符&#39;C&#39;被作为1字节的ASCII值储存在ch中。整数变量i接受由&#39;C&#39;转换的整数，即按4字节储存67。最后，fl接受由67转换的浮点数67.00。\n第11行和第14行：字符变量&#39;C&#39;被转换成整数67，然后加1。计算结果是4字节整数68，被截断成1字节储存在ch中。根据%c转换说明打印时，68被解释成&#39;D&#39;的ASCII码。\n第12行和第14行：ch的值被转换成4字节的整数（68），然后2乘以ch。为了和fl相加，乘积整数（136）被转换成浮点数。计算结果（203.00f）被转换成int类型，并储存在i中。\n第13行和第14行：ch的值（’D’，或68）被转换成浮点数，然后2乘以ch。为了做加法，i的值（203）被转换为浮点类型。计算结果（339.00）被储存在fl中。\n第15行和第16行：演示了类型降级的示例。把ch设置为一个超出其类型范围的值，忽略额外的位后，最终ch的值是字符S的ASCII码。或者，更确切地说，ch的值是1107 % 256，即83。\n第17行和第18行：演示了另一个类型降级的示例。把ch设置为一个浮点数，发生截断后，ch的值是字符P的ASCII码。\n强制类型转换运算符通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是：\n1(type)用实际需要的类型（如，long）替换type即可。\n考虑下面两行代码，其中mice是int类型的变量。第2行包含两次int强制类型转换。\n12mice = 1.6 + 1.7;mice = (int)1.6 + (int)1.7;第1 行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配int 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。\n一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。\n总结 C的一些运算符\n下面是我们学过的一些运算符。\n赋值运算符：\n1=将其右侧的值赋给左侧的变量\n算术运算符：\n+　　　 将其左侧的值与右侧的值相加\n-　　　　将其左侧的值减去右侧的值\n-　　　　作为一元运算符，改变其右侧值的符号\n*　　　 将其左侧的值乘以右侧的值\n/　　　　将其左侧的值除以右侧的值，如果两数都是整数，计算结果将被截断\n%　　　　当其左侧的值除以右侧的值时，取其余数（只能应用于整数）\n++　　　 对其右侧的值加1（前缀模式），或对其左侧的值加1（后缀模式）\n--　　　 对其右侧的值减1（前缀模式），或对其左侧的值减1（后缀模式）\n其他运算符：\nsizeof　　　 获得其右侧运算对象的大小（以字节为单位），运算对象可以是一个被圆括号括起来的类型说明符，如sizeof(float)，或者是一个具体的变量名、数组名等，如sizeoffoo(类型名)\n强制类型转换运算符将其右侧的值转换成圆括号中指定的类型，如(float)9把整数9转换成浮点数9.0\n带参数的函数现在，相信读者已经熟悉了带参数的函数。要掌握函数，还要学习如何编写自己的函数（在此之前，读者可能要复习一下程序清单2.3中的butler()函数，该函数不带任何参数）。程序清单5.15中有一个pound()函数，打印指定数量的#号（该符号也叫作编号符号或井号）。该程序还演示了类型转换的应用。\n程序清单5.15 pound.c程序\n1234567891011121314151617181920/* pound.c -- 定义一个带一个参数的函数　*/#include　&lt;stdio.h&gt;void pound(int n);// ANSI函数原型声明int　main(void)&#123;    int times=5;    char ch='!';　　 // ASCII码是33    float　f=6.0f;    pound(times);　　　// int类型的参数    pound(ch);　　　　　// 和pound((int)ch);相同    pound(f);　　　　　 // 和pound((int)f);相同    return　0;&#125;void pound(int n)　　　// ANSI风格函数头&#123;　　　　　　　　　　　　 // 表明该函数接受一个int类型的参数    while(n--&gt;0)    printf(\"#\");    printf(\"\\n\");&#125;运行该程序后，输出如下：\n123############################################首先，看程序的函数头：\n1void pound(int n)如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的声明。参数名应遵循C语言的命名规则。\n声明参数就创建了被称为形式参数（formal argument或formal parameter，简称形参）的变量。该例中，形式参数是 int 类型的变量 n。像 pound(10)这样的函数调用会把 10 赋给 n。在该程序中，调用pound(times)就是把 times 的值（5）赋给 n。我们称函数调用传递的值为实际参数（actual argument或actual parameter），简称实参。所以，函数调用pound(10)把实际参数10传递给函数，然后该函数把10赋给形式参数（变量n）。也就是说，main()中的变量times的值被拷贝给pound()中的新变量n。\n注意 实参和形参\n形参为变量\n在英文中，argument和parameter经常可以互换使用，但是C99标准规定了：对于actual argument或actual parameter使用术语argument（译为实参）；对于formal argument或formal parameter使用术语parameter（译为形参）。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。因此，在程序清单5.15中，times是pound()的实参，n是pound()的形参。类似地，在函数调用pound(times + 4)中，表达式times + 4的值是该函数的实参。\n变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。如果在pound()中用times代替n，那么这个times与main()中的times不同。也就是说，程序中出现了两个同名的变量，但是程序可以区分它们。\n现在，我们来学习函数调用。第1 个函数调用是pound(times)，times的值5被赋给n。因此， printf()函数打印了5个井号和1个换行符。第2个函数调用是pound(ch)。这里，ch是char类型，被初始化为!字符，在ASCII中ch的数值是33。但是pound()函数的参数类型是int，与char不匹配。程序开头的函数原型在这里发挥了作用。原型（prototype）即是函数的声明，描述了函数的返回值和参数。pound()函数的原型说明了两点：\n该函数没有返回值（函数名前面有void关键字）；\n该函数有一个int类型的参数。\n该例中，函数原型告诉编译器pound()需要一个int类型的参数。相应地，当编译器执行到pound(ch)表达式时，会把参数ch自动转换成int类型。在我们的系统中，该参数从1字节的33变成4字节的33，所以现在33的类型满足函数的要求。与此类似，最后一次调用是pound(f)，使得float类型的变量被转换成合适的类型。\n在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指明了函数名和返回类型，没有指明参数类型。为了向下兼容，C现在仍然允许这样的形式：\n1void pound(); /* ANSI C乊前的函数声明 */如果用这条函数声明代替pound.c程序中的函数原型会怎样？第 1 次函数调用，pound(times)没问题，因为times是int类型。第2次函数调用，pound(ch)也没问题，因为即使缺少函数原型，C也会把char和short类型自动升级为int类型。第3次函数调用，pound(f)会失败，因为缺少函数原型，float 会被自动升级为 double，这没什么用。虽然程序仍然能运行，但是输出的内容不正确。在函数调用中显式使用强制类型转换，可以修复这个问题：\n1pound ((int)f); // 把f强制类型转换为正确的类型注意，如果f的值太大，超过了int类型表示的范围，这样做也不行。\n示例程序程序清单5.16演示了本章介绍的几个概念，这个程序对某些人很有用。程序看起来很长，但是所有的计算都在程序的后面几行中。我们尽量使用大量的注释，让程序看上去清晰明了。请通读该程序，稍后我们会分析几处要点。\n程序清单5.16 running.c程序\n1234567891011121314151617181920212223242526272829303132333435363738//　running.c　--　A　useful　program　for　runners#include　&lt;stdio.h&gt;const int S_PER_M=60;　　　　　　　 // 1分钟的秒数const int S_PER_H=3600;　　　　　　// 1小时的分钟数const double M_PER_K=0.62137;　　 // 1公里的英里数int　main(void)&#123;    double distk, distm;　 // 跑过的距离（分别以公里和英里为单位）    double rate;　　　　　　 // 平均速度（以英里/小时为单位）    int min, sec;　　　　　 // 跑步用时（以分钟和秒为单位）    int time;　　　　　　　　// 跑步用时（以秒为单位）    double mtime;　　　　　 // 跑1英里需要的时间，以秒为单位    int mmin, msec;　　　　 // 跑1英里需要的时间，以分钟和秒为单位    printf(\"This　program　converts　your　time　for　a　metric　race\\n\");    printf(\"to　a　time　for　running　a　mile　and　to　your　average\\n\");    printf(\"speed　in　miles　per　hour.\\n\");    printf(\"Please　enter,　in　kilometers,　the　distance　run.\\n\");    scanf(\"%lf\", &amp;distk);　　　　　　// %lf表示读取一个double类型的值    printf(\"Next　enter　the　time　in　minutes　and　seconds.\\n\");    printf(\"Begin　by　entering　the　minutes.\\n\");    scanf(\"%d\",　&amp;min);    printf(\"Now　enter　the　seconds.\\n\");    scanf(\"%d\",　&amp;sec);    time=S_PER_M * min+sec;　　 // 把时间转换成秒    distm=M_PER_K*distk;　　　　// 把公里转换成英里    rate=distm/time * S_PER_H;　// 英里/秒×秒/小时 = 英里/小时    mtime=(double)time / distm;　// 时间/距离 = 跑1英里所用的时间    mmin=(int)mtime / S_PER_M;　 // 求出分钟数    msec=(int)mtime % S_PER_M;　 // 求出剩余的秒数    printf(\"You　ran　%1.2f　km　(%1.2f　miles)　in　%d　min,　%d　sec.\\n\",    distk,　distm,　min,　sec);    printf(\"That　pace　corresponds　to　running　a　mile　in　%d　min,　\",    mmin);    printf(\"%d　sec.\\nYour　average　speed　was　%1.2f　mph.\\n\",　msec,    rate);    return　0;&#125;程序清单5.16使用了min_sec程序（程序清单5.9）中的方法把时间转换成分钟和秒，除此之外还使用了类型转换。为什么要进行类型转换？因为程序在秒转换成分钟的部分需要整型参数，但是在公里转换成英里的部分需要浮点运算。我们使用强制类型转换运算符进行了显式转换。\n实际上，我们曾经利用自动类型转换编写这个程序，即使用int类型的mtime来强制时间计算转换成整数形式。但是，在测试的11个系统中，这个版本的程序在1个系统上无法运行，这是由于编译器（版本比较老）没有遵循C规则。而使用强制类型转换就没有问题。对读者而言，强制类型转换强调了转换类型的意图，对编译器而言也是如此。\n下面是程序清单5.16的输出示例：\n12345678910111213This　program　converts　your　time　for　a　metric　raceto　a　time　for　running　a　mile　and　to　your　averagespeed　in　miles　per　hour.Please　enter,　in　kilometers,　the　distance　run.10.0Next　enter　the　time　in　minutes　and　seconds.Begin　by　entering　the　minutes.36Now　enter　the　seconds.23You　ran　10.00　km　(6.21　miles)　in　36　min,　23　sec.That　pace　corresponds　to　running　a　mile　in　5　min,　51　sec.Your average speed was 10.25 mph.关键概念C 通过运算符提供多种操作。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。每个 C表达式都有一个值。如果不了解运算符的优先级和结合律，写出的表达式可能不合法或者表达式的值与预期不符。这会影响你成为一名优秀的程序员。\n虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型。因此，C会进行自动类型转换。尽管如此，不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。这样，就不用担心出现不必要的自动类型转换。\n本章小结C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符。一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个运算对象的运算符（如负号和 sizeof）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为二元运算符。\n表达式由运算符和运算对象组成。在C语言中，每个表达式都有一个值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺序。\n大部分语句都以分号结尾。最常用的语句是表达式语句。用花括号括起来的一条或多条语句构成了复合语句（或称为块）。while语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句。\n在C语言中，许多类型转换都是自动进行的。当char和short类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为int类型；float类型在函数参数中时，会被升级为double类型。在K&amp;R C（不是ANSI C）下，表达式中的float也会被升级为double类型。当把一种类型的值赋给另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换成较小类型时（如，long转换成short，或 double 转换成 float），可能会丢失数据。根据本章介绍的规则，在混合类型的运算中，较小类型会被转换成较大类型。\n定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为形式参数。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。\n","plink":"https://dxsummer.gitee.io/posts/d0061c8b/"},{"title":"string.h中常用函数","date":"2020-05-30T07:08:03.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"updated":"2020-06-08T01:58:30.000Z","content":"strlen计算字符串长度\n1size_t strlen(const char *str)计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。\n函数实现：\n1234567int Strlen(const char *str)&#123;\tassert(str);\tint len = 0;\twhile ((*str++) != '\\0')len++;\treturn len;&#125;strcpy字符串复制\n1char *strcpy(char *dest, const char *src)把 src 所指向的字符串复制到 dest。\n函数实现：\n1234567char *Strcpy(char *dst, const char *src)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile ((*dst++ = *src++) != '\\0');\treturn tmp;&#125;strncpy复制连续的n个字符\n1char *strncpy(char *dest, const char *src, size_t n)把 src 所指向的字符串复制到 dest，最多复制 n 个字符。\n函数实现：\n1234567891011121314151617181920char *Strncpy(char *dst, const char *src, int len)&#123;\tassert(dst&amp;&amp;src);\tchar *tmp = dst;\tint offset = 0;\tif (len &gt; strlen(src))\t&#123;\t\toffset = len - strlen(src);\t\tlen = strlen(src);\t&#125;\twhile (len--)\t&#123;\t\t*dst++ = *src++;\t&#125;\twhile (offset--)\t&#123;\t\t*dst++ = '\\0';\t&#125;\treturn tmp;&#125;strcat把一个字符串连接到另一个字符串后面\n1char *strcat(char *dest, const char *src)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾。\n函数实现：\n123456789char *Strcat(char *dst, const char* src)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile (*dst++);\tdst--;\twhile (*dst++ = *src++);\treturn tmp;&#125;strncat把连续的n个字符连接到另一个字符串后面\n1char *strncat(char *dest, const char *src, size_t n)把 src 所指向的字符串追加到 dest 所指向的字符串的结尾，直到 n 字符长度为止。\n函数实现：\n12345678910111213char *Strncat(char *dst, const char* src, int len)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\twhile (*dst++);\tdst--;\twhile (len--)\t&#123;\t\t*dst++ = *src++;\t&#125;\t*dst = '\\0';\treturn tmp;&#125;示例：\n12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt;int main(void)&#123;    char str0[20] = \"Test:\";    char str1[20] = \"Welcome9999\";    char str2[20] = \" To \";    char str3[20] = \"0123Beijing55\";    char tmp[100];    strcpy(tmp, str0);    puts(tmp);      //Test:    strncpy(tmp, str1, 7);  //取st1前7个字符    puts(tmp);      //Welcome    strcat(tmp, str2);      //连接str2    puts(tmp);    strncat(tmp, str3 + 4, 7);  //取str3+4之后的7个字符    puts(tmp);    return 0;&#125;输出结果：\n\nstrchr查找某字符在字符串中首次出现的位置指针，如果不存在则返回NULL\n1char *strchr(const char *str, int c)在参数 str 所指向的字符串中搜索第一次出现字符 c（一个无符号字符）的位置。\n函数实现：\n12345678char* My_strchr(char *s, char c)&#123;    while(*s != '\\0' &amp;&amp; *s != c)    &#123;        ++s;    &#125;    return *s==c ? s : NULL;&#125;示例：\n1234567891011121314151617181920212223#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;    char string[20] = \"This is a string\";    char *ptr1, *ptr2;    char c1 = 'r', c2 = 'b';    ptr1 = strchr(string, c1);    ptr2 = strchr(string, c2);    if(ptr1)        printf(\"字符1:%c 的位置是: %s \\n\",c1,ptr1);    else        printf(\"字符1:%c 未找到 \\n\", c1);    if(ptr2)        printf(\"字符2:%c 的位置是: %s \\n\",c2,ptr2);    else        printf(\"字符2:%c 未找到 \\n\", c2);    return 0;&#125;输出结果：\n\nstrcmp字符串比较\n1int strcmp(const char *str1, const char *str2)把 str1 所指向的字符串和 str2 所指向的字符串进行比较。\n设这两个字符串为str1，str2，若str1=str2，则返回零；若str1&lt;str2，则返回负数；若str1&gt;str2，则返回正数。\n函数实现：\n123456789101112131415161718int Strcmp(char const *s1, char const *s2)&#123;\tassert(s1&amp;&amp;s2);\twhile (*s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\t&#123;\t\ts1++;\t\ts2++;\t&#125;\tif (*s1 == *s2)\t&#123;\t\treturn 0;\t&#125;\telse if (*s1 &gt; *s2)\t&#123;\t\treturn 1;\t&#125;\treturn -1;&#125;示例：\n123456789101112131415161718#include &lt;string.h&gt;#include &lt;stdio.h&gt;int main(void)&#123;    char str1[20] = \"abc\";    char str2[20] = \"abc\";    char str3[20] = \"bbc\";    int r1, r2, r3;    r1 = strcmp(str1, str2);    r2 = strcmp(str1, str3);    r3 = strcmp(str3, str1);    printf(\"r1 = %d, r2 = %d, r3 = %d \\n\", r1, r2, r3);    return 0;&#125;输出结果：\n\nstrstr字符串查找\n1char *strstr(const char *haystack, const char *needle)在字符串 haystack 中查找第一次出现字符串 needle（不包含空结束字符）的位置。\n函数实现：\n12345678910111213141516171819char *Strstr(char const *s1, char const *s2)&#123;\tassert(s1&amp;&amp;s2);\tconst char *ps1, *ps2;\tps1 = s1;\tps2 = s2;\twhile (*ps1)\t&#123;\t\tconst char *tmp = ps1;\t\twhile (*tmp++ == *ps2++);\t\tif (*ps2 == '\\0')\t\t&#123;\t\t\treturn (char*)ps1;\t\t&#125;\t\tps2 = s2;\t\tps1++;\t&#125;\treturn NULL;&#125;strncmp1int strncmp(const char *str1, const char *str2, size_t n)把 str1 和 str2 进行比较，最多比较前 n 个字节。\n函数实现：\n12345678910int Strncmp(char const *s1, char const *s2, int len)&#123;\tassert(s1&amp;&amp;s2);\twhile (len-- &amp;&amp; *s1 == *s2 &amp;&amp; *s1 != '\\0' &amp;&amp; *s2 != '\\0')\t&#123;\t\ts1++;\t\ts2++;\t&#125;\treturn *s1 - *s2;&#125;memcpy内存复制\n1void *memcpy(void *dest, const void *src, size_t n)从 src 复制 n 个字符到 dest。\n函数实现\n1234567891011void *Memcpy(char *dst, char const *src, int len)&#123;\tassert(dst &amp;&amp; src);\tchar *tmp = dst;\tconst char *s = src;\twhile (len--)\t&#123;\t\t*dst++ = *src;\t&#125;\treturn tmp;&#125;","plink":"https://dxsummer.gitee.io/posts/52078792/"},{"title":"模拟电子技术基础笔记","date":"2020-05-28T10:29:09.000Z","date_formatted":{"ll":"2020年5月28日","L":"2020/05/28","MM-DD":"05-28"},"updated":"2020-06-08T01:55:42.000Z","content":"半导体二极管半导体的基本知识导体：自然界中很容易导电的物质称为导体，金属一般都是导体。\n\n绝缘体：有的物质几乎不导电，称为绝缘体，如橡皮、陶瓷、塑料和石英。\n\n半导体：另有一类物质的导电特性处于导体和绝缘体之间，称为半导体，如锗、硅、砷化镓和一些硫化物、氧化物等。\n当受外界热和光的作用时，它的导电能力明显变化。\n往纯净的半导体中掺入某些杂质，会使它的导电能力明显改变。\n\n本征半导体：完全纯净的、结构完整的半导体晶体。\n\n在常温下，由于热激发，使一些价电子获得足够的能量而脱离共价键的束缚，成为自由电子，同时共价键上留下一个空位，称为空穴。\n\n载流子可以运动的带电粒子\n\n\n本征半导体中电流\n自由电子移动产生的电流\n空穴移动产生的电流\n\n本征半导体的导电能力取决于载流子的浓度。温度越高，载流子的浓度越高。因此本征半导体的导电能力越强，温度是影响半导体性能的一个重要的外部因素，这是半导体的一大特点。\n\n杂质半导体N 型半导体：自由电子浓度大大增加的杂质半导体，也称为（电子半导体）。\n在硅或锗晶体中掺入少量的五价元素磷（或锑），晶体点阵中的某些半导体原子被杂质取代，磷原子的最外层有五个价电子，其中四个与相邻的半导体原子形成共价键，必定多出一个电子，这个电子几乎不受束缚，很容易被激发而成为自由电子，这样磷原子就成了不能移动的带正电的离子。每个磷原子给出一个电子，称为施主原子。\n由施主原子提供的电子，浓度与施主原子相同。\n本征半导体中成对产生的电子和空穴。\n掺杂浓度远大于本征半导体中载流子浓度，所以，自由电子浓度远大于空穴浓度。\n\n自由电子称为多数载流子（多子），空穴称为少数载流子（少子）\n\n\nP 型半导体：空穴浓度大大增加的杂质半导体，也称为（空穴半导体）。\n​    \nP 型半导体中空穴是多子，电子是少子\n\n杂质半导体的示意表示法PN结及半导体二极管PN 结的形成在同一片半导体基片上，分别制造P 型半导体和N 型半导体，经过载流子的扩散，在它们的交界面处就形成了PN 结。\n所以扩散和漂移这一对相反的运动最终达到平衡，相当于两个区之间没有电荷运动，空间电荷区的厚度固定不变。\n空间电荷区中没有载流子。\n空间电荷区中内电场阻碍P中的空穴、N区 中的电子（都是多子）向对方运动（扩散运动）。\nP 区中的电子和 N区中的空穴（都是少子），数量有限，因此由它们形成的电流很小。\nPN结的单向导电性PN 结加上正向电压、正向偏置的意思都是： P 区加正、N 区加负电压。\nPN 结加上反向电压、反向偏置的意思都是： P区加负、N 区加正电压。\n半导体二极管最大整流电流 IOM\n二极管长期使用时，允许流过二极管的最大正向平均电流。\n\n反向击穿电压UBR\n二极管反向击穿时的电压值。击穿时反向电流剧增，二极管的单向导电性被破坏，甚至过热而烧坏。手册上给出的最高反向工作电压UWRM一般是UBR的一半。\n\n反向电流 IR\n指二极管加反向峰值工作电压时的反向电流。反向电流大，说明管子的单向导电性差，因此反向电流越小越好。反向电流受温度的影响，温度越高反向电流越大。硅管的反向电流较小，锗管的反向电流要比硅管大几十到几百倍。\n\n","plink":"https://dxsummer.gitee.io/posts/dbbc2d17/"},{"title":"note和小tag标签","date":"2020-05-26T01:55:31.000Z","date_formatted":{"ll":"2020年5月26日","L":"2020/05/26","MM-DD":"05-26"},"updated":"2020-06-08T01:54:16.000Z","content":"/* note语法示例 */\n绿色\n红色\n黄色\n灰色\n蓝色12345&lt;p class&#x3D;&#39;div-border green&#39;&gt;绿色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border red&#39;&gt;红色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border yellow&#39;&gt;黄色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border grey&#39;&gt;灰色&lt;&#x2F;p&gt;&lt;p class&#x3D;&#39;div-border blue&#39;&gt;蓝色&lt;&#x2F;p&gt;/* 小tag标签语法示例 */\n红色小标签绿色小标签蓝色小标签黄色小标签灰色小标签\n12345&lt;span class&#x3D;&quot;inline-tag red&quot;&gt;红色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag green&quot;&gt;绿色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag blue&quot;&gt;蓝色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag yellow&quot;&gt;黄色小标签&lt;&#x2F;span&gt;&lt;span class&#x3D;&quot;inline-tag grey&quot;&gt;灰色小标签&lt;&#x2F;span&gt;绿色1&lt;p class&#x3D;&#39;div-border green left right&#39;&gt;绿色&lt;&#x2F;p&gt;","plink":"https://dxsummer.gitee.io/posts/5d6d7b2d/"},{"title":"添加全局吸底APlayer","date":"2020-05-21T09:47:34.000Z","date_formatted":{"ll":"2020年5月21日","L":"2020/05/21","MM-DD":"05-21"},"updated":"2020-06-08T01:52:16.000Z","content":"如果你使用了butterfly做hexo主题可以向界面加入一些装饰,但butterfly使用了pug模板,所以与其他主题可能有些区别\n\nlive2d看板娘,能聊天,能玩耍,能换装等等这得感谢大神stevenjoezhang为原本只能显示一个模型的live2d插件添加了许多功能如果对位置什么的没有很大的要求的话,直接打开themes\\Butterfly\\layout\\includes\\head.pug结尾加入一行\n1script(src&#x3D;&#39;https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;gh&#x2F;stevenjoezhang&#x2F;live2d-widget&#x2F;autoload.js&#39;)就行了\n当然你会发现直接这样加的话,阅读Page时,打开TOC的话,看板娘会被遮住所以建议调整看板娘位置前往live2d-widget 下载\n解压后将autoload.js第二行的位置改成你挂载在服务器上的autoload.js所在文件夹的绝对路径比如autoload.js在科大ftp的/public_html/js/live2d-widget/目录下,这里就要改成http://home.ustc.edu.cn/~username/js/live2d-widget/ (科大ftp的根目录是/public_html/)然后修改waifu.css里面的 #waifu下的 left: 0;将这一行改成right: 70px;\n123456789#waifu &#123;\tbottom: -1000px;\tleft: 0;           &#x2F;&#x2F;这一行改成right: 70px;\tline-height: 0;\tposition: fixed;\ttransform: translateY(3px);\ttransition: transform .3s ease-in-out, bottom 3s ease-in-out;\tz-index: 1;&#125;将head.pug添加的src的autoload.js的路径改成你上传的路径就行了\n\n全局吸底APlayer打开themes\\Butterfly\\layout\\includes\\head.pug结尾加一句\n1include .&#x2F;third-party&#x2F;aplayer.pug然后在themes\\Butterfly\\layout\\includes\\third-party\\里面新建一个文件叫 aplayer.pug ,内容如下\n123456if theme.aplayer &amp;&amp; theme.aplayer.enable\t.aplayer(data-id&#x3D;theme.aplayer.id data-server&#x3D;theme.aplayer.server data-type&#x3D;theme.aplayer.type data-fixed&#x3D;theme.aplayer.fixed data-mini&#x3D;theme.aplayer.mini data-listFolded&#x3D;theme.aplayer.listFolded data-order&#x3D;theme.aplayer.order data-preload&#x3D;theme.aplayer.preload)\teach item in theme.aplayer.css\t\tlink(rel&#x3D;&#39;stylesheet&#39;, href&#x3D;item)\teach item in theme.aplayer.js\t\tscript(src&#x3D;item)然后打开butterfly.yml(如果你没有启用的话,就打开themes\\Butterfly_config.yml) 加入以下内容\n1234567891011121314aplayer:  enable: true  js:    - https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;aplayer&#x2F;1.10.1&#x2F;APlayer.min.js    - https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;meting@1.2.0&#x2F;dist&#x2F;Meting.min.js  css:    - https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;aplayer&#x2F;1.10.1&#x2F;APlayer.min.css  id: 2661264578  server: netease   type: playlist  fixed: &#39;true&#39;  order: random  preload: none  listFolded: &#39;false&#39;然后重新生成就可以看到 aplayer了,这里的id是我的网易云歌单号,可以修改成别的.但是浏览Page时会发现 aplayer会和 TOC(怎么又是它) 的切换按钮重合打开themes\\Butterfly\\source\\css\\_global\\index.styl修改第61行\n123456789#toggle-sidebar  position: fixed  bottom: $sidebar-icon-top           &#x2F;&#x2F;这里改成bottom: 70px  left: $sidebar-icon-left  z-index: 100  font-size: $sidebar-icon-size  &#x2F;&#x2F; opacity: 0  cursor: pointer  transition: all .2s\n","plink":"https://dxsummer.gitee.io/posts/ae7c64e9/"},{"title":"vscode下级文件夹与上级文件夹并列，文件夹折叠问题解决","date":"2020-05-19T10:16:02.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2020-06-08T01:56:36.000Z","content":"今天在创建文件夹的时候出现了创建的下级文件夹和上级文件夹并列，紧凑排列的情况，这里在最新版本的vs code中解决的途径如下：\n\n\n解决办法如下：\n\n点击上方文件，之后选择首选项，再进入设置；\n在用户中选择功能菜单栏下的资源管理器，在资源管理器中找到Compact Folders,将对号勾掉即可；\n\n\n这是改完后的效果，也是我们习惯的效果。\n\n\n","plink":"https://dxsummer.gitee.io/posts/98214d27/"},{"title":"GO语言环境搭建","date":"2020-05-19T07:18:47.000Z","date_formatted":{"ll":"2020年5月19日","L":"2020/05/19","MM-DD":"05-19"},"updated":"2020-06-08T01:53:48.000Z","content":"注意：\nGo语言1.14版本之后推荐使用`go modules`管理以来，也不再需要把代码写在GOPATH目录下了下载\n下载地址\n\nGo官网下载地址：https://golang.org/dl/\n\nGo官方镜像站（推荐）：https://golang.google.cn/dl/\n\n\n版本的选择\n\nWindows平台和Mac平台推荐下载可执行文件版，Linux平台下载压缩文件版。\n安装\nWindows安装\n\n此安装实例以 64位Win10系统安装 Go1.14.1可执行文件版本为例。将上一步选好的安装包下载到本地。\n\n双击下载好的文件，然后按照下图的步骤安装即可。\n\n\nLinux下安装\n\n如果不是要在Linux平台敲go代码就不需要在Linux平台安装Go，我们开发机上写好的go代码只需要跨平台编译（详见文章末尾的跨平台编译）好之后就可以拷贝到Linux服务器上运行了，这也是go程序跨平台易部署的优势。\n我们在版本选择页面选择并下载好go1.14.1.linux-amd64.tar.gz文件：\n1wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.14.1.linux-amd64.tar.gz将下载好的文件解压到/usr/local目录下：\n1tar -zxvf go1.14.1.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local  # 解压如果提示没有权限，加上sudo以root用户的身份再运行。执行完就可以在/usr/local/下看到go目录了。\n配置环境变量： Linux下有两个文件可以配置环境变量，其中/etc/profile是对所有用户生效的；$HOME/.profile是对当前用户生效的，根据自己的情况自行选择一个文件打开，添加如下两行代码，保存退出。\n12export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;goexport PATH&#x3D;$PATH:$GOROOT&#x2F;bin修改/etc/profile后要重启生效，修改$HOME/.profile后使用source命令加载$HOME/.profile文件即可生效。 检查：\n12~ go versiongo version go1.14.1 linux&#x2F;amd64\nMac下安装\n\n下载可执行文件版，直接点击下一步安装即可，默认会将go安装到/usr/local/go目录下。\n检查上一步安装过程执行完毕后，可以打开终端窗口，输入go version命令，查看安装的Go版本。\n\n配置GOROOT和GOPATHGOROOT和GOPATH都是环境变量，其中GOROOT是我们安装go开发包的路径，而从Go 1.8版本开始，Go开发包在安装完成后会为GOPATH设置一个默认目录，参见下表。\nGOPATH在不同操作系统平台上的默认值\n\n平台GOPATH默认值举例\n\nWindows%USERPROFILE%/goC:\\Users\\用户名\\go\n\nUnix$HOME/go/home/用户名/go\n可以通过以下方法查看默认的GOPATH目录：\n\n我们只需要记住默认的GOPATH路径在哪里就可以了，并且默认情况下 GOROOT下的bin目录及GOPATH下的bin目录都已经添加到环境变量中了，我们也不需要额外配置了。\n\nGOPROXY\n\nGo1.14版本之后，都推荐使用go mod模式来管理依赖环境了，也不再强制我们把代码必须写在GOPATH下面的src目录了，你可以在你电脑的任意位置编写go代码。（网上有些教程适用于1.11版本之前。）\n设置GOPATH路径（GOPATH路径是我们的工作区）\n1go env -w GOPATH&#x3D;我们自己的工作区路径例如我的就设为 /Users/naonao/go\n什么都别管，先打开GoMOD，再配置代理\n在这里感谢「七牛云」为我们中国区的Golang开发者提供的代理服务\n12$ go env -w GO111MODULE&#x3D;on$ go env -w GOPROXY&#x3D;https:&#x2F;&#x2F;goproxy.cn,direct做到这2点后，我们现在就可以打开我们的VsCode（再次感谢七牛云，从此以后我们再也不用到Github以及Golang.org上clone到本地进行install了）\n查看GO相关的环境变量1go envGo项目结构在进行Go语言开发的时候，我们的代码总是会保存在$GOPATH/src目录下。在工程经过go build、go install或go get等指令后，会将下载的第三方包源代码文件放在$GOPATH/src目录下， 产生的二进制可执行文件放在 $GOPATH/bin目录下，生成的中间缓存文件会被保存在 $GOPATH/pkg 下。\n如果我们使用版本管理工具（Version Control System，VCS。常用如Git）来管理我们的项目代码时，我们只需要添加$GOPATH/src目录的源代码即可。bin 和 pkg 目录的内容无需版本控制。\n适合个人开发者我们知道源代码都是存放在GOPATH的src目录下，那我们可以按照下图来组织我们的代码。\n\n目前流行的项目结构Go语言中也是通过包来组织代码文件，我们可以引用别人的包也可以发布自己的包，但是为了防止不同包的项目名冲突，我们通常使用顶级域名来作为包名的前缀，这样就不担心项目名冲突的问题了。\n因为不是每个个人开发者都拥有自己的顶级域名，所以目前流行的方式是使用个人的github用户名来区分不同的包。\n\n举个例子：张三和李四都有一个名叫studygo的项目，那么这两个包的路径就会是：\n1import &quot;github.com&#x2F;zhangsan&#x2F;studygo&quot;和\n1import &quot;github.com&#x2F;lisi&#x2F;studygo&quot;以后我们从github上下载别人包的时候，如：\n1go get github.com&#x2F;jmoiron&#x2F;sqlx那么，这个包会下载到我们本地GOPATH目录下的src/github.com/jmoiron/sqlx。\n适合企业开发场景\nGo开发编辑器Go采用的是UTF-8编码的文本文件存放源代码，理论上使用任何一款文本编辑器都可以做Go语言开发，这里推荐使用VS Code和Goland。 VS Code是微软开源的编辑器，而Goland是jetbrains出品的付费IDE。\n我们这里使用VS Code 加插件做为go语言的开发工具。\nVS Code介绍VS Code全称Visual Studio Code，是微软公司开源的一款免费现代化轻量级代码编辑器，支持几乎所有主流的开发语言的语法高亮、智能代码补全、自定义热键、括号匹配、代码片段、代码对比 Diff、GIT 等特性，支持插件扩展，支持 Win、Mac 以及 Linux平台。\n虽然不如某些IDE功能强大，但是它添加Go扩展插件后已经足够胜任我们日常的Go开发。\n下载与安装VS Code官方下载地址：https://code.visualstudio.com/Download\n三大主流平台都支持，请根据自己的电脑平台选择对应的安装包。\n\n双击下载好的安装文件，双击安装即可。\n配置安装中文简体插件点击左侧菜单栏最后一项管理扩展，在搜索框中输入chinese ，选中结果列表第一项，点击install安装。\n安装完毕后右下角会提示重启VS Code，重启之后你的VS Code就显示中文啦！\n\nVSCode主界面介绍：\n\n安装go扩展现在我们要为我们的VS Code编辑器安装Go扩展插件，让它支持Go语言开发。\n\n变更编辑器主题依次点击设置-&gt;颜色主题，\n\n会弹出如下窗口：\n\n可以根据自己的喜好选择相应的主题。\n安装Go语言开发工具包在座Go语言开发的时候为我们提供诸如代码提示、代码自动补全等功能。\n在此之前请先设置GOPROXY，打开终端执行以下命令：\n1go env -w GOPROXY=https://goproxy.cn,directWindows平台按下Ctrl+Shift+P，Mac平台按Command+Shift+P，这个时候VS Code界面会弹出一个输入框，如下图：\n\n我们在这个输入框中输入&gt;go:install，下面会自动搜索相关命令，我们选择Go:Install/Update Tools这个命令，按下图选中并会回车执行该命令（或者使用鼠标点击该命令）\n\n在弹出的窗口选中所有，并点击“确定”按钮，进行安装。\n\n然后会弹出如下窗口，开始安装工具：\n\n喝口水，等待所有工具都安装成功，如下图所示:\n\n配置VSCode开启自动保存按下图依次点击 文件-&gt;首选项-&gt;设置，\n打开设置页面就能看到自动保存相关配置如下图，可以根据自己的喜好选择自动保存的方式：\n配置代码片段快捷键还是按Ctrl/Command+Shift+P,按下图输入&gt;snippets，选择命令并执行：\n然后在弹出的窗口点击选择go选项：\n然后弹出如下页面：\n大家可以简单看下上面的注释，介绍了主要用法：\n12345“这里放个名字”:&#123;    &quot;prefix&quot;: &quot;这个是快捷键&quot;,    &quot;body&quot;: &quot;这里是按快捷键插入的代码片段&quot;,    &quot;description&quot;: &quot;这里放提示信息的描述&quot;&#125;其中$0表示最终光标提留的位置。 举个例子，我这里创建了两个快捷方式，一个是输入pln就会在编辑器中插入fmt.Println()代码；输入plf，就会插入fmt.Printf(&quot;&quot;)代码。\n123456789101112&#123;\t&quot;println&quot;:&#123;\t\t&quot;prefix&quot;: &quot;pln&quot;,\t\t&quot;body&quot;:&quot;fmt.Println($0)&quot;,\t\t&quot;description&quot;: &quot;println&quot;\t&#125;,\t&quot;printf&quot;:&#123;\t\t&quot;prefix&quot;: &quot;plf&quot;,\t\t&quot;body&quot;: &quot;fmt.Printf(\\&quot;$0\\&quot;)&quot;,\t\t&quot;description&quot;: &quot;printf&quot;\t&#125;&#125;把上面的代码，按下图方式粘贴到配置文件中，保存并关闭配置文件即可。\n添加如上配置后，保存。 我们打开一个go文件，测试一下效果：\n文章源于[Q1mi](https://www.liwenzhou.com/posts/Go/00_go_in_vscode/)","plink":"https://dxsummer.gitee.io/posts/c876fc85/"},{"title":"GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床","date":"2020-05-12T08:29:03.000Z","date_formatted":{"ll":"2020年5月12日","L":"2020/05/12","MM-DD":"05-12"},"updated":"2020-06-08T01:53:12.000Z","content":"GitHub + jsDelivr + PicGo + Imagine 打造稳定快速、高效免费图床前言\n为什么要使用图床呢？\n\n因为在不同平台发布同一篇文章的时候，最一个痛苦的点就是，图片存储问题，各个平台的文件存储方式各不相同，无法直接 Ctrl + C 的方式一键搞定，为了解决这个问题，使用 MarkDown + 图床 的方式进行文章的写作，将图片放到一个统一的地方，在文章中引入图片外链。所谓图床，就是将图片储存到第三方静态资源库中，其返回给你一个 URL 进行获取图片。MarkDown 支持使用 URL 的方式显示图片，我想这也是程序员为什么对其偏爱的原因之一。作为程序员，你会发现，现在很多论坛和社区都开始支持使用 MarkDown，如果你没使用图床的情况下，你分享同一篇文章，你要在不同的平台，各自重新编辑排版一遍和上传图片一次。有了图床，情况就不一样了，Ctrl+C 的方式就搞定了，根本不用再 Check 文章内容一遍。\n\n图床的选择？\n\n微博图床：以前用的人比较多，从 2019 年 4 月开始开启了防盗链，凉凉\nSM.MS：运营四年多了，也变得越来越慢了，到了晚上直接打不开图片，速度堪忧\n其他小众图床：随时有挂掉的风险\nImgur 等国外图床：国内访问速度太慢，随时有被墙的风险\n大厂储存服务：例如七牛云、又拍云、腾讯云COS、阿里云OSS等，操作繁琐，又是实名认证又是域名备案的，麻烦，而且还要花钱（有钱又不怕麻烦的当我没说）\nGitHub 图床：免费，但是国内访问速度慢（不过没关系，利用 jsDelivr 提供的免费的 CDN 加速 速度足够了）\n使用流程新建 GitHub 仓库\n生成一个 Token\n配置 PicGo 并使用 jsdelivr 作为 CDN 加速\n使用 Imagine 进行图片压缩\n上传图片到 PicGo 并使用图床\n新建 GitHub 仓库登录/注册 GitHub\n新建一个仓库，填写好仓库名\n仓库描述\n将权限设置成 public\n根据需求选择是否为仓库初始化一个 README.md 描述文件\n\n新建 GitHub 仓库\n生成一个 Token点击用户头像 -&gt; 选择 Settings\n\nSettings\n点击 Developer settings\n\nDeveloper settings\n点击 Personal access tokens\n\nPersonal access tokens\n点击 Generate new token\n\nGenerate new token\n填写 Token 描述，勾选 repo，然后点击 Generate token 生成一个 Token\n\n填写 Token 描述\n获取 Token 密钥\n\n注意这个 Token 只会显示一次，自己先保存下来，或者等后面配置好 PicGo 后再关闭此网页\n\n\n获取 Token 密钥\n配置 PicGo 并使用 jsdelivr 作为 CDN 加速前往下载 PicGo（点击下载），安装好后开始配置图床\n设定仓库名：按照 用户名/图床仓库名 的格式填写\n设定分支名：master\n设定 Token：粘贴之前生成的 Token\n指定存储路径：填写想要储存的路径，如 img/，这样就会在仓库下创建一个名为 img 的文件夹，图片将会储存在此文件夹中\n设定自定义域名：它的的作用是，在图片上传后，PicGo 会按照自定义域名+上传的图片名的方式生成访问链接，放到粘贴板上，因为我们要使用 jsDelivr 加速访问，所以可以设置为https://cdn.jsdelivr.net/gh/用户名/图床仓库名\n\n配置 PicGo\nText\n123Q：什么是 jsdelivr ?A：jsDelivr 为开发者提供免费公共 CDN 加速服务使用 Imagine 进行图片压缩通常情况下，图片大小都是超过 200KB 的，所以网页加载的时候会特别慢，一般我们会对图片进行压缩，这里我推荐 Imagine（点击下载） 支持全平台。\n\n使用 Imagine 进行图片压缩\n\nImagine 采用的是有损压缩，介意的可以忽略这一步\n\n顺便推荐一个无损压缩的网站：https://tinypng.com/\n上传图片到 PicGo 并使用图床配置好 PicGo 后，我们就可以进行高效创作了，将压缩后的图片拖拽到上传区，将会自动上传并复制访问链接，将链接粘贴到博文中就行了，访问速度杠杠的\n\n上传图片到 PicGo 并使用图床\n此外 PicGo 还有相册功能，可以对已上传的图片进行删除，修改链接等快捷操作，PicGo 还可以生成不同格式的链接、支持批量上传、快捷键上传、自定义链接格式、上传前重命名等，更多功能自己去探索吧！\n文章源于\n[Sitoi](https://sitoi.cn/posts/39161.html)","plink":"https://dxsummer.gitee.io/posts/b6c34a37/"},{"title":"Step 2 了解英语中关键的关键—单词","date":"2020-05-11T09:36:38.000Z","date_formatted":{"ll":"2020年5月11日","L":"2020/05/11","MM-DD":"05-11"},"updated":"2020-06-28T03:26:38.000Z","content":"Day03形容词（含比较级&amp;最高级）形容词的用法\n形容词主要用来修饰名词或不定代词（some，no，every，all，each，both，much，many，（a）little，（a）few，other（s），another），表示人或事物的性质、状态和特征的词。形容词在句中作定语、补语及修饰从句等。例如：\nShe is a pretty girl.（她是一个漂亮的女孩。）He looks very happy.（他看起来很开心。）\n使用时机及用法定语：一般放在所修饰词的前面。\n\n动词补语：放在系动词后面。\n\n宾语补语：修饰句中宾语。\n\n副词从句：成为形容词短语从句，修饰主句。\n\n使用规则及要点修饰不定代词时置于其后：当形容词修饰由some-, any-, no-, every-这些字首所构成的不定代词时，形容词要放在这些不定代词之后。例如：\n\n There must be something wrong with my computer.（我的电脑出了点问题。）\n两个以上的形容词的顺序：\n当一个句子中，有两个以上的形容词用来修饰同一个名词时，其先后顺序为：（冠词＋数量＋性质＋大小＋形状＋新旧＋颜色＋国籍）＋名词。可背诵以下的例句辅助记忆：\n I have a beautiful little new white Chinese wooden table.（我有一张新的白色中式木桌，漂亮且小巧。）\n\n“The＋形容词”用来表示特定的人／物：\n用“The＋形容词”可用来表示特定的人或物，例如：the rich富人、the young年轻人、the old老人等。后面须接复数动词。\nWe should look after the old and love the young.（我们应该尊老爱幼。）\n\n\n两个以上形容词当定语置于最后：\n用and或or连接起来的两个形容词做定语时，一般把它们放在被修饰的名词后面，以进一步产生修饰作用。\nYou can take any dress, pink or blue.（你可以拿这两件裙子中的任何一条，粉红色或蓝色的都行。）\n\n\n修饰长宽高深及年龄置于名词之后：\n表示长、宽、高、深及年龄的形容词，应放在相应的名词之后。\nThe river is about two hundred meters long.（这条河大约两百米长。）\n\n\n形容词的比较级、最高级\n规则变化单音节词在字尾加-er / -est：单音节形容词在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：clean→cleaner→cleanest。\n\n单音节词以–e结尾在字尾加-r / -st：以–e结尾的单音节形容词，转变为比较级和最高级时，规则是在字尾加–r和–st。例如：wide→wider→widest。\n\n双音节（音节中含有两个元音音素，称为双音节单词；如：hello,alone,etc）词以-y, -er, -ow, -ble结尾在字尾加-er / -est：少数以-y, -er, -ow, -ble结尾的双音节形容词，在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：slow→slower→slowest。\n\n以-y结尾的形容词，去掉字尾-y加-ier / -iest：以–y结尾，但–y前是辅音字母的形容词的比较级和最高级是把-y去掉，加上–ier和-iest。例如：lonely→lonelier→loneliest。\n\n形容词字尾“辅元辅”重复字尾再加–er：当形容词或其字尾出现“辅音＋元音＋辅音”现象，也就是最后三个字母和音标的排列是“辅元辅”，在转变为比较级和最高级时，规则是要重复字尾，再加-er。例如：big→bigger→biggest。\n\n三音节词和多音节词，以more / most修饰：三个音节以上的形容词，则在其前加more / most，以形成比较级及最高级。另外注意，more / most后的形容词必须是原级。例如：beautiful→more beautiful→most beautiful。\n\n不规则变化\n比较级与最高级用法两个人或两种事物比较时，用比较级。\n 句型为“比较级＋than…”例如： Bob is taller than Jack.（鲍勃比杰克高。）\n\n三个或三个以上的人或事物比较，其中有一个在某一方面超过其他几个时，用最高级。\n 句型为“the＋最高级＋…in / of…”。例如： Bob is the tallest in his class.（鲍勃是他班上最高的。）\n\n表示双方程度相等时，用“…as＋形容词原级＋as…”句型，可译为“…和…一样”；表示双方程度不相等时，用“…not so / as＋形容词原级＋as…”句型，可译为“…和…不一样”或“…不如…”，例如：\n This box is as big as mine.（这个盒子和我的一样大。） He runs not so fast as me.（他跑得没我快。）\n\n表示“越来越……”可用“The＋形容词比较级……, the＋形容词比较级”。\n 例如：The more you study, the more you know.（你学习的越多，你就知道的越多。）\n\n表示程度越来越强，用“比较级＋and＋比较级”句型，可译为“越来越……”。例如：\n It is getting hotter and hotter.（天气变得越来越热。）\n\nmost同形容词连用，前面不加the，可表示极……，很……，非常……，十分……。例如：\n It’s most dangerous to be here.（在这儿实在很危险。）\n\n比较级前可以加副词修饰，以加强程度。例如：much, far, still, even, a lot, a little, a bit等等。例如：\n The rope is much longer than that one.（这条绳比那条绳长很多。）\n\n两者之间选择“哪一个更……”时，用句型“Which / Who＋is＋比较级，…or…?”，例如：\n Which is bigger, the sun or the moon?（太阳和月亮，哪一个更大？）\n\n表示“最……之一”时，用“one of＋the＋最高级”。例如：\n The light bulb is one of the most helpful inventions.（电灯泡是最有用的发明之一。）\n\n语法观念例句示范01．The sunset was a beautiful sight.日落是一种美丽的景象。\n02．He is the happiest man on earth.他是地球上最快乐的人。\n03．The film is boring.那个电影很枯燥。\n04．It’s an utter mystery.这完全是个迷。\n05．She looked embarrassed.她好像很尴尬。\n06．He is one of the greatest composers in the word.他是世界上最伟大的作曲家之一。\n07．It’s foolish of her to go alone.她单独出去太傻了。\n08．The black one is the more expensive of the two boxes.黑色的是这两个盒子当中最贵的。\n09．The more careful you are, the fewer mistakes you will make.你越仔细，犯的错误越少。\n10．Mountain climbing is one of the most dangerous sports.爬山是最危险的运动之一。\n语法观念辨析练习请选出正确的选项。\n01．The writer died before finishing his________book.\nA lateB laterC lastD latest.\n02．She got________that she couldn’t dance anymore.\nA very angrilyB too angrilyC too angryD so angry\n03．The sweater is very beautiful, but it’s________small.\nA too muchB much tooC manyD more\n04．She looks very________. I think she needs rest.\nA tiredB hardC wellD hardly.\n05．Lots of visitors come to visit Hamburg because she’s________city.\nA very a beautifulB quite a beautifulC so a beautifulD a quite beautiful\n06．- Which is________, the sun, the moon or the earth? —— Of course the moon.\nA smallB smallerC smallestD the smallest\n07．She isn’t so________at math as you are.\nA wellB goodC betterD best\n08．I have________to do today.\nA anything importantB something importantC important nothingD important something\n09．Mary writes________of the three.\nA betterB bestC goodD well\n10．My________brother is________than I.\nA elder, three years olderB older, olderC older, three years elderD elder, elder\n正确答案及题目译文：\n副词（含比较级&amp;最高级）副词主要用来修饰动词、形容词、其他副词或全句，用来说明时间、地点、程度、方式等概念的词。副词在句中主要作状语。副词可以分为时间副词、地点副词、方式副词、程度副词、频率副词等。\nShe speaks English quite well.（她英语说得相当好。）\n\nThey live frugally.（她们生活很节俭。）\n\n使用时机及用法\n使用时机及用法置于形容词前方，修饰形容词用。例如：\n\n置于动词前方，修饰动词用。例如：\n\n置于副词前方，修饰副词用。例如：\n\n置于介词短语前方，修饰介词短语用。例如：\n\n使用enough修饰形容词或其他副词时，置于被修饰词后方。例如：\n\n频率副词，例如：usually, always, often, never等，一般放在行为动词前，或是使役动词、助动词或be动词之后。例如：\n\n句中同时出现时间、地点的副词时，先地点再时间。\n\n某些副词形式相似，但要注意，两种形式的字义不同。例如：\n\nclose接近地←→closely仔细地，密切地\nwide广阔地，充分地←→widely广泛地\n副词的比较级、最高级副词和形容词一样有比较级和最高级。\n同级副词的比较→as＋原级＋as：\n\n比较级副词的比较→副词比较级＋than：\n\n最高级副词的比较→同形容词用法但不加the：\n\n副词的比较级与最高级规则变化：\n 同形容词，单音节词在字尾加-er / -est、以–y结尾的去掉字尾-y加-ier / -iest等。\n （速度）快地：fast→faster→fastest （时间）快地：soon→sooner→soonest （声音）大地：loud→louder→loudest\n\n副词的比较级与最高级常见之不规则变化：\n （程度）良好地：well→better→best （程度）不好地：badly→worse→worst （距离）远地：far→farther→farthest （时间）迟地：late→later→last （数量、程度）多地：much→more→most （数量、程度）少地：little→less→least （程度）糟糕地：poorly→worse→worst （程度）邪恶地：ill→worse→worst\n\n语法观念例句示范01．He knew London very well.他对伦敦很熟悉。\n02．You need to form the habit of reading carefully.你需要养成仔细阅读的习惯。\n03．Please listen to me carefully.请认真听我说。\n04．Her pronunciation is very good.她的发音很棒。\n05．He didn’t study hard enough.他学习不够刻苦。\n06．Tom looked at me suspiciously.汤姆怀疑地看着我。\n07．I sometimes stay up all night.我有时会熬夜。\n语法观念辨析练习请填入正确时态的副词。\n01．My purse was stolen on the bus yesterday.____(Fortunate), there was no money in it.\n02．He put on his coat and went out________(quick).\n03．It’s snowing hard. You must drive________(careful).\n04．I used to smoke________(heavy) but I give it up three years ago.\n05．What have you been doing________(late)?\n06．He thinks________(high) of my opinion.\n07．He is________(strong) enough to carry the heavy box.\n08．These oranges taste________(good).\n正确答案及题目译文：\n动词短语（不可分离vs．可分离）\n所谓的动词短语，是指由动词加上介词／副词所组成的短语。其短语意义有时与原先单独动词的字义不同，并且有多种字义。英语中的动词短语依照结构分为两种：不可分离的动词短语（动词＋介词），及可分离的动词短语（动词＋副词）。\n不可分离动词短语句型结构：（不及物）动词＋介词＋宾语\n不可分离动词短语中，常常是不及物动词连接介词，宾语必须接在后面。\n\n常见的此类动词短语有look after, look for, ask for, care about, laugh at, hear of等，所组成的动词短语字义通常不变。\nDon’t laugh at others.（不要嘲笑别人。）\nThey didn’t look after the children properly.（她们没有正确地照顾孩子们。）\n\n可分离动词短语句型结构：\n（及物）动词＋宾语＋副词\n\n（及物）动词＋副词＋宾语\n可分离动词短语是及物动词与副词可以被分开，并可以在中间加入宾语，也可以把宾语放在副词后面。\n\n\n副词改变原动词字义：\n可分离动词短语中的副词可置于动词后修饰动词，使得动词改变原本的意思，而产生新的字义。\n\n此类常见的动词短语有：give up, find out, think over, pick up, point out, hand in等。\n\n名词放在副词之前或之后：可分离动词短语中，如果宾语是名词，既可放在副词前面，又可放在副词后面。\n\n人称代名词、反身代词放介副词之前：可分离动词短语中，如果宾语是人称代名词或反身代词，则放在副词前面。\n\n语法观念例句示范01．The police are looking into the case.\n警察们在调查那件案子。\n02．They turned down my offer.\n他们拒绝了我的提议。\n03．Something unexpected has turned up.\n出现了令人意外的情况。\n04．This paper comes out once a week.\n这份报纸每星期出版一次。\n05．The meeting has been called off.\n会议被取消了。\n06．I filled in an application form.\n我填写了申请表。\n07．Mr. Ericsson, please put it down.\n艾瑞克森先生，请把东西放下来。\n08．Please don’t forget to hand it in.\n请不要忘了把它交上来。\n09．I can’t figure out why you said that.\n我不能理解你为什么那么说。\n10．I won’t let him down in any way.\n无论如何我是不会让他失望的。\n语法观念辨析练习01．没有人能够解释他的怪异行为。（account for）\n\n02．火车被大雾阻挡而晚点了。（hold up）\n\n03．我在公园等了她很长时间，但是她没有出现。（turn up）\n\n04．请勿践踏草坪！（keep off）\n\n05．如果我这次饶恕了你，你就能保证下次不会这么做了吗？（let off）\n\n06．不要把今天的事情拖到明天做。（pull off）\n\n07．别受骗上当。（take in）\n\n08．请关门。（shut off）\n\n09．你昨天买的这条裙子很漂亮，快穿上吧。（put on）\n\n10．明天早上记得叫我起床。（wake up）\n\n正确答案及题目译文：\n\nDay04系动词vs．感官动词\n系动词是用来补充描述和指明事物的，常用形容词来补充说明主语的不足，使得整句意思更完整，常用的系动词有seem, appear, look, feel, sound, taste, become, get, turn, smell, grow等；感官动词是表示人的感觉的动词，常见的感官动词有feel, hear, sound, see, taste, smell, look at等。\n系动词本质\n系动词是在主语和补语之间起连接功能的动词\n\n补语特性及句型结构\n系动词＋形容词\n\n系动词＋like＋名词\n\n系动词所连接的表语一般为形容词。若要连接名词时可以在系动词后加“like”，例如：\nThe story sounds interesting.（这个故事听起来很有趣。）\nIt sounds like an interesting story.（听起来是个有趣的故事。）\n\n状态的改变\n状态的改变：become, get, grow\nbecome, get, grow等系动词可用来表示“从一种状态变为另一种状态”，并且可以搭配使用进行时，表示（越来越……）。\nI am getting more and more tired.（我变得越来越累。）\n\n感官动词\n本质\n表达人类感受的动词。\n感官动词是表示人类感觉、感受的动词，故称为感官动词。可作完全及物动词或不完全及物动词，例如：listen to, hear, watch, see, feel等。\n   I feel sick today.（我今天觉得不舒服。）\n\n句型结构及特性\n不完全及物动词＋宾语＋动词原形→表示全部过程\n\n不完全及物动词＋宾语＋现在分词→表示正在进行的动作\n I saw the old lady cross the road.（我看到老太太过马路。）\n I saw the old lady crossing the road.（我看见老太太正在过马路。）\n\n\n被动语态\n   感官动词用于被动语态，“V原形”改为“to+V”：\n   感官动词用于被动语态，后面原有动词原形要改为带to的不定式，例如：\n   I hear the boy sing every day.\nThe boy is heard to sing every day.\n（我每天都听到那个男孩唱歌。）\n\n语法观念例句示范01．His suggestion sounds ridiculous.\n他的建议听起来很可笑。\n\n02．The soup tastes good.\n这汤的味道尝起来不错。\n\n03．He becomes lazy.\n他变懒了。\n\n04．She feels nervous before the exam.\n考试前她很紧张。\n\n05．It sounds like a good idea.\n听起来是个不错的主意。\n\n06．The weather usually turns cold in the end of August.\n天气通常在八月底开始变冷。\n\n07．You get fat again.\n你又变胖了。\n\n08．The weather is getting hotter every day.\n天气一天天越来越热了。\n语法观念辨析练习请将以下句子翻译为英语。\n01．我听到有人在唱歌。\n\n02．我昨天晚上觉得牙齿很痛。\n\n03．我看他进房间了。\n\n04．她长得像她妈妈。\n\n05．那时候他很开心。\n\n06．这款布料很柔顺。\n\n07．比赛越来越精彩了。\n\n正确答案及题目译文：\n\n动名词与不定式\n当一个句子中出现两个动词时，通常会用两种形式呈现。\n\n动名词：动词＋ing→具有动词及名词的特性，在句子中作为名词使用。\n\n\n不定式：to＋动词原形→具有名词、形容词和副词的特性，在句子中作为主语、补语及副词使用。\n\n动名词使用时机作为主语使用→置于句首：\n当动名词作为主语时，通常位于句首，例如：\nSeeing is believing.（眼见为实。）\n\n主语为动作→使用动名词：\n在英语语法中，若句子的主语为动作时，通常必须转化为动名词形式。例如：\nWalking to office is a best way to lose weight.（走路上班是减肥的最好方法。）\n\n动名词作补语使用，句子的主语通常为→\n无生命的名词，例如：\nMy favorite sport is playing tennis.（我最喜欢是运动是打网球。）\n以what引导的名词从句，例如：\nWhat I want is having a rest.（我想要的是好好休息一下。）\n\n作为宾语使用→可当动词宾语或介词的宾语：\n\n动词宾语：  英语中有些动词后面只能使用动名词作为宾语。这类动词常见的有：admit, advice, anticipate, appreciate, avoid, consider, delay, deny, dislike, enjoy, escape, excuse, fancy, favor, finish, imagine, include, keep, mind, miss, postpone, practice, prevent, propose, resist, risk, suggest等。例如：\nPlease pardon my disturbing you.（请原谅我打扰您了。）\nI suggest doing it in a different way.（我建议用不同的方法做。）\n\nTIPS!\n\n  连接在need, require, want之后的动词以动名词呈现时，表示被动意义。例如：\n  The car needs repairing.（这辆车需要修理。）\n\n介词的宾语：\n英语中有些连接在介词后面的动词需要以动名词的形式呈现。例如：\nShe is worring about discussing the new proposal with sales manager tomorrow very much.（她现在非常担心明天要跟业务经理讨论新方案。）\n\nTIPS!\n\n\n这类介词后面连接动名词的状况常常出现在特定介词短语中，例如：be afraid of, be careful of, talk about, worry about。\n5 .  作形容词使用→置于名词之前：\n动名词放在名词之前可作为修饰用形容词使用，例如：\n\n时态陈述句动名词→所表时间与主要动词时间一致或未来：\n陈述句动名词所表示的时间，与句中动词所表示的时间“一致或是表示未来”。例如：\nI am sure of his quitting.＝I am sure he will quit.\n（我很肯定他会辞职。）\n\n完成时动名词→所表示的时间比主要动词时间更早：\n完成时动名词所表示的时间，比句中动词所表示的时间“更早发生”。例如：\nI am sure of his having done so.＝I am sure that he has done so.\n（我很肯定他曾经这样做过。）\n\n不定式\n使用时机作为主语使用→置于句首：\n不定式做为主语使用时，一般表示具体的动作，常置于句首。例如：\nTo save time is to lengthen life.（节约时间就等于延长了人的生命。）\n\n作为补语使用→表示将来的动作：\n不定式作补语使用时，常表示将来的动作。而句中主语常常是表示意向、打算、计划的词，例如wish, idea, task, purpose, duty, job等。\nMy work is to clean the classroom every day.（我的工作是每天打扫教室。）\n\n置于系动词后→表示状态：\n不定式置于seem, appear, prove等系动词后面时，表示状态，例如：\nThis plan seems to be possible.（这个计划似乎是可行的。）\n\n作为宾语使用→可当动词宾语或限定介词的宾语：\n\n动词宾语：\n不定式常在下列动词后做宾语，例如afford, agree, apply, arrange, ask, attempt, beg, begin, care, choose, claim, consent, demand, decide, desire, determine, expect, fail, hope, hesitate, hate, intend, learn, like, manage, mean, neglect, offer, plan, prepare, pretend, promise, refuse, resolve, seek, tend, threaten, want等。\nHe promises to keep my secret.（他答应替我保守秘密。）\n\n限定介词之宾语：\n不定式通常不做介词的宾语。但是遇到but, except, besides, than, instead of, about这几个特殊介词，不定式可连接在后面作为宾语。例如：\nWe can do nothing but to wait.（除了等我们什么也做不了。）\n\n作为动词之后的宾语补语\n不定式常跟在下列动词之后做宾语补语：ask, advise, allow, beg, cause, compel, command, enable, encourage, expect, feel, force, find, hear, have, inform, invite, let, make, mean, notice, order, permit, persuade, remind, require, request, teach, tell, urge, watch, warn, watch等。\nThe teacher asked her to answer the question.（老师叫她回答问题。）\n\n\nTIPS!\n\n不定式在下列动词的后面做宾语补语时，需要省略to，例如feel, hear, listen to, let, have, make, look at, see, watch, notice, observe, help等，但是变成被动语态时，省略的to必须再补上。\nWhenever something is wrong with you, please do let me know.（无论什么时候你出问题了，请告诉我。）\n6．作副词使用\n修饰动词→表目的：\n不定式做副词修饰动词时，通常表示特定目的，或是表示出乎意料的结果。\nHe woke up to find everybody gone.\n（他起来后发现所有人都不见了。）→不定式表结果\n\n修饰形容词→表原因：\n不定式做副词修饰形容词时，通常表示原因，并且通常与以下表示感情的形容词连用：glad, sorry, proud, angry, ashamed, excited, disappointed, interested…\nI am sorry to hear this information.（我很遗憾听到这个消息。）→不定式表原因\n\n时态陈述句不定式→所表示的时间与主要动词一致\nI like to read newspaper.（我喜欢看报纸。）\n\n进行时不定式→所表示的时间与主要动词同时\nI am very glad to be work with you.（我很高兴能与你一同工作。）\n\n完成时不定式→所表示的时间比主要动词更早\nI am sorry to have kept you waiting so long.（很抱歉让你等这么久。）\n\n语态主动语态→主语是执行者\n句中不定式使用主动语态时，通常代表主语是该动作的执行者。例如：\nI am glad to attend your marriage.（我很高兴能出席你的婚礼。）\n\n被动语态→主语是承受者\n句中不定式使用被动语态时，通常代表主语是该动作的承受者。例如：\nHe didn’t like to be laughed at.（他不喜欢被人嘲笑。）\n\n延伸用法，事半功倍！动名词和不定式都可以做主语。不定式做主语表示具体的动作，动名词做主语则可以表示抽象或一般性的动作或情况。例如：\nTo play with fire will be dangerous.（玩火是非常危险的。）\n→ 指特定的人的具体动作\nPlaying with fire is dangerous.（玩火是非常危险的。）\n→ 泛指玩火\n\n在allow, advise, forbid, permit等动词后，以另一个动词作宾语时，要用动名词形式。但如果后面有名词、代名词作宾语时，需连接不定式。例如：\nYou don’t allow smoking here.（你不允许在这里抽烟。）\nI don’t allow you to smoke here.（我不允许你在这里抽烟。）\n\n语法观念例句示范01．Smoking may cause cancer.\n吸烟会致癌。\n\n02．It’s useless arguing about it.\n争论这件事没有意义。\n\n03．Her hobby is painting.\n她的爱好是绘画。\n\n04．Remember to tell him the news.\n记得告诉他这个消息。\n\n05．I don’t feel like going to the movie.\n我不想去看电影。\n\n06．To master a foreign language is really important nowadays.\n如今，掌握一门外语真的很重要。\n\n07．It’s kind of you to think so much of us.\n你为我们考虑这么多真是太好了。\n\n08．To see is to believe.\n眼见为实。\n\n09．You must learn to look after yourself.\n你必须自己学会照顾自己。\n\n10．I don’t know what to do next.\n我不知道接下来该怎么做。\n语法观念辨析练习请选出正确的选项。\n01．She can’t help________the house because her guests is about to come.\nA to clean\nB cleaning\nC cleaned\nD being cleaned\n\n02．It is difficult to get used________on the sofa.\nA sleep\nB to sleeping\nC slept\nD to sleep\n\n03．Though________money, his parents managed to send him to university.\nA lacked\nB lacking of\nC lacking\nD lacked in\n\n04．She pretended________me when I passed by.\nA not to see\nB not seeing\nC to not see\nD have not seen\n\n05．It’s no use________to get a bargain in the department store.\nA to except\nB excepting\nC wanting\nD you excepting\n\n06．After________for the job, you will be required to take a language test.\nA being interviewed\nB interviewed\nC interviewing\nD having interviewed\n\n07．It was unbelievable that the fans waited outside the gym for three hours just________a look at the sports stars.\nA had\nB having\nC to have\nD have\n\n08．I saw him________out of the room.\nA go\nB had gone\nC has gone\nD goes\n\n09．No one can avoid________by advertisements.\nA to be influenced\nB being influenced\nC influencing\nD having influence\n\n10．It was impolite of him________without________good-bye.\nA to leave, saying\nB leaving, to say\nC to leave, to say\nD leaving, saying\n\n正确答案及题目译文：\n\n连词\n功能连接单词\nlove and hate（爱和恨）\na difficult but worthy life（艰难却有价值的人生）\nneither the teacher nor his student（不是那位老师也不是他的学生）\n\n连接短语\nready to start and easy to finish（准备出发和容易完成）\n\n连接从句\nJohnny has not smoked since his daughter was born.（自从强尼的女儿出生后，他就没有抽过烟了。）\n\n使用分类并列连词\n此类连词有and, but, so, yet, still, either, or, neither, nor, than, either…or, neither...nor, not only...but also, as well as等。例如：\nI will do it right away and do it well.（我现在就做，而且我会把这件事做好。）\nShe agreed with Martin’s proposal, but she didn’t want to join his team.（她同意马丁的提案，但是她不想加入马丁的团队。）\n\n从属连词\n\n名词从属连词及从句\n可用来当主语和宾语，此类连词有whoever, whatever, who, whom, which, that, when, where, how, what, why, whether等。\nWhen mother finished the cake was a surprise.（妈妈完成蛋糕的时间是个惊喜。）\n→ 名词从句当主语\nMicheal joined the team which is leaded by his father.（迈克加入了由他爸爸领军的团队。）\n→ 名词从句当宾语\n\n形容词从属连词及从句\n可用来当主语补语和形容词，此类连词有who, whom, whose, which, that, when, where等。\nThe point is who did this.（重点是谁完成了这件事。）\n→ 形容词从句当主语补语\nThe old lady who has 5 dogs is my mother-in-law.（有五只狗的老太太是我的岳母。）\n→ 形容词从句当形容词\n\n副词从属连词及从句\n可以当副词使用或是引出副词从句，此类连词有after, as, although, because, before, if, since, though, until, when, whenever, while, wherever等。\nShe woke up after I left home.（我一出家门她就醒了。）\n→ 连词带出副词从句\n\n语法观念例句示范01．Air and water are indispensible for human beings.\n空气和水对人类来说必不可少。\n\n02．You may go, only come back early.\n你可以去，只是要早点回来。\n\n03．We should strike while the iron is hot.\n我们要趁热打铁。\n\n04．Where there is a will, there is a way.\n有志者，事竟成。\n\n05．We wouldn’t lose heart even if we should fail ten times.\n我们就是失败十次也不灰心。\n\n06．Now that you are all back, we’d better start the work right now.\n你们既然都回来了，我们最好马上就开始工作。\n\n07．Wherever you are, I will be with you.\n不管你到哪，我都会在你身边。\n语法观念辨析练习01　I was reading a newspaper________he came in.\nA as soon as\nB since\nC while\nD when\n\n02．Hurry up, ____you’ll be late for school.\nA and\nB but\nC so\nD or\n\n03．Excuse me for breaking in, ____I have some news for you.\nA so\nB and\nC but\nD yet\n\n04．____you’ve got a chance, you might as well make full use of it.\nA Now that\nB After\nC Although\nD As soon as\n\n05．The old man________lives in that old house is my uncle.\nA who\nB which\nC where\nD how\n\n06．One can’t learn a foreign language well________he studies hard.\nA because\nB though\nC unless\nD if\n\n07________you decide to take this job, you should try to make it a success.\nA Whatever\nB Unless\nC Whenever\nD If only\n\n08．I’ll accept any job________I don’t have to get up early.\nA lest\nB as long as\nC in case\nD though\n\n正确答案及题目译文：\n\nDay05介词介词。是用来表明单词与单词之间的各种关系，主要是用来引出具有名词作用的单词，例如名词、动名词、代名词及名词从句。\n\n种类简单介词→只有一个单词：\n简单介词是指只有一个单词的介词。例如：at, before, for, from, in, next, of, over, since, to, under, with等。\n\n合成介词→两个以上单词组成：\n合成介词是指由两个单词所合成的介词。例如：inside, into, out of, outside, upon, within, without等。\n\n双重介词→由两个介词组成：\n双重介词是指由两个介词所组成的介词。例如：according to（根据）、from behind（从……后面）、along with（与……一起）等。\n\n介词短语→由两个或以上的单词组成：\n介词短语是指由两个或以上的单词组成的短语。例如：at the end of（在……最后）、because of（由于）、by means of（以……为手段）、in case of（万一）、in need of（需要）、in front of（在……之前）、in spite of（尽管……还是）、instead of（代替）、owing to（由于）。\n\n使用时机表示时间→at, on, in, by, for, during, from, after\nat：用来表示特定的时间、节日、年龄等。例如：\nat night（在晚上）、at 5 p.m.（在下午五点）。\nI will meet you at 10 a.m. tomorrow morning.（明天早上10点见。）\n\non：用来表示某一天或星期几，指明具体的时间。例如：\non Friday（在礼拜五）、on the date you born（在你出生的那天）\nSarah’s birthday this year is on Saturday.（莎拉今年的生日是星期六。）\n\nin：用来表示一天中某段时间，指天、月、年、季节、周次等。\n例如：in the morning（在早上）、in Summer（在夏天）、in 1991（在1991年）\nI always like to go the beach in Summers.（每年夏天我都喜欢去海边。）\n\nby：表示“……的时候、到……、等到……，已经……”，用在日期、时间的“前面”，例如：by 5 o&#39;clock（到五点的时候）。\nPlease wait for my information. I will come back by 7 p.m.（请等待我的消息，我会在七点的时候回来。）\n\nfor：表示一段不明确的时间，指时间的长度，动作是断断续续的。例如：\nI have been living here for ten years.（我已经住在这里10年了。）\n\nsince：表示从过去某一时间点开始，到现在的一个时间点。例如：\nI have been living here since 2000.（我从2000年开始就住在这里了。）\n\nduring：在……期间。表示一段从开始到结束相当分明的时间片段。动作是规律性的持续，例如：\nHe swims every day during this summer.（在今年夏天，他每天都会游泳。）\n\nfrom：自从……。仅说明从什么时候开始，不说明某动作或情况持续多久，例如：\nI began to work from this morning.（我从今天早上就开始工作了。）\n\nafter：表示在……之后。如果后面接一段不明确的时间，就表示从过去某一段时间以后；如果后面接一个精确的时间点，表示从“某一时刻以后”。例如：\nMy mother was exhausted after 3 hour’s housework.（妈妈在做完三个小时的家务事之后十分疲惫。）\nWe’ll go out for a walk after dinner.（我们晚餐之后会出去散步。）\n\n\n表示地点→at, in, on\nat：在一个精确的点（point），表示地点、地方、位置，指范围较小的地方，或是特定的地点。例如：\nat the school’s front gate（在学校的前门）。\nat the same restaurant（在同一间餐厅）。\nTommy was waiting for you at the bus stop for almost 3 hours!\n（汤米已经在公车站等你等了快三个小时了！）\n\nin：表示在某个特定、有明显区域范围的空间之内（enclosed space），例如：in London（在伦敦）、in the garden（在花园里面）、in my bag（在我的包里）。\nIris has an important meeting at the World Trade Center in Bangkok.\n艾瑞斯在曼谷的世界贸易中心有一个重要的会议。\n\non：表示在一个位置或地点的上方（surface），例如：\non the wall（在墙上）、on the floor（在地板上）、on a page of the book（在这本书的一页上）。\nI live on the 8th floor at Wall Street in New York.（我住在纽约华尔街的八楼。）\n\n\n表示方位→above, over, below, under, in front of, in the front of\nabove：指“在……上方”，不强调是否垂直，与below相对，例如：\nThe bird is flying above my head.（这只鸟飞过了我的头上。）\n\nover：指“垂直”的上方，与under相对，但通常是指上面的物体从一边移动到另一边的情况。例如：\nThere is a bridge over the river.（有一条桥横越那条河。）\n\nbelow, under：都表示“在……下面”，但under在正下方，below不一定在正下方。\nThere is a ball under the chair.（有颗球在椅子下面。）\nMy new skirt came below my ankles.（我的新裙子到我的脚踝以下。）\n\nin front of / in the front of：都表示在……前面，但in front of指甲物在乙物之前，两个物体为各自独立的物体，反义词是behind（在……后面）；in the front of指甲物在乙物的“内部”，也就是乙物包含了甲物在内，反义词为at the back of（在……范围内的后面）。\nThere is a river in front of my house.\n（我家门前有一条小河。）→我家与小河各自独立，没有接触\nOur teacher stands in the front of the classroom.\n（我们老师站在教室的前面。）→老师在教室里面，但是站在教室的前面\n\n\n表示运动方向→along, across, through\nalong：表示“沿着……”，例如：along the river（沿着这条河）。\nJust walk along the street and you will find the bus stop.（只要沿着这条街一直走，你就会看到公共汽车站了。）\n\nacross：表示“横过……”，通常与“道路、河川、平原”等地点连用，例如：across the road（横越马路）。\nThe Wang’s just live across the street.（王氏一家人就住在这条街的对面。）\n\nthrough：表示“穿过……、穿越……”，指从物体内部穿过，例如：through the door（穿过门）。\nI saw Sandy through the window.（我透过玻璃窗看到了珊蒂。）\n\n\n表示在……之间→between, among\nbetween：指在两个人或事物之间，例如：\nbetween you and me（在你跟我之间）。\nMy boss divided all the profit between John and him.（老板把所有的利润分给了他和约翰。）\n\namong：指在三个或以上的人或物之间，例如：among all of us.\nMy boss divided all the profit among all of us.\n（我老板把所有的利润分给了我们所有人。）\n\n\n表示方法、手段、工具→by, with, in\nby：表示以……方法、手段或泛指某种交通工具。例如：\nI go to school by bus every day.（我每天都坐公共汽车上学。）\n\nwith：表示用……工具、手段，一般接具体的工具和手段，如：\nI cut the apple with knife.（我用刀子切开苹果。）\n\nin：表示用……方式，用～语言（语调、笔墨、颜色）等，例如：\nHe talks with me in English for 15 minutes every day.（他每天都用英语跟我说话15分钟。）\n\n\n表示原因→because, as, for\nbecause：表示直接的、明确的原因，用来回答why的问句。例如：\nHe was late for school, because he didn’t catch the bus.\n（他上学迟到了，因为他没有赶上公共汽车。）\n\nas：表示由于……，鉴于……，指一种显而易见、谈话双方已知的理由。如：She stayed at home as she was ill.（她待在家，因为她生病了。）\n\nfor：表示由于、因为，指一种间接原因，甚至只是一种附带的说明。例如：\nIt must have rained last night, for the road is wet.（昨天晚上一定下雨了，因为路是湿的。）\n\n\n语法观念例句示范01．He is intent on winning.\n他一心只想着赢。\n\n02．Joe was very disappointed at not finding her at home.\n乔伊发现她不在家很失望。\n\n03．I shall prevail on him to make the attempt.\n我将说服他试一试。\n\n04．We concentrated on doing one job at a time.\n我们集中精力一次做一份工作。\n\n05．I don’t wish to break in on your thoughts.\n我不是有意打断你的思绪的。\n\n06．He achieved his aim by force of sheer determination.\n他完全凭决心达到了他的目标。\n\n07．Such irresponsible conduct can only work to the prejudice of our cause.\n这种不负责任的行为只会有损于我们的事业。\n\n08．He is working hard now with an eye to the future.\n他为了前途而现在努力工作。\n\n09．In the event of an accident, the police must be called at once.\n如果出了事故，应该立刻叫警察。\n\n10．She was cheated out of 1,000 dollars by the young man.\n她被一个年轻男人骗走了1000美元。\n语法观念辨析练习请填入适合题目句中底线的介词。\n01．Please don’t get mad________me. I was only trying to help.\n02．Fruit is rich________vitamins.\n03．John was impatient________his daughter.\n04．Cathy was particular________the jewelry she wore.\n05．The jury decided that Susan was guilty________murder.\n06．The word derives________Latin.\n07．Everyone blamed you________a certain mistake, you need to say something.\n08．This water taste________salt.\n09．It’s rude to point________someone.\n10．I’ll find someone to fill in this formula________you.\n正确答案及题目译文：\n\n短语短语是指由两个或两个以上的英语单词所组合的词语，其中不包含主语和动词，连在一起具有类似一种词类作用的字群。\n\n名词短语名词短语如同名词，可做句子中的：\n主语 \n（让我失望是你做过的最糟糕的事情。）\n\n及物动词的宾语\n \n\n介词的宾语\n \n\n形容词短语形容词短语如同形容词，用以修饰句中的名词，置于所修饰的名词之后由于形容词能修饰名词，而名词又能做句子的主语、宾语、表语等，所以形容词短语具有修饰主语、宾语、表语的功能。\n修饰主语\n\n  （坐在你身后的女孩是我最好的朋友。）\n修饰宾语\n \n （公司把工作交给最有经验的人。）\n\n修饰主语补语\n \n （这是一本有许多趣味故事的书。）\n\n副词短语副词短语如同副词，用来修饰句中的动词、形容词、副词和整句。\n修饰动词\n \n\n修饰形容词\n \n （很抱歉要你等这么久的时间。）\n\n修饰副词\n \n\n动词短语动词短语是由动词加上副词所形成，这些副词常见的有up, down, in, out, on, off…。\n宾语为名词时→放在短语之后或是中间，例如：\ntake off the coat或take the coat off。\n\n宾语为代名词时→放在短语中间，例如：put it up。\n\n介词短语介词短语就是介词和宾语连在一起，当形容词或副词用。\n当形容词用，修饰主语：\n \n （棕色头发的男孩正在那儿踢足球。）\n\n当副词用，修饰动词：\n \n\n语法观念例句示范01．I will call on you next Sunday.\n我下个星期天会去拜访你。\n\n02．I want to run some errands.\n我要去办点杂事。\n\n03．There is a bunch of books in my living room.\n我的客厅里有一堆书。\n\n04．He pulled an all-nighter last night.\n他昨晚熬夜了。\n\n05．They hang out a lot.\n他们常在一起。\n\n06．Above all, we must finish the work at hand.\n最重要的是，我们必须把手上的工作完成。\n\n07．As a matter of fact, I’m a very efficient worker.\n事实上，我是个做事非常有效率的员工。\n\n08．I will go with the chicken noodle soup.\n我会选择鸡肉汤面。\n\n09．Take a little more money with you, just in case.\n多带一点钱在身上，以备不时之需。\n\n10．You’ve said a lot, but nothing was to the point.\n你说了很多，但都没有说到重点。\n语法观念辨析练习请将题目句翻译成英语。\n01．我们为何不停车，下车一会儿呢？\n\n02．在你出门前把帽子带上。\n\n03．请打开灯，这里太暗了。\n\n04．我只能一天一天的等待奇迹的发生。\n\n05．关于那份新的工作，你接到公司的通知了吗？\n\n06．我相信这个产品会非常畅销。\n\n07．你必须准时赶到约定的地方。\n\n08．请千万小心，别让小孩靠近马路。\n\n09．警察正在调查电脑失窃的案件。\n\n10．没有证据可以证明我是被陷害的。\n\n正确答案及题目译文：\n\n","plink":"https://dxsummer.gitee.io/posts/2f6cae91/"},{"title":"Butterfly主题更新总结","date":"2020-05-08T06:33:23.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:49:56.000Z","content":"本文仅记录一些看似无意义的小改动，你可以在本文 get：\n1. 各种自定义样式的`路径`\n2. 如何自定义字体和文字色块\n3. 如何增加评分的小星星\n4. 插件的总结等…\n对于没学过任何 CSS 的我能改成这样实属不易，还望各位大佬指出我的错误~~并五星好评~~。修改主题，先装依赖出现报错，未安装渲染依赖！\n执行以下命令\n1npm install hexo-renderer-pug hexo-renderer-stylus --save菜单栏设置新版本默认是中文，但是修改根目录配置文件的 language 为 zh-CN 之后，菜单栏会变回英文。直接修改主题配置文件 menu 为中文即可\n123456menu:  首页: &#x2F; || fa fa-home  归档: &#x2F;archives&#x2F; || fa fa-archive  标签: &#x2F;tags&#x2F; || fa fa-tags  分类: &#x2F;categories&#x2F; || fa fa-list-ul  友链: &#x2F;link&#x2F; || fa fa-cogs\n首页留空表示跳转起始页，若加上 /home/ 则为新页面，类似分类标签页\n\n菜单栏跳转外链，去掉 / 直接写链接即可\n\n1云盘 || http:&#x2F;&#x2F;kd.xiabor.com || fa fa-mixcloud文章主页描述关闭自动节选，才能在 Page Front-matter 中添加 description\n1234# 自動節選auto_excerpt:  enable: false  length: 150代码高亮及自动换行代码高亮试了其他的插件，Mac Pannel 样式等，调来调去还不如默认的，索性不改了\n\n打开自动换行code_word_wrap: true，根目录下配置文件_config.yml，將 line_number 改成 false:\n12345highlight:  enable: true  line_number: false  auto_detect: false  tab_replace:事实证明，代码换行在移动端很不舒服，还是关掉吧。\n\n主题美化取消主题配置文件 theme_color 的注释\n自定义主色调为浅绿，设置 footer 显示图片背景与 top_img 一致。\n推荐文章设置 limit: 3\n打开图片文字描述 photofigcaption: true\n设置评论区打字冒光和抖动效果，activate_power_mode: true\n鼠标点击出现爱心 click_heart: true\n美化页面展示，修改标题前图标为闪电 title-prefix-icon:&#39;\\f0e7&#39;，颜色为黄色 title-prefix-icon-color: &quot;#ffb821&quot;\n主页调用金山词霸的每日一句打字效果，需注意的是：自定义副标题 sub 的时候，符号必须用 ASCII 码表示，常用的逗号为 , 句号为 . 双引号为 &quot; 英文缩写符号为 &#39;\n打开 snackbar 弹窗并设置底部居中 position: bottom-center\n打开中英文之间添加空格 pangu: true\n至此主题配置文件在不装插件前提下算是修改完毕了，明天继续折腾插件和 css 样式。眼睛疼，睡了自定义样式修改菜单字体大小为 18，修改鼠标悬停时颜色为主色调浅绿。\n在路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\head.styl 下查找.site-page，设置 font-size 为.7rem\n在此目录下 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl 新增自定义颜色值 $laurel-green = #9fefaf，在路径下修改 &amp;:hover: $laurel-greenhexo clean &amp;&amp; hexo s 查看效果\n\n由于菜单打开子菜单是悬停后选中，鼠标移开子菜单便关闭。导致鼠标如果不是从主菜单近乎垂直往下滑就无法点击子菜单。（改动意义似乎不大）自定义修改参考旧版本如下：路径 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl\n1234567891011121314151617181920212223.menus_item_child        position: absolute        right: 0        display: none        margin-top: 8px        padding: 0        border-radius: 5px        width: max-content        background-color: alpha($white, .8)        box-shadow: 0 5px 20px -4px rgba($dark-black, .5)        animation: sub_menus .3s .1s ease both        &amp;:before          position: absolute          top: -55px          left: 50%          width: 0          height: 21px          content: &#39;&#39;          margin-left: -18px          border-width: 18px          border-style: solid          border-color: transparent transparent rgba($white 0.8)\n主页文章区域，路径均为 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\pagination.styl\n外圆角修改为 5px，且图片与描述圆角为 3px\n\n主页文章描述修改，增加描述区域高度，标题距离描述适当增加，字体由 1.2 调整至 1rem\n123456789101112131415161718&amp; &gt;.recent-post-info  display: inline-block  overflow: hidden  padding: 50px 40px  width: 55%  &amp; &gt; .article-title    display: -webkit-box    overflow: hidden    margin-bottom: 1.2rem    color: $font-black    text-overflow: ellipsis    word-wrap: break-word    font-size: 1.2rem    line-height: 1.5    transition: all .2s ease-in-out    -webkit-box-orient: vertical    -webkit-line-clamp: 2\n描述文字可能较多，因此调整溢出方式为 scroll\n1234567display: -webkit-boxoverflow: scrollmargin-top: .2remheight: 97pxword-break: break-word-webkit-line-clamp: 3-webkit-box-orient: vertical\n并适当降低侧栏滚动条宽度，-webkit-scrollbar 路径为 D:\\blog\\themes\\Butterfly\\source\\css\\_global\\index.styl\n\n调整分类和发表时间字体大小为 80%，路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\page.styl\n12&amp; &gt; .article-meta-wrap      font-size: 80%\n\n\n调整移动端主页文章区域边距 5px 为 0.75rem，调整移动端描述字体大小为 0.6rem\n1234567@media screen and (max-width: $sm)    .layout_page      padding: 1rem 0.75rem !important      .content        height: auto        font-size: 0.6rem\n既然要圆润，那就全部都要圆润。调整页码圆角，算了，直接改成圆形。路径为 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\pagination.styl\n1234567891011121314.page-number  display: inline-block  margin: 0 .2rem  min-width: w &#x3D; 1.5rem  height: w  text-align: center  line-height: w  cursor: pointer&amp;.current  background: $theme-color  color: $button-color  cursor: default  border-radius: 20px\n调整页脚高度，去除驱动和主题描述，，修改 By 字母为红色爱心。\n在路径D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug下，将 By 替换为以下内容\n1&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;\n同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n12345678.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly\n利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n\n\n修改侧栏设置及返回顶部按钮\n在路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\rightside.styl下加大按钮高宽度并设置圆角，调整间距，使设置按钮的子菜单不打开状态隐藏到最右侧不可见。\n1234567891011121314151617181920212223242526#rightside  position: fixed  right: -38px  bottom: 10px  opacity: 0  transition: all .3s  #rightside-config-hide    transform: translate(40px, 0)&amp; &gt; div  &amp; &gt; i,  &amp; &gt; a,  &amp; &gt; div    display: block    margin-bottom: 2px    width: 36px    height: 36px    background-color: $light-blue    color: $button-color    text-align: center    font-size: 16px    line-height: 35px    margin-bottom: 4px    margin-right: 4px    cursor: pointer    border-radius: 3px\n\n文章目录美化\n调整左侧边距 0.5rem 为 2rem\n\n选择某一目录时，背景框宽度为最大且为方形，修改选中时边框为圆润且适应标题长度，路径D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\sidebar.styl下修改或增加以下内容\n12345678910.toc-link  &amp;.active    border-right-color: darken($theme-toc-color, 20%)    background: $theme-toc-color    color: $sidebar-active-color    border-radius: 5px    width: max-content    padding-right: 5px    padding-left: 5px\n\n打赏按钮美化，设置圆角并修改颜色，调整赞赏码大小确保能扫描成功\n路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\reward.styl 下修改赞赏码大小，默认 130，扫描可能无法识别，建议 200。\n\n修改底部标签边框和字体为黑色，调整大小。底部版权声明增加 1px 边框\n路径 D:\\blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下修改以下内容\n12345678910111213141516171819202122232425&amp;__tags   display: inline-block   margin: .4rem .4rem .4rem 0   padding: 0 .6rem   width: fit-content   border: 2px solid $font-black   border-radius: .2rem   color: $font-black   font-size: 14px   text-decoration: overline   cursor: pointer   transition: all .2s ease-in-out  .post-copyright   position: relative   margin: 2rem 0 .5rem   padding: .5rem .8rem   border: 1px solid $dark-white   transition: box-shadow .3s ease-in-out   border-radius: 5px   .post-copyright     &amp;-meta       color: $grey       font-weight: bold\n提到版权申明，修改默认的灰色链接的颜色为蓝色。可以先在 D:\\blog\\themes\\Butterfly\\source\\css\\var.styl 里添加自定义颜色，再去 post.styl 里修改，或者直接修改链接颜色为蓝色。修改其他自定义颜色的方法亦是如此。\n1$a-link-color &#x3D; #638fff版权声明\n\n文章作者: xx\n文章链接: https://xxx\n版权声明：本博客所有文章除特别声明外，均采用 CC BY-NC-SA 4.0 许可协议。\n\n点击这部分的文章作者出现 mailto:undefined，查看 copyright.pug 文件发现 email 需要在根目录 config.yml 下自定义\n因此在根目录 config.yml 下添加即可\n1email: xxxx@xxx.com\nRating 评分评价文章打字麻烦？那就用小星星吧，直接给文章打分。效果如下：\n配置教程：参考学姐的添加 Rating 投票功能\n官网传送门：widgetpack.com\n由于 butterfly 主题和 next、Sakura 等主题文件结构不同，所以详细记录本主题的配置：\n注册完 Widgetpack 选择 Rating 可以拿到一段代码如下：\n123456789101112131415&lt;div id&#x3D;&quot;wpac-rating&quot;&gt;&lt;&#x2F;div&gt;  &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;  wpac_init &#x3D; window.wpac_init || [];  wpac_init.push(&#123;widget: &#39;Rating&#39;, id: 你的IDxxx&#125;);  (function() &#123;      if (&#39;WIDGETPACK_LOADED&#39; in window) return;      WIDGETPACK_LOADED &#x3D; true;      var mc &#x3D; document.createElement(&#39;script&#39;);      mc.type &#x3D; &#39;text&#x2F;javascript&#39;;      mc.async &#x3D; true;      mc.src &#x3D; &#39;https:&#x2F;&#x2F;embed.widgetpack.com&#x2F;widget.js&#39;;      var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(mc, s.nextSibling);  &#125;)();  &lt;&#x2F;script&gt;  &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;widgetpack.com&quot; class&#x3D;&quot;wpac-cr&quot;&gt;Star Rating WIDGET PACK&lt;&#x2F;a&gt;利用在线转化将其转为.pug 格式，并增加点小改动，使其居中。创建并放入目录 D:\\blog\\themes\\Butterfly\\layout\\includes\\addons\\rating.pub 中\n1234567891011121314151617htmlbody  #wpac-rating(align&#x3D;&quot;center&quot;)  script(type&#x3D;&quot;text&#x2F;javascript&quot;).    wpac_init &#x3D; window.wpac_init || [];    wpac_init.push(&#123;widget: &#39;Rating&#39;, id: 你的ID&#125;);     (function() &#123;    if (&#39;WIDGETPACK_LOADED&#39; in window) return;    WIDGETPACK_LOADED &#x3D; true;    var mc &#x3D; document.createElement(&#39;script&#39;);    mc.type &#x3D; &#39;text&#x2F;javascript&#39;;    mc.async &#x3D; true;    mc.src &#x3D; &#39;https:&#x2F;&#x2F;embed.widgetpack.com&#x2F;widget.js&#39;;    var s &#x3D; document.getElementsByTagName(&#39;script&#39;)[0]; s.parentNode.insertBefore(mc, s.nextSibling);    &#125;)();  #copy(align&#x3D;&quot;center&quot;)    | ღ喜欢记得五星好评哦~\n在合适位置引入评分，例如我的：（置于赞赏的上面）\n12345if theme.rating.enable  include includes&#x2F;addons&#x2F;rating.pug&#x2F;&#x2F;-加入以上代码，下面为赞赏    if theme.reward.enable  !&#x3D;partial(&#39;includes&#x2F;post&#x2F;reward&#39;, &#123;&#125;, &#123;cache:theme.fragment_cache&#125;)\n最后，在主题配置文件设置是否打开该功能，星星颜色在 widgetpack.com 修改\n1234# Star rating support to each article.# To get your ID visit https:&#x2F;&#x2F;widgetpack.comrating:   enable: true\n\n特别提示：设置投票记录方式，有三种可选，国内最好选择 IP Address 记录。另外，widgetpack.com 只能绑定一个域名，但可以随时更换\n\n\n特别鸣谢 @GamerNoTitle，一提需求，立马奋笔疾书教我配置小星星。还回来看我文章并指出错误，佩服大佬的细心与热心。\n\n自动切换夜间模式时间修改夜间模式自动切换时间为晚上 21 点至早晨 7 点，路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\head，修改时注意格式不变\n移动端优化PC 端分类归档标签等是显示在右侧，移动端则在底部，与侧栏重复，因此去除分类标签归档个人信息，只保留网站统计。将以下代码添加进任意.styl文件里即可。效果如图（补充：调整移动端底部网站资讯字体大小为 13px）\n12345@media screen and (max-width: $sm)  #aside_content    div:not(:last-child)      display: none      font-size: 13px\n\n手机端侧栏美化，缩小头像及菜单间距。路径 D:\\blog\\themes\\Butterfly\\source\\css\\mobile-sidebar.styl 下自行调整\n在路径 post.styl 下调整移动端.post_cover 圆角为 5px\n调整移动端文章字体大小在D:\\blog\\themes\\Butterfly\\source\\css\\var.styl下自定义一个字体大小值，例如：$font-media-size = 13px，然后在D:\\anewblog\\themes\\Butterfly\\source\\css\\_global\\index.styl增加以下内容\n123@media screen and (max-width: $sm)body    font-size: $font-media-size &#x3D; 13px\n侧栏自定义加入书签按钮设置圆角aside.styl\n123456789#bookmark-it  position: relative  z-index: 1  display: block  background-color: $light-blue  color: $button-color  text-transform: uppercase  line-height: 1.6rem  border-radius: 5px\n顺便设置选中时的圆角D:\\blog\\themes\\Butterfly\\source\\css\\_global\\index.styl\n123456789101112.button--animated  transition-duration: 1s  transition-property: color  &amp;:before    position: absolute    top: 0    right: 0    bottom: 0    left: 0    z-index: -1    border-radius: 5px\n修改某些名称，例如网站资讯的名称在 D:\\blog\\themes\\Butterfly\\languages\\zh-CN 下修改即可\n\n自定义字体，图标引用外部字体和鼠标样式引用格式\n123@font-face &#123; font-family:MyFont;src: url(https:xxx)&#125;body&#123;font-family:MyFont!important;&#125;\n引用方法：将引用代码添加到 D:\\blog\\themes\\Butterfly\\source\\css\\_third-party\\normalize.min.css 末尾即可，鼠标样式亦是如此。\n\n鼠标样式引用格式\n12body &#123; cursor: url(https:&#x2F;&#x2F;xxx.png),default;&#125;a:hover &#123; cursor: url(https:&#x2F;&#x2F;xxx.png),pointer;&#125;\n修改图标可直接使用 Font Awesome 的图标。地址：Font Awesome\n\n在路径 D:\\anewblog\\themes\\Butterfly\\layout\\includes\\mixins\\UI.pug不对等我找找。第二天找到了正确的路径为 D:\\anewblog\\themes\\Butterfly\\layout\\includes\\header 可修改文章内头部（发表、更新、分类等）图标。\n12345678910111213141516#post-meta  .meta-firstline    if (theme.post_meta.post.date_type)      if (theme.post_meta.post.date_type &#x3D;&#x3D;&#x3D; &#39;both&#39;)        time.post-meta__date          span.post-meta__date-created(title&#x3D; _p(&#39;post.created&#39;)+&#39; &#39;+full_date(page.date))            i.fa.fa-pencil(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;&#39; &#39;+_p(&#39;post.created&#39;)+&#39; &#39;+date(page.date, config.date_format)          span.post-meta__separator |          span.post-meta__date-updated(title&#x3D; _p(&#39;post.updated&#39;)+&#39; &#39;+full_date(page.updated))            i.fa.fa-wrench(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;&#39; &#39;+_p(&#39;post.updated&#39;)+&#39; &#39;+date(page.updated, config.date_format)      else        - var data_type_update &#x3D; theme.post_meta.post.date_type &#x3D;&#x3D;&#x3D; &#39;updated&#39;        - var date_type &#x3D; data_type_update ? &#39;updated&#39; : &#39;date&#39;        - var date_icon &#x3D; data_type_update ? &#39;fa-wrench&#39; :&#39;fa-pencil&#39;\n修改主页文章的分类和发表时间图标，在路径 D:\\anewblog\\themes\\Butterfly\\layout\\includes 下修改即可\n12345678910111213141516if (theme.post_meta.page.date_type)      if (theme.post_meta.page.date_type &#x3D;&#x3D;&#x3D; &#39;both&#39;)        time.post-meta__date          span.post-meta__date-created(title&#x3D;_p(&#39;post.created&#39;) + &#39; &#39; + full_date(article.date))            i.fa.fa-pencil(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;date(article.date, config.date_format)          span.article-meta__separator |          span.post-meta__date-updated(title&#x3D;_p(&#39;post.updated&#39;) + &#39; &#39; + full_date(article.updated))            i.fa.fa-wrench(aria-hidden&#x3D;&quot;true&quot;)            &#x3D;date(article.updated, config.date_format)      else        - var data_type_updated &#x3D; theme.post_meta.page.date_type &#x3D;&#x3D;&#x3D; &#39;updated&#39;        - var date_type &#x3D; data_type_updated ? &#39;updated&#39; : &#39;date&#39;        - var date_icon &#x3D; data_type_updated ? &#39;fa-wrench&#39; :&#39;fa-pencil&#39;        - var date_title &#x3D; data_type_updated ? _p(&#39;post.updated&#39;) : _p(&#39;post.created&#39;)        time.post-meta__date(title&#x3D;date_title + &#39; &#39; + full_date(article[date_type]))\n例如修改主页底部向下箭头为双箭头，先去 Font Awesome 找到合适的图标，新版在路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\header\\index.pug 的末尾修改\n12.scroll-down  i.fa.fa-angle-double-down.scroll-down-effects旧版在路径 H:\\blog\\themes\\Butterfly\\layout\\includes\\nav.pug 下修改\n\n文章内引用图标，格式如下\n1&lt;i class&#x3D;&quot;fa fa-plane&quot;&gt;&lt;&#x2F;i&gt;\n插件总结搜索插件采用本地搜索，安装插件 hexo-generator-search\n1npm install hexo-generator-search --save\n根目录配置文件添加以下内容，打开主题配置文件 local_search 即可\n1234search:  path: search.xml  field: post  content: true字数统计安装统计插件，主题配置文件打开 wordcount 即可\n1npm install hexo-wordcount --save音乐电影豆瓣插件\n安装 hexo-douban 插件\n1npm install hexo-douban --save\n并将以下内容加入根目录配置文件，hexo douban 命令进行初始化\n12345678910111213douban:  user: mythsman  builtin: false  book:    title: &#39;This is my book title&#39;    quote: &#39;This is my book quote&#39;  movie:    title: &#39;This is my movie title&#39;    quote: &#39;This is my movie quote&#39;  game:    title: &#39;This is my game title&#39;    quote: &#39;This is my game quote&#39;  timeout: 10000\n\n播放器插件在 Hexo 页面中嵌入APlayer 播放器\n1npm install --save hexo-tag-aplayer\n用法：参数选项详见 APlayer\n1&#123;% aplayer title author url [picture_url, narrow, autoplay, width:xxx, lrc:xxx] %&#125;\n部署插件安装安装 hexo-deployer-git, 填写仓库就可以部署至网络世界啦\n1npm install hexo-deployer-git --save\n置顶插件\n文章置顶\n\n要为文章置顶，你需要安装插件(hexo-generator-index-pin-top 或者 hexo-generator-indexed)，记得先卸载掉hexo-generator-index\n如果使用hexo-generator-index-pin-top, 在文章的front-matter区域里添加top: true属性来把这篇文章置顶\n如果使用hexo-generator-indexed, 在文章的front-matter区域里添加sticky: 1属性来把这篇文章置顶。数值越大，置顶的优先级越大\n方法1\n- 卸载替换置顶插件\n  12npm uninstall hexo-generator-index --save npm install hexo-generator-index-pin-top --save\n在文章的 front-matter 添加 top: true或数值将篇文章置顶方法2\n如果使用`hexo-generator-indexed`, 在文章的`front-matter`区域里添加`sticky: 1`属性来把这篇文章置顶。数值越大，置顶的优先级越大脚注插件这个插件是最容易忘记的，还好看到文章里有注脚脚注，执行以下命令安装注脚插件：\n1npm install hexo-reference --savenew page\nhexo new page xxx\n\n版本更新后建议页面重新建立，再复制 md 内容进去，否则容易报错。出现报错的页面有 music、photo，为什么新建页面一模一样的 md 复制进去就不报错了呢？\n设置页面顶部图photo、music、link 页面均在相应 md 文件内增加 top_img，设置顶部图。其余在主题配置文件设置即可。\n不常见问题侧栏目录消失卸载原有的渲染插件，安装新的插件\n123npm un hexo-renderer-marked --savenpm i hexo-renderer-markdown-it --save\n菜单栏消失更新产生的问题，将_data 的 butterfly.yml 移动到其他地方，重新 hexo clean&amp;&amp;hexo s，在将主题配置文件拷贝替换 butterfl.yml 即可。\n底部去除驱动和主题描述，，修改 By 字母为红色爱心在路径D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug下，将 By 替换为以下内容\n1&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;\n同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n12345678.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly\n利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n\n","plink":"https://dxsummer.gitee.io/posts/d1a5291c/"},{"title":"hexo博客添加live2d看板娘","date":"2020-05-08T05:12:15.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:51:40.000Z","content":"下载安装检测npm版本是否最新\n1npm -v\nnpm更新方法:\n\n1nmp install npm@latest -g安装hexo-helper-live2d进入hexo目录下\n1npm install –save hexo-helper-lived打开hexo目录下的_config.yml的配置文件\n配置\n将以下代码添加到站点配置文件末尾\n\n123456789101112131415161718192021222324252627282930313233  # Live2D## https:&#x2F;&#x2F;github.com&#x2F;EYHN&#x2F;hexo-helper-live2dlive2d:  enable: true  # scriptFrom: jsdelivr # jsdelivr CDN  # scriptFrom: unpkg # unpkg CDN  # scriptFrom: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget@3.x&#x2F;lib&#x2F;L2Dwidget.min.js # 你的自定义 url  # use: wanko # 博客根目录&#x2F;live2d_models&#x2F; 下的目录名  # use: .&#x2F;wives&#x2F;wanko # 相对于博客根目录的路径  # use: https:&#x2F;&#x2F;cdn.jsdelivr.net&#x2F;npm&#x2F;live2d-widget-model-wanko@1.0.5&#x2F;assets&#x2F;wanko.model.json # 你的自定义 url  # enable: false  scriptFrom: local # 默认  pluginRootPath: live2dw&#x2F; # 插件在站点上的根目录(相对路径)  pluginJsPath: lib&#x2F; # 脚本文件相对与插件根目录路径  pluginModelPath: assets&#x2F; # 模型文件相对与插件根目录路径  model:    use: live2d-widget-model-ni-j # npm-module package name    scale: 1    hHeadPos: 0.5    vHeadPos: 0.618  display:    superSample: 2    width: 150    height: 300    position: left    hOffset: 0    vOffset: -50  mobile:    show: true    scale: 0.5  react:    opacityDefault: 0.7    opacityOnHover: 0.2下载模型动画后宫预览点这里选择你的后宫看好了默默记下小姐姐的名字,初音的模型名字:ni-j博客中都是按照ni-j操作\n1npm install –save live2d-widget-model-ni-j\n此时初音模型已经下载完毕\n\n12model:   use: live2d-widget-model-ni-j # 将&#96;ni-j&#96;替换成其他包名,即可替换不同模型人物.资源1[github源码和中文操作指南][3]重新加载博客\nhexo cleanhexo g打开浏览器看看你的初音吧\n\n","plink":"https://dxsummer.gitee.io/posts/2805db8d/"},{"title":"hexo博客开启pwa","date":"2020-05-08T04:41:25.000Z","date_formatted":{"ll":"2020年5月8日","L":"2020/05/08","MM-DD":"05-08"},"updated":"2020-06-08T01:53:02.000Z","content":"前言Progressive Web App, 简称PWA，是提升 Web App 的体验的一种新方法，能给用户原生应用的体验。\nPWA 能做到原生应用的体验不是靠特指某一项技术，而是经过应用一些新技术进行改进，在安全、性能和体验三个方面都有很大提升，PWA 本质上是 Web App，借助一些新技术也具备了 Native App 的一些特性，兼具 Web App 和 Native App 的优点。\nPWA 的主要特点包括下面三点：\n可靠 - 即使在不稳定的网络环境下，也能瞬间加载并展现\n体验 - 快速响应，并且有平滑的动画响应用户的操作\n粘性 - 像设备上的原生应用，具有沉浸式的用户体验，用户可以添加到桌面\nPWA 本身强调渐进式，并不要求一次性达到安全、性能和体验上的所有要求，开发者可以通过 PWA Checklist 查看现有的特征。\n Warning Header\n开始pwa之前，全站必须支持HTTPS\n开始pwa之前，全站必须支持HTTPS\n开始pwa之前，全站必须支持HTTPS安装pwahexo@4.2.0 目前赞不兼容 hexo-pwa,使用 hexo@4.2.0 版本的用户推荐降级到 hexo@4.1.1\n使用sudo hexo -version 查看版本\n安装指定版本 sudo npm install hexo@4.1.1 --save\n安装hexo-pwa\n1sudo npm install hexo-pwa --save配置添加manifest.json在manifest.json生成网站生成manifest.json首先你需要准备一个你喜欢的图标，填写香相关选项，并上传图标，将生成的manifest.json文件，放到 博客根目录下\n我生成的如下：\n12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#123;  &quot;name&quot;: &quot;YH&#39;s Blog&quot;,  &quot;short_name&quot;: &quot;YH&#39;s Blog&quot;,  &quot;theme_color&quot;: &quot;#2196f3&quot;,  &quot;background_color&quot;: &quot;#2196f3&quot;,  &quot;display&quot;: &quot;standalone&quot;,  &quot;Scope&quot;: &quot;&#x2F;&quot;,  &quot;start_url&quot;: &quot;&#x2F;&quot;,  &quot;icons&quot;: [    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-72x72.png&quot;,      &quot;sizes&quot;: &quot;72x72&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-96x96.png&quot;,      &quot;sizes&quot;: &quot;96x96&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-128x128.png&quot;,      &quot;sizes&quot;: &quot;128x128&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-144x144.png&quot;,      &quot;sizes&quot;: &quot;144x144&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-152x152.png&quot;,      &quot;sizes&quot;: &quot;152x152&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-192x192.png&quot;,      &quot;sizes&quot;: &quot;192x192&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-384x384.png&quot;,      &quot;sizes&quot;: &quot;384x384&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;,    &#123;      &quot;src&quot;: &quot;images&#x2F;icons&#x2F;icon-512x512.png&quot;,      &quot;sizes&quot;: &quot;512x512&quot;,      &quot;type&quot;: &quot;image&#x2F;png&quot;    &#125;  ],  &quot;splash_pages&quot;: null&#125;参数解释\nname: {string} 应用名称，用于安装横幅、启动画面显示\nshort_name: {string} 应用短名称，用于主屏幕显示\ntheme_color: {Color} css色值theme_color 属性可以指定 PWA 的主题颜色。可以通过该属性来控制浏览器 UI 的颜色。比如 PWA 启动画面上状态栏、内容页中状态栏、地址栏的颜色，会被 theme_color 所影响。\nbackground_color: {Color} css色值 可以指定启动画面的背景颜色。\ndisplay: {string} 显示类型\nfullscreen 应用的显示界面将占满整个屏幕\nstandalone 浏览器相关UI（如导航栏、工具栏等）将会被隐藏\nminimal-ui 显示形式与standalone类似，浏览器相关UI会最小化为一个按钮，不同浏览器在实现上略有不同\nbrowser 浏览器模式，与普通网页在浏览器中打开的显示一致\nscope: {string} 作用域\n\nscope 应遵循如下规则：如果没有在 manifest 中设置 scope，则默认的作用域为 manifest.json 所在文件夹；scope 可以设置为 …/ 或者更高层级的路径来扩大PWA的作用域；\n\nstart_url 必须在作用域范围内；\n\n如果 start_url 为相对地址，其根路径受 scope 所影响；如果 start_url 为绝对地址（以 / 开头），则该地址将永远以 / 作为根地址；\n\nstart_url: {string} 应用启动地址\nicons: {Array.} 应用图标列表\nsrc: {string} 图标 url\n\nsizes {string} 图标尺寸，格式为widthxheight，宽高数值以 css 的 px 为单位。如果需要填写多个尺寸，则使用空格进行间隔，如”48x48 96x96 128x128”type {string} 图标的 mime 类型，非必填项，该字段可让浏览器快速忽略掉不支持的图标类型\n\n添加sw.js新建一个名为sw.js的文件，放在站点根目录下，在文件里填入一下内容\n1234567891011121314importScripts(&#39;https:&#x2F;&#x2F;g.alicdn.com&#x2F;kg&#x2F;workbox&#x2F;3.3.0&#x2F;workbox-sw.js&#39;);​if (workbox) &#123;    workbox.setConfig(&#123; modulePathPrefix: &#39;https:&#x2F;&#x2F;g.alicdn.com&#x2F;kg&#x2F;workbox&#x2F;3.3.0&#x2F;&#39; &#125;);​    workbox.precaching.precache([&#39;&#x2F;&#39;, &#39;&#x2F;index.html&#39;]);​    workbox.routing.registerRoute(new RegExp(&#39;^https?:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;?$&#39;), workbox.strategies.networkFirst());​    workbox.routing.registerRoute(new RegExp(&#39;.*.html&#39;), workbox.strategies.networkFirst());​    workbox.routing.registerRoute(new RegExp(&#39;.*.(?:js|css|jpg|png|gif)&#39;), workbox.strategies.staleWhileRevalidate());​&#125;\n将其中域名改为你自己主页的域名：https?://dxsummer.gitee.io/ 改为你的域名，格式要和我的一样。\n\n配置站点配置文件首先将生成的images文件复制到 /source 文件夹下将下面的配置代码复制到你的站点根目录配置文件 _config.yml中\n1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# https:&#x2F;&#x2F;github.com&#x2F;lavas-project&#x2F;hexo-pwapwa:  manifest:    path: &#x2F;manifest.json    body:      name: YH&#39;s Blog      short_name: YH&#39;s Blog      theme_color: #2196f3      background_color: #2196f3      display: standalone      orientation: portrait      scope: &#x2F;      start_url: &#x2F;      icons:        - src: &#x2F;images&#x2F;icons&#x2F;icon-72x72.png          type: image&#x2F;png          sizes: 72x72        - src: &#x2F;images&#x2F;icons&#x2F;icon-96x96.png          type: image&#x2F;png          sizes: 96x96        - src: &#x2F;images&#x2F;icons&#x2F;icon-128x128.png          type: image&#x2F;png          sizes: 128x128        - src: &#x2F;images&#x2F;icons&#x2F;icon-144x144.png          type: image&#x2F;png          sizes: 144x144        - src: &#x2F;images&#x2F;icons&#x2F;icon-152x152.png          type: image&#x2F;png          sizes: 152x152        - src: &#x2F;images&#x2F;icons&#x2F;icon-192x192.png          type: image&#x2F;png          sizes: 192x192        - src: &#x2F;images&#x2F;icons&#x2F;icon-384x384.png          type: image&#x2F;png          sizes: 384x384        - src: &#x2F;images&#x2F;icons&#x2F;icon-512x512.png          type: image&#x2F;png          sizes: 512x512  serviceWorker:    path: &#x2F;sw.js    preload:      urls:        - &#x2F;      posts: 12    opts:      networkTimeoutSeconds: 30    routes:      - pattern: !!js&#x2F;regexp &#x2F;hm.baidu.com&#x2F;        strategy: networkOnly      - pattern: !!js&#x2F;regexp &#x2F;www.google-analytics.com&#x2F;        strategy: networkOnly      - pattern: !!js&#x2F;regexp &#x2F;.*\\.(js|css|jpg|jpeg|png|gif)$&#x2F;        strategy: cacheFirst      - pattern: !!js&#x2F;regexp &#x2F;\\&#x2F;&#x2F;        strategy: networkFirst  priority: 5检查pwa部署是否成功执行hexo clean &amp;&amp; hexo g &amp;&amp; hexo s\n然后在浏览器输入localhost:4000，查看效果。\n按F12，然后选择Application—&gt;Service Workers，查看是否成功？\n\n成功状态提示：Status #xxx activated and is running\n\n谷歌浏览器安装PWA\n前面的步骤操作没错，配置也没问题，则在本地运行试，浏览器地址栏中会出现一个类似 ➕ 加号的图标，点击它会出现一个弹出框，就说明配置成功，当然你可以选择安装，安装过后桌面会出现一个图标，点击就可以访问，但是如果你本地服务关闭的话，再点击这个图标，有些页面可以访问，但有些页面访问不了。如果需要它都能够全部访问的话，你需要开启本地服务，也就是hexo s\n如果你的地址栏没有出现这个加号，首先在新的标签页上的地址栏输入Chrome://flags，然后再搜索栏输入PWAS进行查找，会出现两个选项一个为Desktop PWAs local updating，另一个为Desktop PWAs installable from the omnibox，将其设为Enabled，然后点击Relaunch，进行浏览器的重启，再查看localhost:4000，就会出现加号了。\n部署到github和coding123sudo hexo cleansudo hexo gsudo hexo d参考资料引用郭元洪\nHexo添加PWA支持\n","plink":"https://dxsummer.gitee.io/posts/805d5d89/"},{"title":"高数例题","date":"2020-05-06T11:11:13.000Z","date_formatted":{"ll":"2020年5月6日","L":"2020/05/06","MM-DD":"05-06"},"updated":"2020-09-19T09:28:56.000Z","content":"9.7方向导数与梯度1\n2\n设f(x,y,z)=x2+y2+z2,求gradf(1,-1,2)及其模\n\n\n9.8多元函数的极值及其求法1\n2\n![](https://i.loli.net/2020/05/08/SE3YZ9O2FiyweGU.png \"|block\")第九章测试1\n2\n3\n10.1二重积分的概念与性质1\n2\n3\n4 √\n10.2二重积分的计算1\n2\n3\n4\n5 √\n11.3格林公式及其应用\n11.4对面积的曲面积分\n11.5对坐标的曲面积分\n","plink":"https://dxsummer.gitee.io/posts/7c5cf7ba/"},{"title":"C语言程序算法","date":"2020-05-04T12:05:29.000Z","date_formatted":{"ll":"2020年5月4日","L":"2020/05/04","MM-DD":"05-04"},"updated":"2020-06-11T15:07:16.000Z","content":"三角形12345678910111213#include &lt;stdio.h&gt;main()&#123;    int a,b,c;    for(a=1;a&lt;6;a++)    &#123;\t        for(b=5;b&gt;=a*2-a;b--)            printf(\" \");        for(b=1;b&lt;=a*2-1;b++)            printf(\"*\");        printf(\"\\n\");    &#125;&#125;输出结果：\n12345    *   ***  ***** ****************对用户输入的任意一组数字，如{2,3,4,3,5,2,7,8,3,4}输出其中出现次数最多的数及次数1234567891011121314151617181920212223242526#include&lt;stdio.h&gt;#include&lt;math.h&gt;#include&lt;stdlib.h&gt;#include&lt;string.h&gt;int main()&#123;    int i,j,n,max,a[1010],b[1010]=&#123;&#125;;    printf(\"要输入多少个数？\");    scanf(\"%d\",&amp;n);    printf(\"请输入\");    for(i=0;i&lt;n;i++)        scanf(\"%d\",&amp;a[i]);    for(i=0;i&lt;n;i++)        for(j=0;j&lt;n;j++)            if(a[i]==a[j])                b[i]++;    max=b[0],j=0;    for(i=0;i&lt;n;i++)        if(b[i]&gt;max)        &#123;            max=b[i];            j=i;        &#125;    printf(\"重复值%d 数量%d\\n\",a[j],max);    return 0;&#125;字符串多组输入，直到遇到回车结束输入\n论他大神给出的解决办法\n\n12string s;while(getline(std::cin,s)&amp;&amp;!s.empty())&#123;&#125;12char s[maxn];while(gets(s)&amp;&amp;strcmp(s,\"\")!=0)&#123;&#125;比较大小12345678910111213141516#include &lt;stdio.h&gt;int main()&#123;\tint a[5]=&#123;5,2,1,8&#125;,i,k,z;\tscanf(\"%d\",a[4]);\tfor(i=0;i&lt;5;i++)\t\tfor(k=i+1;k&lt;5;k++)\t\t\tif(a[i]&gt;a[k])\t\t\t&#123;\t\t\t\tz=a[i];\t\t\t\ta[i]=a[k];\t\t\t\ta[k]=z;\t\t\t&#125;\tfor(k=0;k&lt;5;k++)\tprintf(\"%d\\n\",a[k]);&#125;🍓以二进制形式打印制整数123456789101112131415161718192021222324252627/* binary.c -- 以二进制形式打印制整数 */#include　&lt;stdio.h&gt;void to_binary(unsigned long n);int main(void)&#123;    unsigned long number;    printf(\"Enter　an　integer　(q　to　quit):\\n\");    while(scanf(\"%lu\",&amp;number)　==　1)    &#123;        printf(\"Binary　equivalent:　\");        to_binary(number);        putchar('\\n');        printf(\"Enter　an　integer　(q　to　quit):\\n\");    &#125;    printf(\"Done.\\n\");    return　0;&#125;void to_binary(unsigned long n)　/* 递归函数 */&#123;    int r;    r=n%2;    if(n&gt;=2)    \tto_binary(n/2);    putchar(r==0?'0':'1');    return;&#125;","plink":"https://dxsummer.gitee.io/posts/13623648/"},{"title":"Step2 字符串和格式化输入/输出","date":"2020-04-29T09:02:38.000Z","date_formatted":{"ll":"2020年4月29日","L":"2020/04/29","MM-DD":"04-29"},"updated":"2020-06-08T01:44:52.000Z","content":"本章介绍以下内容：\n  函数：strlen()  关键字：const  字符串  如何创建、存储字符串  如何使用strlen()函数获取字符串的长度  用C预处理器指令#define和ANSIC的const修饰符创建符号常量  \n\n\n本章重点介绍输入和输出。与程序交互和使用字符串可以编写个性化的程序，本章将详细介绍C语言的两个输入/输出函数：printf()和scanf()。学会使用这两个函数，不仅能与用户交互，还可根据个人喜好和任务要求格式化输出。最后，简要介绍一个重要的工具——C预处理器指令，并学习如何定义、使用符号常量。\n\n程序清单4.1 talkback.c程序\n123456789101112131415161718192021// talkback.c -- 演示与用户交互#include &lt;stdio.h&gt;#include &lt;string.h&gt;　　 // 提供strlen()函数的原型#define DENSITY 62.4　　// 人体密度（单位：磅/立方英尺）int main()&#123;    float weight, volume;    int size, letters;    char name[40];　　　 // name是一个可容纳40个字符的数组    printf(\"Hi! What's your first name?\\n\");    scanf(\"%s\", name);    printf(\"%s, what's your weight in pounds?\\n\", name);    scanf(\"%f\", &amp;weight);    size = sizeof name;    letters = strlen(name);    volume = weight / DENSITY;    printf(\"Well, %s, your volume is %2.2f cubic feet.\\n\", name, volume);    printf(\"Also, your first name has %d letters,\\n\", letters);    printf(\"and we have %d bytes to store it.\\n\", size);    return 0;&#125;运行talkback.c程序，输入结果如下：\n1234567Hi! What's your first name?ChristineChristine, what's your weight in pounds?154Well, Christine, your volume is 2.47 cubic feet.Also, your first name has 9 letters,and we have 40 bytes to store it.该程序包含以下新特性。\n用数组（array）储存字符串（character string）。在该程序中，用户输入的名被储存在数组中，该数组占用内存中40个连续的字节，每个字节储存一个字符值。\n使用%s转换说明来处理字符串的输入和输出。注意，在scanf()中，name没有&amp;前缀，而weight有（稍后解释，&amp;weight和name都是地址）。\n用C预处理器把字符常量DENSITY定义为62.4。\n用C函数strlen()获取字符串的长度。\n对于BASIC的输入/输出而言，C的输入/输出看上去有些复杂。不过，复杂换来的是程序的高效和方便控制输入/输出。而且，一旦熟悉用法后，会发现它很简单。\n字符串简介字符串（character string）是一个或多个字符的序列，如下所示：\n1\"Zing went the strings of my heart!\"双引号不是字符串的一部分。双引号仅告知编译器它括起来的是字符串，正如单引号用于标识单个字符一样。\nchar类型数组和null字符C语言没有专门用于储存字符串的变量类型，字符串都被储存在char类型的数组中。数组由连续的存储单元组成，字符串中的字符被储存在相邻的存储单元中，每个单元储存一个字符（见图4.1）。\n注意图4.1中数组末尾位置的字符\\0。这是空字符（null character），C语言用它标记字符串的结束。空字符不是数字0，它是非打印字符，其ASCII码值是（或等价于）0。C中的字符串一定以空字符结束，这意味着数组的容量必须至少比待存储字符串中的字符数多1。因此，程序清单4.1中有40个存储单元的字符串，只能储存39个字符，剩下一个字节留给空字符。\n那么，什么是数组？可以把数组看作是一行连续的多个存储单元。用更正式的说法是，数组是同类型数据元素的有序序列。程序清单4.1通过以下声明创建了一个包含40个存储单元（或元素）的数组，每个单元储存一个char类型的值：\n1char name[40];name后面的方括号表明这是一个数组，方括号中的40表明该数组中的元素数量。char表明每个元素的类型（见图4.2）。\n字符串看上去比较复杂！必须先创建一个数组，把字符串中的字符逐个放入数组，还要记得在末尾加上一个\\0。还好，计算机可以自己处理这些细节。\n使用字符串试着运行程序清单4.2，使用字符串其实很简单。\n程序清单4.2 praise1.c程序\n1234567891011/* praise1.c -- 使用不同类型的字符串 */#include &lt;stdio.h&gt;#define PRAISE \"You are an extraordinary being.\"int main(void)&#123;    char name[40];    printf(\"What's your name? \");    scanf(\"%s\", name);    printf(\"Hello, %s.%s\\n\", name, PRAISE);    return 0;&#125;%s告诉printf()打印一个字符串。%s出现了两次，因为程序要打印两个字符串：一个储存在name数组中；一个由PRAISE来表示。运行praise1.c，其输出如下所示：\n12What's your name? Angela PlainsHello, Angela.You are an extraordinary being.你不用亲自把空字符放入字符串末尾，scanf()在读取输入时就已完成这项工作。也不用在字符串常量PRAISE末尾添加空字符。稍后我们会解释#define指令，现在先理解PRAISE后面用双引号括起来的文本是一个字符串。编译器会在末尾加上空字符。\n注意（这很重要），scanf()只读取了Angela Plains中的Angela，它在遇到第1个空白（空格、制表符或换行符）时就不再读取输入。因此，scanf()在读到Angela和Plains之间的空格时就停止了。一般而言，根据%s转换说明，scanf()只会读取字符串中的一个单词，而不是一整句。C语言还有其他的输入函数（如，fgets()），用于读取一般字符串。后面章节将详细介绍这些函数。\n字符串和字符字符串常量&quot;x&quot;和字符常量&#39;x&#39;不同。区别之一在于&#39;x&#39;是基本类型（char），而&quot;x&quot;是派生类型（char数组）；区别之二是&quot;x&quot;实际上由两个字符组成：&#39;x&#39;和空字符\\0（见图4.3）。\nstrlen()函数上一章提到了 sizeof 运算符，它以字节为单位给出对象的大小。strlen()函数给出字符串中的字符长度。因为 1 字节储存一个字符，读者可能认为把两种方法应用于字符串得到的结果相同，但事实并非如此。请根据程序清单4.3，在程序清单4.2中添加几行代码，看看为什么会这样。\n程序清单4.3 praise2.c程序\n123456789101112131415161718/* praise2.c */// 如果编译器不识别%zd，尝试换成%u或%lu。#include &lt;stdio.h&gt;#include &lt;string.h&gt;　　/* 提供strlen()函数的原型 */#define PRAISE \"You are an extraordinary being.\"int main(void)&#123;    char name[40];    printf(\"What's your name? \");    scanf(\"%s\", name);    printf(\"Hello, %s.%s\\n\", name, PRAISE);    printf(\"Your name of %zd letters occupies %zd memory cells.\\n\",    strlen(name), sizeof name);    printf(\"The phrase of praise has %zd letters \",    strlen(PRAISE));    printf(\"and occupies %zd memory cells.\\n\", sizeof PRAISE);    return 0;&#125;如果使用ANSI C之前的编译器，必须移除这一行：\n1#include &lt;string.h&gt;string.h头文件包含多个与字符串相关的函数原型，包括strlen()。第11章将详细介绍该头文件（顺带一提，一些ANSI之前的UNIX系统用strings.h代替string.h，其中也包含了一些字符串函数的声明）。\n一般而言，C 把函数库中相关的函数归为一类，并为每类函数提供一个头文件。例如，printf()和scanf()都隶属标准输入和输出函数，使用stdio.h头文件。string.h头文件中包含了strlen()函数和其他一些与字符串相关的函数（如拷贝字符串的函数和字符串查找函数）。\n注意，程序清单4.3使用了两种方法处理很长的printf()语句。第1种方法是将printf()语句分为两行（可以在参数之间断为两行，但是不要在双引号中的字符串中间断开）；第 2 种方法是使用两个printf()语句打印一行内容，只在第2条printf()语句中使用换行符（\\n）。运行该程序，其交互输出如下：\n1234What's your name? Serendipity ChanceHello, Serendipity.You are an extraordinary being.Your name of 11 letters occupies 40 memory cells.The phrase of praise has 31 letters and occupies 32 memory cells.sizeof运算符报告，name数组有40个存储单元。但是，只有前11个单元用来储存Serendipity，所以strlen()得出的结果是11。name数组的第12个单元储存空字符，strlen()并未将其计入。图4.4演示了这个概念。\n对于 PRAISE，用 strlen()得出的也是字符串中的字符数（包括空格和标点符号）。然而，sizeof运算符给出的数更大，因为它把字符串末尾不可见的空字符也计算在内。该程序并未明确告诉计算机要给字符串预留多少空间，所以它必须计算双引号内的字符数。\n第 3 章提到过，C99 和 C11 标准专门为 sizeof 运算符的返回类型添加了%zd 转换说明，这对于strlen()同样适用。对于早期的C，还要知道sizeof和strlen()返回的实际类型（通常是unsigned或unsigned long）。\n另外，还要注意一点：上一章的 sizeof 使用了圆括号，但本例没有。圆括号的使用时机否取决于运算对象是类型还是特定量？运算对象是类型时，圆括号必不可少，但是对于特定量，可有可无。也就是说，对于类型，应写成sizeof(char)或sizeof(float)；对于特定量，可写成sizeof name或sizeof 6.28。尽管如此，还是建议所有情况下都使用圆括号，如sizeof(6.28)。\n程序清单4.3中使用strlen()和sizeof，完全是为了满足读者的好奇心。在实际应用中，strlen()和 sizeof 是非常重要的编程工具。例如，在各种要处理字符串的程序中，strlen()很有用。详见第11章。\n下面我们来学习#define指令。\n常量和C预处理器有时，在程序中要使用常量。例如，可以这样计算圆的周长：\n1circumference &#x3D; 3.14159 * diameter;这里，常量3.14159代表著名的常量pi（π）。在该例中，输入实际值便可使用这个常量。然而，这种情况使用符号常量（symbolic constant）会更好。也就是说，使用下面的语句，计算机稍后会用实际值完成替换：\n1circumference &#x3D; pi * diameter;为什么使用符号常量更好？首先，常量名比数字表达的信息更多。请比较以下两条语句：\n12owed &#x3D; 0.015 * housevalue;owed &#x3D; taxrate * housevalue;如果阅读一个很长的程序，第2条语句所表达的含义更清楚。\n另外，假设程序中的多处使用一个常量，有时需要改变它的值。毕竟，税率通常是浮动的。如果程序使用符号常量，则只需更改符号常量的定义，不用在程序中查找使用常量的地方，然后逐一修改。\n那么，如何创建符号常量？方法之一是声明一个变量，然后将该变量设置为所需的常量。可以这样写：\n123float taxrate;taxrate &#x3D; 0.015;这样做提供了一个符号名，但是taxrate是一个变量，程序可能会无意间改变它的值。C语言还提供了一个更好的方案——C预处理器。第2 章中介绍了预处理器如何使用#include包含其他文件的信息。预处理器也可用来定义常量。只需在程序顶部添加下面一行：\n1#define TAXRATE 0.015编译程序时，程序中所有的TAXRATE都会被替换成0.015。这一过程被称为编译时替换（compile-time substitution）。在运行程序时，程序中所有的替换均已完成（见图 4.5）。通常，这样定义的常量也称为明示常量（manifest constant）[1]。\n请注意格式，首先是#define，接着是符号常量名（TAXRATE），然后是符号常量的值（0.015）（注意，其中并没有=符号）。所以，其通用格式如下：\n1#define NAME value实际应用时，用选定的符号常量名和合适的值来替换NAME和value。注意，末尾不用加分号，因为这是一种由预处理器处理的替换机制。为什么 TAXRATE 要用大写？用大写表示符号常量是 C 语言一贯的传统。这样，在程序中看到全大写的名称就立刻明白这是一个符号常量，而非变量。大写常量只是为了提高程序的可读性，即使全用小写来表示符号常量，程序也能照常运行。尽管如此，初学者还是应该养成大写常量的好习惯。\n另外，还有一个不常用的命名约定，即在名称前带c_或k_前缀来表示常量（如，c_level或k_line）。\n符号常量的命名规则与变量相同。可以使用大小写字母、数字和下划线字符，首字符不能为数字。程序清单4.4演示了一个简单的示例。\n程序清单4.4 pizza.c程序\n1234567891011121314/* pizza.c -- 在比萨饼程序中使用已定义的常量 */#include &lt;stdio.h&gt;#define PI 3.14159int main(void)&#123;    float area, circum, radius;    printf(\"What is the radius of your pizza?\\n\");    scanf(\"%f\", &amp;radius);    area = PI * radius * radius;    circum = 2.0 * PI *radius;    printf(\"Your basic pizza parameters are as follows:\\n\");    printf(\"circumference = %1.2f, area = %1.2f\\n\", circum,area);    return 0;&#125;printf()语句中的%1.2f表明，结果被四舍五入为两位小数输出。下面是一个输出示例：\n1234What is the radius of your pizza?6.0Your basic pizza parameters are as follows:circumference = 37.70, area = 113.10#define指令还可定义字符和字符串常量。前者使用单引号，后者使用双引号。如下所示：\n1234#define BEEP '\\a'#define TEE 'T'#define ESC '\\033'#define OOPS \"Now you have done it!\"记住，符号常量名后面的内容被用来替换符号常量。不要犯这样的常见错误：\n12/* 错误的格式 */#define TOES = 20如果这样做，替换TOES的是= 20，而不是20。这种情况下，下面的语句：\n1digits = fingers + TOES;将被转换成错误的语句：\n1digits = fingers + = 20;const限定符C90标准新增了const关键字，用于限定一个变量为只读（注意，在C语言中，用const类型限定符声明的是变量，不是常量。）\n1const int MONTHS = 12; // MONTHS在程序中不可更改，值为12这使得MONTHS成为一个只读值。也就是说，可以在计算中使用MONTHS，可以打印MONTHS，但是不能更改MONTHS的值。const用起来比#define更灵活，第12章将讨论与const相关的内容。\n明示常量C头文件limits.h和float.h分别提供了与整数类型和浮点类型大小限制相关的详细信息。每个头文件都定义了一系列供实现使用的明示常量 [再次提醒读者注意，本书作者认为“明示常量”相当于“符号常量”，经常在书中混用这两个术语。]。例如，limits.h头文件包含以下类似的代码：\n12#define INT_MAX +32767#define INT_MIN -32768这些明示常量代表int类型可表示的最大值和最小值。如果系统使用32 位的int，该头文件会为这些明示常量提供不同的值。如果在程序中包含limits.h头文件，就可编写下面的代码：\n1printf(\"Maximum int value on this system = %d\\n\", INT_MAX);如果系统使用4字节的int，limits.h头文件会提供符合4字节int的INT_MAX和INT_MIN。表4.1列出了limits.h中能找到的一些明示常量。\n类似地，float.h头文件中也定义一些明示常量，如FLT_DIG和DBL_DIG，分别表示float类型和double类型的有效数字位数。表4.2列出了float.h中的一些明示常量（可以使用文本编辑器打开并查看系统使用的float.h头文件）。表中所列都与float类型相关。把明示常量名中的FLT分别替换成DBL和LDBL，即可分别表示double和long double类型对应的明示常量（表中假设系统使用2的幂来表示浮点数）。\n程序清单4.5演示了如何使用float.h和limits.h中的数据（注意，编译器要完全支持C99标准才能识别LLONG_MIN标识符）。\n程序清单4.5 defines.c程序\n12345678910111213141516// defines.c -- 使用limit.h和float头文件中定义的明示常量#include &lt;stdio.h&gt;#include &lt;limits.h&gt;　 // 整型限制#include &lt;float.h&gt;　　// 浮点型限制int main(void)&#123;    printf(\"Some number limits for this system:\\n\");    printf(\"Biggest int: %d\\n\", INT_MAX);    printf(\"Smallest long long: %lld\\n\", LLONG_MIN);    printf(\"One byte = %d bits on this system.\\n\", CHAR_BIT);    printf(\"Largest double: %e\\n\", DBL_MAX);    printf(\"Smallest normal float: %e\\n\", FLT_MIN);    printf(\"float precision = %d digits\\n\", FLT_DIG);    printf(\"float epsilon = %e\\n\", FLT_EPSILON);    return 0;&#125;该程序的输出示例如下：\n12345678Some number limits for this system:Biggest int: 2147483647Smallest long long: -9223372036854775808One byte = 8 bits on this system.Largest double: 1.797693e+308Smallest normal float: 1.175494e-38float precision = 6 digitsfloat epsilon = 1.192093e-07C预处理器是非常有用的工具，要好好利用它。本书的后面章节中会介绍更多相关应用。\nprintf()和scanf()printf()函数和scanf()函数能让用户可以与程序交流，它们是输入/输出函数，或简称为I/O函数。它们不仅是C语言中的I/O函数，而且是最多才多艺的函数。过去，这些函数和C库的一些其他函数一样，并不是C语言定义的一部分。最初，C把输入/输出的实现留给了编译器的作者，这样可以针对特殊的机器更好地匹配输入/输出。后来，考虑到兼容性的问题，各编译器都提供不同版本的printf()和scanf()。尽管如此，各版本之间偶尔有一些差异。C90 和C99 标准规定了这些函数的标准版本，本书亦遵循这一标准。\n虽然printf()是输出函数，scanf()是输入函数，但是它们的工作原理几乎相同。两个函数都使用格式字符串和参数列表。我们先介绍printf()，再介绍scanf()。\nprintf()函数请求printf()函数打印数据的指令要与待打印数据的类型相匹配。例如，打印整数时使用%d，打印字符时使用%c。这些符号被称为转换说明（conversion specification），它们指定了如何把数据转换成可显示的形式。我们先列出ANSI C标准为printf()提供的转换说明，然后再示范如何使用一些较常见的转换说明。表4.3列出了一些转换说明和各自对应的输出类型。\n\n使用printf()程序清单4.6的程序中使用了一些转换说明。\n程序清单4.6 printout.c程序\n1234567891011121314/* printout.c -- 使用转换说明 */#include &lt;stdio.h&gt;#define PI 3.141593int main(void)&#123;    int number = 7;    float pies = 12.75;    int cost = 7800;    printf(\"The %d contestants ate %f berry pies.\\n\", number,pies);    printf(\"The value of pi is %f.\\n\", PI);    printf(\"Farewell! thou art too dear for my possessing,\\n\");    printf(\"%c%d\\n\", '$', 2 * cost);    return 0;&#125;该程序的输出如下：\n1234The 7 contestants ate 12.750000 berry pies.The value of pi is 3.141593.Farewell! thou art too dear for my possessing,$15600这是printf()函数的格式：\n1printf( 格式字符串, 待打印项1, 待打印项2,...);待打印项1、待打印项2等都是要打印的项。它们可以是变量、常量，甚至是在打印之前先要计算的表达式。第3章提到过，格式字符串应包含每个待打印项对应的转换说明。例如，考虑下面的语句：\n1printf(\"The %d contestants ate %f berry pies.\\n\", number,pies);格式字符串是双引号括起来的内容。上面语句的格式字符串包含了两个待打印项number和poes对应的两个转换说明。图4.6演示了printf()语句的另一个例子。\n下面是程序清单4.6中的另一行：\n1printf(\"The value of pi is %f.\\n\", PI);该语句中，待打印项列表只有一个项——符号常量PI。\n如图4.7所示，格式字符串包含两种形式不同的信息：实际要打印的字符；转换说明。\n警告\n格式字符串中的转换说明一定要与后面的每个项相匹配，若忘记这个基本要求会导致严重的后果。千万别写成下面这样：\n1printf(\"The score was Squids %d, Slugs %d.\\n\", score1);这里，第2个%d没有对应任何项。系统不同，导致的结果也不同。不过，出现这种问题最好的状况是得到无意义的值。\n如果只打印短语或句子，就不需要使用任何转换说明。如果只打印数据，也不用加入说明文字。程序清单4.6中的最后两个printf()语句都没问题：\n12printf(\"Farewell! thou art too dear for my possessing,\\n\");printf(\"%c%d\\n\", '$', 2 * cost);注意第2条语句，待打印列表的第1个项是一个字符常量，不是变量；第2个项是一个乘法表达式。这说明printf()使用的是值，无论是变量、常量还是表达式的值。\n由于 printf()函数使用%符号来标识转换说明，因此打印%符号就成了个问题。如果单独使用一个%符号，编译器会认为漏掉了一个转换字符。解决方法很简单，使用两个%符号就行了：\n12pc = 2*6;printf(\"Only %d%% of Sally's gribbles were edible.\\n\", pc);下面是输出结果：\n1Only 12% of Sally's gribbles were edible.printf()的转换说明修饰符在%和转换字符之间插入修饰符可修饰基本的转换说明。表4.4和表4.5列出可作为修饰符的合法字符。如果要插入多个字符，其书写顺序应该与表4.4中列出的顺序相同。不是所有的组合都可行。表中有些字符是C99新增的，如果编译器不支持C99，则可能不支持表中的所有项。\n\n注意 类型可移植性\nsizeof 运算符以字节为单位返回类型或值的大小。这应该是某种形式的整数，但是标准只规定了该值是无符号整数。在不同的实现中，它可以是unsigned int、unsigned long甚至是unsigned long long。因此，如果要用printf()函数显示sizeof表达式，根据不同系统，可能使用%u、%lu或%llu。这意味着要查找你当前系统的用法，如果把程序移植到不同的系统还要进行修改。鉴于此， C提供了可移植性更好的类型。首先，stddef.h头文件（在包含stdio.h头文件时已包含其中）把size_t定义成系统使用sizeof返回的类型，这被称为底层类型（underlying type）。其次，printf()使用z修饰符表示打印相应的类型。同样，C还定义了ptrdiff_t类型和t修饰符来表示系统使用的两个地址差值的底层有符号整数类型。\n注意 float参数的转换对于浮点类型，有用于double和long double类型的转换说明，却没有float类型的。这是因为在K&amp;R C中，表达式或参数中的float类型值会被自动转换成double类型。一般而言，ANSI C不会把float自动转换成double。然而，为保护大量假设float类型的参数被自动转换成double的现有程序，printf()函数中所有float类型的参数（对未使用显式原型的所有C函数都有效）仍自动转换成double类型。因此，无论是K&amp;R C还是ANSI C，都没有显示float类型值专用的转换说明。\n\n使用修饰符和标记的示例接下来，用程序示例演示如何使用这些修饰符和标记。先来看看字段宽度在打印整数时的效果。考虑程序清单4.7中的程序。\n程序清单4.7 width.c程序\n1234567891011/* width.c -- 字段宽度 */#include &lt;stdio.h&gt;#define PAGES 959int main(void)&#123;    printf(\"*%d*\\n\", PAGES);    printf(\"*%2d*\\n\", PAGES);    printf(\"*%10d*\\n\", PAGES);    printf(\"*%-10d*\\n\", PAGES);    return 0;&#125;程序清单4.7通过4种不同的转换说明把相同的值打印了4次。程序中使用星号（*）标出每个字段的开始和结束。其输出结果如下所示：\n1234*959**959**　　 959**959　　 *第1个转换说明%d不带任何修饰符，其对应的输出结果与带整数字段宽度的转换说明的输出结果相同。在默认情况下，没有任何修饰符的转换说明，就是这样的打印结果。\n第2个转换说明是%2d，其对应的输出结果应该是 2 字段宽度。因为待打印的整数有 3 位数字，所以字段宽度自动扩大以符合整数的长度。\n第 3个转换说明是%10d，其对应的输出结果有10个空格宽度，实际上在两个星号之间有7个空格和3位数字，并且数字位于字段的右侧。\n最后一个转换说明是%-10d，其对应的输出结果同样是 10 个空格宽度，-标记说明打印的数字位于字段的左侧。熟悉它们的用法后，能很好地控制输出格式。试着改变PAGES的值，看看编译器如何打印不同位数的数字。\n\n接下来看看浮点型格式。请输入、编译并运行程序清单4.8中的程序。\n\n程序清单4.8 floats.c程序\n123456789101112131415// floats.c -- 一些浮点型修饰符的组合#include &lt;stdio.h&gt;int main(void)&#123;    const double RENT = 3852.99;　// const变量    printf(\"*%f*\\n\", RENT);    printf(\"*%e*\\n\", RENT);    printf(\"*%4.2f*\\n\", RENT);    printf(\"*%3.1f*\\n\", RENT);    printf(\"*%10.3f*\\n\", RENT);    printf(\"*%10.3E*\\n\", RENT);    printf(\"*%+4.2f*\\n\", RENT);    printf(\"*%010.2f*\\n\", RENT);    return 0;&#125;该程序中使用了const关键字，限定变量为只读。该程序的输出如下：\n12345678*3852.990000**3.852990e+03**3852.99**3853.0**　3852.990** 3.853E+03**+3852.99**0003852.99*本例的第1个转换说明是%f。在这种情况下，字段宽度和小数点后面的位数均为系统默认设置，即字段宽度是容纳带打印数字所需的位数和小数点后打印6位数字。\n第2个转换说明是%e。默认情况下，编译器在小数点的左侧打印1个数字，在小数点的右侧打印6个数字。这样打印的数字太多！解决方案是指定小数点右侧显示的位数，程序中接下来的 4 个例子就是这样做的。请注意，第4个和第6个例子对输出结果进行了四舍五入。另外，第6个例子用E代替了e。\n第7个转换说明中包含了+标记，这使得打印的值前面多了一个代数符号（+）。0标记使得打印的值前面以0填充以满足字段要求。注意，转换说明%010.2f的第1个0是标记，句点（.）之前、标记之后的数字（本例为10）是指定的字段宽度。尝试修改RENT的值，看看编译器如何打印不同大小的值。程序清单4.9演示了其他组合。\n程序清单4.9 flags.c程序\n123456789/* flags.c -- 演示一些格式标记 */#include &lt;stdio.h&gt;int main(void)&#123;    printf(\"%x %X %#x\\n\", 31, 31, 31);    printf(\"**%d**% d**% d**\\n\", 42, 42, -42);    printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\", 6, 6, 6, 6);    return 0;&#125;该程序的输出如下：\n1231f 1F 0x1f**42** 42**-42****　 6** 006**00006** 006**第1行输出中，1f是十六进制数，等于十进制数31。第1行printf()语句中，根据%x打印出1f，%F打印出1F，%#x打印出0x1f。\n第 2 行输出演示了如何在转换说明中用空格在输出的正值前面生成前导空格，负值前面不产生前导空格。这样的输出结果比较美观，因为打印出来的正值和负值在相同字段宽度下的有效数字位数相同。\n第3行输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被忽略。\n\n下面来看看字符串格式的示例。考虑程序清单4.10中的程序。\n\n程序清单4.10 stringf.c程序\n1234567891011/* stringf.c -- 字符串格式 */#include &lt;stdio.h&gt;#define BLURB \"Authentic imitation!\"int main(void)&#123;    printf(\"[%2s]\\n\", BLURB);    printf(\"[%24s]\\n\", BLURB);    printf(\"[%24.5s]\\n\", BLURB);    printf(\"[%-24.5s]\\n\", BLURB);    return 0;&#125;该程序的输出如下：\n1234[Authentic imitation!][　　Authentic imitation!][　　　　　　　　　　Authe][Authe　　　　　　　　　　]注意，虽然第1个转换说明是%2s，但是字段被扩大为可容纳字符串中的所有字符。还需注意，精度限制了待打印字符的个数。.5告诉printf()只打印5个字符。另外，-标记使得文本左对齐输出。\n学以致用学习完以上几个示例，试试如何用一个语句打印以下格式的内容：\n1The NAME family just may be $XXX.XX dollars richer!这里，NAME和XXX.XX代表程序中变量（如name[40]和cash）的值。可参考以下代码：\n1printf(\"The %s family just may be $%.2f richer!\\n\",name,cash);转换说明的意义下面深入探讨一下转换说明的意义。转换说明把以二进制格式储存在计算机中的值转换成一系列字符（字符串）以便于显示。例如，数字76在计算机内部的存储格式是二进制数01001100。%d转换说明将其转换成字符7和6，并显示为76；%x转换说明把相同的值（01001100）转换成十六进制记数法4c；%c转换说明把01001100转换成字符L。\n转换（conversion）可能会误导读者认为原始值被转替换成转换后的值。实际上，转换说明是翻译说明，%d的意思是“把给定的值翻译成十进制整数文本并打印出来”。\n转换不匹配\n前面强调过，转换说明应该与待打印值的类型相匹配。通常都有多种选择。例如，如果要打印一个int类型的值，可以使用%d、%x或%o。这些转换说明都可用于打印int类型的值，其区别在于它们分别表示一个值的形式不同。类似地，打印double类型的值时，可使用%f、%e或%g。\n转换说明与待打印值的类型不匹配会怎样？上一章中介绍过不匹配导致的一些问题。匹配非常重要，一定要牢记于心。程序清单4.11演示了一些不匹配的整型转换示例。\n程序清单4.11 intconv.c程序\n1234567891011121314/* intconv.c -- 一些不匹配的整型转换 */#include &lt;stdio.h&gt;#define PAGES 336#define WORDS 65618int main(void)&#123;    short num = PAGES;    short mnum = -PAGES;    printf(\"num as short and unsigned short:　%hd %hu\\n\", num,num);    printf(\"-num as short and unsigned short: %hd %hu\\n\", mnum,mnum);    printf(\"num as int and char: %d %c\\n\", num, num);    printf(\"WORDS as int, short, and char: %d %hd %c\\n\",WORDS,WORDS, WORDS);    return 0;&#125;在我们的系统中，该程序的输出如下：\n1234num as short and unsigned short: 336 336-num as short and unsigned short: -336 65200num as int and char: 336 PWORDS as int, short, and char: 65618 82 R请看输出的第1行，num变量对应的转换说明%hd和%hu输出的结果都是336。这没有任何问题。\n然而，第2行mnum变量对应的转换说明%u（无符号）输出的结果却为65200，并非期望的336。这是由于有符号short int类型的值在我们的参考系统中的表示方式所致。首先，short int的大小是2字节；其次，系统使用二进制补码来表示有符号整数。这种方法，数字0～32767代表它们本身，而数字32768～65535则表示负数。其中，65535表示-1，65534表示-2，以此类推。因此，-336表示为65200（即， 65536-336）。所以被解释成有符号int时，65200代表-336；而被解释成无符号int时，65200则代表65200。一定要谨慎！一个数字可以被解释成两个不同的值。尽管并非所有的系统都使用这种方法来表示负整数，但要注意一点：别期望用%u转换说明能把数字和符号分开。\n第3行演示了如果把一个大于255的值转换成字符会发生什么情况。在我们的系统中，short int是2字节，char是1字节。当printf()使用%c打印336时，它只会查看储存336的2字节中的后1字节。这种截断（见图4.8）相当于用一个整数除以256，只保留其余数。在这种情况下，余数是80，对应的ASCII值是字符P。用专业术语来说，该数字被解释成“以256为模”（modulo 256），即该数字除以256后取其余数。\n最后，我们在该系统中打印比short int类型最大整数（32767）更大的整数（65618）。这次，计算机也进行了求模运算。在本系统中，应把数字65618储存为4字节的int类型值。用%hd转换说明打印时， printf()只使用最后2个字节。这相当于65618除以65536的余数。这里，余数是82。鉴于负数的储存方法，如果余数在32767～65536范围内会被打印成负数。对于整数大小不同的系统，相应的处理行为类似，但是产生的值可能不同。\n总结\n当遇到溢出问题，为：**该数字模除256后取其余数**混淆整型和浮点型，结果更奇怪。考虑程序清单4.12。\n程序清单4.12 floatcnv.c程序\n12345678910111213/* floatcnv.c -- 不匹配的浮点型转换 */#include &lt;stdio.h&gt;int main(void)&#123;    float n1 = 3.0;    double n2 = 3.0;    long n3 = 2000000000;    long n4 = 1234567890;    printf(\"%.1e %.1e %.1e %.1e\\n\", n1, n2, n3, n4);    printf(\"%ld %ld\\n\", n3, n4);    printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);    return 0;&#125;在我们的系统中，该程序的输出如下：\n1233.0e+00 3.0e+00 3.1e+46 1.7e+2662000000000 12345678900 1074266112 0 1074266112第1行输出显示，%e转换说明没有把整数转换成浮点数。\n考虑一下，如果使用%e转换说明打印n3（long类型）会发生什么情况。首先，%e转换说明让printf()函数认为待打印的值是double类型（本系统中double为8字节）。当printf()查看n3（本系统中是4字节的值）时，除了查看n3的4字节外，还会查看查看n3相邻的4字节，共8字节单元。接着，它将8字节单元中的位组合解释成浮点数（如，把一部分位组合解释成指数）。因此，即使n3的位数正确，根据%e转换说明和%ld转换说明解释出来的值也不同。最终得到的结果是无意义的值。\n第1行也说明了前面提到的内容：float类型的值作为printf()参数时会被转换成double类型。在本系统中，float是4字节，但是为了printf()能正确地显示该值，n1被扩成8字节。\n第2行输出显示，只要使用正确的转换说明，printf()就可以打印n3和n4。\n第3行输出显示，如果printf()语句有其他不匹配的地方，即使用对了转换说明也会生成虚假的结果。用%ld转换说明打印浮点数会失败，但是在这里，用%ld打印long类型的数竟然也失败了！问题出在C如何把信息传递给函数。具体情况因编译器实现而异。“参数传递”框中针对一个有代表性的系统进行了讨论。\n\n参数传递\n\n参数传递机制因实现而异。下面以我们的系统为例，分析参数传递的原理。函数调用如下：\n1printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);该调用告诉计算机把变量n1、n2、n3和n4的值传递给程序。这是一种常见的参数传递方式。程序把传入的值放入被称为栈（stack）的内存区域。计算机根据变量类型（不是根据转换说明）把这些值放入栈中。因此，n1被储存在栈中，占8字节（float类型被转换成double类型）。同样，n2也在栈中占8字节，而n3和n4在栈中分别占4字节。然后，控制转到printf()函数。该函数根据转换说明（不是根据变量类型）从栈中读取值。%ld转换说明表明printf()应该读取4字节，所以printf()读取栈中的前4字节作为第1个值。这是n1的前半部分，将被解释成一个long类型的整数。根据下一个%ld转换说明，printf()再读取4字节，这是n1的后半部分，将被解释成第2个long类型的整数（见图4.9）。类似地，根据第3个和第4个%ld，printf()读取n2的前半部分和后半部分，并解释成两个long类型的整数。因此，对于n3和n4，虽然用对了转换说明，但printf()还是读错了字节。\n12345float n1; /* 作为double类型传递 */double n2;long n3, n4;...printf(\"%ld %ld %ld %ld\\n\", n1, n2, n3, n4);printf()的返回值第2章提到过，大部分C函数都有一个返回值，这是函数计算并返回给主调程序（calling program）的值。例如，C库包含一个sqrt()函数，接受一个数作为参数，并返回该数的平方根。可以把返回值赋给变量，也可以用于计算，还可以作为参数传递。总之，可以把返回值像其他值一样使用。printf()函数也有一个返回值，它返回打印字符的个数。如果有输出错误，printf()则返回一个负值（printf()的旧版本会返回不同的值）。\nprintf()的返回值是其打印输出功能的附带用途，通常很少用到，但在检查输出错误时可能会用到（如，在写入文件时很常用）。如果一张已满的CD或DVD拒绝写入时，程序应该采取相应的行动，例如终端蜂鸣30秒。不过，要实现这种情况必须先了解if语句。程序清单4.13演示了如何确定函数的返回值。\n程序清单4.13 prntval.c程序\n12345678910/* prntval.c -- printf()的返回值 */#include &lt;stdio.h&gt;int main(void)&#123;    int bph2o = 212;    int rv;    rv = printf(\"%d F is water's boiling point.\\n\", bph2o);    printf(\"The printf() function printed %d characters.\\n\",rv);    return 0;&#125;该程序的输出如下：\n12212 F is water's boiling point.The printf() function printed 32 characters.首先，程序用rv = printf(...);的形式把printf()的返回值赋给rv。因此，该语句执行了两项任务：打印信息和给变量赋值。其次，注意计算针对所有字符数，包括空格和不可见的换行符（\\n）。\n打印较长的字符串有时，printf()语句太长，在屏幕上不方便阅读。如果空白（空格、制表符、换行符）仅用于分隔不同的部分，C 编译器会忽略它们。因此，一条语句可以写成多行，只需在不同部分之间输入空白即可。例如，程序清单4.13中的一条printf()语句：\n12printf(\"The printf() function printed %d characters.\\n\",rv);该语句在逗号和 rv之间断行。为了让读者知道该行未完，示例缩进了 rv。C编译器会忽略多余的空白。\n但是，不能在双引号括起来的字符串中间断行。如果这样写：\n12printf(\"The printf() function printed %dcharacters.\\n\", rv);C编译器会报错：字符串常量中有非法字符。在字符串中，可以使用\\n来表示换行字符，但是不能通过按下Enter（或Return）键产生实际的换行符。\n给字符串断行有3种方法，如程序清单4.14所示。\n12345678910111213141516程序清单4.14 longstrg.c程序/* longstrg.c ––打印较长的字符串 */\\#include &lt;stdio.h&gt;int main(void)&#123;    printf(\"Here's one way to print a \");\t//方法1    printf(\"long string.\\n\");        printf(\"Here's another way to print a \\long string.\\n\");\t//方法2        printf(\"Here's the newest way to print a \"\"long string.\\n\");　　/* ANSI C */    return 0;&#125;该程序的输出如下：\n123Here's one way to print a long string.Here's another way to print a long string.Here's the newest way to print a long string.方法1：使用多个printf()语句。因为第1个字符串没有以\\n字符结束，所以第2个字符串紧跟第1个字符串末尾输出。\n方法2：用反斜杠（\\）和Enter（或Return）键组合来断行。这使得光标移至下一行，而且字符串中不会包含换行符。其效果是在下一行继续输出。但是，下一行代码必须和程序清单中的代码一样从最左边开始。如果缩进该行，比如缩进5个空格，那么这5个空格就会成为字符串的一部分。\n方法3：ANSI C引入的字符串连接。在两个用双引号括起来的字符串之间用空白隔开，C编译器会把多个字符串看作是一个字符串。因此，以下3种形式是等效的：\n123456printf(\"Hello, young lovers, wherever you are.\");printf(\"Hello, young \"　　 \"lovers\" \", wherever you are.\");printf(\"Hello, young lovers\"\", wherever you are.\");上述方法中，要记得在字符串中包含所需的空格。如，&quot;young&quot;&quot;lovers&quot;会成为&quot;younglovers&quot;，而&quot;young &quot; &quot;lovers&quot;才是&quot;young lovers&quot;。\n使用scanf()刚学完输出，接下来我们转至输入——学习scanf()函数。C库包含了多个输入函数，scanf()是最通用的一个，因为它可以读取不同格式的数据。当然，从键盘输入的都是文本，因为键盘只能生成文本字符：字母、数字和标点符号。如果要输入整数 2014，就要键入字符 2、0、1、4。如果要将其储存为数值而不是字符串，程序就必须把字符依次转换成数值，这就是scanf()要做的。scanf()把输入的字符串转换成整数、浮点数、字符或字符串，而 printf()正好与它相反，把整数、浮点数、字符和字符串转换成显示在屏幕上的文本。\nscanf()和 printf()类似，也使用格式字符串和参数列表。scanf()中的格式字符串表明字符输入流的目标数据类型。两个函数主要的区别在参数列表中。printf()函数使用变量、常量和表达式，而scanf()函数使用指向变量的指针。\n这里，读者不必了解如何使用指针，只需记住以下两条简单的规则：\n如果用scanf()读取基本变量类型的值，在变量名前加上一个&amp;；\n如果用scanf()把字符串读入字符数组中，不要使用&amp;。\n程序清单4.15中的小程序演示了这两条规则。\n12345678910111213141516程序清单4.15 input.c程序// input.c -- 何时使用&amp;\\#include &lt;stdio.h&gt;int main(void)&#123;    int age;　　　　　 // 变量    float assets;　　　// 变量    char pet[30];　　　// 字符数组，用于储存字符串    printf(\"Enter your age, assets, and favorite pet.\\n\");    scanf(\"%d %f\", &amp;age, &amp;assets); // 这里要使用&amp;    scanf(\"%s\", pet);　　　　　　　 // 字符数组不使用&amp;    printf(\"%d $%.2f %s\\n\", age, assets, pet);    return 0;&#125;下面是该程序与用户交互的示例：\n1234Enter your age, assets, and favorite pet.3892360.88 llama38 $92360.88 llamascanf()函数使用空白（换行符、制表符和空格）把输入分成多个字段。在依次把转换说明和字段匹配时跳过空白。注意，上面示例的输入项（粗体部分是用户的输入）分成了两行。只要在每个输入项之间输入至少一个换行符、空格或制表符即可，可以在一行或多行输入：\n12345Enter your age, assets, and favorite pet.422121.45guppy42 $2121.45 guppy唯一例外的是%c转换说明。根据%c，scanf()会读取每个字符，包括空白。我们稍后详述这部分。\nscanf()函数所用的转换说明与printf()函数几乎相同。主要的区别是，对于float类型和double类型，printf()都使用%f、%e、%E、%g和%G转换说明。而scanf()只把它们用于float类型，对于double类型时要使用l修饰符。表4.6列出了C99标准中常用的转换说明。\n表4.6 ANSI C中scanf()的转换说明\n可以在表4.6所列的转换说明中（百分号和转换字符之间）使用修饰符。如果要使用多个修饰符，必须按表4.7所列的顺序书写。\n表4.7 scanf()转换说明中的修饰符\n\n如你所见，使用转换说明比较复杂，而且这些表中还省略了一些特性。省略的主要特性是，从高度格式化源中读取选定数据，如穿孔卡或其他数据记录。因为在本书中，scanf()主要作为与程序交互的便利工具，所以我们不在书中讨论更复杂的特性。\n1.从scanf()角度看输入\n接下来，我们更详细地研究scanf()怎样读取输入。假设scanf()根据一个%d转换说明读取一个整数。scanf()函数每次读取一个字符，跳过所有的空白字符，直至遇到第1个非空白字符才开始读取。因为要读取整数，所以 scanf()希望发现一个数字字符或者一个符号（+或-）。如果找到一个数字或符号，它便保存该字符，并读取下一个字符。如果下一个字符是数字，它便保存该数字并读取下一个字符。scanf()不断地读取和保存字符，直至遇到非数字字符。如果遇到一个非数字字符，它便认为读到了整数的末尾。然后，scanf()把非数字字符放回输入。这意味着程序在下一次读取输入时，首先读到的是上一次读取丢弃的非数字字符。最后，scanf()计算已读取数字（可能还有符号）相应的数值，并将计算后的值放入指定的变量中。\n如果使用字段宽度，scanf()会在字段结尾或第1个空白字符处停止读取（满足两个条件之一便停止）。\n如果第1个非空白字符是A而不是数字，会发生什么情况？scanf()将停在那里，并把A放回输入中，不会把值赋给指定变量。程序在下一次读取输入时，首先读到的字符是A。如果程序只使用%d转换说明， scanf()就一直无法越过A读下一个字符。另外，如果使用带多个转换说明的scanf()，C规定在第1个出错处停止读取输入。\n用其他数值匹配的转换说明读取输入和用%d 的情况相同。区别在于 scanf()会把更多字符识别成数字的一部分。例如，%x转换说明要求scanf()识别十六进制数a～f和A～F。浮点转换说明要求scanf()识别小数点、e记数法（指数记数法）和新增的p记数法（十六进制指数记数法）。\n如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串。如果使用字段宽度，scanf()在字段末尾或第1个空白字符处停止读取。无法利用字段宽度让只有一个%s的scanf()读取多个单词。最后要注意一点：当scanf()把字符串放进指定数组中时，它会在字符序列的末尾加上&#39;\\0&#39;，让数组中的内容成为一个C字符串。\n实际上，在C语言中scanf()并不是最常用的输入函数。这里重点介绍它是因为它能读取不同类型的数据。C 语言还有其他的输入函数，如 getchar()和 fgets()。这两个函数更适合处理一些特殊情况，如读取单个字符或包含空格的字符串。我们将在第7章、第11章、第13章中讨论这些函数。目前，无论程序中需要读取整数、小数、字符还是字符串，都可以使用scanf()函数。\n格式字符串中的普通字符scanf()函数允许把普通字符放在格式字符串中。除空格字符外的普通字符必须与输入字符串严格匹配。例如，假设在两个转换说明中添加一个逗号：\n1scanf(\"%d,%d\", &amp;n, &amp;m);scanf()函数将其解释成：用户将输入一个数字、一个逗号，然后再输入一个数字。也就是说，用户必须像下面这样进行输入两个整数：\n188,121由于格式字符串中，%d后面紧跟逗号，所以必须在输入88后再输入一个逗号。但是，由于scanf()会跳过整数前面的空白，所以下面两种输入方式都可以：\n188, 121和\n1288,121格式字符串中的空白意味着跳过下一个输入项前面的所有空白。例如，对于下面的语句：\n1scanf(\"%d ,%d\", &amp;n, &amp;m);以下的输入格式都没问题：\n12388,12188 ,12188 , 121请注意，“所有空白”的概念包括没有空格的特殊情况。\n除了%c，其他转换说明都会自动跳过待输入值前面所有的空白。因此，scanf(&quot;%d%d&quot;, &amp;n, &amp;m)与scanf(&quot;%d %d&quot;, &amp;n, &amp;m)的行为相同。对于%c，在格式字符串中添加一个空格字符会有所不同。例如，如果把%c放在格式字符串中的空格前面，scanf()便会跳过空格，从第1个非空白字符开始读取。也就是说，\n🍖scanf(&quot;%c&quot;, &amp;ch)从输入中的第1个字符开始读取，而scanf(&quot; %c&quot;, &amp;ch)则从第1个非空白字符开始读取。\nscanf()的返回值scanf()函数返回成功读取的项数。如果没有读取任何项，且需要读取一个数字而用户却输入一个非数值字符串，scanf()便返回0。当scanf()检测到“文件结尾”时，会返回EOF（EOF是stdio.h中定义的特殊值，通常用#define指令把EOF定义为-1）。我们将在第6章中讨论文件结尾的相关内容以及如何利用scanf()的返回值。在读者学会if语句和while语句后，便可使用scanf()的返回值来检测和处理不匹配的输入。\nprintf()和scanf()的*修饰符printf()和scanf()都可以使用*修饰符来修改转换说明的含义。但是，它们的用法不太一样。首先，我们来看printf()的*修饰符。\n如果你不想预先指定字段宽度，希望通过程序来指定，那么可以用*修饰符代替字段宽度。但还是要用一个参数告诉函数，字段宽度应该是多少。也就是说，如果转换说明是%*d，那么参数列表中应包含*和 d对应的值。这个技巧也可用于浮点值指定精度和字段宽度。程序清单4.16演示了相关用法。\n123456789101112131415161718程序清单4.16 varwid.c程序/* varwid.c -- 使用变宽输出字段 */\\#include &lt;stdio.h&gt;int main(void)&#123;    unsigned width, precision;    int number = 256;    double weight = 242.5;    printf(\"Enter a field width:\\n\");    scanf(\"%d\", &amp;width);    printf(\"The number is :%*d:\\n\", width, number);    printf(\"Now enter a width and a precision:\\n\");    scanf(\"%d %d\", &amp;width, &amp;precision);    printf(\"Weight = %*.*f\\n\", width, precision, weight);    printf(\"Done!\\n\");    return 0;&#125;变量width提供字段宽度，number是待打印的数字。因为转换说明中*在d的前面，所以在printf()的参数列表中，width在number的前面。同样，width和precision提供打印weight的格式化信息。下面是一个运行示例：\n1234567Enter a field width:6The number is : 256:Now enter a width and a precision:8 3Weight = 242.500Done!这里，用户首先输入6，因此6是程序使用的字段宽度。类似地，接下来用户输入8和3，说明字段宽度是8，小数点后面显示3位数字。一般而言，程序应根据weight的值来决定这些变量的值。\nscanf()中*的用法与此不同。把*放在%和转换字符之间时，会使得scanf()跳过相应的输出项。程序清单4.17就是一个例子。\n程序清单4.17 skip2.c程序\n1234567891011/* skiptwo.c -- 跳过输入中的前两个整数 */\\#include &lt;stdio.h&gt;int main(void)&#123;    int n;    printf(\"Please enter three integers:\\n\");    scanf(\"%*d %*d %d\", &amp;n);    printf(\"The last integer was %d\\n\", n);    return 0;&#125;程序清单4.17中的scanf()指示：跳过两个整数，把第3个整数拷贝给n。下面是一个运行示例：\n123Please enter three integers:2013 2014 2015The last integer was 2015在程序需要读取文件中特定列的内容时，这项跳过功能很有用。\nprintf()的用法提示想把数据打印成列，指定固定字段宽度很有用。因为默认的字段宽度是待打印数字的宽度，如果同一列中打印的数字位数不同，那么下面的语句：\n1printf(\"%d %d %d\\n\", val1, val2, val3);打印出来的数字可能参差不齐。例如，假设执行3次printf()语句，用户输入不同的变量，其输出可能是这样：\n12312 234 12224 5 2322334 2322 10001使用足够大的固定字段宽度可以让输出整齐美观。例如，若使用下面的语句：\n1printf(\"%9d %9d %9d\\n\", val1, val2, val3);上面的输出将变成：\n123   12　　 　234　　　1222    4　　　 　5　　 　2322334　　  2322　　 10001在两个转换说明中间插入一个空白字符，可以确保即使一个数字溢出了自己的字段，下一个数字也不会紧跟该数字一起输出（这样两个数字看起来像是一个数字）。这是因为格式字符串中的普通字符（包括空格）会被打印出来。\n另一方面，如果要在文字中嵌入一个数字，通常指定一个小于或等于该数字宽度的字段会比较方便。这样，输出数字的宽度正合适，没有不必要的空白。例如，下面的语句：\n1printf(\"Count Beppo ran %.2f miles in 3 hours.\\n\", distance);其输出如下：\n1Count Beppo ran 10.22 miles in 3 hours.如果把转换说明改为%10.2f，则输出如下：\n1Count Beppo ran　　 10.22 miles in 3 hours.本地化设置\n美国和世界上的许多地区都使用一个点来分隔十进制值的整数部分和小数部分，如3.14159。然而，许多其他地区用逗号来分隔，如 3,14159。读者可能注意到了，printf()和 scanf()都没有提供逗号的转换说明。C语言考虑了这种情况。本书附录B的参考资料V中介绍了C支持的本地化概念，因此C程序可以选择特定的本地化设置。例如，如果指定了荷兰语言环境，printf()和scanf()在显示和读取浮点值时会使用本地惯例（在这种情况下，用逗号代替点分隔浮点值的整数部分和小数部分）。另外，一旦指定了环境，便可在代码的数字中使用逗号：\n1double pi &#x3D; 3,14159; &#x2F;&#x2F; 荷兰本地化设置C标准有两个本地化设置：”C“和” “（空字符串）。默认情况下，程序使用”C”本地化设置，基本上符合美国的用法习惯。而””本地化设置可以替换当前系统中使用的本地语言环境。原则上，这与”C”本地化设置相同。事实上，大部分操作系统（如UNIX、Linux和Windows）都提供本地化设置选项列表，只不过它们提供的列表可能不同。\n关键概念C语言用char类型表示单个字符，用字符串表示字符序列。字符常量是一种字符串形式，即用双引号把字符括起来：”Good luck, my friend”。可以把字符串储存在字符数组（由内存中相邻的字节组成）中。字符串，无论是表示成字符常量还是储存在字符数组中，都以一个叫做空字符的隐藏字符结尾。\n在程序中，最好用#define 定义数值常量，用 const 关键字声明的变量为只读变量。在程序中使用符号常量（明示常量），提高了程序的可读性和可维护性。\nC 语言的标准输入函数（scanf()）和标准输出函数（printf()）都使用一种系统。在该系统中，第1个参数中的转换说明必须与后续参数中的值相匹配。例如，int转换说明%d与一个浮点值匹配会产生奇怪的结果。必须格外小心，确保转换说明的数量和类型与函数的其余参数相匹配。对于scanf()，一定要记得在变量名前加上地址运算符（&amp;）。\n空白字符（制表符、空格和换行符）在 scanf()处理输入时起着至关重要的作用。除了%c 模式（读取下一个字符），scanf()在读取输入时会跳过非空白字符前的所有空白字符，然后一直读取字符，直至遇到空白字符或与正在读取字符不匹配的字符。考虑一下，如果scanf()根据不同的转换说明读取相同的输入行，会发生什么情况。假设有如下输入行：\n1-13.45e12# 0\t//`-`前面有空格如果其对应的转换说明是%d，scanf()会读取3个字符（-13）并停在小数点处，小数点将被留在输入中作为下一次输入的首字符。如果其对应的转换说明是%f，scanf()会读取-13.45e12，并停在#符号处，而#将被留在输入中作为下一次输入的首字符；然后，scanf()把读取的字符序列-13.45e12转换成相应的浮点值，并储存在float类型的目标变量中。如果其对应的转换说明是%s，scanf()会读取-13.45e12#，并停在空格处，空格将被留在输入中作为下一次输入的首字符；然后，scanf()把这 10个字符的字符码储存在目标字符数组中，并在末尾加上一个空字符。如果其对应的转换说明是%c，scanf()只会读取并储存第1个字符，该例中是一个空格 \n本章小结字符串是一系列被视为一个处理单元的字符。在C语言中，字符串是以空字符（ASCII码是0）结尾的一系列字符。可以把字符串储存在字符数组中。数组是一系列同类型的项或元素。下面声明了一个名为name、有30个char类型元素的数组：\n1char name[30];要确保有足够多的元素来储存整个字符串（包括空字符）。\n字符串常量是用双引号括起来的字符序列，如：&quot;This is an example of a string&quot;。\nscanf()函数（声明在string.h头文件中）可用于获得字符串的长度（末尾的空字符不计算在内）。scanf()函数中的转换说明是%s时，可读取一个单词。\nC预处理器为预处理器指令（以#符号开始）查找源代码程序，并在开始编译程序之前处理它们。处理器根据#include指令把另一个文件中的内容添加到该指令所在的位置。#define指令可以创建明示常量（符号常量），即代表常量的符号。limits.h和float.h头文件用#define定义了一组表示整型和浮点型不同属性的符号常量。另外，还可以使用const限定符创建定义后就不能修改的变量。\nprintf()和scanf()函数对输入和输出提供多种支持。两个函数都使用格式字符串，其中包含的转换说明表明待读取或待打印数据项的数量和类型。另外，可以使用转换说明控制输出的外观：字段宽度、小数位和字段内的布局。\n","plink":"https://dxsummer.gitee.io/posts/2a5471de/"},{"title":"英语笔记","date":"2020-04-26T01:22:05.000Z","date_formatted":{"ll":"2020年4月26日","L":"2020/04/26","MM-DD":"04-26"},"updated":"2020-07-23T10:16:06.000Z","content":"及物动词、不及物动词英语是以【动词】为核心的语言。探索语法的起步阶段，必须不厌其烦地分析动词。\n按各种不同的标准来分类动词，会带给我们清晰的视野。\n及物动词与不及物动词，来源于这样的分类标准：\n有些动词自身词义完整，比如：游泳swim， 睡觉sleep。\nI swim. 我游泳。 swim 没有【受者】\nHe sleeps. 他睡觉。 sleep 没有【受者】\n这类的动词， 不需要 【受者】。\n\n有些动词必须要有【受者】，比如：喜欢like， 想要want。\nI like him. 我喜欢。 如果like没有【受者】，句子不完整。\nHe wants some money. 他想要一些钱。 如果want没有【受着】，句子不完整。\n这类动词，必须要【 受者】。\n\n不需要【受者】的动词，叫做 不及物动词（vi.)\n需要【受者】的动词，叫做 及物动词(vt.)\n\n分类的意义何在？写正确的句子。\n有些动词，只具备及物动词词性\n这意味着，句子没有出现【受者】，句子错误。\n错误的句子：I like.\n正确的句子：I like it. 及物动词后一定要出现【受者】\n\n有些动词，只具备不及物动词词性\n这意味着，句子出现了【受者】，句子错误。\n错误的句子：I wait you. 正确的句子：I wait.\n那，这时候根据句子要表达的含义，不及物动词后要接【受者】，解决这个问题，虚词———介词登场了。\n 不及物动词+介词 = 及物动词 介词有词义，同一个不及物动词 + 不同的介词 ，表达的是不一样的含义呢，这个另起一篇文章讲吧。\n 我等你，正确的句子是：I wait for you.\n 这样的句子中，介词没有，错！\n wait 后用的不是for，而是别的介词，还是错！\n （题外话再说一句—– 业界也有称英文是以介词为核心的语言。不及物动词这样的用法是原因之一，其它的原因，再看我写的关于介词的文章吧，关注此专栏，敬请期待，不会让你失望。）\n\n有些动词，既具备不及物动词词性，又具备及物动词词性，两种词性下，词义相同。 （这样的用法，我们太喜欢啦）\nI am reading now. “read” 没有【受者】 不及物动词 词义”阅读”\nI am reading a newspaper now. “read” 有【受者】 及物动词 词义还是”阅读”\n\n最复杂，最烦人的这类动词来了，偏偏这一类动词很多呀这一类动词，既具备不及物动词词性， 又具备及物动词词性，两种词性下，词义非常的不同 （这就是词法啦，量的积累要靠时间支持）\n\n\n\nI got a book.get 及物动词 词义”得到”\n\nI got to the zoo.get 不及物动词 词义”到达”\n\nThey are moving the bookcase.move 及物动词 词义”移动””挪动”\n\nThey moved.move 不及物动词 词义”搬家”\n\nThey moved into the new house.move不及物动词 词义”搬家”\n\nThey are playing the piano.play 及物动词 词义”弹，玩”\n\nThey are playing.play 不及物动词 词义”玩耍”\n\nThey played with the children.play 不及物动词 词义”玩耍”\n\n情态动词+动词原型\n英语中有3个基本助动词: \n\n基本助动词\n\n1be\n\n2do\n\n3have be+doing表进行;be+done 表被动;have+done    表完成等。\n\nbe+to do表既定计划;do+do 表强调;\nbe动词作助动词由连系动词am，is， are构成的句子:变一般疑问句时把am，is， are提到句子的前面，句尾用问号即可。变否定句时直接在am，is, are后面加not即可。肯定句:     He is a student.一般疑问句:     Is he a student?否定句:     He is not a student.\n\nwas是am，is的过 去式，were是are的过去式，若句子中有以上两词时，变疑问句及否定句方法与1相同。\n\n情态动词作助动词由情态动词can，may， will， shall等 构成的句子:变一般疑问句时把can，may,will，shall提到句子的前面，句尾用问号即可。变否定句时直接在can，may， 后面加not即可。肯定句: She can swim.一般疑问句: Can she swim?否定句: She can not swim.\n\ncould，might， would， should是can， may，will， sha11的过去式，若句子中有以上两词时，变疑问句及否定句方法与1相同。\n\ndo作为助动词由行为动词构成的句子: 需要加助词do或does。变一般疑问句时把do/ does放在句子前面，变否定句时把 don’t / doesn’ t 放在动词的前面。要注意观察动词的形式并对号入座。一般疑问句和否定句的动词三单式都要变回原型。\n\nplay——doplays——does\n\n\nhave/has作为助动词由have，has构成的现在完成时句子，变一般疑问句时把have，has提到句子的前面，句尾用问号即可。变否定句时直接在have，has后面加not即可。肯定句: He has read today’ s newspaper.一般疑问句: Has he read today’ s newspaper?否定句: He has not read today’ s newspape.\n\nhad是have和has的过去式，在构成的过去完成时句子中，一般疑问句时把had提到到句子的前面，句尾用问号即可。变否定句时直接在had后面加not即可。\n\n若have，has，had没有出现在完成时的句子中，则当实义动词对待，请参考实义动词的用法。.\n\n情态动词\n英语中有所谓的助动词。英语中有很多助动词，除了do外，can, may, might, would, will, must也是助动词。\n\n情态动词+动词原型\n\nxYou must practiced your English every day.（你必须每天练习英语。）\n\noYou must practice your English every day.\nto的三种用法\n在英语中to的用法是比较重要的，一般来说to有三种基本用法: \n做介词，表示“到，向，往”，如go to，fly to，后面跟名词作定语，构成介宾结构。\n\n动词不定式的标志，很常见的，如: want to do， be happy to do。 注意有一些看似不定式但实为介词的结构，如look forward to, pay attention to，他们后面跟动词的ing形式作宾语，千万不能跟原形。\n\n其他的如to+do作定语等等基本都是以上两种用法的延伸。\n\nto doing用法当to用作介词的时候，后bai面跟du表示动作的动词时，要把这个动词通过zhi加ing变成“动dao名词(动词加ing,用作名词时，叫动名词)”。\n例如:\nHe is used to getting up early.他习惯早起了。\n这里的to是介词。\nHe preferred staying at home to going out.\n他更喜欢呆在家，而不愿意外出。\n这里的to也是介词。\n\n\n扩展资料动词+宾语+介词to+动名词\n\napply oneself to doing sth 专心致力于做某事\ndevote sth to doing sth 把……献给做某事\ndevote oneself to doing sth 献身于做某事\nlimit sth to doing sth 把…限制在做某事的范围内\nreduce sb to doing sth 使某人沦为做某事\ngive one’s life to doing sth 献身于做某事\ngive one’s mind to doing sth 专心做某事\nhave a dislike to doing sth 厌恶做某事\nhave an eye to doing sth 注意做某事\nhave an objection to doing sth 反对(反感)做某事\npay attention to doing sth 注意做某事\nset one’s mind to doing sth 决心做某事\n不及物动词+to+名词若是要表示过去的“习惯性”动作，可用would, used to来表达，例如：He used to go to school by bus.（他过去经常坐公共汽车去上课。）\ngo是不及物动词，后面跟名词则+to不及物动词+to+名词home是副词，所以不用+to\narrive+at/in+名词I often go to school by bike.I go home at 5 o’clock.I arrived in London yesterday.I arrived here just now.\nwill be用法will表示将要做什么，后面加动词原型。am/is/are的 原型是be，所以will be就是表示“将要成为”，“将 要…..”. ; will be后面加形容词。\n\nwill be用 于将来时，be和后面的名词、形容词等可以构成系表结构，表示主语的身份或者所处的状态等。\nwill be用法用于一般将来时。will后面可以加实意动词的原形，比如will go， will run等， 表示实际的动作。will be，be和后面的名词、形容词等可以构成系表结构，表示主语的身份或者所处的状态等，比如: \nWe will be pleased to answer any questions you may have.我们将很乐意回答你们可能想问的任何问题。\nwill be例句\nI’ m afraid the meeting will be postponed.会议怕要延期了。\n\nI hope what I have written will be of benefit to someone else who may feel the same way.我希望我所写的内容能对其他和我有同感的人有所裨益。\n\nThere will be no moon.月亮不会出来了。\n\nIf they arrive before I leave，well and good. If not, the responsibility will be mine.如果他们在我离开之前到达，那自然很好。但如果不是的话，那责任就是我的了。\n\nwill be与would be的区别意思：will be与would be意思相同，都为“将；将会”，但would be比will be多了一层委婉的意思。\n\n时态：will be 与would be都用于将来时态的句子，但will be 用于将来时而would be用于过去将来时。\n\n具体介绍：\nwill be的意思：将会;该怎样就怎样;我将会。\nwill be用于将来时态句子，比如将来进行时（will be doing）。\n例句：I’m afraid the meeting will be postponed. \n翻译：会议怕要延期了。\nbe原形一个完整的句子里面一定要有个动词.(如果遇到第二个动词则前面加”to“)\nwill,would,shall,must,等助动词后面必须用原形动词；\n形容词前面一定要用 be 动词（is,are,was,were,be）“be+adj.”这种组合是固定的.\nbe + p.p（过去分词）－－该过去分词就当做形容词用.例如：be relaxed（放轻松）；be boxed（用纸箱包装的）\n用be to/be about to＋动词原形 表示将来表示按计划、安排要做的事，具有“必要”的强制性意义。 The meeting is to take place tonight.（今晚召开会议。）\n\n表示约定、责任、命令或注定要发生的动作。Our plan is to be a failure.（我们的计划注定会失败。）  \n\n官方计划或决定（常见于报纸或广播）。The President is to visit USA next week.（总统将于下个星期出访美国。）\n\n用“be about to＋动词原形”表示将来。表示（按计划）即将发生的动作或情况。My grandpa is about to retire.（我祖父就要退休了。）She was about to go out when I arrived.（我来的时候她正准备出门。）\n\n\nHad you ever been to a blind date before you married?（你结婚以前曾经参加相亲吗？）\n\n解析：    在你结婚前，你有过一次相亲    Had you ever been to a blind date before you married，结婚之前你相亲过吗？    have gone to 不能代替这个意思    have been to 表示去过某地，经常和表示次数的次连用    have gone to 表示去了某地，还没有回来\nis being“be”动词用于现在进行时表示说话者认为是短暂的、和平常不一样的、甚至是伪装的。He is being foolish. 他在装傻。He is being honest. 他表现得特别老实。She is being rude. 她故意表现粗鲁。I can’t understand why he is being so selfish.我不明白此时他为何如此自私。适合于此种用法的有：foolish愚蠢的，nice好的，kind好心的，careful细心的，patient耐心的，lazy懒惰的，silly傻的，rude粗鲁的，polite礼貌的，impolite无礼的等表示人的特性、性格的形容词。(“be”动词用于现在进行时表示人的行为，纯粹表示心理或生理的状态而不带有行动时或主语不是人时，“be”动词不能用于现在进行时)如： \nI am happy.(表语是纯粹的心理状态，不可用am being) 我很快乐。He’s tired.(表语是纯粹的生理状态，不可用is being) 他很疲倦。It’s hot today.(主语不是人，不可用is being) 今天很热。\n形容词修饰不定代词时置于其后：当形容词修饰由some-, any-, no-, every-这些字首所构成的不定代词时，形容词要放在这些不定代词之后。例如：\nThere must be something wrong with my computer.（我的电脑出了点问题。）\nthe用法\n表示特指的人或物The boy in red is her brother.穿黑衣服的那个男孩是她哥哥。I like the music of the film.我喜欢这部电影的音乐。\n和单数名词、形容词或者分词连用，表示一类人或事物。the tiger老虎 the old老年人 the living生者 .\n指世界上独一无二的事物The sun is shining. 阳光普照。\n特指再次出现的人或事物。He told us a story , but I was not interested in the story.他给我们讲了一一个故事,但是我对这个故事不感兴趣。\n指谈话双方都知道或心中明白的人或物We went the station to see the friend off.我们去车站送朋友。\n表示某一国家的人时,其前用the。Yesterday the Singaporean came to visit our school.昨天有新加坡人来我校参观。\n用于表示方位的名词前There is a beautiful park in the east of our city.在我们的城市东面有-一个美丽的公园。\n用在江河、海洋、湖泊、群岛、山脉的名称前the Great Wall 长城\n用在乐器名词前play the guitar 弹吉他\n用在序数词、形容词最高级前\n形容词的比较级、最高级单音节词在字尾加-er / -est：单音节形容词在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：clean→cleaner→cleanest。\n\n单音节词以–e结尾在字尾加-r / -st：以–e结尾的单音节形容词，转变为比较级和最高级时，规则是在字尾加–r和–st。例如：wide→wider→widest。\n\n双音节词以-y, -er, -ow, -ble结尾在字尾加-er / -est：少数以-y, -er, -ow, -ble结尾的双音节形容词，在转变为比较级和最高级时，规则是在字尾加–er和-est。例如：slow→slower→slowest。\n\n以-y结尾的形容词，去掉字尾-y加-ier / -iest：以–y结尾，但–y前是辅音字母的形容词的比较级和最高级是把-y去掉，加上–ier和-iest。例如：lonely→lonelier→loneliest。\n\n形容词字尾“辅元辅”重复字尾再加–er：当形容词或其字尾出现“辅音＋元音＋辅音”现象，也就是最后三个字母和音标的排列是“辅元辅”，在转变为比较级和最高级时，规则是要重复字尾，再加-er。例如：big→bigger→biggest。\n\n好句好句We should look after the old and love the young.（我们应该尊老爱幼。）\n\nI have a beautiful little new white Chinese wooden table.（我有一张新的白色中式木桌，漂亮且小巧。）\n\n\n两个以上的形容词的顺序,（冠词＋数量＋性质＋大小＋形状＋新旧＋颜色＋国籍）＋名词。可背诵例句2辅助记忆\n\nThere must be something wrong with my computer.（我的电脑出了点问题。）\n","plink":"https://dxsummer.gitee.io/posts/4e70975/"},{"title":"C语言菜鸟笔记","date":"2020-04-23T05:18:11.000Z","date_formatted":{"ll":"2020年4月23日","L":"2020/04/23","MM-DD":"04-23"},"updated":"2020-06-26T14:48:52.000Z","content":"此帖记录C语言学习笔记，整合从最初学习C语言遇到的问题到一步步成长数据C 语言中 main()、void main() 和 int main(void) 有什么区别？main()是K&amp;R C的语法，也就是C89，现在可以使用，但是不推荐。int main(void)是c99的语法。void main()不是任何标准定义的，根据维基百科 C语言 的说法，这个是微软自己定义的。\n\nint main(void)表示返回一个整数值，不接收任何参数。main()按照老的C语言标准，不写返回值的函数默认返回类型为整形。空的括号表示可以接收任意个数任意类型的参数。\n\nvoid main() 的空括号表示可以接收任意个数任意类型的参数。在一般函数里void表示没有返回值。但是这个在main函数里面有点特殊,按照C99标准的5.1.2.2.3节描述，程序依然会返回一个unspecified的值。(实际上这一节的内容也隐喻了main函数可以不是int main(void)的形式)\n\n1void pound(int n)如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void。由于该函数接受一个 int 类型的参数，所以圆括号中包含一个int类型变量n的声明。\n\nC 标识符只能由字母.下划线和数字组成 且不能以数字开头。int(常量)是求不大于括号内数字 的最大整数1int(3.5)=3float在计算机中存储类型默认为double精度char为1字符，8位\nshort 2字节 16位\nshort int 2字节 16位 输出格式：%hd\nint为2字符或4字符，16位或32位\nfloat实际为4字符，即32位,C语言，float类型值会被自动转换成double类型,即64位\nlong浮点数要占用4字节，32位\ndouble 八字节，64位\nlong long 八字节，64位\nlong double 十六位，128位\n\n默认情况下，编译器假定浮点型float常量是double类型的精度。例如，假设some是float类型的变量，编写下面的语句：\n1some = 4.0 * 2.0; 通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。\n\n在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混淆。没有后缀的浮点型常量是double类型。\n\n123456Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 4 bytes.Type long long has a size of 8 bytes.Type double has a size of 8 bytes.Type long double has a size of 16 bytes.\nfloatfloat类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。\n12345678910/* floaterr.c--演示舍入错误 */#include　&lt;stdio.h&gt;int　main(void)&#123;    float　a,b;    b　=　2.0e20　+　1.0;    a　=　b　-　2.0e20;    printf(\"%f　\\n\",　a);    return　0;&#125;该程序的输出如下\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。\n字符串常量用双引号(“”)括起来的0个或者多个字符组成的序列存储：每个字符串尾自动加一个 ‘\\0’ 作为字符串结束标志\n字符串常量是百一对双引号括起来的字符序列。字符常量可以赋值给字符变量，如char b=&#39;a&#39;;,但不能把一个字符串常量赋给一个字符变量，同时也不能对字符串常量赋值。\n优先级\n算数运算符&gt;关系运算符&gt;赋值运算符\n\n关系运算符的优先级比算术运算符低（包括+和-），比赋值运算符高。这意味着x &gt; y + 2和x &gt; (y+ 2)相同，x = y &gt; 2和x = (y &gt; 2)相同。换言之，如果y大于2，则给x赋值1，否则赋值0。y的值不会赋给x。\n关系运算符比赋值运算符的优先级高，因此，x_bigger=x&gt;y;相当于x_bigger=(x &gt; y);。\n关系运算符之间有两种不同的优先级。\n高优先级组： &lt;&lt;= &gt;&gt;=\n低优先级组： == !=\n与其他大多数运算符一样，关系运算符的结合律也是从左往右。因此：\nex!=wye==zee与(ex != wye) == zee相同\n首先，C判断ex与wye是否相等；然后，用得出的值1或0（真或假）再与zee比较。我们并不推荐这样写，但是在这里有必要说明一下。\n表6.2列出了目前我们学过的运算符的性质。附录B的参考资料II“C运算符”中列出了全部运算符的完整优先级表。\n\n格式化输入字符串%s如果使用%s 转换说明，scanf()会读取除空白以外的所有字符。scanf()跳过空白开始读取第 1 个非空白字符，并保存非空白字符直到再次遇到空白。这意味着 scanf()根据%s 转换说明读取一个单词，即不包含空白字符的字符串\n12scanf(\"%s\",s);printf(\"\\n输出%s\",s);123输出abc123 123输出abc123格式输出符%hu hd%hd表示短整数(short int)。\n\n%hu用于输出一个unsigned short int类型的数值百，此类型占两个字节，度范围问为0到65535（2^16-1）\n\n%hhu用于输出一个unsigned short类型答的数值，此类型占一个字节，范围为0到255（2^8-1）\n\n%m.ne、%e%e是按指数的形式输出，比如 4.22e5\ne表示10的N次方，5.2 长度为5，小数点精确度为2，这个本身和复%e没有关系，C语言的输出就是标准就这样。\n%hd：short int 16位\n详细点的说明就是 %m.ne 指定输出的数值共占m位，其中有n位小数制。若数值长度小于m，则左端补空格。若数值长度大于m，则按实际数值输出，小数位保留n位。\n123456#include &lt;stdio.h&gt;main()&#123;\tfloat i=1777777;\tprintf(\"%3.2f\",i); &#125;输出结果：\n11777777.00这是ptintf()的格式。\n\n带格式输出 %#x%#x是带格zd式输出, 效果为在输出前加0x.\n1printf(\"%x %X %#x\\n\", 31, 31, 31); 输出\n11f 1F 0x1f\n输出演示了如何在整型格式中使用精度（%5.3d）生成足够的前导0以满足最小位数的要求（本例是3）。然而，使用0标记会使得编译器用前导0填充满整个字段宽度。最后，如果0标记和精度一起出现，0标记会被忽略。\n1printf(\"**%5d**%5.3d**%05d**%05.3d**\\n\", 6, 6, 6, 6); 输出：  \n1**    6**  006**00006**  006**\n带格式输出 %*s123int a;char b[10];scanf(\"%d%*s\",&amp;a,b);输入为：\n112 abc那么12将会读取到变量a中，但是后面的abc将在读取之后抛弃，不赋予任何变量(例如这里的字符数组b）用*和扫描集配合，可以从输入中只选出需要的内容，而忽略其余的东西。另外，也常用于清空缓冲区。\n1printf(\"%*s\",10,s);意思是输出字符串s，但至少占10个位置，不足的在字符串s左边补空格，这里等同于\n1printf(\"%10s\",s);带格式输入输出 %*d如果转换说明是%*d，那么参数列表中应包含*和 d对应的值\n\n例一 printf()\n\n12scanf(\"%d\", &amp;width);printf(\"The number is :%*d:\\n\", width, number);输出\n126The number is :      256:\n例二 printf()\n\n12scanf(\"%d %d\", &amp;width, &amp;precision);printf(\"Weight = %*.*f\\n\", width, precision, weight);输出\n128 3Weight = 242.500\n例三 scanf()\n\n12scanf(\"%*d %*d %d\", &amp;n);printf(\"The last integer was %d\\n\", n);scanf()指示：跳过两个整数，把第3个整数拷贝给n。下面是一个运行示例：\n122013 2014 2015The last integer was 2015在程序需要读取文件中特定列的内容时，这项跳过功能很有用。\nstrlen()和 sizeof()的区别C语言中没有字符串类型，字符串在内存中是用字符数组表示的。\nstrlen( )：strlen( )求得的是字符串的长度 %u、%lu、%zd\nsizeof( )：sizeof( )计算字符串占的总内存空间 %u、%lu、%zd\n例如字符串  \n1str[20]&#x3D; &#123;“abcdef”&#125;;strlen(str),结果为6\nsizeof(str),结果为20\nx-=y x+=y12x+=y\t/*x=x+y*/x-=y\t/*x=x-y*/scanf（） 的返回值C=scanf() 返回值赋给C\nC表示scanf（）成功收到赋值的个数\n12345678void main()&#123;int a,b,c;    c=scanf(\"%d %d\",&amp;a,&amp;b);    printf(\"%d\",c);&#125;为什么我    输入a 1\tc的值就为0，    输入1 a\tc的值为112345scanf返回接收到的变量值的个数。 int  a,b,c。a 1进去时，试图用字符‘a’对a赋值，肯定是错的，于是退出，返回成功接收到赋值的个数 0.1 a进去时，首先a能获取1.但b不能获取'a',于是返回只是1 如果是  1 1的话，那就都成功，返回2指针1temp = *u;记住，u的值是&amp;x，即x的地址，所以u指向x。这意味着用*u即可表示x的值，这正是我们需要的。不要写成这样：\n1temp = u; /* 不要这样做 */因为这条语句赋给temp的是x的地址（u的值就是x的地址），而不是x的值。函数要交换的是x和y的值，而不是它们的地址。\n二维数组名、二维数组名取地址、二级指针首先给出几个定义：\n12typedef int (*p1x4)[4];//定义数据类型，p1x4这种类型为指向含4个int元素的1维数组的指针typedef int (*p3x4)[3][4];//定义数据类型，p3x4这种类型为指向含3x4个int元素的2维数组的指针下面从一维数组说起：（定义：int a[4]）\n一维数组名a是个地址，地址类型为：int *\n\n一维数组名取地址&amp;a是个地址，地址类型同：int (*p)[4]， 也即&amp;a指向含4个int元素的一维数组\n\n再看二维数组b[3][4]，这个二维数组也可以可以看成一个含3个成员的一维数组，每一个成员含有4个int元素，依次，仿照一维数组的结论，有：\nb[0]是个一维数组名，也是个地址，地址类型为：int *\n\n&amp;b[0]是个地址，地址类型同：int (*p)[4]， 也即&amp;b[0]指向含4个int元素的一维数组\n更进一步：\n\nb是个地址，地址类型同：int (*p)[4]，也即b指向含4个int元素的一维数组\n\n&amp;b是个地址，地址类型同：int (*p)[3][4]，也即&amp;b指向含3x4个int元素的2维数组\n\n注意：尤其注意上面的（3），这条结论指出了：二维数组名实际上是一维数组的地址！\n总结：\n① 数组名，是指向它的第一个一级成员的指针\n② 数组名取地址，是指向整个数组的指针\nPS：所谓一级成员，举个例子，int a[5]，那么数组a的一级成员就是int型变量；int b[10][5]，数组b的一级成员是int [5]的一维数组\n","plink":"https://dxsummer.gitee.io/posts/4f274412/"},{"title":"加油吧！少年——社会还在逼他们继续奋斗","date":"2020-04-22T05:18:50.000Z","date_formatted":{"ll":"2020年4月22日","L":"2020/04/22","MM-DD":"04-22"},"updated":"2020-06-08T01:56:18.000Z","content":"文章引用知乎，视频源于B站\n问题想的有点多，但以目前能力解决不掉。\n观点不代表大多数。\n不喜欢的直接喷！\n以下是从男方的角度写的。\n一:社会风气\n【也不能说是被当下社会风气影响吧】\n举个身边的例子吧。 \n1、男方自身经济实力不足（没钱）\n  我大致粗略算了算，假设我有一个喜欢我，而且我也喜欢的女孩子，两个人三观还都合得来，那么即使他们家的要求，按照我个人感觉的最低……  \n  我需要大概56万的一笔费用。  也就是在老家桐城结个婚的所有花销。  仅仅是结婚而已。  房子30万首付得自己出吧（后续的贷款两人慢慢还。没毛病吧）  车子最低10万吧？难道面包车也可以么？  还有16万，彩礼+三金+婚宴（婚纱照司仪等等）+烟酒等等一系列所谓的看不见的花销……  16万不过分吧？我感觉。  这还是仅仅只是结婚，结完婚一年内要不要孩子呢？  \n2、这是个现实问题哦。    要的话，媳妇一怀孕最低一年半至两年，所有的花销压力基本上男方负担了吧。  媳妇如果有嫁妆垫一垫也可以，可我是按照最坏的打算准备的。    万一媳妇那边不随嫁妆呢？  \n3、小孩子不生病还好，一生病那钱花的……我大哥家的孩子一个月去医院两三次，一个月光在医院就一两千之多。这让人均工资在5.6000的家庭咋整？\n第二：责任问题  \n如果结婚真是那种到点就上班的活儿，那还好了，关键不是呀。  \n只是因为年轻人感觉到了，结婚对于一个男人/女人来说需要承担什么。  一种极重的责任感。牵一发动全身的感觉。双方父母，老婆孩子，大人还好啦，相对于小孩子来说，家庭条件不好的，从一开始他就落后别人一步了。大多数普通人结了婚，娃娃一生，扔给爷爷奶奶带，自己出去打工。对吧。当然啦，这是没办法的事情，陪伴和赚钱只能二选一。我从道德上表示理解，但个人情感上无法理解。这些在我看来，这是一种极其不负责任的表现。孩子在他小时候的大部分性格形成是需要父母的陪伴的，需要父母言传身教的。父母和爷爷奶奶本质上是不同的，再开明的爷爷奶奶，对待小孩子从情感上就不同于父母。另外没有父母陪伴，孩子没有底气，没有自信，当别的小朋友上学放学有爸妈接送，时间长了他会自己感觉和别人不一样。心里种下了种子，等待的就是若干年后的矛盾和恶性后果。我经常会听到有些家长说:那家小孩不是这样过来的，我们小时候都这样过来的，不也活的好好的，就你不行？我想说的是：你愿意赌那万分之一，那是你的事，我不愿意。重要的是我们90后长大了，有一大部分人都有过这样的经历，那个时候我们被称为“留守儿童”。  我们是经历过的，亲身体验到被留守是什么感觉。可家长们看到的大多数”幸存者”都是有一点点运气在里面的，后面死掉的不知道多少。他们喜欢拿特例当典范，好比人家买彩票中一千万，我买怎么就不中？你看看别人家如何如何，你怎么就不行？或许也因为年轻人怕自己给不了孩子想要的生活，所以宁愿单着。从某方面来说，也可以算是一种逃避和懦弱。万一……我像我父母那样怎么办？我的孩子要重复我的一生么？明知问题在哪儿，可就是无法解决。人们叫嚣着让他们去努力，拼搏，积极向上……一堆堆的大道理扑面而来。可年轻人现在接触的信息比以往更加的激烈和冲突。他们深知这个世界没道理可言。某些人说的都是建立在道德上的道理，现实中，只能精神慰藉。就像我们都知道的“拾金不昧”“见义勇为”这种道德体系的东西，在我看来，这是社会结构的“大纲，骨架”。但流通的血液是权利和金钱。可现如今……人心却不是以前的心了。\n三：认识自己穷，怕给不了她幸福大多数男生认识到自己穷了，这是真的，当今的社会，太过于物质化。谁不希望能有一个童话般的爱情故事？现实就是，柴米油盐酱醋茶会不断的用同一个招式把你从左边捶到右边。再从右边捶到左边。没有物质滋养的爱情，没有光泽，没有保鲜期，古话说的好：贫贱夫妻百事哀。我知道贫贱夫妻百事哀的原译文不是这个意思，但现在来形容另一种也不为过。没有这个赚钱的能力，结了婚说白了:害人害己。害了父母，害了媳妇，害了孩子，害了自己。我希望的是男方可以在结婚前就有一定经济基础，或者工作稳定，有可观的稳定的收入来源，有一笔相对来说能够应付两到三年的花销存款，这是对家人也是对另一半和孩子的一种保障吧。为什么这么说？时代不一样了，过去父母那辈儿结婚，物质条件的需求是啥？冰箱，收音机，摩托车。可以说人人通过努力都能达到，它的可得性要比现在大的多的多。现在呢？我有时回想起父辈们常说的一句:努力奋斗，肯吃苦，就可以把日子过好。现在想想……不以为然。难道那些父辈们的吃苦耐劳，流血流汗还是算不上努力么？或者说他们的努力还不够？那为什么他们努力一辈子，却还要两代人合力都买不起一套房子了？还要绑定下一代二三十年的时间和收入，才能勉强有个“家”？那这样努力，不就是个笑话呢？我不是说努力无用，努力是有用的，可你的努力追不上社会经济发展。这不是笑话，这是活生生的现实。网络上有一句话:你不努力下，你都不知道什么是绝望。年前看上一套房，拼死拼活干一年，攒个十几万去交首付，结果房价涨了。只够买半个房子了。\n【笑哭】社会高速发展所带来的弊端，高房价，高物价，时时刻刻都在冲击着年轻人的三观和对社会美好的期待。\n混迹这么久 我一直在踏步 没有进步，还是会陷入最后的死结 如我所愿 我不是解决 我只是在逃避，最后还是想告诉你 如果当下很难 不要压抑自己 找一个信赖的人 哭一哭诉说一下真的很解压 然后在打起精神面对 多去做一些事情充实自己 看书 或者学一中乐器 给自己找点爱好 因为我们的生活里不能只有责任和义务  活的通透一些自私一些真的很好。\n不管如何，现在年轻人的压力是很大的，无论哪个城市都一样。买房、买车要花钱，结婚要花钱，照顾父母要花钱，抚养小孩要花钱……到处都要钱，然而现在的环境，物价房价飞涨的厉害，以现在大多数年轻人的收入，怎么能实现房车以及稳定情感的目标？很难。\n说句实在话，倘若没有父母的帮扶，绝大多数的人是不可能买车买房的，光靠自己个人打拼，起码得打拼十多年，才能够实现自己的生活愿景。但是又有多少人能够忍得住十多年的时间，等到自己35岁以后再去实现这些事？\n在合适的年纪，做不了符合内心想做的事，这是现代年轻人觉得焦虑、感觉压力大的根本原因。\n现在是越年轻越轻松不了，只有奋斗，才能创造自己想要的生活。但是，当这种生活通过奋斗都还实现不了呢？就只能丧了。\n如果重来一次，你还会读计算机专业吗？\n","plink":"https://dxsummer.gitee.io/posts/ca5d3c1d/"},{"title":"PS简单的抠图方法","date":"2020-04-20T10:45:49.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-06-08T01:56:26.000Z","content":"魔棒与快速选项工具首先把需要抠图的素材拖入PS里，然后对背景图层执行CTRL+J复制。（提示：无论你要做什么，都要先解锁背景图层在对背景图层执行CTRL+J复制）\n\n点击左侧工具栏的魔棒工具，在副本里需要删除的地方，单击鼠标左键，之后会出现蚂蚁线按Delele清除（快速选项工具同理）  \n\n\n最终效果图与对比图\n（提示：用魔棒工具抠图还留有白边，这是我们要用橡皮擦细心的擦去白边，为了看起来不生硬，按住CTRL+鼠标左键单击图层生成选区，然后在选区里右键→羽化【1-2值】→Delele清除）\n通道抠图法首先把需要抠图的素材拖入PS里，然后对背景图层执行CTRL+J复制。（提示：无论你要做什么，都要先解锁背景图层在对背景图层执行CTRL+J复制）\n\n点击来到通道面板下，观察一下那个通道的明暗反差大一些，在抠图的时候，要在反差较大的那个通道来进行操作。通道比较发现，绿色和红色通道都还可以，不过绿色要更好一些，这里我们就选择绿色来进行通道抠图了。\n\n右键复制绿色通道\n\n选中绿色通道，按CTRL+L色阶处理，这能使图片反差更明显\n\n然后用画笔工具把需要清除的地方涂黑（提示：如看不清边缘，请点击RGB图层进行选区，然后再换回绿色通道，用油漆桶涂黑）\n\n之后，用画笔工具，把颜色调成白色，然后我们就可以大胆的把需要保留的地方涂成白色\n\n复制后，还有发现有一些边缘和头发没弄好，如图所示\n\n是不是还发现有一处头发没弄好呢，别急，我们先复制一层原图+蒙版，PNG图层也是。擦完之后要 向下合拼图层 抠图工具及方法\n\n是不是觉得好有点生硬呢，不怕，我们按住CTRL+鼠标左键，点击PNG图层，建立选区。然后在选区里右键羽化【1-2值】，反向选择，Delele清除。如果还觉得生硬就再次羽化。（提示：PNG图层就是指你抠出来的图像）\n\n钢笔与套索工具先用钢笔或套索工具，抠出不要的地方，如果看到有瑕疵的地方就用橡皮擦慢慢调整好。\n","plink":"https://dxsummer.gitee.io/posts/164adefb/"},{"title":"Step 1　先搞懂概念与时态","date":"2020-04-20T02:16:27.000Z","date_formatted":{"ll":"2020年4月20日","L":"2020/04/20","MM-DD":"04-20"},"updated":"2020-07-23T07:50:32.000Z","content":"Day01什么是英语语法？\n\n什么是英语语法？\n\n英语语法，指英语中语言的结构规律，主要包括“单词、短语、句型和语法”四个要素。以下就根据这四个要素做细节说明：\n单词英语单词依据在句子中的作用，可分为八大词类，分别为名词、代词、形容词、动词、副词、介词、连词和感叹词。以下为详细说明：\n名词：表示人、地、事、物等的词。名词分为可数名词和不可数名词，可数名词前要加冠词a / an，不可数名词前要加定冠词the，例如：a book, an apple, the air。\n\n代名：表示代替名词或名词短语的形式用词。代名词可以分为：\n\n形容词：用来修饰名词或代词的词。形容词可分为：\n\n动词：是用以表示动作或状态的词，例如：be, go, get, have, run, send等。另外，动词在使用上，要特别注意时态和语态的变化。\n\n副词：可用来修饰动词、形容词和其他副词，也可以用来修饰短语。副词分为：\n\n介词：通常放在名词和代词之前，用来表示名词或代词和其前面词的关系。介词从形式上来分有四种：\n\n连词：用来连接单词、短语、从句和句子的词。连词分为：\n\n感叹词：用以表示强烈的情绪和感情的一种声音或叫喊。例如：Hello! Hurrah! Hi! Oh！等等。\n\n短语短语是由两个或两个以上的英语单词所组合的词语，不包含主语和动词，可以构成句子的一部分，也可以用来当名词、形容词和副词使用。短语主要分为以下五大种类：\n句型句子是按照一定的语法规律组成的，表达一个完整的意义。一个句子一般由两部分构成，即主语部分和动词部分，这两部分也是句子中最主要的成分。而句子的次要成分包括宾语，形容词，副词，主语补语等。首先介绍一下，在一般语法说明中容易使用到的英语缩写：\n及物动词：后面必须跟宾语意义才完整\n\n不及物动词：本身意义完整后面不需要跟宾语\n\n直接宾语：动作的承受者，物\n\n间接宾语：动作对谁，为谁做\n\n\n以下为英语五大基本句型：\n\n句型01：S＋V（主语＋不及物动词）\n\n句型02：S＋V＋SC（主语＋系动词＋表语）此结构中的动词常为系动词，例如：look, seem, appear, prove, become, turn, sound, taste, keep, stay… 等。\n\n句型03：S＋V＋O（主语＋及物动词＋宾语）\n\n句型04：S＋V＋O1＋O2（主语＋双宾动词＋间接宾语＋直接宾语）间接宾语通常会是“人”，直接宾语通常会是“物品”。\n\n句型05：S＋V＋O＋OC（主语＋使役动词＋宾语＋宾语补语）\n\n语法英语语法有一定的规则，它是客观存在的，而不是语言学家规定的。语言学家只是对其进行归纳、整理，并选择恰当的方式把它们描述出来。学习英语语法得注意如下基本规则：\n规则01：两个动词是不能连在一起的。x　I like play piano.（我喜欢弹钢琴。）o　I like to play piano.\n\n规则02：如果一定要同时用两个动词，第二个动词的前面必须加“to”，或是加上“-ing”。例如：x　I like swim.（我喜欢游泳。）o　I like to swim. / I like swimming.\n\n规则03：主语如果是第三人称单数，现在时中的动词必须加“s”，例如：x　She sing very well.（她歌唱得很好。）o　She sings very well.\n\n规则04：绝大多数的否定句，不能直接加not，必须加上助动词或使役动词。例如：x　I not want to go.（我不想离开。）o　I don’t want to go.\n\n规则05：在不定式“to”的后面，必须用动词原形，例如：x　She wants to becomes a good teacher.（她想要变成一位好老师。）o　She wants to become a good teacher.\n\n规则06：英语中有所谓的助动词。英语中有很多助动词，除了do外，can, may, might, would, will, must也是助动词。例如：情态动词+动词原型x　You must practiced your English every day.（你必须每天练习英语。）o　You must practice your English every day.\n\n规则07：大部分的英语问句都要包含助动词，例如：Do you like playing basketball?（你喜欢打篮球吗？）How many books do you have?（你有多少本书？）\n\n规则08：特殊动词随主语变化，另外，英语中有些动词因主语不同而有所变形，例如be动词。I am a good student.（我是一位好学生。）She has a big heart.（她有宽大的胸襟。）They have been to Paris.（他们去过巴黎。）\n\n一般现在时vs．一般过去时\n一般现在时表示经常性、习惯性的动作、行为或者现在的某种状况；一般过去时表示过去某一时间内发生的动作或存在的状态，常与表示过去的时间副词连用，例如：yesterday, last night / week, a month ago, in 1990’s等。\n现在时使用时机与现在时动词连用，依照使用时机分为：\n现在时刻发生的动作或状态。It’s five o’clock now.（现在五点钟了。）\n\n经常性或习惯性的动作，常与always, usually, often, sometimes等频率副词连用。We have three meals every day.（我们每天吃三顿饭。）\n\n主语具备的性格、能力和本质特征等。He likes playing soccer.（他喜欢踢足球。）  \n喜欢某事物，以前就喜欢，还可能持续 like doing  \n表示想要，欲做某事 like to do\n\n客观事实、普遍真理、名言、警句或谚语等。The earth goes around the sun.（地球绕着太阳转。）\n\n按规定、时刻表、计划或安排要发生的动作。通常会用一般现在时表示将来的状态。常用的动词有：begin, start, stop, arrive, come, go, leave, return, open, close, be等。例如：School begins the day after tomorrow.（学校后天开学。）\n\n在由when, before, after, until, as soon as等连接的时间副词从句和if引导的条件副词从句，以一般现在时表示将来的动作。Remember to turn off the light before you leave.（离开之前记得关上电灯。）\n\n在由here、there引导的倒装句中，表示此刻正在发生的动作。There goes the bell.（铃响了。）\n\n过去时使用时机表示过去特定时间发生的动作或状态。My dad won the music award last year.（我爸去年赢得了一项音乐奖。）\n\n表示过去经常或反复发生的动作。She often came to help me when I was in trouble.（我遇到麻烦的时候她总是来帮助我。）  \n\n另外，若是要表示过去的“习惯性”动作，可用would, used to来表达，例如：He used to go to school by bus.（他过去经常坐公共汽车去上课。）\n\ngo是不及物动词，后面跟名词则+to  不及物动词+to+名词  home是副词，所以不用+to\n\narrive+at/in+名词  I often go to school by bike.\n  I go home at 5 o’clock.\n  I arrived in London yesterday.\n  I arrived here just now.\n\n延伸用法，事半功倍！\nLearning Plus!\n\n一般现在时vs．一般过去时的“相同点”两者均可表示人的性格、特征、爱好以及习惯，常与频率副词often, sometimes, seldom, usually, always, once a week等连用。  \nI often play basketball.（我常常打篮球。）  \nI often played basketball when I was at school.（我以前在学校的时候常常打篮球。）\n\n一般现在时vs．一般过去时的“不同点”  \n\n一般现在时表示现阶段发生的动作或状态，以及永恒不变的事实、自然规律，常与时间副词today, every day, every morning, on Sunday等连用。  \n- I ride bike to school every day.（我每天都骑自行车上学。）  \n- Springs return in March.（春天会在三月到来。）\n\n一般过去时表示过去阶段发生的动作或状态，常与时间副词yesterday, last year, last night, the day before yesterday, this morning, two days ago等连用。\n- I lost my mobile phone yesterday.（我昨天弄丟了我的手机。）  \n- She met her ex-boyfriend on the street the day before yesterday.\n  （她前天在路上遇到了她的前男友。）\n\n语法观念例句示范Shelly is my best friend since 10 years ago. 雪莉从10年前开始就是我最好的朋友。\n\nI get up at seven every day. 我每天都七点钟起床。\n\nShe speaks English very well. 她英语说得很好。\n\nWe lived in Thailand ten years ago. 我们十年前住在泰国。\n\nIt was very hot yesterday. 昨天天气很热。\n\nWhen I was a child, I often read comic books. 我小的时候经常看漫画书。\n\nDid you have a good time last night? 你昨天晚上玩得开心吗？\n\nShe stayed in Paris for almost a month. 她在巴黎待了将近一个月。\n\nWendy comes from Canada and speaks good French. 温蒂来自加拿大，而且说得一口好法语。\n\nMandy doesn’t know how to read the map.曼蒂不会看地图。\n\n语法观念辨析练习\n请填入正确时态的动词。\n\n01．I often________(go) to school by bus.\n02．He________(play) basketball every day.\n03．I________(be) hungry now.\n04．They________(go) to the ZOO yesterday.\n05．Mr. Smith________(come) to Hong Kong last Sunday.\n06．His mother________(watch) TV for 8 hours last night.\n07．There________(be) a shop not long ago.\n08．I________(need) a glass of water.\n09．She________(be) a student two years ago.\n10．The river________(run) to the ocean.\n\n正确答案及题目译文：\n\n\n将来时\n将来时表示将来某个时间要发生的动作或存在的状态，也表示将来经常或者重复发生的动作，常与表示将来的时间副词连用，例如：tomorrow, soon, next week, this afternoon…。We will graduate next year.　我们明年毕业。\n将来时的句型构成陈述句：S＋will / shall＋V原形第一人称I, we用shall或will，其余人称都用will。I will call you this afternoon.（我下午会打电话给你。）He believes that he will win the Best Sales of the Year.（他深信他会赢得年度最佳业务员奖。）\n\n否定句：S＋will / shall＋not＋V原形Because John failed his final exam, so his parents will not let him join the band.（约翰的父母不会让他参加乐团，因为他的期末考试考得太差了。）\n\n疑问句：Will / Shall＋S＋V原形？Shall we dance?（我们来跳舞吧？）\n\n\nOf    1. （属于）···的 The wood of this desk is cracked.    2. 某某市 The city of London.    3. 数量 a kind of、a piece of、a bottle of    4. 部分/全部 all of us、most of all    5. 时间  of the year 本年度的 、of year每年的、for the year本年度\n\n将来时使用时机表示将来某个时间点要发生的事She will go to visit the British Museum tomorrow.（她明天会去参观大英博物馆。）\n\n表示不以人意志为转移的自然发展的事。Jack will be 20 next year.（杰克明年将满20岁。）\n\n在疑问句中用来征询听话人意图或愿望。Will you go shopping with me?（你要和我一起逛街吗？）\n\n表示说话时马上要做的事，也就是临时决定要做的动作。A：Tom is in hospital now. He is serious ill.（汤姆现在在医院。他病得很严重。）B：Oh, I’m sorry to hear that, I will go and see him.（太不幸了，我马上就去探望他。）\n\n延伸用法，事半功倍！用“be going to＋动词原形”表示将来  \n表示打算或计划在最近或将来要做的事。  My friend and I are going to travel together this summer.  （我和我朋友打算今年夏天一起去旅游。）\n表示根据某种迹象，在最近或将来将要发生的事情。  Dark clouds are gathering. It is going to rain.（乌云在聚集，看来要下雨了。）\n\n用“be to＋动词原形”表示将来  \n表示按计划、安排要做的事，具有“必要”的强制性意义。  The meeting is to take place tonight.（今晚召开会议。）\n表示约定、责任、命令或注定要发生的动作。  Our plan is to be a failure.（我们的计划注定会失败。）\n官方计划或决定（常见于报纸或广播）。  The President is to visit USA next week.（总统将于下个星期出访美国。）\n用”be about to＋动词原形”表示将来。表示（按计划）即将发生的动作或情况。  My grandpa is about to retire.（我祖父就要退休了。）  She was about to go out when I arrived.（我来的时候她正准备出门。）\n\n用“一般现在时”表示将来 表示一个按照规定、计划、安排或时刻表而即将要发生的情况。通常句中都会包含一个表示将来的时间副词。 The train leaves at three this afternoon.（火车将在下午3点出发。） The film begins in ten minutes.（电影十分钟后开始放映。）  \n\nTIPS! 时间副词、条件副词从句中，从句一般用现在时表示将来，而主句则用将来时。 I will go shopping when I am free. （我空闲的時候就去逛街。）\n\n\n用“现在进行时”表示将来 表示即将发生的将来，多与表示移动的动词come, go, arrive, leave, start, take off等连用。 The doctor is coming to check you in 5 minutes. （医生5分钟之内就会为你做检查。） The train is leaving.（火车离开了。）\n\n用“There will＋be”表示将来 There will be＋名词＋其他补语，但无论后面的是单数名词还是复数名词，be动词必须用原形。 There will be a conference call at 3 p.m. tomorrow.（明天下午3点有个电话会议。）\n\n祈使句＋将来时 句型：祈使句＋and / or＋将来时＋（will） Work hard or you will fail.（努力工作否则你就会失败。） Work hard and you will succeed.（努力工作你就会成功。）\n\n语法观念例句示范My sister will go to Paris on vacation. 我姐姐要去巴黎度假。\n\nI’ll be a good teacher as long as I can pass this test. 只要我能通过这个测验，我就能成为一名优秀的教师。\n\nHe is going to work next week. 下星期他要去工作。\n\nI am going to have a picnic with my co-workers in a few weeks. 几星期后我要和我的同事们一起野餐。\n\nWill you leave for Hong Kong tomorrow? 你明天要去香港吗？\n\nHe is to come to see me at four this afternoon. 他今天下午4点会来见我。\n\nI will meet you at 10 a.m. in the airport tomorrow, Ok? 我们明天早上10点在机场见面，好吗？\n\nShe was about to leave when the phone rang. 她正准备出门的时候，电话响了。\n\nWe are about to finish this project. Don’t give up now. 我们快要完成这个项目了，千万不要现在放弃！\n\nIf it rains tomorrow, the picnic will postpone to next weekend.如果明天下雨，野餐就延期到下个周末举行。\n\n语法观念辨析练习01．He will write to his father as soon as he________Italy.A arrivedB arrivesC is arrivingD will arrive  \n02．My father________fifty years old next year.A is going to beB shall beC is to beD will be  \n03．He said, “Look at these black clouds.____.”A It is to rainB It’ll be rainingC It’s going to rainD It’ll rain  \n04．I hope that you________a good time this evening.A haveB are havingC will haveD has  \n05．There________a basketball match this afternoon.A will haveB will beC hasD have  \n06．We________to the park if the weather is nice tomorrow.A will goB goC goesD to go  \n07．Don’t be late, Lily.The test________at 10 a.m.A is startingB has startedC would startD starts\n08．I don’t know if it________or not tomorrow.A will snowB snowsC has snowedD is snowing\n09．She has bought some cloth. She________herself a dress.A makesB is going to makeC would makeD has made\n10．There________a birthday party for Kevin this Sunday.A shall beB will beC shall going to beD will going to be\n\n正确答案及题目译文：\n\n\nDay02现在进行时vs．过去进行时vs．将来进行时进行时的句型构成\n现在进行时陈述句型：S＋be（is / am /are）＋现在分词（V-ing）I am playing piano with my brother now.（我和我哥哥正在一起弹钢琴。）\n\n否定句型：S＋be（is / am /are）＋not＋现在分词（V-ing）Tony is totally not listening.（汤尼根本就没在听。）\n\n疑问句型：be（is / am /are）＋S＋现在分词（V-ing）?Are you reading now?（你在读书吗？）\n\n过去进行时一般句型：S＋be（was / were）＋现在分词（V-ing）She was trying on a piece of new clothes when her phone rang.（电话响时候她正在试穿一件新衣服。）\n\na piece of 既可以加可数名词，也可以加不可数名词\n\n\n否定句型：S＋be（was / were）＋not＋现在分词（V-ing）I was not speeding!（我当时并没有超速！）\n\n疑问句型：be（was / were）＋S＋现在分词（V-ing）?Were you talking to Tom on the phone at 8 p.m. last night?（你昨晚八点是否在跟汤姆打电话？）\n\n将来进行时一般句型：S＋will be＋现在分词（V-ing）If I continue to go out with you, my mother will soon be very pissing off.（如果我继续跟你出去，我妈妈很快就会非常生气。）\n\n否定句型：S＋will be＋not＋现在分词（V-ing）I hope it won’t still be raining when I have to go to work.（我希望我要上班的时候不要还在下雨。）\n\nwon’t = will not\n\n\n一般句型：Will＋S＋be＋现在分词（V-ing）?Will you be using your notebook tomorrow morning?（你明天早上还会用你的笔记本电脑吗？）\n\n进行时的使用时机\n现在进行时表示现阶段正在进行的动作。常与\n now right now：现在；马上；立刻 at the moment=right now：此刻；现在；目前 for a moment： “一会儿”表示时间的延续，一个段时间。 in a moment = very soon “很快，立即，马上，不久”,一般用于将来时的句子 at present：现在；当今；眼下 for the time being：暂且；眼下；now暂且，就现在来说\n 等时间副词连用，例如： I am looking for someone to talk with now.（我现在想找个人来说说话。）\n\n表示一个在最近按计划要进行的动作。常与一个表示将来的时间副词连用，这种情况仅限于少量动词，如go, come, leave, start, arrive, work, have, stay, play, return等。I am coming to pick you up.（我马上就来接你。）\n\n表示反复发生或持续存在的状态。常与always, constantly, forever等词连用，往往带有说话人的主观色彩，多含抱怨意味。You are always changing your mind with no reason.（你老是毫无理由地改变主意。）\n\n表示强调逐渐变化或改变的过程。常与get, grow, change, become, turn, go, run, begin等动词搭配。My parents are getting old.（我的父母越来越老了。）\n\n过去进行时表示过去的某个时刻或时间正在进行的动作。常与表示过去的时间副词then, at that time, this time yesterday, at six yesterday等连用。 I was reading a novel this morning.（上午我在看小说。）\n\n表示某种强烈感情。常与always, constantly, forever等副词连用。 She was always complaining.（她老是抱怨。）\n\n表示过去某个事件发生时，另一个正在进行的动作。此时，延续性动作用过去进行时，瞬间动作用一般过去时。 I met Ann when I was shopping this morning.（我早上逛街时遇到了安。）\n\nTIPS!\n\n 如果表示的是两个延续性的动作，都用过去进行时。 Some students were playing football,while others were running around the track. （一些学生在踢足球，另一些学生在跑步。）\n\n过去进行时可以表达委婉语气，例如：I was wondering if you can give me a lift.（不知我可否顺便搭你的车。）\n\n表示过去某个时间认为“将来”要发生的事。When his son arrived, the old man is dying.（当他的儿子抵达的时候，这位老人已经奄奄一息。）\n\n将来进行时表示在将来某个时间正在进行的动作。At this time tomorrow, I will be sleeping at home.（明天这个时候我将会在家睡觉。）\n\n表示按计划或安排，将来要发生的动作。We will be spending our summer vacation in Hawaii.（我们将在夏威夷过暑假。）\n\n表示不含意图又未发生的动作。Lucy won’t pay this bill.（露西不肯付这笔钱。）→表意愿Lucy won’t be paying this bill.（不会要求露西来付钱的。）→单纯谈将来情况\n\n表示委婉语气。Will you be having a cup of coffee?（要来杯咖啡吗？）\n\n延伸用法，事半功倍！表示状态或感觉的动词，如果指现在的情况的话，一般不用进行时，而要用一般现在时，这样的动词有：love, like, hate, want, hope, need, wish, know, understand, remember, belong, hear, see, seem, have, sound, taste等，但如果它们的词义改变，也可以用进行时态。\nShe looks pale. What’s wrong with her?（她看起来很苍白。她怎么了吗？）→look此为系动词，意为“看起来，显得”。\nShe is looking for her books.（她在找她的书。）→look在此为实义动词，意为“寻找”。\n语法观念例句示范I was reading the newspaper when the doorbell rang.我正在看报，突然门铃响了。\n\nI’ll be taking holidays soon.不久后我将在度假了。\n\nIt’s raining outside now.现在外面在下雨。\n\nWe are having a meeting now.我们现在正在开会。\n\nI was doing my homework while she is listening music.我在做作业的时候，她正在听音乐。\n\nThis time next week I will be lying on the beach.下个星期的这个时候我就会躺在沙滩上了。\n\nWhen I got to the top of the mountain, the sun was rising.当我到达山顶的时候，太阳正在升起。\n\nThe train is leaving soon.火车马上要开了。\n\nShe will be coming home soon.她不久后就会回家了。\n\nThe leaves are turning yellow.树叶变黄了。\n\n语法观念辨析练习用所给动词的正确形式填空。\n01．I________(clean) my room now.\n02．Jessie________(do) her homework when I called her last night.\n03．What________you________(do) now? I________(sing).\n04．My father________(read) newspaper at ten yesterday.\n05．It________(rain) when I went out yesterday.\n06．David________(play) chess with his grandfather now.\n07．He________(mend) a car now.\n08．This time next day they________(sit) in the cinema.\n09．I________(have) a meeting at 3 o’clock tomorrow afternoon.\n10．What do you think you________(do) at this time next year?\n正确答案及题目译文：\n现在完成时vs．过去完成时vs．将来完成时完成时的句型构成\n现在完成时陈述句型：S＋has / have＋过去分词（p.p.）I have already finished my homework.（我已经完成了我的作业。）\n\n否定句型：S＋has / have＋not＋过去分词（p.p.）Sandy has been a nurse in this hospital for 15 years.（珊蒂已经在这间医院担任护士长达15年了。）\n\n疑问句型：Has / Have＋S＋过去分词（p.p.）?Have you ever seen Peter in past 3 months?（过去3个月内，你看见过彼得吗？）\n\n过去完成时陈述句型：S＋had＋过去分词（p.p.）This proposal had been delivered by Eva before Aaron finished it.（这个计划在艾伦完成以前，伊娃就已经提交出去了。）\n\n否定句型：S＋had＋not＋过去分词（p.p.）I had not finished my work when he visited me last week.（上周他来拜访我以前，我还没有完成工作。）\n\n疑问句型：Had＋S＋过去分词（p.p.）?Had you ever been to a blind date before you married?（你结婚以前曾经参加相亲吗？）\n\n将来完成时陈述句型：S＋shall / will＋have＋过去分词（p.p.）They will have finished the meeting by now.（他们现在应该已经开完会了。）\n\n否定句型：S＋shall / will＋have＋not＋过去分词（p.p.）We will have not made 10 apple pies by the end of today.（我们在今天结束之前不能做完10个苹果派。）\n\n疑问句型：Shall / Will＋S＋have＋过去分词（p.p.）?Will they have already left by the time we get there?（我们到的时候，他们会不会已经离开了？）\n\n完成时的使用时机\n现在完成时表示过去发生的动作对现在所造成的影响。常与just, already, yet, recently, before, twice, three times等时间副词连用，例如：Luckily, I have seen the questions before.（很幸运，我之前就已经看过这些问题。）\n\n表示从过去某一时刻开始一直延续到现在的动作或状态，常与“since＋时间点”、“for＋时间段”，及how long, (ever) since, ever, before, so far, in the last / past few years, up to now, till now等时间副词连用。例如：She has been a PE teacher for five years.（她已经当了五年的体育老师了。）\n\n表示从过去某个时间直到现在的这个时间范围内，不断重复发生的动作或情况，并且这个不断重复的动作可能继续下去，也可能到现在就结束。He has always gone to school by bus.（他总是坐公共汽车上学。）\n\n有时可用于时间或条件副词从句中代替一般现在时，表将来意义。例如：You can have a rest if you have finished your work.（如果你完成了工作就可以休息一下。）\n\n过去完成时表示在过去某一时刻或某一动作之前已经完成了的动作，即“过去的过去”。例如：The train had left before she got to the station.（在她抵达车站之前，火车已经开走了。）\n\n表示从过去某一时刻开始一直延续到另一过去时刻的动作或状态。常与how long, for three days, before等表示一段时间的状语连用。例如：By twelve o’clock, I had worked ten hours.到12点钟时我已经工作了10个小时。\n\n表示未曾实现的希望或打算，即“本来希望或打算做某事（但却没有做）”。常与wish, hope, want, expect, think, suppose, plan, mean, intend, desire等动词连用，例如：I had meant to take a good holiday this year, but I wasn’t able to get away from this job.（本来打算今年好好度假的，但我还是没办法从工作中脱身。）\n\n将来完成时表示在将来某一时刻或某一时刻之前已经完成的动作，往往对将来某一时间产生影响，常与表示将来的时间副词及条件或时间副词从句连用。例如：They will have arrived by now.（她们现在应该已经到了。）If you come at six o’clock, I shall not yet have finished dinner.（你若六点钟可以到，我应该还没吃完晚饭。）When we get there, he will have gone to work.（我们到那里时，他应该已经去上班了。）\n\n 将来时只有have\n\n\n表示一种推测，主语要用第二、第三人称。例如：You will have finished your homework by now.（这时候你应该已经完成了你的作业。）She will have watched this film already.（她恐怕已经看过这场电影了。）\n\n延伸用法，事半功倍！主句与从句中完成时的运用：\n 如果主句中的谓语动词为一般现在时，从句中谓语动词就用现在完成时； 如果主句中谓语动词是一般过去时，从句谓语动词用过去完成时。例如：\n\n\n过去完成时常用于以下固定句型：\n (a) hardly, scarcely, barely＋过去完成时＋when＋一般过去时 Hardly had I got on the bus when it started to move. （公共汽车开车前，我差一点就赶不上了。）\n (b) no sooner＋过去完成时＋than＋一般过去时 No sooner had I got in the office than the manager started to yell at me. （我一到办公室，经理就开始对我吼叫。）\n (c) by (the end of)＋过去时间副词→主语的谓语动词用过去完成时 The experiment had been finished by 4 o’clock yesterday afternoon. （这个实验在昨天下午四点结束。）\n\n语法观念例句示范01．I have just received a letter from my mother.我正好收到一封来自我妈妈的信。\n02．As soon as the sun had set we returned to our hotel.太阳一下山我们就回到了旅馆。\n03．I had not understood the problem until she explained it.直到她给我解释我才明白问题出在哪。\n04．They have seen the film several times.这部电影她们已经看了好几次。\n05．I have lived here for ten years.我已经在这里住了十年了。\n06．Next Monday, I shall have been in this company for a year.到下周一，我到这家公司就满一年了。\n07．He will have gone back to Paris.他想必已经回巴黎去了。\n08．I had meant to go to your party, but something happened.我本打算去你的派对，但突然发生了一点事。\n语法观念辨析练习请选出题目中最适合的选项。\n01．No sooner________than the accident happened.A he had goneB had he goneC his goingD he went.\n02．We have been friends since________.A five yearB five yearsC five years agoD five years before\n03．You________that question three times.A already askedB have already askedC already have askedD asked already\n04．All the machines________by the end of the following week.A were repairedB will be repairedC have been repairedD will have been repaired  \n05．His grandfather________for thirty years.A diedB was deadC has been deadD has died\n06．”Are Alice and Tom still living in London?””No, they________to New York.”A are just movedB have just movedC had just movedD will just move\n07．I lost the dictionary I________.A have boughtB boughtC had boughtD had been bought\n08．I________800 English words by the time I was ten.A learnedB was learningC had learnedD learnt\n正确答案及题目译文：\n完成进行时（现在vs．过去vs．将来）完成时的句型构成\n现在完成进行时基本句型：S＋has / have＋been＋V-ingThe Smith Family has been making sports car for 200 years.（史密斯家族有200年制作跑车的历史。）\n\n否定句型：S＋has / have＋been＋not＋V-ingI have been not dancing for three months.（我已经三个月不跳舞了。）\n\n疑问句型：Has / Have＋S＋been＋V-ing ?Has Enzo been learing English since three years ago?（恩佐从三年前就开始学英语了吗？）\n\n过去完成进行时基本句型：S＋had been＋V-ingEli had been playing games before you got home.（伊莱在你回家之前一直都在玩游戏。）\n\n否定句型：S＋had been＋not＋V-ingAmy had been not working for ten years before I met her.（艾米在我遇到她的十年前就没在工作了。）\n\n疑问句型：Had＋S＋been＋V-ing ?Had your father been driving all day before he went to sleep?（你爸爸在睡觉之前开了一整天的车吗？）\n\n将来完成进行时基本句型：S＋will / shall＋have been＋V-ingWhen Mrs. Wang retires next year, she will have been teaching for 40 years.（当王太太下个月退休时，她就已经教书教了四十年。）\n\n否定句型：S＋will / shall＋not＋have been＋V-ingI won’t have been waiting for you since you keep talking to me like this.（如果你继续这样对我说话，我就不会一直等着你的。）\n\n疑问句型：Will / Shall＋S＋have been＋V-ing ?When Leo goes out tonight, it will have been raining.（当里奥今天晚上出门的时候，外头应该正下着雨。）\n\n完成时的使用时机？\n完成进行时是完成时的强调形式，分为现在完成进行时、过去完成进行时及将来完成进行时。\n现在完成进行时表示从过去某个时候开始一直延续到现在的动作，强调现在仍然在进行，并还可能继续延续下去；\n过去完成进行时表示从过去某一时间开始一直延续到另外一个过去时间的动作，这个动作在当时仍在进行并可能继续延续下去；\n未来完成进行时表示在未来某一时间以前已经完成，或一直持续的动作。\n现在完成进行时表示从过去某个时候开始一直延续到现在的动作。强调现在依然在进行，并还可能继续延续下去。例如： I have been looking for my lost book for two days, but I still haven’t found it. （我已经找我弄丢的书找了两天了，但我仍然没有找到。）\n\n表示根据直接或间接的证据得出的结论。Her eyes are red. She has been crying.（她眼睛红了。她一直在哭。）\n\n过去完成进行时表示从过去某一时间开始一直延续到另外一个过去时间的动作，这个动作在当时仍在进行并可能继续延续下去，例如：We had been waiting for her before she came in.（在她进来之前，我们一直在等她。）\n未来完成进行时表示在将来某一时刻之前开始的一个动作或状态一直延续到将来某一时刻，常与一个以by开头的时间短语连用。例如：By the end of this month, she will have been learning piano for half a year.（到这个月底，她就学钢琴半年了。）\n\n表示一种经常性反复进行的持续性动作。例如：By the end of this month, he will have been climbing mountains for ten years.（到了这个月底他的登山资历就满10年了。）\n\n语法观念例句示范01．We have been living here since 2000.从2000年起我们就住在这里了。\n02．He was out of breath. He had been running.他气喘吁吁。他一直在跑着。\n03．I heard you had been looking for me.我听说你一直在找我。\n04．I have been looking forward to meeting you.我一直盼望着见到你。\n05．Without doubt you have been working very hard.毫无疑问，你工作一向非常努力。\n06．By the end of this year, she will have been teaching for five years.到今年年底，她就当了五年老师了。\n07．On December we will have living here for two years.到12月1日，我们住在这儿就满两年了。\n08．She had been suffering from a bad cold when she took the exam.她在考试之前一直患重感冒。\n09．By the time you arrive tomorrow, she will have been typing for hours.到明天你抵达的时候，她将已经打了数小时的字。\n10．He had been mentioning your name to me.他总是向我提起你的名字。\n语法观念辨析练习请填入正确时态的动词。\n01．We________(wait) for her for two hours.\n02．They________(build) the bridge for six months.\n03．He________(study) abroad for one year.\n04．By the end of this month, I________(work) here for three months.\n05．He________(prepare) his exam till one o’clock this morning.\n06．Up to直到 that time he________(translate) those books.\n07．I wanted to know what________(go) on.\n08．She________(have) treatment治疗 all her life.\n09．By this time next year, we________(do) business with each other for 20 years.\n10．He gave up smoking last year. He________(smoke) for thirty years.\n正确答案及题目译文：\n","plink":"https://dxsummer.gitee.io/posts/8206f3bb/"},{"title":"原子弹制造从入门到精通","date":"2020-04-19T12:27:46.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:56:10.000Z","content":"原子弹制造从入门到精通\n在家闲来无事，于是与圈内大佬谈论了一下原子弹的原理，文章写作参考于谷歌、百度、必应和各位大佬，此文章仅供参考。\n\n准备工作 :我们大约需要３０磅的铀２３５，体积差不多有一个棒球的大小，再配合一些很容易到手的材料，这种炸弹就能使１／３哩以内任何东西化为乌有；２／３哩以内的东西严重受损；在１.２５哩半径内的人都会受到致命的辐射线；辐射尘随风飘扬，能使４０哩内的人都致病。如果它在纽约市引爆，大概有２５万人会死亡，还有４０万人会受伤。这种效果恐怖份子应该会很满意；这种原子弹甚至在战场上也都能派上用场。\n不过，要提醒各位：铀２３５的分量不要超过４５磅，因为对这样多的铀，其引爆的技巧相当困难，单凭业余的机槭工匠，大概是无法适时且有效地把这些东西凑在一起。挺有可能你还没做一半，它就在你面前 BOOM了，那可就真浪费感情。\n\n我个人的偏好是用３６磅或３７磅的铀２３５，因为这样效果不差，而且，如果设计上出点小差错，也不致于有太严重的后果。一旦把足够的材料紧聚在一起，我们最棘手的技术就是得使它们能紧聚在一起维持约半秒钟，这半秒钟的延迟就是技术上最主要的问题。\n\n原因是这样的：当这两堆物质靠太近时，会发生剧烈的反应而产生大量的能量，在瞬间（比一秒钟小很多）迫使这两堆物质分开。这样的结果和爆竹的效果差不多，几百尺外的人根本不知道有这回事。\n\n对一个稍有「自尊」的恐怖份子而言，是不会以此为满足的，对吗？所以，当务之急就是要设计出一套办法，使两堆铀２３５能聚得久一点，好让一些比较惊人的「大事」发生。如果你这位恐怖份子有栋两层楼房（含地下室）、两根火药、１５包水泥、２０立方码的沙石，那么大约只要一个礼拜就可以完工了。全部的费用，除去房租不算，大概只要３，０００美元就够了。根据当前汇率，折合成人民币大概就是 25000元。最后的问题是怎样把铀２３５或钸弄到手，这留待后面再谈。\n\n开始动工：准备妥当后，第一件事就是把分批弄来的铀２３５分成二等分，用一对半球容器装起来，你或可用乙炔喷灯（AcetyleneTorch）来作。\n铀的熔点是４１４。２℃，而乙炔喷灯的燃点是５２６。４℃，因此理论土来说，乙炔喷灯足以熔化铀２３５。也许你应该花几十块耐火砖作个窑，加上一个风箱，效果会此较好；不过如果你有耐心再加上一些运气（因为铀这东西燃烧会 BOOM），乙炔喷灯应该是够用的了。铀熔成液体后，流到半球状的洼槽（制陶瓷用的耐火泥就可派上用场），则第一个半球型作好冷却了，再移开作第二个。\n\n有件事要注意：这时候，在这区域附近不能有人。因为，铀有对人不利的特性。如果铀熔化时你就在现场，那么，你总会吸进一点，嘿嘿…，其结果不是说你会少活几年，而是你只剩下几个钟头好活了！如果你这个恐怖份子确能置个人生死于度外，那当然就不必计较这些了，否则我建议你采用自动控制装置。\n\n当铀熔化时，和它相隔５０尺，再用５吨铅隔离，这样应该足够安全了。将铀２３５分成两堆的工作完成后，你就应分别用铅箱装好。再从二楼挖个洞通到地下室，用一对黑铁管接起来，使总长约２０尺左右。若能用６寸厚的水泥敷于管外可能稍好，不过如果地板够坚实，而且房子是建在岩石上，也可以不必这么麻烦。在放下管子之前，先把装铀的半球形容器的平面朝上放在水泥上，再把管子放置妥当，原子弹就已完工一半了。\n\n为了不使铀散逸，地下室应该用沙、石、水泥和水混合填好，但因为这只要用一次就达到目的了，做得好不好看也无所谓啦。真正要注意的是，管子外面有足够的阻挡力量，使原子弹在 BOOM前铀不致漏出。其实只要半液体状的沙泥混合物，就足以担当大任了。如此这般，原子弹的接收部分就完工了。\n\n引爆部分比较难做，构想之一是将另一个半球容器放在管子的上端，引爆时，让它倒向下面的接收部分就可以了。原理上虽很简单，但有些技术上的困难不易解决，比如说，如果引爆用的半球容器放歪了一点，它就会沿着管子滑下来，这样你想成为恐怖份子的美梦就落空了，因为这种死法不会让人觉得恐怖，只会成为茶余饭后的笑料罢了。\n\n目前可能是最简单而有效的设计，把一个细线织成的罩子（就像夏天防苍蝇的那种），放在管子的上端，再塞进管内，留约３～４寸在外面；这时再把另一段４尺长的管子焊在原来的管子上。若要使连接的部分更牢，可以在此部分钻几个洞，把铁钉插进去。然后拿３尺长的２。５寸铜管，里面装熔化的铅，将引爆的半球容器安在铅底座中一个吻合的凹槽里；另一根铁棍则凿入管子的另一端约一尺，这装置总重量是８０～９５磅。最后，把有螺纹的盖子套在管子上头，等到它能旋得松紧自如时，再将它拿下来，在它上面钻一个洞，使能容得下引爆的装置杆；装置杆则留下６～８寸长露出洞口，杆上并恰留钻一个钉孔。将各种大小不同的钉子试着去配合，最恰当的大小是能合于整个引爆装置（当然，试着配合时暂不在接受管上端作，以免危险）。然后，将 TNT或炸药涂在一个碟子上（最好是咖啡壶中过滤器的底座），再塞进去，并插进一两个雷管。这放在引爆装置杆的四周，再由一两条引线连出来到外面，然后把它旋紧，原子弹就大功告成了。\n\n剩下的工作只是把引线接到定时器上，再把下端的安全针拔掉，然后离开这城市，约１２小时后，这城市就离开这个世界了。定时器一旦引爆，其力量足使另一个安全针脱落，引爆装置就掉到接收部分去，即使不考虑 BOOM产生的加速度，光是重力就足使９５磅的物体由２０尺高空掉下，产生８Ｘ１０的十次方耳格／秒的动能。把 BOOM所生的冲力考虑进去，则接触点有１０的十二次方耳格／秒的动能，可使两个半球容器接触的时间够长，而产生令人满意的效果。\n\n防辐设备：为了要将所有重要的步骤交代清楚，应该再将几个小问题说明一下。例如，前文曾经简略地谈到，用乙炔喷灯时要考虑铀有发火燃烧的可能性。其实，应该说整个机械操作都要在「乳状液槽」中进行。对不太熟悉机械技术操作的人而言，所谓乳状液就是一种看来像牛乳一样的液体，和油有许多相似之处，可是不会发火燃烧。这种乳状液在一般机械工厂供货商处都很容易买到，而且不会有入问你买这种东西干什么？用了这种乳状液，可以使危险降到最低程度。\n事实上，若我们要溶解铀或对铀作机械处理，最好在纯氮的大气中才安全。可是如果你够小心，而且运气又好的话，那么也不必用这种极端安全的方法。辐射的问题是比较麻烦的一点，镭的辐射量和重量成正比，但铀的辐射量和重量却是成指数关系（也是这种性质使它具有 BOOM性）。因为每个半球所装的质量都超过了临界值的一半，所以和它们同在一间房子里非常地危险。只吸进去一点点含放射性尘埃的空气，就意味着你马上要离开这个世界。因此我建议所有的工作人员应有其它的氧气供应，每人口中含个氧气管或可解决这个问题。但要通盘解决辐射的问题可能比较麻烦，不过只要有决心，加上智能和运气，这问题还是可以克服的。\n\n我还要建议采用一种用铅作成外壳而且有动力的轮椅，让操作员坐在里面可以安全地作业。上面只要开个小缝，用铅作的玻璃当窗户，操作员就可以看到外面。铅作的袖子和手套，可以用来作一些需要和铀碰触的机械动作。为了防止辐射外逸，整栋房子的墙壁、地板都需覆盖上一层铅；地下室的天花板也要加上一层铅板，以免接收部分产生辐射的问题。算起来起码要用上６～８吨的铅，以维持基本的安全问题。这么一来，又得多花工夫支撑地板，免得垮下来。\n\n这些工作都作好了，就可以开始动手制造原子弹。如果你想作一道「红烧兔子」大餐，打开食谱第一步就是要抓一只兔子来！同理，现在你也会问：「怎样把铀２３５弄到手？」（铀２３５通常此钸容易拿到。）其实，你只要平时注意看报纸，应该不难知道，核能发电厂里就有。只要由电厂里偷根控制棒出来，把它熔了，再把其中没有用的铀２３８分离出来就成了。\n\n要潜入一个核子反应炉，说起来并不是什么太难的事，尤其大学校园中的核子反应炉，都只有些马马虎虎的安全设施。一般设施就是些带刺铁丝网围墙，门口站了一两个警卫。事前可以作出误闯的样子来几次投石问路，看看有没有什么电子安全装置，大概结果都是根本没有的。可是我们偷偷摸摸的潜进去并没有什么用，因为铀非常的重，不要讲是一个人，就算是一队人马开进去，也搬不到足够的分量出来。尤其这批人马又身装铅甲以防辐射，就更不管用了。\n\n依我之见，干脆偷辆卡车和拖车（要那种特重型的，就是运三峡电站转子的那种），干掉警卫，代以自己人，然后就直闯进去拿你要的东西，很干脆，效率又高。不过，反应器都是装在一个镍－铁合金的球状容器里，容器再浸在水中，通常，旁边会有千斤顶，以便修护时用，所以也可以顺便用来把整个反应炉心起出来放到卡车里。不过要注意一件事，搬动反应器时要拔出一些燃料棒，或是插进一些节制棒，否则你和整个反应器都要化为灰烬。\n\n建议你或可向当时被你挟制的人质请教这方面的技术，以便搬动炉心。此外，整个反应器重约５０吨，加上拖车需要６寸厚的铅板作防护，所以拖车如何拖动６５吨的重量，还是颇伤脑筋的（所以前面要用特重型的拖车，要不然到了地，炉子也搬上车了，却发现拖不动，那不是面子都丢尽了）。或者，你觉得搬走整个反应器不切实际，也可以只带走约１，２００磅的备用燃料棒。\n\n不过千万也要带着石墨或铅，免得燃料棒因不断地反应生热而熔化了。如果你忘了这步骤，回家打开盖子，只会看到一堆熔化了的铀，而且四处散射，可能你当场就一命呜呼而遗笑万年。性命是小，这脸咱可丢不起，所以别忘记拿了１，２００磅的燃料棒之后，要和１５，０００磅的石墨或铅混合。反应器的铀大约含３％的铀２３５（自然界铀则只含０．５％的铀２３５），做原子弹的铀则需要９７％的铀２３５，否则根本不 BOOM。到手的１，２００磅燃料棒，可以提炼出所需要约 36磅的铀２３５，不过要有耐心和经验去分离它。如果你自知无法全部把铀２３５分离出来，就得多弄点燃料棒。\n\n一般说来，以目前的技术，要达到每次增加纯度２５％并没有什么问题，所以你最少要弄到４，８００磅的燃料棒，若能弄到９，６００磅最好。把这些加上去，你总共要带１５万磅（７５吨）的东西。\n\n其次还要找个地方放这些东西，我建议你租间仓库，如用原来那两层楼的建筑来分离铀似乎不太实际，因为这至少需要２万平方尺的空间。\n\n分离高招：下面就要考虑用什么方法来分离铀２３５。对恐怖份子来说，气体扩散法是好方法之一，这也是早期制造原子弹时所采用的，不但可靠又不必太复杂的技术。不过花费较多，而且所用的化学药品更是吓人。\n首先，你要有约１２哩长的特殊玻璃线钢管，并以６０吨的氢氟酸（ＨＦ）形成六氟化铀，然后吹向一具有特殊小孔的膜。因为六氟化铀２３８较重，在经过这层膜时会被陷住而不易透过。每过一次可使铀２３５的成分增加０。５％，如此程序只要反复操作，所得六氟化铀２３５的成分就愈大，最后只要把六氟化铀中的氟分离出来就行了。因为氢氟酸很贵，而且不易取得所以最好是去偷一点来，要不然就先去偷个几百万美金也行。\n\n如果你觉得此路不通，还有其它的办法。你可以在树林里建个滋生反应器（BreederReactor），用铀来作钸，再用化学上的技术分离即可。至于如何建滋生反应器，也不是难事，随便一本大学教科书，都可以告诉你好几种方法。虽然在理论上没有困难，但是也有它实际上的难处。不过如果你刚好有私人用的小河，又有几火车的钠，数量可观的不锈钢管，一百亩与外界隔离的土地，那就没有间题。\n\n如果对这两种方法你都没有兴趣，还有一些有趣的新技术可供参考。你可以先用一块低温磁铁（CryogenicMagnet），它在液态氦的温度（约零下２７０℃）下能保持 20,000高斯的磁扬…不过，唔，不过下面的程序太复杂了… \n\n还有一法是用雷射，因为铀２３８较重，被激光束照射后，运动的偏离角比铀２３５小。所以若在和雷射光垂直的平面上洒上一层铀，则铀２３５、铀２３８可藉其偏离角来分离。此法原理上简单可行，但时间上太慢。一天大概只能处理 20磅的铀（含２３５和２３８），而分离的效率约１２。５％，每处理一次可以产生约１０％的铀２３５，所以要处理９次才能达到原子弹的标准。\n\n如此算来，从９，６００磅磅的燃料棒中分离出３６磅纯度９７％的铀２３５，约需费时四年、。然而，它的辐射量又使你根本没有四年好活，所以还得找三两个志愿者来完成你的未竟之志。因此，若能有愚公移山之志，或可成功，祝你好运 ! \n\n\n","plink":"https://dxsummer.gitee.io/posts/a1b9e5e4/"},{"title":"Page and Post Front-matter","date":"2020-04-19T08:45:59.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:50:56.000Z","content":"Page Front-matter123456789title:date:type: comments: description:top_img:mathjax:katex:aside:\n写法解释\n\ntitle【必需】页面标题\n\ndate【必需】页面创建时间\n\ntype【必需】标签、分类和友情链接三个頁面需要配置\n\ndescription【可选】页面描述\n\ncomments【可选】显示页面评论模块（默认 true)\n\ntop_img【可选】页面顶部图片\n\nmathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\nkatex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n\naside【可选】显示侧边栏 （默认 true)\nPost Front-matter1234567891011121314title:date:tags:categories:keywords:description:top_img:comments：cover:  toc:  toc_number: copyright: mathjax:katex:\n写法解释\n\ntitle【必需】文章标题\n\ndate【必需】文章创建日期\n\ntags【可选】文章标签\n\ncategories【可选】文章分类\n\nkeywords【可选】文章关键字\n\ndescription【可选】文章描述\n\ntop_img【可选】文章顶部图片\n\ncover【可选】文章缩略图（如果没有设置top_img,文章页顶部将显示缩略图，可设为false/图片地址/留空）\n\ncomments【可选】显示文章评论模块（默认 true)\n\ntoc【可选】显示文章TOC（默认为设置中toc的enable配置）\n\ntoc_number【可选】显示toc_number（默认为设置中toc的number配置）\n\ncopyright【可选】显示文章版权模块（默认 true)\n\nmathjax【可选】显示mathjax(当设置mathjax的per_page: false时，才需要配置，默认 false)\n\nkatex【可选】显示katex(当设置katex的per_page: false时，才需要配置，默认 false)\n","plink":"https://dxsummer.gitee.io/posts/67dd97ac/"},{"title":"字体、颜色常用代码","date":"2020-04-19T05:17:09.000Z","date_formatted":{"ll":"2020年4月19日","L":"2020/04/19","MM-DD":"04-19"},"updated":"2020-06-08T01:50:26.000Z","content":"字体、颜色常用代码常用字体名称中文字体：黑体：SimHei\n宋体：SimSun\n新宋体：NSimSun\n仿宋：FangSong\n楷体：KaiTi\n仿宋_GB2312：FangSong_GB2312\n楷体_GB2312：KaiTi_GB2312\n微软雅黑：Microsoft YaHei\n英文字体：PmingLiu\nImpact\nGeorgia\nTahoma\n- Arial\nBook Antiqua\nCentury Gothic\nCourier New\nTimes New Roman\nVerdana\n其他字体：仿宋：FangSong\n华文细黑：STHeiti Light [STXihei]\n华文黑体：STHeiti\n华文楷体：STKaiti\n华文宋体：STSong\n华文仿宋：STFangsong\n隶书：LiSu\n幼圆：YouYuan\n华文细黑：STXihei\n华文楷体：STKaiti\n华文宋体：STSong\n华文中宋：STZhongsong\n华文仿宋：STFangsong\n方正舒体：FZShuTi\n方正姚体：FZYaoti\n华文彩云：STCaiyun\n华文琥珀：STHupo\n华文隶书：STLiti\n华文行楷：STXingkai\n华文新魏：STXinwei\n常用颜色代码color=maroon\ncolor=grey\ncolor=silver\ncolor=lightgrey\ncolor=HotPink\ncolor=DeepPink\ncolor=VioletRed\ncolor=Purple\ncolor=navy\ncolor=Blue\ncolor=DeepSkyBlue\ncolor=LightSkyBlue\ncolor=aqua\ncolor=DarkTurquoise\ncolor=LightSeaGreen\ncolor=YellowGreen\ncolor=LawnGreen\ncolor=GreenYellow\ncolor=Yellow\ncolor=Tomato\ncolor=red\ncolor=fuchsia\ncolor=MediumOrchid\ncolor=DarkViolet\n颜色表\n颜色名十六进制颜色值颜色\n\nAliceBlue#F0F8FFrgb(240, 248, 255)\n\nAntiqueWhite#FAEBD7rgb(250, 235, 215)\n\nAqua#00FFFFrgb(0, 255, 255)\n\nAquamarine#7FFFD4rgb(127, 255, 212)\n\nAzure#F0FFFFrgb(240, 255, 255)\n\nBeige#F5F5DCrgb(245, 245, 220)\n\nBisque#FFE4C4rgb(255, 228, 196)\n\nBlack#000000rgb(0, 0, 0)\n\nBlanchedAlmond#FFEBCDrgb(255, 235, 205)\n\nBlue#0000FFrgb(0, 0, 255)\n\nBlueViolet#8A2BE2rgb(138, 43, 226)\n\nBrown#A52A2Argb(165, 42, 42)\n\nBurlyWood#DEB887rgb(222, 184, 135)\n\nCadetBlue#5F9EA0rgb(95, 158, 160)\n\nChartreuse#7FFF00rgb(127, 255, 0)\n\nChocolate#D2691Ergb(210, 105, 30)\n\nCoral#FF7F50rgb(255, 127, 80)\n\nCornflowerBlue#6495EDrgb(100, 149, 237)\n\nCornsilk#FFF8DCrgb(255, 248, 220)\n\nCrimson#DC143Crgb(220, 20, 60)\n\nCyan#00FFFFrgb(0, 255, 255)\n\nDarkBlue#00008Brgb(0, 0, 139)\n\nDarkCyan#008B8Brgb(0, 139, 139)\n\nDarkGoldenRod#B8860Brgb(184, 134, 11)\n\nDarkGray#A9A9A9rgb(169, 169, 169)\n\nDarkGreen#006400rgb(0, 100, 0)\n\nDarkKhaki#BDB76Brgb(189, 183, 107)\n\nDarkMagenta#8B008Brgb(139, 0, 139)\n\nDarkOliveGreen#556B2Frgb(85, 107, 47)\n\nDarkorange#FF8C00rgb(255, 140, 0)\n\nDarkOrchid#9932CCrgb(153, 50, 204)\n\nDarkRed#8B0000rgb(139, 0, 0)\n\nDarkSalmon#E9967Argb(233, 150, 122)\n\nDarkSeaGreen#8FBC8Frgb(143, 188, 143)\n\nDarkSlateBlue#483D8Brgb(72, 61, 139)\n\nDarkSlateGray#2F4F4Frgb(47, 79, 79)\n\nDarkTurquoise#00CED1rgb(0, 206, 209)\n\nDarkViolet#9400D3rgb(148, 0, 211)\n\nDeepPink#FF1493rgb(255, 20, 147)\n\nDeepSkyBlue#00BFFFrgb(0, 191, 255)\n\nDimGray#696969rgb(105, 105, 105)\n\nDodgerBlue#1E90FFrgb(30, 144, 255)\n\nFeldspar#D19275rgb(209, 146, 117)\n\nFireBrick#B22222rgb(178, 34, 34)\n\nFloralWhite#FFFAF0rgb(255, 250, 240)\n\nForestGreen#228B22rgb(34, 139, 34)\n\nFuchsia#FF00FFrgb(255, 0, 255)\n\nGainsboro#DCDCDCrgb(220, 220, 220)\n\nGhostWhite#F8F8FFrgb(248, 248, 255)\n\nGold#FFD700rgb(255, 215, 0)\n\nGoldenRod#DAA520rgb(218, 165, 32)\n\nGray#808080rgb(128, 128, 128)\n\nGreen#008000rgb(0, 128, 0)\n\nGreenYellow#ADFF2Frgb(173, 255, 47)\n\nHoneyDew#F0FFF0rgb(240, 255, 240)\n\nHotPink#FF69B4rgb(255, 105, 180)\n\nIndianRed#CD5C5Crgb(205, 92, 92)\n\nIndigo#4B0082rgb(75, 0, 130)\n\nIvory#FFFFF0rgb(255, 255, 240)\n\nKhaki#F0E68Crgb(240, 230, 140)\n\nLavender#E6E6FArgb(230, 230, 250)\n\nLavenderBlush#FFF0F5rgb(255, 240, 245)\n\nLawnGreen#7CFC00rgb(124, 252, 0)\n\nLemonChiffon#FFFACDrgb(255, 250, 205)\n\nLightBlue#ADD8E6rgb(173, 216, 230)\n\nLightCoral#F08080rgb(240, 128, 128)\n\nLightCyan#E0FFFFrgb(224, 255, 255)\n\nLightGoldenRodYellow#FAFAD2rgb(250, 250, 210)\n\nLightGrey#D3D3D3rgb(211, 211, 211)\n\nLightGreen#90EE90rgb(144, 238, 144)\n\nLightPink#FFB6C1rgb(255, 182, 193)\n\nLightSalmon#FFA07Argb(255, 160, 122)\n\nLightSeaGreen#20B2AArgb(32, 178, 170)\n\nLightSkyBlue#87CEFArgb(135, 206, 250)\n\nLightSlateBlue#8470FFrgb(132, 112, 255)\n\nLightSlateGray#778899rgb(119, 136, 153)\n\nLightSteelBlue#B0C4DErgb(176, 196, 222)\n\nLightYellow#FFFFE0rgb(255, 255, 224)\n\nLime#00FF00rgb(0, 255, 0)\n\nLimeGreen#32CD32rgb(50, 205, 50)\n\nLinen#FAF0E6rgb(250, 240, 230)\n\nMagenta#FF00FFrgb(255, 0, 255)\n\nMaroon#800000rgb(128, 0, 0)\n\nMediumAquaMarine#66CDAArgb(102, 205, 170)\n\nMediumBlue#0000CDrgb(0, 0, 205)\n\nMediumOrchid#BA55D3rgb(186, 85, 211)\n\nMediumPurple#9370D8rgb(147, 112, 216)\n\nMediumSeaGreen#3CB371rgb(60, 179, 113)\n\nMediumSlateBlue#7B68EErgb(123, 104, 238)\n\nMediumSpringGreen#00FA9Argb(0, 250, 154)\n\nMediumTurquoise#48D1CCrgb(72, 209, 204)\n\nMediumVioletRed#C71585rgb(199, 21, 133)\n\nMidnightBlue#191970rgb(25, 25, 112)\n\nMintCream#F5FFFArgb(245, 255, 250)\n\nMistyRose#FFE4E1rgb(255, 228, 225)\n\nMoccasin#FFE4B5rgb(255, 228, 181)\n\nNavajoWhite#FFDEADrgb(255, 222, 173)\n\nNavy#000080rgb(0, 0, 128)\n\nOldLace#FDF5E6rgb(253, 245, 230)\n\nOlive#808000rgb(128, 128, 0)\n\nOliveDrab#6B8E23rgb(107, 142, 35)\n\nOrange#FFA500rgb(255, 165, 0)\n\nOrangeRed#FF4500rgb(255, 69, 0)\n\nOrchid#DA70D6rgb(218, 112, 214)\n\nPaleGoldenRod#EEE8AArgb(238, 232, 170)\n\nPaleGreen#98FB98rgb(152, 251, 152)\n\nPaleTurquoise#AFEEEErgb(175, 238, 238)\n\nPaleVioletRed#D87093rgb(216, 112, 147)\n\nPapayaWhip#FFEFD5rgb(255, 239, 213)\n\nPeachPuff#FFDAB9rgb(255, 218, 185)\n\nPeru#CD853Frgb(205, 133, 63)\n\nPink#FFC0CBrgb(255, 192, 203)\n\nPlum#DDA0DDrgb(221, 160, 221)\n\nPowderBlue#B0E0E6rgb(176, 224, 230)\n\nPurple#800080rgb(128, 0, 128)\n\nRed#FF0000rgb(255, 0, 0)\n\nRosyBrown#BC8F8Frgb(188, 143, 143)\n\nRoyalBlue#4169E1rgb(65, 105, 225)\n\nSaddleBrown#8B4513rgb(139, 69, 19)\n\nSalmon#FA8072rgb(250, 128, 114)\n\nSandyBrown#F4A460rgb(244, 164, 96)\n\nSeaGreen#2E8B57rgb(46, 139, 87)\n\nSeaShell#FFF5EErgb(255, 245, 238)\n\nSienna#A0522Drgb(160, 82, 45)\n\nSilver#C0C0C0rgb(192, 192, 192)\n\nSkyBlue#87CEEBrgb(135, 206, 235)\n\nSlateBlue#6A5ACDrgb(106, 90, 205)\n\nSlateGray#708090rgb(112, 128, 144)\n\nSnow#FFFAFArgb(255, 250, 250)\n\nSpringGreen#00FF7Frgb(0, 255, 127)\n\nSteelBlue#4682B4rgb(70, 130, 180)\n\nTan#D2B48Crgb(210, 180, 140)\n\nTeal#008080rgb(0, 128, 128)\n\nThistle#D8BFD8rgb(216, 191, 216)\n\nTomato#FF6347rgb(255, 99, 71)\n\nTurquoise#40E0D0rgb(64, 224, 208)\n\nViolet#EE82EErgb(238, 130, 238)\n\nVioletRed#D02090rgb(208, 32, 144)\n\nWheat#F5DEB3rgb(245, 222, 179)\n\nWhite#FFFFFFrgb(255, 255, 255)\n\nWhiteSmoke#F5F5F5rgb(245, 245, 245)\n\nYellow#FFFF00rgb(255, 255, 0)\n\nYellowGreen#9ACD32rgb(154, 205, 50)\n颜色块配置123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245&#x2F;&#x2F; 颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FFD700;&#125;&#x2F;&#x2F; 颜色块-绿span#inline-green &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #5cb85c;&#125;&#x2F;&#x2F; 颜色块-蓝span#inline-blue &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #2780e3;&#125;&#x2F;&#x2F; 颜色块-灰span#inline-grey &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #4F4F4F;&#125;&#x2F;&#x2F; 颜色块-红span#inline-red &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FF3030;&#125;&#x2F;&#x2F; 颜色块-紫span#inline-purple &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#fff;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #9954bb;&#125;&#x2F;&#x2F; 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;&#x2F;&#x2F; 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;&#x2F;&#x2F; 左侧边框绿色块级p#div-border-left-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #5cb85c;&#125;&#x2F;&#x2F; 左侧边框灰色块级p#div-border-left-grey &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #4F4F4F;&#125;&#x2F;&#x2F; 左侧边框蓝色块级p#div-border-left-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #2780e3;&#125;&#x2F;&#x2F; 左侧边框紫色块级p#div-border-left-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #9954bb;&#125;&#x2F;&#x2F; 右侧边框红色块级p#div-border-right-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #df3e3e;&#125;&#x2F;&#x2F; 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;&#x2F;&#x2F; 右侧边框绿色块级p#div-border-right-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #5cb85c;&#125;&#x2F;&#x2F; 右侧边框蓝色块级p#div-border-right-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #2780e3;&#125;&#x2F;&#x2F; 右侧边框紫色块级p#div-border-right-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #9954bb;&#125;&#x2F;&#x2F; 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;&#x2F;&#x2F; 上侧边框黄色p#div-border-top-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #f0ad4e;&#125;&#x2F;&#x2F; 上侧边框绿色p#div-border-top-green &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #5cb85c;&#125;&#x2F;&#x2F; 上侧边框蓝色p#div-border-top-blue &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #2780e3;&#125;&#x2F;&#x2F; 上侧边框紫色p#div-border-top-purple &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #9954bb;&#125;","plink":"https://dxsummer.gitee.io/posts/964fa96f/"},{"title":"Step1 数据和C","date":"2020-04-18T10:35:51.000Z","date_formatted":{"ll":"2020年4月18日","L":"2020/04/18","MM-DD":"04-18"},"updated":"2020-06-08T01:45:04.000Z","content":"此经验基于C Primer Plus\n\n一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。\n\n本章介绍以下内容：关键字：int 、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary运算符：sizeof()函数：scanf()整数类型和浮点数类型的区别如何书写整型和浮点型常数，如何声明这些类型的变量如何使用printf()和scanf()函数读写不同类型的值\nC 语言提供两大系列的多种数据类型。本章详细介绍两大数据类型：整数类型和浮点数类型，除此之外，还将介绍常量和变量的区别。\n示例程序12345678910111213141516#include　&lt;stdio.h&gt;int　main(void)&#123;float weight;　 &#x2F;* 你的体重　　　　　　　*&#x2F;float value;　　&#x2F;* 相等重量的白金价值　　　*&#x2F;printf(&quot;Are　you　worth　your　weight　in　platinum?\\n&quot;);printf(&quot;Let&#39;s　check　it　out.\\n&quot;);printf(&quot;Please　enter　your　weight　in　pounds:　&quot;);   &#x2F;* 获取用户的输入*&#x2F;scanf(&quot;%f&quot;,　&amp;weight);  &#x2F;* 假设白金的价格是每盎司$1700　　　　　*&#x2F;                        &#x2F;* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*&#x2F;value &#x3D; 1700.0 * weight * 14.5833;printf(&quot;Your　weight　in　platinum　is　worth　$%.2f.\\n&quot;,　value);printf(&quot;You　are　easily　worth　that!　If　platinum　prices　drop,\\n&quot;);printf(&quot;eat　more　to　maintain　your　value.\\n&quot;);return　0;&#125;提示 错误与警告如果输入程序时打错（如，漏了一个分号），编译器会报告语法错误消息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从double类型转换成float类型可能会丢失数据”。错误消息表明程序中有错，不能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译。特殊的警告与C如何处理1700.0这样的值有关。\n输入该程序时，可以把1700.0改成贵金属白金当前的市价，但是不要改动14.5833，该数是1英镑的金衡盎司数（金衡盎司用于衡量贵金属，而英镑常衡盎司用于衡量人的体重）。\n注意，“enter your weight”的意思是输入你的体重，然后按下Enter或Return键（不要键入体重后就一直等着）。按下Enter键是告知计算机，你已完成输入数据。该程序需要你输入一个数字（如，155），而不是单词（如，too much）。如果输入字母而不是数字，会导致程序出问题。这个问题要用if语句来解决，因此请先输入数字。下面是程序的输出示例：\n123456Are　you　worth　your　weight　in　platinum?Let&#39;s　check　it　out.Please　enter　your　weight　in　pounds:　156Your　weight　in　platinum　is　worth　$3867491.25.You　are　easily　worth　that!　If　platinum　prices　drop,eat　more　to　maintain　your　value.程序调整即使在程序中添加下面一行代码：\n1getchar();程序的输出是否依旧在屏幕上一闪而过？本例，需要调用两次getchar()函数：\n12getchar();getchar();\ngetchar()函数读取下一个输入字符，因此程序会等待用户输入。在这种情况下，键入 156 并按下Enter（或Return）键（发送一个换行符），然后scanf()读取键入的数字，第1个getchar()读取换行符，第2个getchar()让程序暂停，等待输入。\n\n程序中的新元素注意，代码中使用了一种新的变量声明。前面的例子中只使用了整数类型的变量（int），但是本例使用了浮点数类型（float）的变量，以便处理更大范围的数据。float 类型可以储存带小数的数字。\n\n为了打印新类型的变量，在printf()中使用%f来处理浮点值。%.2f中的.2用于精确控制输出，指定输出的浮点数只显示小数点后面两位。\n\nscanf()函数用于读取键盘的输入。%f说明scanf()要读取用户从键盘输入的浮点数，&amp;weight告诉 scanf()把输入的值赋给名为 weight 的变量。scanf()函数使用&amp;符号表明找到 weight变量的地点。\n\n变量与常量数据有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为常量（constant）。其他数据类型在程序运行期间可能会改变或被赋值，这些称为变量（variable）。\n在示例程序中，weight 是一个变量，14.5833 是一个常量。那么，1700.0 是常量还是变量？在现实生活中，白金的价格不会是常量，但是在程序中，像1700.0这样的价格被视为常量。\n数据：数据类型关键字不仅变量和常量不同，不同的数据类型之间也有差异。一些数据类型表示数字，一些数据类型表示字母（更普遍地说是字符）。C通过识别一些基本的数据类型来区分和使用这些不同的数据类型。如果数据是常量，编译器一般通过用户书写的形式来识别类型（如，42是整数，42.100是浮点数）。但是，对变量而言，要在声明时指定其类型。\n现在，我们先来了解一下 C语言的基本类型关键字。K&amp;C给出了7个与类型相关的关键字。C90标准添加了2个关键字，C99标准又添加了3个关键字。\n\n在C语言中，用int关键字来表示基本的整数类型。后3个关键字（long、short和unsigned）和C90新增的signed用于提供基本整数类型的变式，例如unsigned short int和long long int。char关键字用于指定字母和其他字符（如，#、$、%和*）。\n\n另外，char类型也可以表示较小的整数。float、double和long double表示带小数点的数。_Bool类型表示布尔值（true或false），_complex和_Imaginary分别表示复数和虚数。\n\n通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类型：整数类型和浮点数类型。\n位、字节和字位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存储单元。\n\n最小的存储单元是位（bit），可以储存0或1（或者说，位用于设置“开”或“关”）。虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。\n\n字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C语言对此有不同的定义，请参阅baidu）。既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1的组合。通过二进制编码（仅用0和1便可表示数字），便可表示0～255的整数或一组字符（后面将详细讨论二进制编码，如果感兴趣可以现在浏览一下该章的内容）。\n\n字（word）是设计计算机时给定的自然存储单位。对于8位的微型计算机（如，最初的苹果机）， 1个字长只有8位。从那以后，个人计算机字长增至16位、32位，直到目前的64位。计算机的字长越大，其数据转移越快，允许的内存访问也更多。\n\n整数\n和数学的概念一样，在C语言中，整数是没有小数部分的数。例如，2、−23和2456都是整数。而3.14、0.22和2.000都不是整数。计算机以二进制数字储存整数，例如，整数7以二进制写是111。因此，要在8位字节中储存该数字，需要把前5位都设置成0，后3位设置成1\n\n\n浮点数浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。注意，在一个值后面加上一个小数点，该值就成为一个浮点值。所以，7是整数，7.00是浮点数。显然，书写浮点数有多种形式。稍后将详细介绍e记数法，这里先做简要介绍：3.16E7 表示3.16×107（3.16 乘以10 的7次方）。其中， 107=10000000，7被称为10的指数。\n\n这里关键要理解浮点数和整数的储存方案不同。计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和7在数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成0.7E1。这里，0.7是小数部分，1是指数部分。\n\n\n\n上图演示了一个储存浮点数的例子。当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂。后面位操作将详述相关内容。现在，我们着重讲解这两种类型的实际区别。\n\n整数没有小数部分，浮点数有小数部分。浮点数可以表示的范围比整数大。对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。浮点数通常只是实际值的近似值。例如，7.0可能被储存为浮点值6.99999。\n过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距。\nC语言基本数据类型int类型int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整数或零。其取值范围依计算机系统而异。一般而言，储存一个int要占用一个机器字长。因此，早期的16位IBM PC兼容机使用16位来储存一个int值，其取值范围（即int值的取值范围）是-32768～32767。目前的个人计算机一般是32位，因此用32位储存一个int值。现在，个人计算机产业正逐步向着64位处理器发展，自然能储存更大的整数。ISO C规定int的取值范围最小为-32768～32767。一般而言，系统用一个特殊位的值表示有符号整数的正负号。\n初始化变量初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋给变量的值即可。如下所示：\n123int hogs &#x3D; 21;int cows &#x3D; 32, goats &#x3D; 14;int dogs, cats &#x3D; 94; &#x2F;* 有效，但是这种格式很糟糕 *&#x2F;以上示例的最后一行，只初始化了cats，并未初始化dogs。这种写法很容易让人误认为dogs也被初始化为94，所以最好不要把初始化的变量和未初始化的变量放在同一条声明中。\n简而言之，声明为变量创建和标记存储空间，并为其指定初始值\n\nint类型常量上面示例中出现的整数（21、32、14和94）都是整型常量或整型字面量。C语言把不含小数点和指数的数作为整数。因此，22和-44都是整型常量，但是22.0和2.2E1则不是。C语言把大多数整型常量视为int类型，但是非常大的整数除外。详见后面“long常量和long long常量”小节对long int类型的讨论。\n打印int值可以使用printf()函数打印int类型的值。%d指明了在一行中打印整数的位置。%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误。下面演示了一个简单的程序，程序中初始化了一个变量，并打印该变量的值、一个常量值和一个简单表达式的值。另外，程序还演示了如果粗心犯错会导致什么结果。\n1234567891011#include　&lt;stdio.h&gt;int　main(void)&#123;    int　ten　&#x3D;　10;    int　two　&#x3D;　2;    printf(&quot;Doing　it　right:　&quot;);    printf(&quot;%d　minus　%d　is　%d\\n&quot;,ten,2,ten-two);    printf(&quot;Doing　it　wrong:　&quot;);    printf(&quot;%d minus %d is %d\\n&quot;,ten);　&#x2F;&#x2F; 遗漏2个参数    return　0;&#125;编译并运行该程序，输出如下：\n12Doing it right: 10 minus 2 is 8Doing it wrong: 10 minus 16 is 1650287143在第一行输出中，第1个%d对应int类型变量ten；第2个%d对应int类型常量2；第3个%d对应int类型表达式ten - two的值。\n在第二行输出中，第1个%d对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是内存中的任意值（读者在运行该程序时显示的这两个数值会与输出示例中的数值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不同）。\n你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 printf()不寻常的设计。大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确。但是，printf()函数的参数数目不定，可以有1个、2个、3个或更多，编译器也爱莫能助。记住，使用printf()函数时，要确保转换说明的数量与待打印值的数量相等。\n\n当printf没有为%d提供对应的值时，打印出的值是内存中的任意值\n\n八进制和十六进制通常，C语言都假定整型常量是十进制数。然而，许多程序员很喜欢使用八进制和十六进制数。因为8和16都是2的幂，而10却不是。显然，八进制和十六进制记数系统在表达与计算机相关的值时很方便。\n例如，十进制数65536经常出现在16位机中，用十六进制表示正好是10000。另外，十六进制数的每一位的数恰好由4位二进制数表示。例如，十六进制数3是0011，十六进制数5是0101。因此，十六进制数35的位组合（bit pattern）是00110101，十六进制数53的位组合是01010011。这种对应关系使得十六进制和二进制的转换非常方便。但是，计算机如何知道10000是十进制、十六进制还是二进制？在C语言中，用特定的前缀表示使用哪种进制。\n0x或0X前缀表示十六进制值，所以十进制数16表示成十六进制是0x10或0X10。与此类似，0前缀表示八进制。例如，十进制数16表示成八进制是020。第15章将更全面地介绍进制相关的内容。\n要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也就是说，无论把数字写成16、020或0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码。\n显示八进制和十六进制在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以十进制显示数字，使用%d；以八进制显示数字，使用%o；以十六进制显示数字，使用%x。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。下面程序演示了一个小程序。回忆一下，在某些集成开发环境（IDE）下编写的代码中插入getchar();语句，程序在执行完毕后不会立即关闭执行窗口。\n123456789&#x2F;* bases.c--以十进制、八进制、十六进制打印十进制数100 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    int　x　&#x3D;　100;    printf(&quot;dec&#x3D;%d;octal&#x3D;%o;hex&#x3D;%x\\n&quot;,x,x,x);    printf(&quot;dec&#x3D;%d;octal&#x3D;%#o;hex&#x3D;%#x\\n&quot;,x,x,x);    return　0;&#125;编译并运行该程序，输出如下：\n12dec &#x3D; 100; octal &#x3D; 144; hex &#x3D; 64dec &#x3D; 100; octal &#x3D; 0144; hex &#x3D; 0x64该程序以3种不同记数系统显示同一个值。printf()函数做了相应的转换。注意，如果要在八进制和十六进制值前显示0和0x前缀，要分别在转换说明中加入#。\n其他整数类型C语言提供3个附属关键字修饰基本整数类型：short、long和unsigned。应记住以下几点。\nshort int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。\n\nlong int或long占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是有符号类型。\n\nlong long int或long long（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。\n\nunsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。\n\n在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。\n\n在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。例如，short、short int、signed short、signed short int都表示同一种类型。\n\n声明其他整数类型其他整数类型的声明方式与int类型相同，下面列出了一些例子。不是所有的C编译器都能识别最后3条声明，最后一个例子所有的类型是C99标准新增的。\n123456789long int　estine;long johns;short int　erns;short　ribs;unsigned int　s_count;unsigned　players;unsigned long　headcount;unsigned short　yesvotes;long long　ago;使用多种整数类型的原因为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int类型占用的空间多？因为C语言只规定了short占用的存储空间不能多于int，long占用的存储空间不能少于int。这样规定是为了适应不同的机器。\n例如，过去的一台运行Windows 3的机器上，int类型和short类型都占16位，long类型占32位。后来，Windows和苹果系统都使用16位储存short类型，32位储存int类型和long类型（使用32位可以表示的整数数值超过20亿）。现在，计算机普遍使用64位处理器，为了储存64位的整数，才引入了long long类型。\n现在，个人计算机上最常见的设置是，long long占64位，long占32位，short占16位，int占16位或32位（依计算机的自然字长而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。\nC 标准对基本数据类型只规定了允许的最小大小。对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64位的需求，最小取值范围是[−9223372036854775807,9223372036854775807]；unsigned long long的最小取值范围是[0,18446744073709551615]。如果要开支票，这个数是一千八百亿亿（兆）六千七百四十四万亿零七百三十七亿零九百五十五万一千六百一十五。但是，谁会去数？\nint类型那么多，应该如何选择？首先，考虑unsigned类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正数。\n如果一个数超出了int类型的取值范围，且在long类型的取值范围内时，使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型。\n如果在int设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。\nlong常量和long long常量通常，程序代码中使用的数字（如，2345）都被储存为int类型。如果使用1000000这样的大数字，超出了int类型能表示的范围，编译器会将其视为long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。\n八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。\n有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类型的值。要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小写的L）或L后缀。使用L后缀更好，因为l看上去和数字1很像。因此，在int为16位、long为32位的系统中，会把7作为16位储存，把7L作为32位储存。l或L后缀也可用于八进制和十六进制整数，如020L和0x10L。\n类似地，在支持long long类型的系统中，也可以使用ll或LL后缀来表示long long类型的值，如3LL。另外，u或U后缀表示unsigned long long，如5ull、10LLU、6LLU或9Ull。\n整数溢出如果整数超出了相应类型的取值范围会怎样？下面分别将有符号类型和无符号类型的整数设置为比最大值略大，看看会发生什么（printf()函数使用%u说明显示unsigned int类型的值）。\n12345678910&#x2F;* toobig.c-- 超出系统允许的最大int值*&#x2F;#include &lt;stdio.h&gt;int main(void)&#123;    int i&#x3D;2147483647;    unsigned int j&#x3D;4294967295;    printf(&quot;%d %d %d\\n&quot;,i,i+1,i+2);    printf(&quot;%u %u %u\\n&quot;,j,j+1,j+2);    return 0;&#125;在我们的系统下输出的结果是：\n122147483647　　　-2147483648　 -21474836474294967295　　　0　　 1可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在超过最大值时，unsigned int 类型的变量 j 从 0开始；而int类型的变量i则从−2147483648开始。注意，当i超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户。因此，在编程时必须自己注意这类问题。\n溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。以上描述的溢出行为比较有代表性，但是也可能会出现其他情况。\n打印short、long、long long和unsigned类型打印unsigned int类型的值，使用%u转换说明；打印long类型的值，使用%ld转换说明。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。\nC语言有多种printf()格式。对于short类型，可以使用h前缀。%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，%lu表示打印unsigned long类型的值。下面程序演示了一些例子。对于支持long long类型的系统，%lld和%llu分别表示有符号和无符号类型。《字符串和格式化输入/输出》将详细介绍转换说明。\n1234567891011121314&#x2F;* print2.c--更多printf()的特性 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    unsigned int un&#x3D;3000000000;     &#x2F;* int为32位和short为16位的系统 *&#x2F;    short　end&#x3D;200;    long　big&#x3D;65537;    long　long　verybig　&#x3D;　12345678908642;    printf(&quot;un&#x3D;%u　and　not　%d\\n&quot;,　un,　un);    printf(&quot;end&#x3D;%hd　and　%d\\n&quot;,　end,　end);    printf(&quot;big&#x3D;%ld　and　not　%hd\\n&quot;,　big,　big);    printf(&quot;verybig&#x3D;%lld　and　not　%ld\\n&quot;,verybig,verybig);    return　0;&#125;在特定的系统中输出如下（输出的结果可能不同）：\n1234un &#x3D; 3000000000 and not -1294967296end &#x3D; 200 and 200big &#x3D; 65537 and not 1verybig&#x3D; 12345678908642 and not 1942899938该例表明，使用错误的转换说明会得到意想不到的结果。第 1 行输出，对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000 和有符号值−129496296 在系统内存中的内部表示完全相同（详见位操作）。\n因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值。在待打印的值大于有符号值的最大值时，会发生这种情况。对于较小的正数（如96），有符号和无符号类型的存储、显示都相同。\n第2行输出，对于short类型的变量end，在printf()中无论指定以short类型（%hd）还是int类型（%d）打印，打印出来的值都相同。这是因为在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值。你可能会提出疑问：为什么要进行转换？h修饰符有什么用？第1个问题的答案是， int类型被认为是计算机处理整数类型时最高效的类型。因此，在short和int类型的大小不同的计算机中，用int类型的参数传递速度更快。第2个问题的答案是，使用h修饰符可以显示较大整数被截断成 short 类型值的情况。\n第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd，printf()只会查看后 16 位，所以显示的值是 1。\n与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。\n本章前面介绍过，程序员必须确保转换说明的数量和待打印值的数量相同。以上内容也提醒读者，程序员还必须根据待打印值的类型使用正确的转换说明。\n\n提示 匹配printf()说明符的类型\n\n在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。\n使用字符：char类型char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码，本书也使用此编码。例如，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65（许多IBM的大型主机使用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可能使用完全不同的编码）。\n标准ASCII码的范围是0～127，只需7位二进制数即可表示。通常，char类型被定义为8位的存储单元，因此容纳标准ASCII码绰绰有余。许多其他系统（如IMB PC和苹果Macs）还提供扩展ASCII码，也在8位的表示范围之内。一般而言，C语言会保证char类型足够大，以储存系统（实现C语言的系统）的基本字符集。\n许多字符集都超过了127，甚至多于255。例如，日本汉字（kanji）字符集。商用的统一码（Unicode）创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过110000个。国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了ISO/IEC 10646标准。统一码标准也与ISO/IEC 10646标准兼容。\nC语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。\n声明char类型变量char类型变量的声明方式与其他类型变量的声明方式相同。下面是一些例子：\n12char response;char itable, latan;以上声明创建了3个char类型的变量：response、itable和latan。\n字符常量和初始化如果要把一个字符常量初始化为字母 A，不必背下 ASCII 码，用计算机语言很容易做到。通过以下初始化把字母A赋给grade即可：\n1char grade &#x3D; &#39;A&#39;;在C语言中，用单引号括起来的单个字符被称为字符常量（character constant）。编译器一发现’A’，就会将其转换成相应的代码值。单引号必不可少。下面还有一些其他的例子：\n1234char broiled;　　 &#x2F;* 声明一个char类型的变量 *&#x2F;broiled &#x3D; &#39;T&#39;;　　&#x2F;* 为其赋值，正确 *&#x2F;broiled &#x3D; T;　　　&#x2F;* 错误！此时T是一个变量 *&#x2F;broiled &#x3D; &quot;T&quot;;　　&#x2F;* 错误！此时&quot;T&quot;是一个字符串 *&#x2F;如上所示，如果省略单引号，编译器认为T是一个变量名；如果把T用双引号括起来，编译器则认为”T”是一个字符串。字符串的内容将在《字符串和格式化输入/输出》中介绍。\n实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值：\n1char grade &#x3D; 65; &#x2F;* 对于ASCII，这样做没问题，但这是一种不好的编程风格 *&#x2F;在本例中，虽然65是int类型，但是它在char类型能表示的范围内，所以将其赋值给grade没问题。由于65是字母A对应的ASCII码，因此本例是把A赋给grade。注意，能这样做的前提是系统使用ASCII码。其实，用’A’代替65才是较为妥当的做法，这样在任何系统中都不会出问题。因此，最好使用字符常量，而不是数字代码值。\n奇怪的是，C语言将字符常量视为int类型而非char类型。例如，在int为32位、char为8位的ASCII系统中，有下面的代码：\n1char grade &#x3D; &#39;B&#39;;本来’B’对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade）。利用字符常量的这种特性，可以定义一个字符常量’FATE’，即把4个独立的8位ASCII码储存在一个32位存储单元中。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是’E’。\n非打印字符单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。\n第1种方法前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII值是7，因此可以这样写：1char beep &#x3D; 7;\n第2种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）。图列出了转义序列及其含义。把转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如，假设有下面一行代码：1char nerf &#x3D; &#39;\\n&#39;;稍后打印变量nerf的效果是，在打印机或屏幕上另起一行。\n\n现在，我们来仔细分析一下转义序列。使用C90新增的警报字符（\\a）是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报（在一些系统中，警报字符不起作用）。C标准规定警报字符不得改变活跃位置。标准中的活跃位置（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。\n接下来的转义字符\\b、\\f、\\n、\\r、\\t和\\v是常用的输出设备控制字符。了解它们最好的方式是查看它们对活跃位置的影响。\n换页符（\\f）把活跃位置移至下一页的开始处；\n\n换行符（\\n）把活跃位置移至下一行的开始处；\n\n回车符（\\r）把活跃位置移动到当前行的开始处；\n\n水平制表符（\\t）将活跃位置移至下一个水平制表点（通常是第1个、第9个、第17个、第25个等字符位置）；\n\n垂直制表符（\\v）把活跃位置移至下一个垂直制表点。\n\n这些转义序列字符不一定在所有的显示设备上都起作用。例如，换页符和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动。只有将其输出到打印机上时才会产生前面描述的效果。\n接下来的3个转义序列（\\\\、\\‘、\\“）用于打印\\、&#39;、&quot;字符（由于这些字符用于定义字符常量，是printf()函数的一部分，若直接使用它们会造成混乱）。如果打印下面一行内容：\n1Gramps sez, &quot;a \\ is a backslash.&quot;应这样编写代码：\n1printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash.\\&quot;\\n&quot;);表中的最后两个转义序列（\\0oo和\\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\\）并用单引号括起来。八进制表示格式为/000，可写1～3位八进制进制数字，每位数最大值为7\n例如，如果编译器不识别警报字符（\\a），可以使用ASCII码来代替：\n1beep &#x3D; &#39;\\007&#39;;可以省略前面的 0，’\\07’甚至’\\7’都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。\n从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X。十六进制数表示格式为/xhh，前面的x表示是十六进制，再加上1～2位十六进制数字，所以后面的两个h可以表示两位数，每位数最大值为f\n例如，Ctrl+P字符的ASCII十六进制码是10（相当于十进制的16），可表示为’\\x10’或’\\x010’。下图列出了一些整数类型的不同进制形式。\n\n使用ASCII码时，注意数字和数字字符的区别。例如，字符4对应的ASCII码是52。&#39;4&#39;表示字符4，而不是数值4。\n关于转义序列，读者可能有下面3个问题。\n上面最后一个例子（printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash\\&quot;\\&quot;n&quot;），  为何没有用单引号把转义序列括起来？ 无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来。双引号中的字符集合叫作字符串（详见字符串和格式化输入输出）。注意，该例中的其他字符（G、r、a、m、p、s等）都没有用单引号括起来。与此类似，printf(&quot;Hello!\\007\\n&quot;);将打印Hello!并发出一声蜂鸣，而 printf(&quot;Hello!7\\n&quot;);则打印 Hello!7。不是转义序列中的数字将作为普通字符被打印出来。\n\n何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使用’\\f’）和ASCII码（’\\014’）之间选择，请选择前者（即’\\f’）。这样的写法不仅更好记，而且可移植性更高。’\\f’在不使用ASCII码的系统中，仍然有效。\n\n如果要使用ASCII码，为何要写成’\\032’而不是032？首先，’\\032’能更清晰地表达程序员使用字符编码的意图。其次，类似\\032这样的转义序列可以嵌入C的字符串中，如printf(“Hello!\\007\\n”);中就嵌入了\\007。\n\n打印字符printf()函数用%c指明待打印的字符。前面介绍过，一个字符变量实际上被储存为1字节的整数值。因此，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字符。程序清单3.5演示了打印char类型变量的两种方式。\n程序清单3.5 charcode.c程序\n12345678910&#x2F;* charcode.c-显示字符的代码编号 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;char　ch;printf(&quot;Please　enter　a　character.\\n&quot;);scanf(&quot;%c&quot;, &amp;ch);　&#x2F;* 用户输入字符 *&#x2F;printf(&quot;The　code　for　%c　is　%d.\\n&quot;,　ch,　ch);return　0;&#125;运行该程序后，输出示例如下：\n123Please　enter　a　character.CThe　code　for　C　is　67.运行该程序时，在输入字母后不要忘记按下Enter或Return键。随后，scanf()函数会读取用户输入的字符，&amp;符号表示把输入的字符赋给变量ch。接着，printf()函数打印ch的值两次，第1次打印一个字符（对应代码中的%c），第2次打印一个十进制整数值（对应代码中的%d）。注意，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式。\n\n有符号还是无符号有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。请查阅相应的编译器手册，确定正在使用的编译器如何实现char类型。或者，可以查阅limits.h头文件。下一章将详细介绍头文件的内容。\n根据C90标准，C语言允许在关键字char前面使用signed或unsigned。这样，无论编译器默认char是什么类型，signed char表示有符号类型，而unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果只用char处理字符，那么char前面无需使用任何修饰符。\nBool类型C99标准添加了_Bool类型，用于表示布尔值，即逻辑值true和false。因为C语言用值1表示true，值0表示false，所以_Bool类型实际上也是一种整数类型。但原则上它仅间占用1位存储空，因为对0和1而言，1位的存储空间足够了。\n程序通过布尔值可选择执行哪部分代码。\n可移植类型：stdint.h和inttypes.hC 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件stdint.h和inttypes.h，以确保C语言的类型在各系统中的功能相同。\n C语言为现有类型创建了更多类型名。这些新的类型名定义在stdint.h头文件中。  \n例如，int32_t表示32位的有符号整数类型。在使用32位int的系统中，头文件会把int32_t作为int的别名。  \n不同的系统也可以定义相同的类型名。\n\n例如，int为16位、long为32位的系统会把int32_t作为long的别名。然后，使用int32_t类型编写程序，并包含stdint.h头文件时，编译器会把int或long替换成与当前系统匹配的类型。\n上面讨论的类型别名是精确宽度整数类型（exact-width integer type）的示例。int32_t表示整数类型的宽度正好是32位。但是，计算机的底层系统可能不支持。因此，精确宽度整数类型是可选项。\n\n\n如果系统不支持精确宽度整数类型怎么办？ C99和C11提供了第2类别名集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。这组类型集合被称为最小宽度类型（minimum width type）。\n 例如，int_least8_t是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义int8_t类型。尽管如此，该系统仍可使用int_least8_t类型，但可能把该类型实现为16位的整数类型。\n 当然，一些程序员更关心速度而非空间。为此，C99和C11定义了一组可使计算达到最快的类型集合。这组类型集合被称为最快最小宽度类型（fastst minimum width type）。\n\n例如，int_fast8_t被定义为系统中对8位有符号值而言运算最快的整数类型的别名。\n另外，有些程序员需要系统的最大整数类型。为此，C99定义了最大的有符号整数类型intmax_t，可储存任何有效的有符号整数值。类似地，unintmax_t表示最大的无符号整数类型。顺带一提，这些类型有可能比long long和unsigned long类型更大，因为C编译器除了实现标准规定的类型以外，还可利用C语言实现其他类型。例如，一些编译器在标准引入 long long 类型之前，已提前实现了该类型。\nC99 和C11 不仅提供可移植的类型名，还提供相应的输入和输出。\n例如，printf()打印特定类型时要求与相应的转换说明匹配。\n\n如果要打印int32_t类型的值，有些定义使用%d，而有些定义使用%ld，怎么办？\n\nC 标准针对这一情况，提供了一些字符串宏（下章中详细介绍）来显示可移植类型。例如， inttypes.h头文件中定义了PRId32字符串宏，代表打印32位有符号值的合适转换说明（如d或l）。程序清单3.6演示了一种可移植类型和相应转换说明的用法。\n程序清单3.6 altnames.c程序\n1234567891011121314&#x2F;* altnames.c -- 可移植整数类型名 *&#x2F;#include　&lt;stdio.h&gt;#include &lt;inttypes.h&gt; &#x2F;&#x2F; 支持可移植类型int　main(void)&#123;\tint32_t me32;　　 &#x2F;&#x2F; me32是一个32位有符号整型变量\tme32&#x3D;45933945;\tprintf(&quot;First,assume int32_t is int: &quot;);\tprintf(&quot;me32&#x3D;%d\\n&quot;,me32);\tprintf(&quot;Next,let&#39;s not make any assumptions.\\n&quot;);\tprintf(&quot;Instead,use a \\&quot;macro\\&quot; from　inttypes.h:　&quot;);\tprintf(&quot;me32&#x3D;%&quot; PRId32 &quot;\\n&quot;,　me32);\treturn　0;&#125;该程序最后一个printf()中，参数PRId32被定义在inttypes.h中的”d”替换，因而这条语句等价于：\n1printf(&quot;me16 &#x3D; %&quot; &quot;d&quot; &quot;\\n&quot;, me16);在C语言中，可以把多个连续的字符串组合成一个字符串，所以这条语句又等价于：\n1printf(&quot;me16 &#x3D; %d\\n&quot;, me16);下面是该程序的输出，注意，程序中使用了&quot;转义序列来显示双引号：\n123First, assume int32_t is int: me32 &#x3D; 45933945Next, let&#39;s not make any assumptions.Instead, use a &quot;macro&quot; from inttypes.h: me32 &#x3D; 45933945篇幅有限，无法介绍扩展的所有整数类型。本节主要是为了让读者知道，在需要时可进行这种级别的类型控制。附录B中的参考资料VI“扩展的整数类型”介绍了完整的inttypes.h和stdint.h头文件。\n注意 对C99/C11的支持\nC语言发展至今，虽然ISO已发布了C11标准，但是编译器供应商对C99的实现程度却各不相同。在本书第6版的编写过程中，一些编译器仍未实现inttypes.h头文件及其相关功能。\nfloat、double和long double各种整数类型对大多数软件开发项目而言够用了。然而，面向金融和数学的程序经常使用浮点数。C语言中的浮点类型有float、double和long double类型。它们与FORTRAN和Pascal中的real类型一致。前面提到过，浮点类型能表示包括小数在内更大范围的数。浮点数的表示类似于科学记数法（即用小数乘以10的幂来表示数字）。该记数系统常用于表示非常大或非常小的数。表3.3列出了一些示例。\n表3.3 记数法示例\n\n第1列是一般记数法；第2列是科学记数法；第3列是指数记数法（或称为e记数法），这是科学记数法在计算机中的写法，e后面的数字代表10的指数。图3.7演示了更多的浮点数写法。\nC标准规定，float类型必须至少能表示6位有效数字，且取值范围至少是10-37～10+37。前一项规定指float类型必须至少精确表示小数点后的6位有效数字，如33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30千克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字。通常，系统储存一个long浮点数要占用32位。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。\n\nC语言提供的另一种浮点类型是double（意为双精度）。double类型和float类型的最小取值范围相同，但至少必须能表示10位有效数字。一般情况下，double占用64位而不是32位。一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，double类型的值至少有13位有效数字，超过了标准的最低位数规定。\nC语言的第3种浮点类型是long double，以满足比double类型更高的精度要求。不过，C只保证long double类型至少与double类型的精度相同。\n声明浮点型变量 浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子：\n1234float　noah,　jonah;double　trouble;float　planck　&#x3D;　6.63e-34;long　double　gnp;\n浮点型常量 在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。下面是两个有效的浮点型常量：\n12-1.56E+122.87e-3 正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常量示例：\n123453.14159.24e16.8E-5100.不要在浮点型常量中间加空格：1.56 E+12（错误！）\n\n默认情况下，编译器假定浮点型常量是double类型的精度。例如，假设some是float类型的变量，编写下面的语句：\n1some &#x3D; 4.0 * 2.0;通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。\n在浮点数后面加上f或F后缀可覆盖默认设置，编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用l或L后缀使得数字成为long double类型，如54.3l和4.32L。注意，建议使用L后缀，因为字母l和数字1很容易混淆。没有后缀的浮点型常量是double类型。\n\nC99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。如下所示：\n\n10xa.1fp10十六进制a等于十进制10，.1f是1/16加上15/256（十六进制f等于十进制15），p10是210或1024。0xa.1fp10表示的值是(10 + 1/16 + 15/256)×1024（即，十进制10364.0）。\n注意，并非所有的编译器都支持C99的这一特性。\n打印浮点值printf()函数使用%f转换说明打印十进制记数法的float和double类型浮点数，用%e打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E。打印long double类型要使用%Lf、%Le或%La转换说明。给那些未在函数原型中显式说明参数类型的函数（如，printf()）传递参数时，C编译器会把float类型的值自动转换成double类型。程序清单3.7演示了这些特性。\n程序清单3.7 showf_pt.c程序\n1234567891011121314&#x2F;* showf_pt.c -- 以两种方式显示float类型的值 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　aboat　&#x3D;　32000.0;    double　abet　&#x3D;　2.14e9;    long　double　dip　&#x3D;　5.32e-5;    printf(&quot;%f　can　be　written　%e\\n&quot;,　aboat,　aboat);    &#x2F;&#x2F; 下一行要求编译器支持C99或其中的相关特性    printf(&quot;And　it&#39;s　%a　in　hexadecimal,　powers　of　2　notation\\n&quot;,　aboat);    printf(&quot;%f　can　be　written　%e\\n&quot;,　abet,　abet);    printf(&quot;%Lf　can　be　written　%Le\\n&quot;,　dip,　dip);    return　0;&#125;该程序的输出如下，前提是编译器支持C99/C11：\n123432000.000000　can　be　written　3.200000e+04And　it&#39;s　0x1.f4p+14　in　hexadecimal,　powers　of　2　notation2140000000.000000　can　be　written　2.140000e+090.000053　can　be　written　5.320000e-05该程序示例演示了默认的输出效果。下一章将介绍如何通过设置字段宽度和小数位数来控制输出格式。\n浮点值的上溢和下溢假设系统的最大float类型值是3.4E38，编写如下代码：\n12float toobig &#x3D; 3.4E38 * 100.0f;printf(&quot;%e\\n&quot;, toobig);会发生什么？这是一个上溢（overflow）的示例。当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定义的，不过现在C语言规定，在这种情况下会给toobig赋一个表示无穷大的特定值，而且printf()显示该值为inf或infinity（或者具有无穷含义的其他内容）。\n当除以一个很小的数时，情况更为复杂。回忆一下，float类型的数以指数和尾数部分来储存。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作下溢（underflow）。C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值。因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。\n还有另一个特殊的浮点值NaN（not a number的缩写）。例如，给asin()函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的值。但是正弦值不能大于1，因此，如果传入的参数大于1，该函数的行为是未定义的。在这种情况下，该函数将返回NaN值，printf()函数可将其显示为nan、NaN或其他类似的内容。\n浮点数舍入错误给定一个数，加上1，再减去原来给定的数，结果是多少？你一定认为是1。但是，下面的浮点运算给出了不同的答案：\n12345678910&#x2F;* floaterr.c--演示舍入错误 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　a,b;    b　&#x3D;　2.0e20　+　1.0;    a　&#x3D;　b　-　2.0e20;    printf(&quot;%f　\\n&quot;,　a);    return　0;&#125;该程序的输出如下：\n得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。\n浮点数表示法上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011年，该标准被ISO/IEC/IEEE 60559:2011标准收录。该标准作为C99和C11的可选项，符合硬件要求的平台可开启。floaterr.c程序的第3个输出示例即是支持该浮点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工具。详见附录B.5，参考资料V。\n复数和虚数类型许多科学和工程计算都要用到复数和虚数。C99 标准支持复数类型和虚数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要使用复数和虚数（VCR芯片就不需要复数）。一般而言，虚数类型都是可选项。C11标准把整个复数软件包都作为可选项。\n简而言之，C语言有3种复数类型：float_Complex、double_Complex和long double _Complex。例如，float _Complex类型的变量应包含两个float类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型是float _Imaginary、double _Imaginary和long double _Imaginary。\n如果包含complex.h头文件，便可用complex代替_Complex，用imaginary代替_Imaginary，还可以用I代替-1的平方根。\n\n为何 C 标准不直接用 complex 作为关键字来代替_Complex，而要添加一个头文件（该头文件中把complex定义为_Complex）？\n\n因为标准委员会考虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。例如，之前的 C99，许多程序员已经使用 struct complex 定义一个结构来表示复数或者心理学程序中的心理状况（关键字struct用于定义能储存多个值的结构，详见第14章）。让complex成为关键字会导致之前的这些代码出现语法错误。但是，使用struct _Complex的人很少，特别是标准使用首字母是下划线的标识符作为预留字以后。因此，标准委员会选定_Complex作为关键字，在不用考虑名称冲突的情况下可选择使用complex。\n其他类型现在已经介绍完C语言的所有基本数据类型。有些人认为这些类型实在太多了，但有些人觉得还不够用。注意，虽然C语言没有字符串类型，但也能很好地处理字符串。第4章将详细介绍相关内容。\nC语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用到了指针〔指针（pointer）指向变量或其他数据对象位置〕。例如，在 scanf()函数中用到的前缀&amp;，便创建了一个指针，告诉 scanf()把数据放在何处。\n小结：基本数据类型关键字：基本数据类型由11个关键字组成：int、long、short、unsigned、char、float、double、signed、_Bool、_Complex和_Imaginary。\n\n有符号整型：  有符号整型可用于表示正整数和负整数。\n  int——系统给定的基本整数类型。C语言规定int类型不小于16位。\n  short或short int ——最大的short类型整数小于或等于最大的int类型整数。C语言规定short类型至少占16位。\n  long或long int ——该类型可表示的整数大于或等于最大的int类型整数。C语言规定long类型至少占32位。\n  long long或long long int ——该类型可表示的整数大于或等于最大的long类型整数。Long long类型至少占64位。\n  一般而言，long类型占用的内存比short类型大，int类型的宽度要么和long类型相同，要么和short类型相同。例如，旧DOS系统的PC提供16位的short和int，以及32位的long；Windows 95系统提供16位的short以及32位的int和long。\n\n无符号整型：\n  无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。在整型类型前加上关键字unsigned表明该类型是无符号整型：unsignedint、unsigned long、unsigned short。单独的unsigned相当于unsigned int。\n\n字符类型：\n  可打印出来的符号（如A、&amp;和+）都是字符。根据定义，char类型表示一个字符要占用1字节内存。出于历史原因，1字节通常是8位，但是如果要表示基本字符集，也可以是16位或更大。\n  char ——字符类型的关键字。有些编译器使用有符号的char，而有些则使用无符号的char。在需要时，可在char前面加上关键字signed或unsigned来指明具体使用哪一种类型。\n\n布尔类型：\n  布尔值表示true和false。C语言用1表示true，0表示false。\n  _Bool ——布尔类型的关键字。布尔类型是无符号 int类型，所占用的空间只要能储存0或1即可。\n\n实浮点类型：\n  实浮点类型可表示正浮点数和负浮点数。\n  float ——系统的基本浮点类型，可精确表示至少-6位有效数字。\n  double ——储存浮点数的范围（可能）更大，能表示比 float 类型更多的有效数字（至少 10位，通常会更多）和更大的指数。\n  long long ——储存浮点数的范围（可能）比double更大，能表示比double更多的有效数字和更大的指数。\n\n复数和虚数浮点数：\n  虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成：\n123456float _Complexdouble _Complexlong double _Complexfloat _Imaginarydouble _Imaginarylong long _Imaginary\n小结：如何声明简单变量\n\n\n选择需要的类型。\n\n使用有效的字符给变量起一个变量名。\n\n按以下格式进行声明：\n 类型说明符 变量名;\n 类型说明符由一个或多个关键字组成。下面是一些示例：\n12int erest;unsigned short cash;\n可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所示：\n1char ch, init, ans;\n在声明的同时还可以初始化变量：\n1float mass &#x3D; 6.0E24;\n类型大小如何知道当前系统的指定类型的大小是多少？运行程序清单3.8，会列出当前系统的各类型的大小。\n123456789101112131415161718程序清单3.8 typesize.c程序&#x2F;&#x2F;* typesize.c -- 打印类型大小 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    &#x2F;* C99为类型大小提供%zd转换说明 *&#x2F;    printf(&quot;Type　int　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(int));    printf(&quot;Type　char　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(char));    printf(&quot;Type　long　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(long));    printf(&quot;Type　long　long　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(long　long));    printf(&quot;Type　double　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(double));    printf(&quot;Type　long　double　has　a　size　of　%zd　bytes.\\n&quot;,    sizeof(long　double));    return　0;&#125;sizeof是C语言的内置运算符，以字节为单位给出指定类型的大小。C99和C11提供%zd转换说明匹配sizeof的返回类型。一些不支持C99和C11的编译器可用%u或%lu代替%zd。\n该程序的输出如下：\n123456Type int has a size of 4 bytes.Type char has a size of 1 bytes.Type long has a size of 8 bytes.Type long long has a size of 8 bytes.Type double has a size of 8 bytes.Type long double has a size of 16 bytes.该程序列出了6种类型的大小，你也可以把程序中的类型更换成感兴趣的其他类型。注意，因为C语言定义了char类型是1字节，所以char类型的大小一定是1字节。而在char类型为16位、double类型为64位的系统中，sizeof给出的double是4字节。在limits.h和float.h头文件中有类型限制的相关信息（下一章将详细介绍这两个头文件）。\n顺带一提，注意该程序最后几行 printf()语句都被分为两行，只要不在引号内部或一个单词中间断行，就可以这样写。\n使用数据类型编写程序时，应注意合理选择所需的变量及其类型。通常，用int或float类型表示数字，char类型表示字符。在使用变量之前必须先声明，并选择有意义的变量名。初始化变量应使用与变量类型匹配的常数类型。例如：\n12int apples &#x3D; 3;　　　 &#x2F;* 正确 *&#x2F;int oranges &#x3D; 3.0;　　&#x2F;* 不好的形式 *&#x2F;与Pascal相比，C在检查类型匹配方面不太严格。C编译器甚至允许二次初始化，但在激活了较高级别警告时，会给出警告。最好不要养成这样的习惯。\n把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。例如，下面的初始化：\n12int cost &#x3D; 12.99;　　 &#x2F;* 用double类型的值初始化int类型的变量 *&#x2F;float pi &#x3D; 3.1415926536;　 &#x2F;* 用double类型的值初始化float类型的变量 *&#x2F;第1个声明，cost的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第2个声明会损失一些精度，因为C只保证了float类型前6位的精度。编译器对这样的初始化可能给出警告。读者在编译程序清单3.1时可能就遇到了这种警告。\n许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 i_前缀表示 int类型，us_前缀表示 unsigned short 类型。这样，一眼就能看出来i_smart 是 int 类型的变量， us_versmart是unsigned short类型的变量。\n参数和陷阱有必要再次提醒读者注意 printf()函数的用法。读者应该还记得，传递给函数的信息被称为参数。例如，printf(&quot;Hello, pal.&quot;)函数调用有一个参数：&quot;Hello,pal.&quot;。双引号中的字符序列（如，”Hello,pal.“）被称为字符串（string），第4章将详细讲解相关内容。现在，关键是要理解无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数。\n与此类似，scanf(&quot;%d&quot;, &amp;weight)函数调用有两个参数：&quot;%d&quot;和&amp;weight。C语言用逗号分隔函数中的参数。printf()和scanf()函数与一般函数不同，它们的参数个数是可变的。例如，前面的程序示例中调用过带一个、两个，甚至三个参数的 printf()函数。程序要知道函数的参数个数才能正常工作。printf()和scanf()函数用第1个参数表明后续有多少个参数，即第1个字符串中的转换说明与后面的参数一一对应。例如，下面的语句有两个%d转换说明，说明后面还有两个参数：\n1printf(&quot;%d cats ate %d cans of tuna\\n&quot;, cats, cans);后面的确还有两个参数：cats和cans。\n程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配。现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确。但是，该机制对printf()和scanf()不起作用，因为这两个函数的参数个数可变。如果参数在匹配上有问题，会出现什么情况？假设你编写了程序清单 3.9中的程序。\n程序清单3.9 badcount.c程序\n12345678910111213&#x2F;* badcount.c -- 参数错误的情况 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    int　n　&#x3D;　4;    int　m　&#x3D;　5;    float　f　&#x3D;　7.0f;    float　g　&#x3D;　8.0f;    printf(&quot;%d\\n&quot;, n, m);　 &#x2F;* 参数太多　*&#x2F;    printf(&quot;%d %d %d\\n&quot;, n); &#x2F;* 参数太少　*&#x2F;    printf(&quot;%d %d\\n&quot;, f, g); &#x2F;* 值的类型不匹配 *&#x2F;    return　0;&#125;XCode 4.6（OS 10.8）的输出如下：\n12344　1　-7063378361606414344　1Microsoft Visual Studio Express 2012（Windows 7）的输出如下：\n12344　0　00　1075576832\n注意，用%d显示float类型的值，其值不会被转换成int类型。在不同的平台下，缺少参数或参数类型不匹配导致的结果不同。\n\n所有编译器都能顺利编译并运行该程序，但其中大部分会给出警告。的确，有些编译器会捕获到这类问题，然而C标准对此未作要求。因此，计算机在运行时可能不会捕获这类错误。如果程序正常运行，很难觉察出来。如果程序没有打印出期望值或打印出意想不到的值，你才会检查 printf()函数中的参数个数和类型是否得当。\n转义序列示例再来看一个程序示例，该程序使用了一些特殊的转义序列。程序清单 3.10 演示了退格（\\b）、水平制表符（\\t）和回车（\\r）的工作方式。这些概念在计算机使用电传打字机作为输出设备时就有了，但是它们不一定能与现代的图形接口兼容。例如，程序清单3.10在某些Macintosh的实现中就无法正常运行。\n程序清单3.10 escape.c程序\n12345678910111213&#x2F;* escape.c -- 使用转移序列 *&#x2F;#include　&lt;stdio.h&gt;int　main(void)&#123;    float　salary;    printf(&quot;\\aEnter your desired monthly salary:&quot;);　&#x2F;* 1 *&#x2F;    printf(&quot; $_______\\b\\b\\b\\b\\b\\b\\b&quot;);　　　　　　　 &#x2F;* 2 *&#x2F;    scanf(&quot;%f&quot;,　&amp;salary);    printf(&quot;\\n\\t$%.2f　a　month　is　$%.2f　a　year.&quot;,　salary,    salary * 12.0);　　　　　　　　　　　　　　&#x2F;* 3 *&#x2F;    printf(&quot;\\rGee!\\n&quot;);　　　　　　　　　　　　　　　 &#x2F;* 4 *&#x2F;    return　0;&#125;程序运行情况假设在系统中运行的转义序列行为与本章描述的行为一致（实际行为可能不同。例如，XCode 4.6把\\a、\\b和\\r显示为颠倒的问号），下面我们来分析这个程序。\n第1条printf()语句（注释中标为1）发出一声警报（因为使用了\\a），然后打印下面的内容：\n1Enter your desired monthly salary:因为printf()中的字符串末尾没有\\n，所以光标停留在冒号后面。\n第2条printf()语句在光标处接着打印，屏幕上显示的内容是：\n1Enter your desired monthly salary: $_______冒号和美元符号之间有一个空格，这是因为第2条printf()语句中的字符串以一个空格开始。7个退格字符使得光标左移7个位置，即把光标移至7个下划线字符的前面，紧跟在美元符号后面。通常，退格不会擦除退回所经过的字符，但有些实现是擦除的，这和本例不同。\n假设键入的数据是4000.00（并按下Enter键），屏幕显示的内容应该是：\n1Enter your desired monthly salary: $4000.00键入的字符替换了下划线字符。按下Enter键后，光标移至下一行的起始处。\n第3条printf()语句中的字符串以\\n``\\t开始。换行字符使光标移至下一行起始处。水平制表符使光标移至该行的下一个制表点，一般是第9列（但不一定）。然后打印字符串中的其他内容。执行完该语句后，此时屏幕显示的内容应该是：\n12Enter　your　desired　monthly　salary:　$4000.00$4000.00　a　month　is　$48000.00　a　year.因为这条printf()语句中没有使用换行字符，所以光标停留在最后的点号后面。\n第4条printf()语句以\\r开始。这使得光标回到当前行的起始处。然后打印Gee!，接着\\n使光标移至下一行的起始处。屏幕最后显示的内容应该是：\n12Enter　your　desired　monthly　salary:　$4000.00Gee!　$4000.00　a　month　is　$48000.00　a　year.刷新输出printf()何时把输出发送到屏幕上？最初，printf()语句把输出发送到一个叫作缓冲区（buffer）的中间存储区域，然后缓冲区中的内容再不断被发送到屏幕上。C 标准明确规定了何时把缓冲区中的内容发送到屏幕：  \n当缓冲区满、遇到换行字符或需要输入的时候（从缓冲区把数据发送到屏幕或文件被称为刷新缓冲区）。\n\n例如，前两个 printf()语句既没有填满缓冲区，也没有换行符，但是下一条 scanf()语句要求用户输入，这迫使printf()的输出被发送到屏幕上。\n\n旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。代码应改为：1printf(&quot;Enter your desired monthly salary:\\n&quot;);\nscanf(&quot;%f&quot;, &amp;salary);无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新缓冲区的方法是使用fflush()函数，详见其他章。\n关键概念C语言提供了大量的数值类型，目的是为程序员提供方便。那以整数类型为例，C认为一种整型不够，提供了有符号、无符号，以及大小不同的整型，以满足不同程序的需求。\n计算机中的浮点数和整数在本质上不同，其存储方式和运算过程有很大区别。即使两个32位存储单元储存的位组合完全相同，但是一个解释为float类型，另一个解释为long类型，这两个相同的位组合表示的值也完全不同。\n例如，在PC中，假设一个位组合表示float类型的数256.0，如果将其解释为long类型，得到的值是113246208。C语言允许编写混合数据类型的表达式，但是会进行自动类型转换，以便在实际运算时统一使用一种类型。\n计算机在内存中用数值编码来表示字符。美国最常用的是ASCII码，除此之外C也支持其他编码。字符常量是计算机系统使用的数值编码的符号表示，它表示为单引号括起来的字符，如&#39;A&#39;。\n本章小结C 有多种的数据类型。基本数据类型分为两大类：整数类型和浮点数类型。通过为类型分配的储存量以及是有符号还是无符号，区分不同的整数类型。最小的整数类型是char，因实现不同，可以是有符号的char或无符号的char，即unsigned char或signed char。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有short、int、long和long long类型。\nC规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用unsigned关键字创建相应的无符号类型：unsigned short、unsigned int、unsigned long和unsigned long long。或者，在类型名前加上signed修饰符显式表明该类型是有符号类型。最后，_Bool类型是一种无符号类型，可储存0或1，分别代表false和true。\n浮点类型有3种：float、double和C90新增的long double。后面的类型应大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关键字_Complex和_Imaginary与浮点类型的关键字组合（如，double _Complex类型和float _Imaginary类型）来表示这些类型。\n整数可以表示为十进制、八进制或十六进制。0前缀表示八进制数，0x或0X前缀表示十六进制数。例如，32、040、0x20分别以十进制、八进制、十六进制表示同一个值。l或L前缀表明该值是long类型， ll或LL前缀表明该值是long long类型。\n在C语言中，直接表示一个字符常量的方法是：把该字符用单引号括起来，如&#39;Q&#39;、&#39;8&#39;和&#39;$&#39;。C语言的转义序列（如，&#39;\\n&#39;）表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，&#39;\\007&#39;），表示ASCII码中的一个字符。\n浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如，7.38E10）。C99和C11提供了第3种指数表示法，即用十六进制数和2的幂来表示（如，0xa.1fp10）。\nprintf()函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（%）和一个转换字符组成，如%d或%f。\n","plink":"https://dxsummer.gitee.io/posts/e51e6bb3/"},{"title":"hexo搭建+Butterfly主题配置","date":"2020-04-15T07:01:53.000Z","date_formatted":{"ll":"2020年4月15日","L":"2020/04/15","MM-DD":"04-15"},"updated":"2020-06-08T01:59:02.000Z","content":"Hexo基本操作手册此贴 结合简书 俗俗俗俗俗人 与 Butterfly制作人——JerryC 以及 Emil等前辈的经验，方便后人的学习。在此感谢 俗俗俗俗俗人  JerryC  Emil等各位前辈若有问题 请于我留言安装安装Node.js左边的是稳定版本，右边的是最新版双击运行安装包，然后去命令行123node -v# 这时候会出现你的版本号v10.16.3，安装成功&#96;安装Git\n1brew install gitbrew又不知道了？[○･｀Д´･ ○] 别太过分！ 戳这里到brew官网\n安装Hexo1npm install -g hexo-cli官方这里也提到，如果系统未安装Xcode会遇到问题，这时候去Mac的应用商店搜索\n建立博客123hexo init &lt;你所放置的文件地址&gt;cd &lt;你所放置的文件地址&gt;npm install此时你就会看到以下的目录结构\n这就是基础的目录了这里就介绍几个关键的文件和文件夹\n_config.yml网站的配置的信息都存储在这里面，很关键的文件，文章后面会做到详细阐述\nsource这里面是存放用户资源的地方，什么意思呢？也就是博客内容都放在这里面进到目录中，就会发现有一个 _post文件夹 ，这个文件夹就是之后的文档主要文件。\nthemes主题文件夹，放心，之后恶心你的大部分地方都在这里面！\nhexo常用的命令新建文章1hexo new &lt;文章标题&gt; # 可以简写hexo n &lt;文章标题&gt;生成静态文件由于Hexo是用Node.js来进行页面渲染，所以需要生成对应的静态文件\n1hexo generate # 可以简写hexo g启动本地服务器每篇文章总得查看无论是编排、内容，所以我们需要测试，这时候我们就需要本地服务了\n1hexo server # 可以简写hexo s但是运行之前需要确保已经安装 hexo-server 插件\n1npm install hexo-server --save此时服务器就会开启4000端口供你使用，但是可能你的服务器端口被占用了，会提示以下错误\n1FATAL Port 4000 has been used. Try other port instead.此时你需要切换一个端口\n1hexo s -p 5000 # -p 是可以指定端口的操作部署网站辛辛苦苦打理了这么久的博客，不上传到服务器上展（zhuang）示（bi）一下，怎么对得起自己\n1hexo deploy # 可以简写 hexo d这里涉及到几个知识点\n\n需要先渲染博客，也就是hexo g（可以hexo g -d一步操作）还需要配置博客目录下 _config.yml 文件中的deploy模块\n\n12345# 之后会教大家如何操作deploy:    type: git    repo: &lt;git地址&gt;    branch: master其余的命令实际上用到真的不多，万一需要，百度就可以了\n安装主题戳这里到Hexo的插件库\n该博客的主题hexo-theme-butterfly 是基于Molunerfinn的hexo-theme-melody的基础上进行开发的。\n安装hexo-theme-butterfly在博客的根目录\n1git clone -b master https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly或者想用最新的分支的话\n1git clone -b dev https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly.git themes&#x2F;Butterfly替换主题博客根目录\n1打开config.yml然后将\n1theme: Butterfly博客配置文章front-matter12345678910111213title:date:tags:categories:keywords:description:top_img: （除非特定需要，可以不寫）comments: 是否展示评论系统（true.展示 false.不展示）description: 节选，如果不填就默认从文章中选择配置的长度cover:  首页缩略图toc:  是否显示toctoc_number: 是否显示toc数字copyright: 是否显示版权1234# 节选内容auto_excerpt:  enable: true  length: 150系统中英文替换替换主题后你会发现首页的菜单一开始是英文名字，或者不是自己想要的样子，怎么办？配置 _config.yml\n1language: zh-CN12# 进入主题文件夹cd themes&#x2F;Butterfly会发现这里也有一个 _config.yml 文件，这个文件是掌管整套系统主题相关的配置，个人觉得重要程度的比重要比前面博客根目录的同名文件要重要，当然缺一不可。\n编辑这个文件\n123456789101112# 可以像俗人一样把原本的英文名修改成中文，这样就会完全解决切换不彻底问题menu:  首页: &#x2F; || fa fa-home  时间轴: &#x2F;archives&#x2F; || fa fa-archive  留言板: &#x2F;message&#x2F; || fa fa-coffee  标签: &#x2F;tags&#x2F; || fa fa-tags  分类: &#x2F;categories&#x2F; || fa fa-folder-open  链接: &#x2F;link&#x2F; || fa fa-link  关于: &#x2F;about&#x2F; || fa fa-heart  列表||fa fa-list:    - 音乐 || &#x2F;music&#x2F; || fa fa-music    - 视频 || &#x2F;movies&#x2F; || fa fa-film这里如果需要新增菜单栏目的话，记得这样的规律\n名称 || 路径 || icon新增菜单此时发现点击页面都是空白\n这时候就需要新增页面的操作了，但是注意这里的新增和新增文章不同，这里需要加上分类\n12# 新增标签hexo new page tags在博客的根目录访问\n1source&#x2F;tags&#x2F;index.md发现这是一个文档文件\n是的，基本上大同小异，但是要注意，由于主题的底层已经加上了对该页面的效果，所以需要遵循命名规范后修改文档\n123title: 标签date: 2019-10-01 10:00:00type: &quot;tags&quot;此时首页的标签按钮已经展示对应的页面内容了，其余的页面同理。\n友情链接前往你的Hexo根目录\n输入 hexo new page link\n找到 source/link/index.md 这个文件\n编辑这个文件123title: 链接date: 2019-10-01 10:00:00type: &quot;link&quot;注意，主题中配置友情链接的位置不是在该文件本身，而是需要你去 创建 source/_data目录，并且新建文件 link.yml12345678910111213class:  class_name: 友情链接  link_list:    1:      name: 名称      link: 地址      avatar: 头像      descr: 描述    #2:    #  name: xxxxxx    #  link: https:&#x2F;&#x2F;www.xxxxxxcn&#x2F;    #  avatar: https:&#x2F;&#x2F;xxxxx&#x2F;avatar.png    #  descr: xxxxxxx\n同时，可以在themes/Butterfly/_config.yml文件中，写上个人博客的信息，方便他人帮忙转载\n12345678Flink:  headline: 友情链接  info_headline: 我的Blog资料  name: Blog 名字： Dx  address: Blog 地址： https:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;  avatar: Blog 头像： https:&#x2F;&#x2F;dxsummer.gitee.io&#x2F;img&#x2F;avatar.png  info: Blog 简介： 生命不息,折騰不止|  comment: 如果需要交换链接，请给我留言，谢谢~代码高亮Butterfly支持五种高亮样式：\ndefault\ndarker\npale night\nlight\nocean\n配置 _config.yml\n1highlight_theme: light复制配置 _config.yml\n12345678910111213# Highlight theme# ---------------highlight_theme: lighthighlight_copy: true    #代碼複製按鈕highlight_lang: true     #代碼語言顯示highlight_shrink: false #代碼框不展開，需點擊 &#39;&gt;&#39; 打開# copy setting# 是否禁止複製（如果禁止，highlight_copy的功能將無效)# copyright 複製的内容後面加上版權信息copy:  enable: true  # true 開啓 &#x2F; false 禁止  copyright: true换行在默认情况下，配置中是不开启换行功能的，如果不希望在代码中有横向滚动条，可以开启这个功能。配置 _config.yml\n123456code_word_wrap: truehighlight:  enable: true  line_number: false  auto_detect: false  tab_replace:社交图标戳这里到对应的图标中心\n配置 _config.yml\n1234social:  fa fa-weixin: http:&#x2F;&#x2F;iblog.thatwang.com&#x2F;qrcode_for_gh_706ce3f91494_258.jpg  fa fa-weibo: http:&#x2F;&#x2F;weibo.cn&#x2F;wordpole9981  fa fa-qq: https:&#x2F;&#x2F;jq.qq.com&#x2F;?_wv&#x3D;1027&amp;k&#x3D;5E3IUHu文章版权配置 _config.yml\n1234post_copyright:  enable: true  license: CC BY-NC-SA 4.0  license_url: https:&#x2F;&#x2F;creativecommons.org&#x2F;licenses&#x2F;by-nc-sa&#x2F;4.0&#x2F;是否开启版权\n1copyright: false文章打赏配置 _config.yml\n123456789reward:  enable: true  QR_code:    - itemlist:        img: &#x2F;img&#x2F;wechat.jpg        text: 微信    - itemlist:        img: &#x2F;img&#x2F;alipay.jpg        text: 支付宝头像配置 _config.yml\n1avatar: https:&#x2F;&#x2F;xxxx&#x2F;avatar.png文章目录配置 _config.yml\n123toc:  enable: true  number: true  # 显示章节数字相关文章配置 _config.yml\n123related_post:  enable: true  limit: 6         # 显示推荐文章数量博客年份配置 _config.yml\n1since: 2018页脚配置 _config.yml\n1footer_custom_text: &lt;a href&#x3D;&quot;https:&#x2F;&#x2F;blog.thatwang.com&#x2F;&quot;&gt;Everybody&#39;s good at something.&lt;&#x2F;a&gt;夜间模式Apple都有这模式了，我们也不能输呀\n配置 _config.yml\n12darkmode:  enable: true阅读模式阅读模式会去除文章以外的内容\n配置 _config.yml\n12readmode:  enable: true侧边栏设置配置 _config.yml\n123456789aside:  position: right # left or right  card_author: true  card_announcement: true  card_recent_post: true  card_categories: true  card_tags: true  card_archives: true  card_webinfo: true访问人数配置 _config.yml\n1234busuanzi:  site_uv: true  site_pv: true  page_pv: true运行时间配置 _config.yml\n123456runtimeshow:  enable: true  start_date: 6&#x2F;7&#x2F;2018 00:00:00    ##博客开通时间  # 格式: 月&#x2F;日&#x2F;年 时间  # 也可以写成 年&#x2F;月&#x2F;日 时间相册文章页面编辑以下markdown格式内容\n123&#123;% gallery %&#125;markdown 圖片格式&#123;% endgallery %&#125;评论戳这个leancloud服务\n其实Hexo能支持很多评论系统，但是用下来，就leancloud这个最舒服，最方便\n配置 _config.yml\n123456789101112valine:  enable: true # if you want use valine,please set this value is true  appId: 配置中心查看  # leancloud application app id  appKey: key  # leancloud application app key  notify: false # valine mail notify (true&#x2F;false) https:&#x2F;&#x2F;github.com&#x2F;xCss&#x2F;Valine&#x2F;wiki  verify: false # valine verify code (true&#x2F;false)  pageSize: 10 # comment list page size  avatar: robohash  # gravatar style https:&#x2F;&#x2F;valine.js.org&#x2F;#&#x2F;avatar  lang: zh-cn # i18n: zh-cn&#x2F;en  placeholder: 来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～ # valine comment input placeholder(like: Please leave your footprints )  guest_info: nick,mail,link #valine comment header info  bg: &#x2F;img&#x2F;comment_bg.png  # valine background注册登录\n创建应用\n获取key\n此时就安装好了评论系统，就这么简单\n音乐同样是使用leancloud服务\n前面的注册逻辑与评论一样，接下来就是存储环节\n加入单条音乐播放器的页面\n1&#123;% aplayer &quot;可以了&quot; &quot;陈奕迅&quot; &quot;https:&#x2F;&#x2F;xxx.xxx.com&#x2F;92b3af330d2274b1fa55.mp3&quot; &quot;https:&#x2F;&#x2F;xxx.xxx.com&#x2F;xx.png&quot; &quot;autoplay&quot; %&#125;加入列表音乐播放器的页面\n1&#123;% aplayerlist %&#125;&#123;&quot;narrow&quot;: false,&quot;autoplay&quot;: true,&quot;showlrc&quot;: 3,&quot;mode&quot;: &quot;random&quot;,&quot;music&quot;: [&#123;&quot;title&quot;: &quot;美好事物&quot;,&quot;author&quot;: &quot;房东的猫&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;945198c4909674765644.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;6e0e9e63cb0733f7ff12.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;,&#123;&quot;title&quot;: &quot;尚好的青春&quot;,&quot;author&quot;: &quot;云の泣&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;5b42b829b8ae08ccabe0.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;889df742eca5261f2fc5.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;,&#123;&quot;title&quot;: &quot;预谋邂逅&quot;,&quot;author&quot;: &quot;阿肆&quot;,&quot;url&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;1bd4f91441982710bcad.mp3&quot;,&quot;pic&quot;: &quot;http:&#x2F;&#x2F;xxx.xxx.com&#x2F;f72d61579f74d4ff9ce0.png&quot;,&quot;lrc&quot;: &quot;&quot;&#125;]&#125;&#123;% endaplayerlist %&#125;即可\n分享配置 _config.yml\n123sharejs:  enable: true  sites: wechat,weibo,qq搜索安装 hexo-generator-search，根据文档做对应配置\n配置 _config.yml\n12345local_search:  enable: true  labels:    input_placeholder: 试试看能找到啥宝藏吧!    hits_empty: &quot;客官，本店还未提供该服务: $&#123;query&#125;&quot; # if there are no result自定义主题配置 _config.yml\n1234567891011theme_color:   enable: true   main: &quot;#696969&quot;   paginator: &quot;#00c4b6&quot;   button_hover: &quot;#FF7242&quot;   text_selection: &quot;#00c4b6&quot;   link_color: &quot;#99a9bf&quot;   meta_color: &#39;#858585&#39;   hr_color: &quot;#A4D8FA&quot;   read-mode-bg_color: &#39;#FAF9DE&#39;   inline-code-color: &#39;#F47466&#39;打字效果配置 _config.yml\n12activate_power_mode:  enable: true动态彩带配置 _config.yml\n123canvas_ribbon_piao:  enable: true  mobile: false # false 手机端不显示 true 手机端显示背景线条配置 _config.yml\n1234567canvas_nest:  enable: true  color: &#39;0,0,255&#39; #color of lines, default: &#39;0,0,0&#39;; RGB values: (R,G,B).(note: use &#39;,&#39; to separate.)  opacity: 0.7 # the opacity of line (0~1), default: 0.5.  zIndex: -1 # z-index property of the background, default: -1.  count: 99 # the number of lines, default: 99.  mobile: false #  false 手机端不显示 true 手机端显示鼠标点击效果配置 _config.yml\n123456fireworks:  enable: true  # 點擊出現愛心click_heart:  enable: true首页弹幕座右铭配置 _config.yml\n12345678# 主頁subtitle# 打字效果# (如果有英文逗號&#39; , &#39;，請使用轉義字符 &amp;#44;)subtitle:  enable: true  sub:    - 努力不一定能成功&amp;#44;但是永远不会后悔    - Hard work may not always result in success&amp;#44;but it will never result in regret更新优化更新\n设置foot调整页脚高度，去除驱动和主题描述，，修改 By 字母为红色爱心。\n在路径 D:\\blog\\themes\\Butterfly\\layout\\includes\\footer.pug 下，将 By 替换为以下内容\n12Styl&lt;i style&#x3D;&quot;color:#FF6A6A&quot; class&#x3D;&quot;fa fa-heartbeat&quot;&gt;&lt;&#x2F;i&gt;同一路径下，删除以下内容，便可以去除驱动和主题描述，也可以按照以下格式添加自定义内容\n123456789Code.framework-info  span&#x3D; _p(&#39;footer.driven&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;hexo.io&#39;)    span Hexo  span.footer-separator |  span&#x3D; _p(&#39;footer.theme&#39;) + &#39; &#39;  a(href&#x3D;&#39;https:&#x2F;&#x2F;github.com&#x2F;jerryc127&#x2F;hexo-theme-butterfly&#39;)    span Butterfly利用 PS 修改 ICP 图标大小为 18x18，头像，图标，加载动画等在 D:\\blog\\themes\\Butterfly\\source\\img 中可替换。\n自定义字体、鼠标指针样式引用格式\n123@font-face &#123; font-family:MyFont;src: url(https:xxx)&#125;body&#123;font-family:MyFont!important;&#125;\n引用方法：将引用代码添加到 D:\\blog\\themes\\Butterfly\\source\\css\\_third-partynormalize.min.css 末尾即可，鼠标样式亦是如此。\n\n鼠标样式\n\n引用格式123456789body &#123;cursor: url(https:&#x2F;&#x2F;xxx),    default;&#125;a,img &#123;    cursor: url(https:&#x2F;&#x2F;xxx),        default;&#125;\n","plink":"https://dxsummer.gitee.io/posts/10474aaf/"},{"title":"hexo的目录结构","date":"2020-04-13T06:21:52.000Z","date_formatted":{"ll":"2020年4月13日","L":"2020/04/13","MM-DD":"04-13"},"updated":"2020-06-08T01:51:16.000Z","content":"hexo的目录结构效果预览今天来整理一下hexo的目录结构，了解hexo每个目录的作用，并且设置全局配置文件 _config.yml 的相关参数，初步定义属于你自己的博客。我们开始吧.\n主目录结构12345678|-- _config.yml|-- package.json|-- scaffolds|-- source   |-- _posts|-- themes|-- .gitignore|-- package.json主目录介绍_config.yml全局配置文件，网站的很多信息都在这里配置，诸如网站名称，副标题，描述，作者，语言，主题，部署等等参数。这个文件下面会做较为详细的介绍。\npackage.jsonhexo框架的参数和所依赖插件，如下：\n12345678910111213141516171819&#123;  &quot;name&quot;: &quot;hexo-site&quot;,  &quot;version&quot;: &quot;0.0.0&quot;,  &quot;private&quot;: true,  &quot;hexo&quot;: &#123;    &quot;version&quot;: &quot;3.2.0&quot;  &#125;,  &quot;dependencies&quot;: &#123;    &quot;hexo&quot;: &quot;^3.2.0&quot;,    &quot;hexo-generator-archive&quot;: &quot;^0.1.4&quot;,    &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;,    &quot;hexo-generator-index&quot;: &quot;^0.2.0&quot;,    &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-ejs&quot;: &quot;^0.2.0&quot;,    &quot;hexo-renderer-stylus&quot;: &quot;^0.3.1&quot;,    &quot;hexo-renderer-marked&quot;: &quot;^0.2.10&quot;,    &quot;hexo-server&quot;: &quot;^0.2.0&quot;  &#125;&#125;scaffoldsscaffolds是“脚手架、骨架”的意思，当你新建一篇文章（hexo new ‘title’）的时候，hexo是根据这个目录下的文件进行构建的。基本不用关心。\nsource这个目录很重要，新建的文章都是在保存在这个目录下的._posts 。需要新建的博文都放在 _posts 目录下。_posts 目录下是一个个 markdown 文件。你应该可以看到一个hello-world.md 的文件，文章就在这个文件中编辑。_posts 目录下的md文件，会被编译成html文件，放到 public （此文件现在应该没有，因为你还没有编译过）文件夹下。\nthemes网站主题目录，hexo有非常好的主题拓展，支持的主题也很丰富。该目录下，每一个子目录就是一个主题，我的子目录如下：\n12|-- landscape  &#x2F;&#x2F;默认主题|-- hexo-theme-next  &#x2F;&#x2F;第三方主题你也可以自己下载主题放到该文件下,hexo主题传送门\n_config.yml文件_config.yml 采用YAML语法格式，具体语法自行学习 。具体配置可以参考官方文档，_config.yml 文件中的内容，并对主要参数做简单的介绍\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172# Hexo Configuration## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;configuration.html## Source: https:&#x2F;&#x2F;github.com&#x2F;hexojs&#x2F;hexo&#x2F;# Sitetitle: Hexo #网站标题subtitle:   #网站副标题description:  #网站描述author: John Doe  #作者language:    #语言timezone:    #网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America&#x2F;New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;url: http:&#x2F;&#x2F;yoursite.com   #你的站点Urlroot: &#x2F;                       #站点的根目录permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;   #文章的 永久链接 格式   permalink_defaults:    #永久链接中各部分的默认值# Directory   source_dir: source   #资源文件夹，这个文件夹用来存放内容public_dir: public     #公共文件夹，这个文件夹用于存放生成的站点文件。tag_dir: tags         # 标签文件夹     archive_dir: archives    #归档文件夹category_dir: categories      #分类文件夹code_dir: downloads&#x2F;code     #Include code 文件夹i18n_dir: :lang                #国际化（i18n）文件夹skip_render:                #跳过指定文件的渲染，您可使用 glob 表达式来匹配路径。    # Writingnew_post_name: :title.md # 新文章的文件名称default_layout: post     #预设布局titlecase: false # 把标题转换为 title caseexternal_link: true # 在新标签中打开链接filename_case: 0     #把文件名称转换为 (1) 小写或 (2) 大写render_drafts: false  #是否显示草稿post_asset_folder: false  #是否启动 Asset 文件夹relative_link: false      #把链接改为与根目录的相对位址    future: true                #显示未来的文章highlight:                    #内容中代码块的设置      enable: true  line_number: true  auto_detect: false  tab_replace:# Category &amp; Tagdefault_category: uncategorizedcategory_map:          #分类别名tag_map:            #标签别名# Date &#x2F; Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http:&#x2F;&#x2F;momentjs.com&#x2F;docs&#x2F;#&#x2F;displaying&#x2F;format&#x2F;date_format: YYYY-MM-DD         #日期格式time_format: HH:mm:ss        #时间格式    # Pagination## Set per_page to 0 to disable paginationper_page: 10    #分页数量pagination_dir: page  # Extensions## Plugins: https:&#x2F;&#x2F;hexo.io&#x2F;plugins&#x2F;## Themes: https:&#x2F;&#x2F;hexo.io&#x2F;themes&#x2F;theme: landscape   #主题名称# Deployment## Docs: https:&#x2F;&#x2F;hexo.io&#x2F;docs&#x2F;deployment.html#  部署部分的设置deploy:       type:  #类型，常用的git\n网站存放在子目录如果您的网站存放在子目录中，例如 http://yoursite.com/blog，则请将您的 url 设为 http://yoursite.com/blog 并把 root 设为 /blog/。\n\nhexo的目录结构基本介绍完了，具体人配置需要在用的时候在启用。\n完整hexo教程，请访问hexo搭建个人博客\n","plink":"https://dxsummer.gitee.io/posts/48b5ba15/"},{"title":"Markdown教程","date":"2020-04-12T04:41:40.000Z","date_formatted":{"ll":"2020年4月12日","L":"2020/04/12","MM-DD":"04-12"},"updated":"2020-06-08T01:52:30.000Z","content":"Markdown教程1.Markdown标题二级标题三级标题123# 一级标题## 二级标题###三级标题2.段落格式字体斜体文本斜体文本粗体文本粗体文本粗斜体文本粗斜体文本\n*斜体文本*  \n_斜体文本_  \n**粗体文本**  \n__粗体文本__  \n***粗斜体文本***  \n___粗斜体文本___分隔线\n\n12-------*******删除线、下划、脚注BAIDU.COM带下划线文本你们好,大家好\n1234~~BAIDU.COM~~   &lt;u&gt;带下划线文本&lt;&#x2F;u&gt;  你们好,[大家好][大家好]: hello3.Markdown列表无序列表无序列表使用星号(*)、加号(+)或是减号(-)作为列表标记:  \n无序列表项\n无序列表项\n无序列表项   \n123* 无序列表项* 无序列表项* 无序列表项有序列表有序列表使用数字并加上 . 号来表示\n有序列表1\n有序列表2\n有序列表3\n1231. 有序列表12. 有序列表23. 有序列表3列表嵌套第一项：第一项嵌套的第一个元素\n第一项嵌套的第二个元素\n\n第二项：第二项嵌套的第一个元素\n第二项嵌套的第二个元素\n\n1234561. 第一项：- 第一项嵌套的第一个元素- 第一项嵌套的第二个元素2. 第二项：- 第二项嵌套的第一个元素- 第二项嵌套的第二个元素4.Markdown 区块区块引用\n这是一段引用段落，将会被高亮显示最外层\n\n第一层嵌套\n\n第二层嵌套\n\n\n\n1234&gt;这是一段引用段落，将会被高亮显示  &gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套区块中使用列表\n区块中使用列表\n第一项\n第二项  \n第一项\n第二项\n第三项\n\n123456&gt; 区块中使用列表&gt; 1. 第一项&gt; 2. 第二项  &gt; + 第一项&gt; + 第二项&gt; + 第三项列表中使用区块第一项\n菜鸟教程学的不仅是技术更是梦想\n\n\n第二项1234* 第一项    &gt; 菜鸟教程      &gt; 学的不仅是技术更是梦想* 第二项\n5.Markdown 代码如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`）\nprintf() 函数\n1&#96;printf()&#96; 函数代码区块代码区块使用 4 个空格或者一个制表符（Tab 键）。  \njavascript\n$(document).ready(function () {\nalert(&apos;RUNOOB&apos;);\n});6.Markdown 链接超链接百度https://www.baidu.com/\n123[超链接名称](链接地址)或&lt;链接地址&gt;高级链接这个链接用 1 作为网址变量 Google这个链接用 runoob 作为网址变量 Runoob然后在文档的结尾为变量赋值（网址）\n123456这个链接用 1 作为网址变量 [Google][1]这个链接用 runoob 作为网址变量 [Runoob][runoob]然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;www.google.com&#x2F;  [runoob]: http:&#x2F;&#x2F;www.runoob.com&#x2F;7.Markdown 图片图片\n12![alt 属性文本](图片地址)![alt 属性文本](图片地址 &quot;可选标题&quot;)使用实例：\n12![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png)![RUNOOB 图标](http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png &quot;RUNOOB&quot;)当然，你也可以像网址那样对图片网址使用变量:  \n123这个链接用 1 作为网址变量 [RUNOOB][1].然后在文档的结尾为变量赋值（网址）  [1]: http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.pngMarkdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用普通的 &lt;img&gt; 标签。\n1&lt;img src&#x3D;&quot;http:&#x2F;&#x2F;static.runoob.com&#x2F;images&#x2F;runoob-logo.png&quot; width&#x3D;&quot;50%&quot;&gt;8.Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。| Tables        | Are           | Cool  || ————- |:————-:| —–:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |\n12345| Tables        | Are           | Cool  || ------------- |:-------------:| -----:|| col 3 is      | right-aligned | $1600 || col 2 is      | centered      |   $12 || zebra stripes | are neat      |    $1 |对齐方式我们可以设置表格的对齐方式：\n-: 设置内容和标题栏居右对齐。:- 设置内容和标题栏居左对齐。:-: 设置内容和标题栏居中对齐。  \n实例如下：\n\n1234| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |9.Markdown 高级技巧支持的 HTML 元素不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。\n目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：\n1使用 &lt;kbd&gt;Ctrl&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Alt&lt;&#x2F;kbd&gt;+&lt;kbd&gt;Del&lt;&#x2F;kbd&gt; 重启电脑输出结果为：\n转义Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：\n12**文本加粗** \\*\\* 正常显示星号 \\*\\*输出结果为：\nMarkdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：\n123456789101112\\   反斜线&#96;   反引号*   星号_   下划线&#123;&#125;  花括号[]  方括号()  小括号#   井字号+   加号-   减号.   英文句点!   感叹号公式当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：\n12345678$$\\mathbf&#123;V&#125;_1 \\times \\mathbf&#123;V&#125;_2 &#x3D;  \\begin&#123;vmatrix&#125; \\mathbf&#123;i&#125; &amp; \\mathbf&#123;j&#125; &amp; \\mathbf&#123;k&#125; \\\\\\frac&#123;\\partial X&#125;&#123;\\partial u&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial u&#125; &amp; 0 \\\\\\frac&#123;\\partial X&#125;&#123;\\partial v&#125; &amp;  \\frac&#123;\\partial Y&#125;&#123;\\partial v&#125; &amp; 0 \\\\\\end&#123;vmatrix&#125;$&#123;$tep1&#125;&#123;\\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;$$输出结果：\n以下几个实例效果图如下：\n1、横向流程图源码格式：\n123456graph LRA[方形] --&gt;B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt;|a&#x3D;1| D[结果1]    C --&gt;|a&#x3D;2| E[结果2]    F[横向流程图]2、竖向流程图源码格式：\n123456graph TDA[方形] --&gt; B(圆角)    B --&gt; C&#123;条件a&#125;    C --&gt; |a&#x3D;1| D[结果1]    C --&gt; |a&#x3D;2| E[结果2]    F[竖向流程图]3、标准流程图源码格式：\n123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st-&gt;op-&gt;condcond(yes)-&gt;io-&gt;econd(no)-&gt;sub1(right)-&gt;op4、标准流程图源码格式（横向）：\n123456789st&#x3D;&gt;start: 开始框op&#x3D;&gt;operation: 处理框cond&#x3D;&gt;condition: 判断框(是或否?)sub1&#x3D;&gt;subroutine: 子流程io&#x3D;&gt;inputoutput: 输入输出框e&#x3D;&gt;end: 结束框st(right)-&gt;op(right)-&gt;condcond(yes)-&gt;io(bottom)-&gt;econd(no)-&gt;sub1(right)-&gt;op5、UML时序图源码样例：\n12345对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象A-&gt;对象B: 你真的好吗？6、UML时序图源码复杂样例：\n1234567891011Title: 标题：复杂使用对象A-&gt;对象B: 对象B你好吗?（请求）Note right of 对象B: 对象B的描述Note left of 对象A: 对象A的描述(提示)对象B--&gt;对象A: 我很好(响应)对象B-&gt;小三: 你好吗小三--&gt;&gt;对象A: 对象B找我了对象A-&gt;对象B: 你真的好吗？Note over 小三,对象B: 我们是朋友participant CNote right of C: 没人陪我玩7、UML标准时序图样例：\n123456789101112%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头  sequenceDiagram    participant 张三    participant 李四    张三-&gt;王五: 王五你好吗？    loop 健康检查        王五-&gt;王五: 与疾病战斗    end    Note right of 王五: 合理 食物 &lt;br&#x2F;&gt;看医生...    李四--&gt;&gt;张三: 很好!    王五-&gt;李四: 你怎么样?    李四--&gt;王五: 很好!8、甘特图样例：\n12345678910111213141516171819%% 语法示例        gantt        dateFormat  YYYY-MM-DD        title 软件开发甘特图        section 设计        需求                      :done,    des1, 2014-01-06,2014-01-08        原型                      :active,  des2, 2014-01-09, 3d        UI设计                     :         des3, after des2, 5d    未来任务                     :         des4, after des3, 5d        section 开发        学习准备理解需求                      :crit, done, 2014-01-06,24h        设计框架                             :crit, done, after des2, 2d        开发                                 :crit, active, 3d        未来任务                              :crit, 5d        耍                                   :2d        section 测试        功能测试                              :active, a1, after des3, 3d        压力测试                               :after a1  , 20h        测试报告                               : 48h\n文字色块\nMarkDown 自带的文字高亮，其他方法就看第 3 点\n\n高亮文字\n1&lt;mark&gt;高亮文字&lt;&#x2F;mark&gt;\n利用 HTML 表格标签的 bgcolor 属性来实现文字背景色（整行填充背景），写法如下，文末附有常用颜色表。\n\n这里的背景色是：ForestGreen1&lt;table&gt;&lt;tr&gt;&lt;td bgcolor&#x3D;PowderBlue&gt;这里的背景色是：PowderBlue&lt;&#x2F;td&gt;&lt;&#x2F;tr&gt;&lt;&#x2F;table&gt;\n文字色块利用 span 标签赋予样式，引用边框用 p 标签变色。当然编辑器里无法预览效果\n\n黄色色块 绿色色块 蓝色色块 灰色色块 红色色块 紫色色块\n123456&lt;span id&#x3D;&quot;inline-yellow&quot;&gt;黄色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-green&quot;&gt;绿色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-blue&quot;&gt;蓝色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-grey&quot;&gt;灰色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-red&quot;&gt;红色色块&lt;&#x2F;span&gt;&lt;span id&#x3D;&quot;inline-purple&quot;&gt;紫色色块&lt;&#x2F;span&gt;\nCSS 样式里添加自定义颜色块，在文章中引用，主题不同配置有所差异，例如 NexT 主题在blog\\themes\\next\\source\\css\\_custom 下添加以下内容，Butterfly 主题在 blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下添加（不用在意符号，直接添加即可），各举一例，其余色块见其他文章。色块的所有配置传送点\n\n左边框红色块级\n右边框红色块级\n上边框蓝色块级CSS 样式里添加自定义颜色块，Butterfly 在 blog\\themes\\Butterfly\\source\\css\\_layout\\post.styl 下添加（不用在意符号，直接添加即可）\n123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&#x2F;&#x2F; 颜色块-黄span#inline-yellow &#123;display:inline;padding:.2em .6em .3em;font-size:90%;font-weight:normal;line-height:1;color:#000;text-align:center;white-space:nowrap;vertical-align:baseline;border-radius:0.1rem;background-color: #FFD700;&#125;    &#x2F;&#x2F; 左侧边框红色块级p#div-border-left-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #df3e3e;&#125;&#x2F;&#x2F; 左侧边框黄色块级p#div-border-left-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-left-width: 5px;border-radius: 3px;border-left-color: #f0ad4e;&#125;&#x2F;&#x2F; 右侧边框黄色块级p#div-border-right-yellow &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-right-width: 5px;border-radius: 3px;border-right-color: #f0ad4e;&#125;&#x2F;&#x2F; 上侧边框红色p#div-border-top-red &#123;display: block;padding: 10px;margin: 10px 0;border: 1px solid #ccc;border-top-width: 5px;border-radius: 3px;border-top-color: #df3e3e;&#125;文章中添加代码\n左边框红色块级\n 右边框红色块级\n 上边框蓝色块级123&lt;p id&#x3D;&quot;div-border-left-red&quot;&gt;左边框红色块级&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;div-border-right-red&quot;&gt;右边框红色块级&lt;&#x2F;p&gt;&lt;p id&#x3D;&quot;div-border-top-blue&quot;&gt;上边框蓝色块级&lt;&#x2F;p&gt;\n字体样式\nMarkDown嵌入HTML文字样式即可，字体名称及颜色代码可在字体、颜色常用代码找到\n\n这是黑体字\n1&lt;font face&#x3D;&quot;黑体&quot;&gt;这是黑体字&lt;&#x2F;font&gt;这是微软雅黑\n1&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;这是微软雅黑&lt;&#x2F;font&gt;这是华文彩云\n1&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;这是华文彩云&lt;&#x2F;font&gt;三号蓝色黑体\n1&lt;font color&#x3D;#0099ff size&#x3D;3 face&#x3D;&quot;黑体&quot;&gt;三号蓝色黑体&lt;&#x2F;font&gt;四号青色字\n1&lt;font color&#x3D;#00ffff size&#x3D;4&gt;四号青色字&lt;&#x2F;font&gt;五号灰色字\n1&lt;font color&#x3D;gray size&#x3D;5&gt;五号灰色字&lt;&#x2F;font&gt;","plink":"https://dxsummer.gitee.io/posts/c079e252/"},{"title":"About","date":"2020-05-25T09:28:23.000Z","date_formatted":{"ll":"2020年5月25日","L":"2020/05/25","MM-DD":"05-25"},"updated":"2020-11-21T14:41:44.000Z","content":"\n\n  [Dx的博客🐷]\n  \n    \n    \n    \n    \n    与&nbsp;\n    DxSummer&nbsp;\n    （\n    \n    技术的进步总是从痛苦开始\n    \n    ）\n    \n    交流中...\n    \n    \n    \n    \n  \n\n\n\nbot_ui_ini()\n\n\n\n","plink":"https://dxsummer.gitee.io/about/"}]