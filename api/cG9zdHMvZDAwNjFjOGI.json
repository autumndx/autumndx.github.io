{"title":"Step3 运算符、表达式和语句","date":"2020-05-30T08:10:08.000Z","date_formatted":{"ll":"2020年5月30日","L":"2020/05/30","MM-DD":"05-30"},"link":"posts/d0061c8b","comments":true,"tags":["C语言基础"],"categories":["C语言"],"updated":"2020-06-08T01:44:44.883Z","content":"<h1 id=\"运算符、表达式和语句\">[运算符、表达式和语句]<a href=\"#运算符、表达式和语句\" title=\"[运算符、表达式和语句]\"></a></h1><p>本章介绍以下内容：</p>\n<p>关键字：<code>while</code>、<code>typedef</code></p>\n<p>运算符：<code>=</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>、<code>++</code>、<code>--</code>、(类型名)</p>\n<p>C语言的各种运算符，包括用于普通数学运算的运算符</p>\n<p>运算符优先级以及语句、表达式的含义</p>\n<p>while循环</p>\n<p>复合语句、自动类型转换和强制类型转换</p>\n<p>如何编写带有参数的函数</p>\n<p>现在，读者已经熟悉了如何表示数据，接下来我们学习如何处理数据。C 语言为处理数据提供了大量的操作，可以在程序中进行算术运算、比较值的大小、修改变量、逻辑地组合关系等。我们先从基本的算术运算（<strong>加、减、乘、除</strong>）开始。</p>\n<p>组织程序是处理数据的另一个方面，让程序按正确的顺序执行各个步骤。C 有许多语言特性，帮助你完成组织程序的任务。循环就是其中一个特性，本章中你将窥其大概。循环能重复执行行为，让程序更有趣、更强大。</p>\n<h2 id=\"循环简介\">循环简介<a href=\"#循环简介\" title=\"循环简介\"></a></h2><p>程序清单5.1是一个简单的程序示例，该程序进行了简单的运算，计算穿9码男鞋的脚长（单位：英寸）。为了让读者体会循环的好处，程序的第1个版本演示了不使用循环编程的局限性。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.1</span> shoes1.c程序</span><br><span class=\"line\"><span class=\"comment\">/* shoes1.c -- 把鞋码转换成英寸 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ADJUST 7.31　　　　　　　　　　<span class=\"comment\">// 字符常量</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> SCALE = <span class=\"number\">0.333</span>;<span class=\"comment\">// const变量</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span>　shoe,　foot;</span><br><span class=\"line\">    shoe　=　<span class=\"number\">9.0</span>;</span><br><span class=\"line\">    foot = SCALE * shoe + ADJUST;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Shoe　size　(men's)　　 foot　length\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%10.1f　%15.2f　inches\\n\"</span>,　shoe,　foot);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shoe　size　(men's)　foot　length</span><br><span class=\"line\">\t<span class=\"number\">9.0</span>　　　　<span class=\"number\">10.31</span>　inches</span><br></pre></td></tr></table></figure><p>该程序演示了用<code>#define</code> 指令创建符号常量和用 <code>const</code> 限定符创建在程序运行过程中不可更改的变量。程序使用了乘法和加法，假定用户穿9码的鞋，以英寸为单位打印用户的脚长。你可能会说：“这太简单了，我用笔算比敲程序还要快。”说得没错。写出来的程序只使用一次（本例即只根据一只鞋的尺码计算一次脚长），实在是浪费时间和精力。如果写成交互式程序会更有用，但是仍无法利用计算机的优势。</p>\n<p>应该让计算机做一些重复计算的工作。毕竟，需要重复计算是使用计算机的主要原因。C 提供多种方法做重复计算，我们在这里简单介绍一种——<strong>while循环</strong>。它能让你对运算符做更有趣地探索。程序清单5.2演示了用循环改进后的程序。</p>\n<p>程序清单5.2 shoes2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* shoes2.c -- 计算多个不同鞋码对应的脚长 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ADJUST 7.31　　　　　　　　　　<span class=\"comment\">// 字符常量</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> SCALE = <span class=\"number\">0.333</span>;<span class=\"comment\">// const变量</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span>　shoe,　foot;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Shoe size (men's) foot length\\n\"</span>);</span><br><span class=\"line\">    shoe　=　<span class=\"number\">3.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (shoe &lt; <span class=\"number\">18.5</span>)　　　　　　<span class=\"comment\">/* while循环开始 */</span></span><br><span class=\"line\">    &#123;　　　　　　　　　　　　　　　<span class=\"comment\">/* 块开始　*/</span></span><br><span class=\"line\">        foot = SCALE * shoe + ADJUST;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%10.1f　%15.2f　inches\\n\"</span>,　shoe,　foot);</span><br><span class=\"line\">        shoe　=　shoe　+　<span class=\"number\">1.0</span>;</span><br><span class=\"line\">    &#125;　　　　　　　　　　　　　　　<span class=\"comment\">/* 块结束　　　 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"If　the　shoe　fits,　wear　it.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是shoes2.c程序的输出（…表示并未显示完整，有删节）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Shoe　size　(men's)　foot　length</span><br><span class=\"line\"><span class=\"number\">3.0</span>　　　　　　 <span class=\"number\">8.31</span>　inches</span><br><span class=\"line\"><span class=\"number\">4.0</span>　　　　　　 <span class=\"number\">8.64</span>　inches</span><br><span class=\"line\"><span class=\"number\">5.0</span>　　　　　　 <span class=\"number\">8.97</span>　inches</span><br><span class=\"line\"><span class=\"number\">6.0</span>　　　　　　 <span class=\"number\">9.31</span>　inches</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">16.0</span>　　　　　<span class=\"number\">12.64</span>　inches</span><br><span class=\"line\"><span class=\"number\">17.0</span>　　　　　<span class=\"number\">12.97</span>　inches</span><br><span class=\"line\"><span class=\"number\">18.0</span>　　　　　<span class=\"number\">13.30</span>　inches</span><br><span class=\"line\">If　the　shoe　fits,　wear　it.</span><br></pre></td></tr></table></figure><p>（如果读者对此颇有研究，应该知道该程序不符合实际情况。程序中假定了一个统一的鞋码系统。）</p>\n<p>下面解释一下<code>while</code>循环的原理。当程序第1次到达<code>while</code>循环时，会检查圆括号中的条件是否为真。该程序中，条件表达式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe &lt; <span class=\"number\">18.5</span></span><br></pre></td></tr></table></figure><p>符号<code>&lt;</code>的意思是小于。变量<code>shoe</code>被初始化为3.0，显然小于18.5。因此，该条件为真，程序进入块中继续执行，把尺码转换成英寸。然后打印计算的结果。下一条语句把 shoe增加1.0，使shoe的值为4.0：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe = shoe + <span class=\"number\">1.0</span>;</span><br></pre></td></tr></table></figure><p>此时，程序返回<code>while</code>入口部分检查条件。为何要返回<code>while</code>的入口部分？因为上面这条语句的下面是右花括号（<code>}</code>），代码使用一对花括号（<code>{}</code>）来标出<code>while</code>循环的范围。花括号之间的内容就是要被重复执行的内容。<strong>花括号以及被花括号括起来的部分被称为块（block）</strong>。现在，回到程序中。因为4小于18.5，所以要重复执行被花括号括起来的所有内容（用计算机术语来说就是，程序循环这些语句）。该循环过程一直持续到shoe的值为19.0。此时，由于19.0小于18.5，所以该条件为假：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe &lt; <span class=\"number\">18.5</span></span><br></pre></td></tr></table></figure><p>出现这种情况后，控制转到紧跟<code>while</code>循环后面的第1条语句。该例中，是最后的<code>printf()</code>语句。</p>\n<p>可以很方便地修改该程序用于其他转换。例如，把SCALE设置成1.8、ADJUST设置成32.0，该程序便可把摄氏温度转换成华氏温度；把SCALE设置成0.6214、ADJUST设置成0，该程序便可把公里转换成英里。注意，修改了设置后，还要更改打印的消息，以免前后表述不一。</p>\n<p>通过<code>while</code>循环能便捷灵活地控制程序。现在，我们来学习程序中会用到的基本运算符。</p>\n<h2 id=\"基本运算符\">基本运算符<a href=\"#基本运算符\" title=\"基本运算符\"></a></h2><p>C用运算符（operator）表示算术运算。例如，<code>+</code>运算符使在它两侧的值加在一起。如果你觉得术语“运算符”很奇怪，那么请记住东西总得有个名称。与其叫“那些东西”或“运算处理符”，还不如叫“<strong>运算符</strong>”。现在，我们介绍一下用于基本算术运算的运算符：<code>=</code>、<code>+</code>、<code>-</code>、<code>*</code>和<code>/</code>（C 没有指数运算符。不过，C 的标准数学库提供了一个<code>pow()</code>函数用于指数运算。例如，pow(3.5, 2.2)返回3.5的2.2次幂）。</p>\n<h3 id=\"赋值运算符：\">赋值运算符：=<a href=\"#赋值运算符：\" title=\"赋值运算符：=\"></a></h3><p>在C语言中，=并不意味着“相等”，而是一个赋值运算符。下面的赋值表达式语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bmw = <span class=\"number\">2002</span>;</span><br></pre></td></tr></table></figure><p>把值2002赋给变量<code>bmw</code>。也就是说，<code>=</code>号左侧是一个变量名，右侧是赋给该变量的值。符号<code>=</code>被称为赋值运算符。另外，上面的语句不读作“bmw等于2002”，而读作“把值2002赋给变量bmw”。赋值行为从右往左进行。</p>\n<p>也许变量名和变量值的区别看上去微乎其微，但是，考虑下面这条常用的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i = i + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure><p>对数学而言，这完全行不通。如果给一个有限的数加上 1，它不可能“等于”原来的数。但是，在计算机赋值表达式语句中，这很合理。该语句的意思是：找出变量 i 的值，把该值加 1，然后把新值赋值变量i（见图5.1）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/图5.1.png\" class=\"φcy\"></p>\n<p>在C语言中，类似这样的语句没有意义（实际上是无效的）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">2002</span> = bmw;</span><br></pre></td></tr></table></figure><p>因为在这种情况下，2002 被称为右值（rvale），只能是字面常量。不能给常量赋值，常量本身就是它的值。因此，在编写代码时要记住，<strong><code>=</code>号左侧的项必须是一个变量名</strong>。实际上，赋值运算符左侧必须引用一个存储位置。最简单的方法就是使用变量名。不过，后面章节还会介绍“<strong>指针</strong>”，可用于指向一个存储位置。概括地说，C 使用可修改的左值（modifiable lvalue）标记那些可赋值的实体。也许“可修改的左值”不太好懂，我们再来看一些定义。</p>\n<p>几个术语：<strong>数据对象</strong>、<strong>左值</strong>、<strong>右值</strong>和<strong>运算符</strong></p>\n<p>赋值表达式语句的目的是把值储存到内存位置上。用于储存值的数据存储区域统称为<strong>数据对象</strong>（data object）。C 标准只有在提到这个概念时才会用到对象这个术语。使用变量名是标识对象的一种方法。除此之外，还有其他方法，但是要在后面的章节中才学到。例如，可以指定<strong>数组的元素</strong>、<strong>结构的成员</strong>，或者使用<strong>指针表达式</strong>（指针中储存的是它所指向对象的地址）。左值（lvalue）是 C 语言的术语，用于标识特定数据对象的名称或表达式。因此，对象指的是实际的数据存储，而左值是用于标识或定位存储位置的标签。</p>\n<p>对于早期的C语言，提到左值意味着：</p>\n<p>1.它指定一个对象，所以引用内存中的地址；</p>\n<p>2.它可用在赋值运算符的左侧，左值（lvalue）中的l源自left。</p>\n<p>但是后来，标准中新增了<code>const</code>限定符。用<code>const</code>创建的变量不可修改。因此，<code>const</code>标识符满足上面的第1项，但是不满足第2项。一方面C继续把标识对象的表达式定义为左值，一方面某些左值却不能放在赋值运算符的左侧。有些左值不能用于赋值运算符的左侧。此时，标准对左值的定义已经不能满足当前的状况。</p>\n<p>为此，C标准新增了一个术语：可修改的左值（modifiable lvalue），用于标识可修改的对象。所以，赋值运算符的左侧应该是可修改的左值。当前标准建议，使用术语对象定位值（object locator value）更好。</p>\n<p>右值（rvalue）指的是能赋值给可修改左值的量，且本身不是左值。例如，考虑下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">bmw = <span class=\"number\">2002</span>;</span><br></pre></td></tr></table></figure><p>这里，<code>bmw</code>是可修改的<strong>左值</strong>，2002是右值。读者也许猜到了，右值中的r源自right。右值可以是常量、变量或其他可求值的表达式（如，函数调用）。实际上，当前标准在描述这一概念时使用的是表达式的值（value of an expression），而不是右值。</p>\n<p>我们看几个简单的示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>　ex;</span><br><span class=\"line\"><span class=\"keyword\">int</span>　why;</span><br><span class=\"line\"><span class=\"keyword\">int</span>　zee;</span><br><span class=\"line\"><span class=\"keyword\">const</span>　<span class=\"keyword\">int</span>　TWO　=　<span class=\"number\">2</span>;</span><br><span class=\"line\">why　=　<span class=\"number\">42</span>;</span><br><span class=\"line\">zee = why;</span><br><span class=\"line\">ex = TWO * (why + zee);</span><br></pre></td></tr></table></figure><p>这里，ex、why和zee都是可修改的左值（或对象定位值），它们可用于赋值运算符的左侧和右侧。<code>TWO</code>是不可改变的左值，它只能用于赋值运算符的右侧（在该例中，TWO被初始化为2，<strong>这里的=运算符表示初始化而不是赋值</strong>，因此并未违反规则）。同时，42 是右值，它不能引用某指定内存位置。另外，why和 zee 是可修改的左值，表达式<code>(why + zee)</code>是右值，该表达式不能表示特定内存位置，而且也不能给它赋值。它只是程序计算的一个临时值，在计算完毕后便会被丢弃。</p>\n<p>在学习名称时，被称为“项”（如，赋值运算符左侧的项）的就是运算对象（operand）。运算对象是运算符操作的对象。例如，可以把吃汉堡描述为：“吃”运算符操作“汉堡”运算对象。类似地可以说，=运算符的左侧运算对象应该是可修改的左值。</p>\n<p>C的基本赋值运算符有些与众不同，请看程序清单5.3。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.3</span> golf.c程序</span><br><span class=\"line\"><span class=\"comment\">/* golf.c -- 高尔夫锦标赛记分卡 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　jane,　tarzan,　cheeta;</span><br><span class=\"line\">    cheeta=tarzan=jane=<span class=\"number\">68</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"cheeta　　tarzan　　 jane\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"First　round　score　%4d　%8d　%8d\\n\"</span>,　cheeta,　tarzan,　jane);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>许多其他语言都会回避该程序中的三重赋值，但是C完全没问题。赋值的顺序是从右往左：首先把68赋给jane，然后再赋给tarzan，最后赋给cheeta。因此，程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cheetah　　tarzan　　　　jane</span><br><span class=\"line\">First　round　score　　<span class=\"number\">68</span>　　　　　　<span class=\"number\">68</span>　　　　　　<span class=\"number\">68</span></span><br></pre></td></tr></table></figure><h3 id=\"加法运算符：\">加法运算符：+<a href=\"#加法运算符：\" title=\"加法运算符：+\"></a></h3><p>加法运算符（addition operator）用于加法运算，使其两侧的值相加。例如，语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\"</span>, <span class=\"number\">4</span> + <span class=\"number\">20</span>);</span><br></pre></td></tr></table></figure><p>打印的是24，而不是表达式</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span> + <span class=\"number\">20</span></span><br></pre></td></tr></table></figure><p>相加的值（运算对象）可以是变量，也可以是常量。因此，执行下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">income = salary + bribes;</span><br></pre></td></tr></table></figure><p>计算机会查看加法运算符右侧的两个变量，把它们相加，然后把和赋给变量<code>income</code>。</p>\n<p>在此提醒读者注意，<code>income</code>、<code>salary</code>和<code>bribes</code>都是可修改的左值。因为每个变量都标识了一个可被赋值的数据对象。但是，表达式<code>salary + brives</code>是一个右值。</p>\n<h3 id=\"减法运算符：-\">减法运算符：-<a href=\"#减法运算符：-\" title=\"减法运算符：-\"></a></h3><p>减法运算符（subtraction operator）用于减法运算，使其左侧的数减去右侧的数。例如，下面的语句把200.0赋给takehome：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">takehome = <span class=\"number\">224.00</span> – <span class=\"number\">24.00</span>;</span><br></pre></td></tr></table></figure><p>+和-运算符都被称为二元运算符（binary operator），即这些运算符需要两个运算对象才能完成操作。</p>\n<h3 id=\"符号运算符：-和\">符号运算符：-和+<a href=\"#符号运算符：-和\" title=\"符号运算符：-和+\"></a></h3><p>减号还可用于标明或改变一个值的代数符号。例如，执行下面的语句后，<code>smokey</code>的值为12：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">rocky = –<span class=\"number\">12</span>;</span><br><span class=\"line\">smokey = –rocky;</span><br></pre></td></tr></table></figure><p>以这种方式使用的负号被称为<strong>一元运算符</strong>（unary operator）。一元运算符只需要一个运算对象（见图5.2）。</p>\n<img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/一元和二元运算符.png\" style=\"zoom:67%;\" /><p>C90标准新增了<strong>一元+</strong>运算符，它不会改变运算对象的值或符号，只能这样使用：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dozen &#x3D; +12;</span><br></pre></td></tr></table></figure><p>编译器不会报错。但是在以前，这样做是不允许的。</p>\n<h3 id=\"乘法运算符：\">乘法运算符：*<a href=\"#乘法运算符：\" title=\"乘法运算符：*\"></a></h3><p>符号<code>*</code>表示乘法。下面的语句用2.54乘以inch，并将结果赋给cm：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cm = <span class=\"number\">2.54</span> * inch;</span><br></pre></td></tr></table></figure><p>C没有平方函数，如果要打印一个平方表，怎么办？如程序清单5.4所示，可以使用乘法来计算平方。</p>\n<p>程序清单5.4 squares.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* squares.c -- 计算1～20的平方 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　num　=　<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>　(num　&lt;　<span class=\"number\">21</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4d %6d\\n\"</span>, num, num * num);</span><br><span class=\"line\">        num　=　num　+　<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序打印数字1～20及其平方。接下来，我们再看一个更有趣的例子。</p>\n<h4 id=\"指数增长\">指数增长<a href=\"#指数增长\" title=\"指数增长\"></a></h4><p>读者可能听过这样一个故事，一位强大的统治者想奖励做出突出贡献的学者。他问这位学者想要什么，学者指着棋盘说，在第1个方格里放1粒小麦、第2个方格里放2粒小麦、第3个方格里放4粒小麦，第4个方格里放 8 粒小麦，以此类推。这位统治者不熟悉数学，很惊讶学者竟然提出如此谦虚的要求。因为他原本准备奖励给学者一大笔财产。如果程序清单5.5运行的结果正确，这显然是跟统治者开了一个玩笑。程序计算出每个方格应放多少小麦，并计算了总数。可能大多数人对小麦的产量不熟悉，该程序以谷粒数为单位，把计算的小麦总数与粗略估计的世界小麦年产量进行了比较。</p>\n<p>程序清单5.5 wheat.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* wheat.c -- 指数增长 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SQUARES 64　　　　　　 <span class=\"comment\">// 棋盘中的方格数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">double</span> CROP = <span class=\"number\">2E16</span>;　<span class=\"comment\">// 世界小麦年产谷粒数</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> current,total;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"square　grains　total \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"fraction　of　\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　　added　　grains　　 \"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"world　total\\n\"</span>);</span><br><span class=\"line\">    total=current=<span class=\"number\">1.0</span>;　　 <span class=\"comment\">/* 从1颗谷粒开始　*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4d　%13.2e　%12.2e　%12.2e\\n\"</span>,count,　current,total,total/CROP);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(count&lt;SQUARES)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        count=count+<span class=\"number\">1</span>;</span><br><span class=\"line\">        current=<span class=\"number\">2.0</span>*current;　 <span class=\"comment\">/* 下一个方格谷粒翻倍 */</span></span><br><span class=\"line\">        total=total+current;　 <span class=\"comment\">/* 更新总数 */</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4d　%13.2e　%12.2e　%12.2e\\n\"</span>,count,　current,total,total/CROP);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"That's　all.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>程序的输出结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">square　　　　　　grains　　　　　 total　　　　　　 fraction　of</span><br><span class=\"line\"></span><br><span class=\"line\">added　　　　　　 grains　　　　　 world　total</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">1</span>　　　　　　　 <span class=\"number\">1.00e+00</span>　　　　<span class=\"number\">1.00e+00</span>　　　　<span class=\"number\">5.00e-17</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">2</span>　　　　　　　 <span class=\"number\">2.00e+00</span>　　　　<span class=\"number\">3.00e+00</span>　　　　<span class=\"number\">1.50e-16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">3</span>　　　　　　　 <span class=\"number\">4.00e+00</span>　　　　<span class=\"number\">7.00e+00</span>　　　　<span class=\"number\">3.50e-16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">4</span>　　　　　　　 <span class=\"number\">8.00e+00</span>　　　　<span class=\"number\">1.50e+01</span>　　　　<span class=\"number\">7.50e-16</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">5</span>　　　　　　　 <span class=\"number\">1.60e+01</span>　　　　<span class=\"number\">3.10e+01</span>　　　　<span class=\"number\">1.55e-15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">6</span>　　　　　　　 <span class=\"number\">3.20e+01</span>　　　　<span class=\"number\">6.30e+01</span>　　　　<span class=\"number\">3.15e-15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">7</span>　　　　　　　 <span class=\"number\">6.40e+01</span>　　　　<span class=\"number\">1.27e+02</span>　　　　<span class=\"number\">6.35e-15</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">8</span>　　　　　　　 <span class=\"number\">1.28e+02</span>　　　　<span class=\"number\">2.55e+02</span>　　　　<span class=\"number\">1.27e-14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">9</span>　　　　　　　 <span class=\"number\">2.56e+02</span>　　　　<span class=\"number\">5.11e+02</span>　　　　<span class=\"number\">2.55e-14</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"number\">10</span>　　　　　　　<span class=\"number\">5.12e+02</span>　　　　<span class=\"number\">1.02e+03</span>　　　　<span class=\"number\">5.12e-14</span></span><br></pre></td></tr></table></figure><p>10个方格以后，该学者得到的小麦仅超过了1000粒。但是，看看55个方格的小麦数是多少：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">55</span>　　　　　 <span class=\"number\">1.80e+16</span>　　　　<span class=\"number\">3.60e+16</span>　　　　<span class=\"number\">1.80e+00</span></span><br></pre></td></tr></table></figure><p>总量已超过了世界年产量！不妨自己动手运行该程序，看看第64个方格有多少小麦。</p>\n<p>这个程序示例演示了指数增长的现象。世界人口增长和我们使用的能源都遵循相同的模式。</p>\n<h3 id=\"除法运算符：\">除法运算符：/<a href=\"#除法运算符：\" title=\"除法运算符：/\"></a></h3><p>C使用符号<code>/</code>来表示除法。<code>/</code>左侧的值是被除数，右侧的值是除数。例如，下面four的值是4.0：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">four = <span class=\"number\">12.0</span>/<span class=\"number\">3.0</span>;</span><br></pre></td></tr></table></figure><p>整数除法和浮点数除法不同。浮点数除法的结果是浮点数，而整数除法的结果是整数。整数是没有小数部分的数。这使得5除以3很让人头痛，因为实际结果有小数部分。在C语言中，整数除法结果的小数部分被丢弃，这一过程被称为截断（truncation）。</p>\n<p>运行程序清单5.6中的程序，看看截断的情况，体会整数除法和浮点数除法的区别。</p>\n<p>程序清单5.6 divide.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* divide.c -- 演示除法 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"integer　division:　5/4　is　%d　\\n\"</span>,<span class=\"number\">5</span>/<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"integer　division:　6/3　is　%d　\\n\"</span>,<span class=\"number\">6</span>/<span class=\"number\">3</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"integer　division:　7/4　is　%d　\\n\"</span>,<span class=\"number\">7</span>/<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"floating　division:　7./4. is　%1.2f　\\n\"</span>,</span><br><span class=\"line\"><span class=\"number\">7.</span>/<span class=\"number\">4.</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"mixed　division:　7./4　is　%1.2f　\\n\"</span>,<span class=\"number\">7.</span>/<span class=\"number\">4</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>程序清单5.6中包含一个“混合类型”的示例，即浮点值除以整型值。C相对其他一些语言而言，在类型管理上比较宽容。尽管如此，一般情况下还是要避免使用混合类型。该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">integer　division:　 <span class=\"number\">5</span>/<span class=\"number\">4</span>　　 is　<span class=\"number\">1</span></span><br><span class=\"line\">integer　division:　 <span class=\"number\">6</span>/<span class=\"number\">3</span>　　 is　<span class=\"number\">2</span></span><br><span class=\"line\">integer　division:　 <span class=\"number\">7</span>/<span class=\"number\">4</span>　　 is　<span class=\"number\">1</span></span><br><span class=\"line\">floating　division:　<span class=\"number\">7.</span>/<span class=\"number\">4.</span>　is　<span class=\"number\">1.75</span></span><br><span class=\"line\">mixed　division:　　　<span class=\"number\">7.</span>/<span class=\"number\">4</span>　 is　<span class=\"number\">1.75</span></span><br></pre></td></tr></table></figure><p>注意，<strong>整数除法会截断计算结果的小数部分</strong>（丢弃整个小数部分），不会四舍五入结果。混合整数和浮点数计算的结果是浮点数。实际上，计算机不能真正用浮点数除以整数，编译器会把两个运算对象转换成相同的类型。本例中，在进行除法运算前，整数会被转换成浮点数。</p>\n<p>C99标准以前，C语言给语言的实现者留有一些空间，让他们来决定如何进行负数的整数除法。一种方法是，舍入过程采用小于或等于浮点数的最大整数。当然，对于3.8而言，处理后的3符合这一描述。但是-3.8 会怎样？该方法建议四舍五入为-4，因为-4 小于-3.8.但是，另一种舍入方法是直接丢弃小数部分。这种方法被称为“<strong>趋零截断</strong>”，即把-3.8转换成-3。在C99以前，不同的实现采用不同的方法。但是C99规定使用趋零截断。所以，应把-3.8转换成-3。</p>\n<h3 id=\"运算符优先级\">运算符优先级<a href=\"#运算符优先级\" title=\"运算符优先级\"></a></h3><p>考虑下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">butter=<span class=\"number\">25.0</span>+<span class=\"number\">60.0</span>*n/SCALE;</span><br></pre></td></tr></table></figure><p>这条语句中有加法、乘法和除法运算。先算哪一个？是25.0加上60.0，然后把计算的和85.0乘以n，再把结果除以SCALE？还是60.0乘以n，然后把计算的结果加上25.0，最后再把结果除以SCALE？还是其他运算顺序？假设n是6.0，SCALE是2.0，带入语句中计算会发现，第1种顺序得到的结果是255，第2种顺序得到的结果是192.5。C程序一定是采用了其他的运算顺序，因为程序运行该语句后，butter的值是205.0。</p>\n<p>显然，执行各种操作的顺序很重要。C 语言对此有明确的规定，通过运算符优先级来解决操作顺序的问题。每个运算符都有自己的优先级。正如普通的算术运算那样，乘法和除法的优先级比加法和减法高，所以先执行乘法和除法。如果两个运算符的优先级相同怎么办？如果它们处理同一个运算对象，则根据它们在语句中出现的顺序来执行。对大多数运算符而言，这种情况都是按从左到右的顺序进行（=运算符除外）。因此，语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">butter=<span class=\"number\">25.0</span>+<span class=\"number\">60.0</span>*n/SCALE;</span><br></pre></td></tr></table></figure><p>的运算顺序是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">60.0</span>*n　　　　　<span class=\"comment\">/*首先计算表达式中的*或/（假设n的值是6，所以60.0*n得360.0）*/</span></span><br><span class=\"line\"><span class=\"number\">360.0</span>/SCALE　　 <span class=\"comment\">/*然后计算表达式中第2个*或*/</span></span><br><span class=\"line\"><span class=\"number\">25.0</span>+<span class=\"number\">180</span>　　　　　<span class=\"comment\">/*最后计算表达式里第1个+或-，结果为205.0（假设SCALE的值是2.0）</span></span><br></pre></td></tr></table></figure><p>许多人喜欢用表达式树（expression tree）来表示求值的顺序，如图5.3所示。该图演示了如何从最初的表达式逐步简化为一个值。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/用表达式树演示运算符运算对象和求值顺序.png\" class=\"φcy\"></p>\n<p>如何让加法运算在乘法运算之前执行？可以这样做：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flour=(<span class=\"number\">25.0</span>+<span class=\"number\">60.0</span>*n)/SCALE;</span><br></pre></td></tr></table></figure><p>最先执行圆括号中的部分。圆括号内部按正常的规则执行。该例中，先执行乘法运算，再执行加法运算。执行完圆括号内的表达式后，用运算结果除以SCALE。</p>\n<p>表5.1总结了到目前为止学过的运算符优先级。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/5.1运算符优先级.png\" class=\"φcy\"></p>\n<p>注意正号（加号）和负号（减号）的两种不同用法。结合律栏列出了运算符如何与运算对象结合。例如，一元负号与它右侧的量相结合，在除法中用除号左侧的运算对象除以右侧的运算对象。</p>\n<h3 id=\"优先级和求值顺序\">优先级和求值顺序<a href=\"#优先级和求值顺序\" title=\"优先级和求值顺序\"></a></h3><p>运算符优先级为表达式中的求值顺序提供重要的依据，但是并没有规定所有的顺序。C 给语言的实现者留出选择的余地。考虑下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y=<span class=\"number\">6</span>*<span class=\"number\">12</span>+<span class=\"number\">5</span>*<span class=\"number\">20</span>;</span><br></pre></td></tr></table></figure><p>当运算符共享一个运算对象时，优先级决定了求值顺序。例如上面的语句中，12是<em>和+运算符的运算对象。根据运算符的优先级，乘法的优先级比加法高，所以先进行乘法运算。类似地，先对 5 进行乘法运算而不是加法运算。简而言之，先进行两个乘法运算6 * 12和5 * 20，再进行加法运算。但是，优先级并未规定到底先进行哪一个乘法。C 语言把主动权留给语言的实现者，根据不同的硬件来决定先计算前者还是后者。可能在一种硬件上采用某种方案效率更高，而在另一种硬件上采用另一种方案效率更高。无论采用哪种方案，表达式都会简化为 72 + 100，所以这并不影响最终的结果。但是，读者可能会根据乘法从左往右的结合律，认为应该先执行+运算符左边的乘法。结合律只适用于共享同一运算对象运算符。例如，在表达式12 / 3 * 2中，/和</em>运算符的优先级相同，共享运算对象3。因此，从左往右的结合律在这种情况起作用。表达式简化为4 * 2，即8（如果从右往左计算，会得到12/6，即2，这种情况下计算的先后顺序会影响最终的计算结果）。在该例中，两个*运算符并没有共享同一个运算对象，因此从左往右的结合律不适用于这种情况。</p>\n<p>学以致用</p>\n<p>接下来，我们在更复杂的示例中使用以上规则，请看程序清单5.7。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.7</span> rules.c程序</span><br><span class=\"line\"><span class=\"comment\">/* rules.c -- 优先级测试 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　top,　score;</span><br><span class=\"line\">    top = score = -(<span class=\"number\">2</span> + <span class=\"number\">5</span>) * <span class=\"number\">6</span> + (<span class=\"number\">4</span> + <span class=\"number\">3</span> * (<span class=\"number\">2</span> + <span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"top　=　%d,　score　=　%d\\n\"</span>,　top,　score);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序会打印什么值？先根据代码推测一下，再运行程序或阅读下面的分析来检查你的答案。</p>\n<p>首先，圆括号的优先级最高。先计算-(2 + 5) * 6中的圆括号部分，还是先计算(4 + 3 * (2 + 3))中的圆括号部分取决于具体的实现。圆括号的最高优先级意味着，在子表达式-(2 + 5) * 6中，先计算(2 + 5)的值，得7。然后，把一元负号应用在7上，得-7。现在，表达式是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top = score = <span class=\"number\">-7</span> * <span class=\"number\">6</span> + (<span class=\"number\">4</span> + <span class=\"number\">3</span> * (<span class=\"number\">2</span> + <span class=\"number\">3</span>))</span><br></pre></td></tr></table></figure><p>下一步，计算2 + 3的值。表达式变成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top = score = <span class=\"number\">-7</span> * <span class=\"number\">6</span> + (<span class=\"number\">4</span> + <span class=\"number\">3</span> * <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure><p>接下来，因为圆括号中的*比+优先级高，所以表达式变成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top = score = <span class=\"number\">-7</span> * <span class=\"number\">6</span> + (<span class=\"number\">4</span> + <span class=\"number\">15</span>)</span><br></pre></td></tr></table></figure><p>然后，表达式为：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top = score = <span class=\"number\">-7</span> * <span class=\"number\">6</span> + <span class=\"number\">19</span></span><br></pre></td></tr></table></figure><p>-7乘以6后，得到下面的表达式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top = score = <span class=\"number\">-42</span> + <span class=\"number\">19</span></span><br></pre></td></tr></table></figure><p>然后进行加法运算，得到：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">top = score = <span class=\"number\">-23</span></span><br></pre></td></tr></table></figure><p>现在，-23被赋值给score，最终top的值也是-23。记住，=运算符的结合律是从右往左。</p>\n<h2 id=\"其他运算符\">其他运算符<a href=\"#其他运算符\" title=\"其他运算符\"></a></h2><p>C语言有大约40个运算符，有些运算符比其他运算符常用得多。前面讨论的是最常用的，本节再介绍4个比较有用的运算符。</p>\n<h3 id=\"sizeof运算符和size_t类型\">sizeof运算符和size_t类型<a href=\"#sizeof运算符和size_t类型\" title=\"sizeof运算符和size_t类型\"></a></h3><p>读者在第3章就见过<code>sizeof</code>运算符。回顾一下，<code>sizeof</code>运算符以字节为单位返回运算对象的大小（在C中，1字节定义为<code>char</code>类型占用的空间大小。过去，1字节通常是8位，但是一些字符集可能使用更大的字节）。运算对象可以是具体的数据对象（如，变量名）或类型。如果运算对象是类型（如，<code>float</code>），则必须用圆括号将其括起来。程序清单5.8演示了这两种用法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.8</span> <span class=\"keyword\">sizeof</span>.c程序</span><br><span class=\"line\"><span class=\"comment\">// sizeof.c -- 使用sizeof运算符</span></span><br><span class=\"line\"><span class=\"comment\">// 使用C99新增的%zd转换说明 -- 如果编译器不支持%zd，请将其改成%u或%lu</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　n=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">size_t</span> intsize;</span><br><span class=\"line\">    intsize=<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"n=%d,　n　has　%zd　bytes;　all　ints　have　%zd　bytes.\\n\"</span>,</span><br><span class=\"line\">n,<span class=\"keyword\">sizeof</span>　n,intsize);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>C 语言规定，<code>sizeof</code> 返回 <code>size_t</code> 类型的值。这是一个无符号整数类型，但它不是新类型。前面介绍过，<code>size_t</code>是语言定义的标准类型。C有一个<code>typedef</code>机制（第14章再详细介绍），允许程序员为现有类型创建别名。例如，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">double</span> real;</span><br></pre></td></tr></table></figure><p>这样，real就是double的别名。现在，可以声明一个real类型的变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">real deal; <span class=\"comment\">// 使用typedef</span></span><br></pre></td></tr></table></figure><p>编译器查看<code>real</code>时会发现，在typedef声明中<code>real</code>已成为<code>double</code>的别名，于是把<code>dea</code>l创建为<code>double</code> 类型的变量。类似地，<mark>C 头文件系统可以使用 <code>typedef</code> 把 <code>size_t</code> 作为 <code>unsigned int</code> 或<code>unsigned long</code>的别名</mark>。这样，在使用<code>size_t</code>类型时，编译器会根据不同的系统替换标准类型。</p>\n<p>C99 做了进一步调整，新增了<code>%zd</code> 转换说明用于 <code>printf()</code>显示 <code>size_t</code> 类型的值。如果系统不支持<code>%zd</code>，可使用<code>%u</code>或<code>%lu</code>代替<code>%zd</code>。</p>\n<h3 id=\"求模运算符：\">求模运算符：%<a href=\"#求模运算符：\" title=\"求模运算符：%\"></a></h3><p>求模运算符（modulus operator）用于整数运算。求模运算符给出其左侧整数除以右侧整数的余数（remainder）。例如，13 % 5（读作“13求模5”）得3，因为13比5的两倍多3，即13除以5的余数是3。求模运算符只能用于整数，不能用于浮点数。</p>\n<p>乍一看会认为求模运算符像是数学家使用的深奥符号，但是实际上它非常有用。求模运算符常用于控制程序流。例如，假设你正在设计一个账单预算程序，每 3 个月要加进一笔额外的费用。这种情况可以在程序中对月份求模3（即，month % 3），并检查结果是否为0。如果为0，便加进额外的费用。等学到第7章的if语句后，读者会更明白。</p>\n<p>程序清单5.9演示了<code>%</code>运算符的另一种用途。同时，该程序也演示了<code>while</code>循环的另一种用法。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.9</span> min_sec.c程序</span><br><span class=\"line\"><span class=\"comment\">// min_sec.c -- 把秒数转换成分和秒</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> SEC_PER_MIN 60　　　　　 <span class=\"comment\">// 1分钟60秒</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> sec,<span class=\"built_in\">min</span>,left;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Convert　seconds　to　minutes　and　seconds!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　the　number　of　seconds　(&lt;=0　to　quit):\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;sec);　　　　　 <span class=\"comment\">// 读取秒数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(sec&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">min</span>=sec/SEC_PER_MIN;　　<span class=\"comment\">// 截断分钟数</span></span><br><span class=\"line\">        left=sec%SEC_PER_MIN;　 <span class=\"comment\">// 剩下的秒数</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d　seconds　is　%d　minutes,　%d　seconds.\\n\"</span>,sec,</span><br><span class=\"line\">        <span class=\"built_in\">min</span>,left);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　next　value　(&lt;=0　to　quit):\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;sec);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Done!\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/程序清单5.9.png\" class=\"φcy\"></p>\n<p>程序清单5.2使用一个计数器来控制<code>while</code>循环。当计数器超出给定的大小时，循环终止。而程序清单5.9则通过<code>scanf()</code>为变量<code>sec</code>获取一个新值。只要该值为正，循环就继续。当用户输入一个0或负值时，循环退出。这两种情况设计的要点是，每次循环都会修改被测试的变量值。</p>\n<p>负数求模如何进行？C99规定“<strong>趋零截断</strong>”之前，该问题的处理方法很多。但自从有了这条规则之后，如果第1个运算对象是负数，那么求模的结果为负数；如果第1个运算对象是正数，那么求模的结果也是正数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">11</span>/<span class=\"number\">5</span>\t得<span class=\"number\">2</span>，\t\t<span class=\"number\">11</span> % <span class=\"number\">5</span>\t\t得<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">11</span>/<span class=\"number\">-5</span>\t得<span class=\"number\">-2</span>，\t<span class=\"number\">11</span> % <span class=\"number\">-2</span>\t\t得<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">-11</span>/<span class=\"number\">-5</span>\t得<span class=\"number\">2</span>，\t\t<span class=\"number\">-11</span> % <span class=\"number\">-5</span>\t得<span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">-11</span>/<span class=\"number\">5</span>\t得<span class=\"number\">-2</span>，\t<span class=\"number\">-11</span> % <span class=\"number\">5</span>\t\t得<span class=\"number\">-1</span></span><br></pre></td></tr></table></figure><p>如果当前系统不支持C99标准，会显示不同的结果。实际上，标准规定：无论何种情况，只要a和b都是整数值，便可通过a - (a/b)*b来计算a%b。例如，可以这样计算-11%5：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">-11</span>-(<span class=\"number\">-11</span>/<span class=\"number\">5</span>)*<span class=\"number\">5</span>=<span class=\"number\">-11</span>-(<span class=\"number\">-2</span>)*<span class=\"number\">5</span>=<span class=\"number\">-11</span>-(<span class=\"number\">-10</span>)=<span class=\"number\">-1</span></span><br></pre></td></tr></table></figure><h3 id=\"递增运算符：\">递增运算符：++<a href=\"#递增运算符：\" title=\"递增运算符：++\"></a></h3><p>递增运算符（increment operator）执行简单的任务，将其运算对象递增1。该运算符以两种方式出现。第1种方式，<code>++</code>出现在其作用的变量前面，这是前缀模式；第2种方式，<code>++</code>出现在其作用的变量后面，这是后缀模式。两种模式的区别在于递增行为发生的时间不同。我们先解释它们的相似之处，再分析它们不同之处。程序清单5.10中的程序示例演示了递增运算符是如何工作的。</p>\n<p>程序清单5.10 add_one.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* add_one.c -- 递增：前缀和后缀 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> ultra=<span class=\"number\">0</span>,super=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(super&lt;<span class=\"number\">5</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        super++;</span><br><span class=\"line\">        ++ultra;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"super=%d,ultra=%d\\n\"</span>,super,ultra);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序后，其输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">super　=　<span class=\"number\">1</span>,　ultra　=　<span class=\"number\">1</span></span><br><span class=\"line\">super　=　<span class=\"number\">2</span>,　ultra　=　<span class=\"number\">2</span></span><br><span class=\"line\">super　=　<span class=\"number\">3</span>,　ultra　=　<span class=\"number\">3</span></span><br><span class=\"line\">super　=　<span class=\"number\">4</span>,　ultra　=　<span class=\"number\">4</span></span><br><span class=\"line\">super　=　<span class=\"number\">5</span>,　ultra　=　<span class=\"number\">5</span></span><br></pre></td></tr></table></figure><p>该程序两次同时计数到5。用下面两条语句分别代替程序中的两条递增语句，程序的输出相同：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">super　=　super　+　<span class=\"number\">1</span>;</span><br><span class=\"line\">ultra　=　ultra　+　<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure><p>这些都是很简单的语句，为何还要创建两个缩写形式？原因之一是，紧凑结构的代码让程序更为简洁，可读性更高。这些运算符让程序看起来很美观。例如，可重写程序清单5.2（shoes2.c）中的一部分代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe=<span class=\"number\">3.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(shoe&lt;<span class=\"number\">18.5</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    foot=SCALE*<span class=\"built_in\">size</span>+ADJUST;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%10.1f　%20.2f　inches\\n\"</span>,shoe,foot);</span><br><span class=\"line\">    ++shoe;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>但是，这样做也没有充分利用递增运算符的优势。还可以这样缩短这段程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe　=　<span class=\"number\">2.0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>　(++shoe&lt;<span class=\"number\">18.5</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    foot = SCALE*shoe + ADJUST;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%10.1f　%20.2f　inches\\n\"</span>,　shoe,　foot);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示，把变量的递增过程放入<code>while</code>循环的条件中。这种结构在C语言中很普遍，我们来仔细分析一下。</p>\n<p>首先，这样的<code>while</code>循环是如何工作的？很简单。<code>shoe</code>的值递增1，然后和18.5作比较。如果递增后的值小于18.5，则执行花括号内的语句一次。然后，shoe的值再递增1，重复刚才的步骤，直到shoe的值不小于18.5为止。注意，我们把shoe的初始值从3.0改为2.0，因为在对foot第1次求值之前， shoe已经递增了1（见图5.4）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/执行一次循环.png\" class=\"φcy\"></p>\n<p>其次，这样做有什么好处？它使得程序更加简洁。更重要的是，它把控制循环的两个过程集中在一个地方。该循环的主要过程是判断是否继续循环（本例中，要检查鞋子的尺码是否小于 18.5），次要过程是改变待测试的元素（本例中是递增鞋子的尺码）。</p>\n<p>如果忘记改变鞋子的尺码，shoe的值会一直小于18.5，循环不会停止。计算机将陷入无限循环（infinite loop）中，生成无数相同的行。最后，只能强行关闭这个程序。把循环测试和更新循环放在一处，就不会忘记更新循环。</p>\n<p>但是，把两个操作合并在一个表达式中，降低了代码的可读性，让代码难以理解。而且，还容易产生计数错误。</p>\n<p>递增运算符的另一个优点是，通常它生成的机器语言代码效率更高，因为它和实际的机器语言指令很相似。尽管如此，随着商家推出的C编译器越来越智能，这一优势可能会消失。一个智能的编译器可以把x = x + 1当作++x对待。</p>\n<p>最后，递增运算符还有一个在某些场合特别有用的特性。我们通过程序清单5.11来说明。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.11</span> post_pre.c程序</span><br><span class=\"line\"><span class=\"comment\">/* post_pre.c -- 前缀和后缀 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a=<span class=\"number\">1</span>,b=<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> a_post,　pre_b;</span><br><span class=\"line\">    a_post=a++;　<span class=\"comment\">// 后缀递增</span></span><br><span class=\"line\">    pre_b=++b;　 <span class=\"comment\">// 前缀递增</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"a　 a_post　　b　　pre_b　\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%1d　%5d　%5d　%5d\\n\"</span>,　a,　a_post,　b,　pre_b);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如果你的编译器没问题，那么程序的输出应该是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a\ta_post\tb\t\tpre_b</span><br><span class=\"line\"><span class=\"number\">2</span>\t<span class=\"number\">1</span>\t\t<span class=\"number\">2</span>　　　　<span class=\"number\">2</span></span><br></pre></td></tr></table></figure><p>a和b都递增了1，但是，<code>a_post</code>是a递增之前的值，而<code>b_pre</code>是b递增之后的值。这就是<code>++</code>的前缀形式和后缀形式的区别（见图5.5）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/前缀和后缀.png\" class=\"φcy\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a_post = a++;　　　<span class=\"comment\">// 后缀：使用a的值乊后，递增a</span></span><br><span class=\"line\">b_pre= ++b;　　　　<span class=\"comment\">// 前缀：使用b的值乊前，递增b</span></span><br></pre></td></tr></table></figure><p>单独使用递增运算符时（如，ego++;），使用哪种形式都没关系。但是，当运算符和运算对象是更复杂表达式的一部分时（如上面的示例），使用前缀或后缀的效果不同。例如，我们曾经建议用下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (++shoe &lt; <span class=\"number\">18.5</span>)</span><br></pre></td></tr></table></figure><p>该测试条件相当于提供了一个鞋子尺码到18的表。如果使用<code>shoe++</code>而不是<code>++shoes</code>，尺码表会增至19。因为shoe会在与18.5进行比较之后才递增，而不是先递增再比较。</p>\n<p>当然，使用下面这种形式也没错：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">shoe = shoe + <span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure><p>只不过，有人会怀疑你是否是真正的C程序员。</p>\n<p>在学习本书的过程中，应多留意使用递增运算符的例子。自己思考是否能互换使用前缀和后缀形式，或者当前环境是否只能使用某种形式。</p>\n<p>如果使用前缀形式和后缀形式会对代码产生不同的影响，那么最为明智的是不要那样使用它们。例如，不要使用下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">b=++i; <span class=\"comment\">// 如果使用i++，会得到不同的结果</span></span><br><span class=\"line\">应该使用下列语句：</span><br><span class=\"line\">++i;　　　<span class=\"comment\">// 第1行</span></span><br><span class=\"line\">b=i; <span class=\"comment\">// 如果第1行使用的是i++，幵不会影响b的值</span></span><br></pre></td></tr></table></figure><p>尽管如此，有时小心翼翼地使用会更有意思。所以，本书会根据实际情况，采用不同的写法。</p>\n<h3 id=\"递减运算符：\">递减运算符：–<a href=\"#递减运算符：\" title=\"递减运算符：–\"></a></h3><p>每种形式的递增运算符都有一个递减运算符（decrement operator）与之对应，用–代替++即可：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">--count; <span class=\"comment\">// 前缀形式的递减运算符</span></span><br><span class=\"line\">count--; <span class=\"comment\">// 后缀形式的递减运算符</span></span><br></pre></td></tr></table></figure><p>程序清单5.12演示了计算机可以是位出色的填词家。</p>\n<p>程序清单5.12 bottles.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MAX　100</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　count　=　MAX　+　<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(--count&gt;<span class=\"number\">0</span>)　</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d　bottles　of　spring　water　on　the　wall,\"</span></span><br><span class=\"line\"><span class=\"string\">\"%d　bottles　of　spring　water!\\n\"</span>,　count,　count);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Take　one　down　and　pass　it　around,\\n\"</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d　bottles　of　spring　water!\\n\\n\"</span>,　count　-　<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下（篇幅有限，省略了中间大部分输出）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">100</span>　bottles　of　spring　water　on　the　wall,　<span class=\"number\">100</span>　bottles　of　spring　water!</span><br><span class=\"line\">Take　one　down　<span class=\"keyword\">and</span>　pass　it　around,</span><br><span class=\"line\"><span class=\"number\">99</span>　bottles　of　spring　water!</span><br><span class=\"line\"><span class=\"number\">99</span>　bottles　of　spring　water　on　the　wall,　<span class=\"number\">99</span>　bottles　of　spring　water!</span><br><span class=\"line\">Take　one　down　<span class=\"keyword\">and</span>　pass　it　around,</span><br><span class=\"line\"><span class=\"number\">98</span>　bottles　of　spring　water!</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"number\">1</span> bottles of spring water on the wall, <span class=\"number\">1</span> bottles of spring water!</span><br><span class=\"line\">Take one down <span class=\"keyword\">and</span> pass it around,</span><br><span class=\"line\"><span class=\"number\">0</span> bottles of spring water!</span><br></pre></td></tr></table></figure><p>显然，这位填词家在复数的表达上有点问题。在学完第7章中的条件运算符后，可以解决这个问题。</p>\n<p>顺带一提，<code>&gt;</code>运算符表示“大于”，<code>&lt;</code>运算符表示“小于”，它们都是关系运算符（relational operator）。我们将在第6章中详细介绍关系运算符。</p>\n<h3 id=\"优先级\">优先级<a href=\"#优先级\" title=\"优先级\"></a></h3><p>递增运算符和递减运算符都有很高的结合优先级，只有圆括号的优先级比它们高。因此，<code>x*y++</code>表示的是<code>(x)*(y++)</code>，而不是<code>(x*y)++</code>。不过后者无效，因为递增和递减运算符只能影响一个变量（或者，更普遍地说，只能影响一个可修改的左值），而组合x*y本身不是可修改的左值。</p>\n<p>不要混淆这两个运算符的优先级和它们的求值顺序。假设有如下语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y=<span class=\"number\">2</span>;</span><br><span class=\"line\">n=<span class=\"number\">3</span>;</span><br><span class=\"line\">nextnum=(y+n++)*<span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure><p><code>nextnum</code>的值是多少？把<code>y</code>和<code>n</code>的值带入上面的第3条语句得：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nextnum = (<span class=\"number\">2</span> + <span class=\"number\">3</span>)*<span class=\"number\">6</span> = <span class=\"number\">5</span>*<span class=\"number\">6</span> = <span class=\"number\">30</span></span><br></pre></td></tr></table></figure><p><code>n</code>的值只有在被使用之后才会递增为4。根据优先级的规定，<code>++</code>只作用于n，不作用与<code>y + n</code>。除此之外，根据优先级可以判断何时使用n的值对表达式求值，而递增运算符的性质决定了何时递增n的值。</p>\n<p>如果<code>n++</code>是表达式的一部分，可将其视为“先使用n，再递增”；而<code>++n</code>则表示“先递增n，再使用”。</p>\n<h3 id=\"不要自作聪明\">不要自作聪明<a href=\"#不要自作聪明\" title=\"不要自作聪明\"></a></h3><p>如果一次用太多递增运算符，自己都会糊涂。例如，利用递增运算符改进 squares.c 程序（程序清单5.4），用下面的<code>while</code>循环替换原程序中的<code>while</code>循环：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>　(num&lt;<span class=\"number\">21</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%10d %10d\\n\"</span>, num, num*num++);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个想法看上去不错。打印<code>num</code>，然后计算<code>num*num</code>得到平方值，最后把<code>num</code>递增1。但事实上，修改后的程序只能在某些系统上能正常运行。该程序的问题是：当 <code>printf()</code>获取待打印的值时，可能先对最后一个参数（ ）求值，这样在获取其他参数的值之前就递增了<code>num</code>。所以，本应打印：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">5</span>　　　　　　 <span class=\"number\">25</span></span><br></pre></td></tr></table></figure><p>却打印成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6</span>　　　　　　 <span class=\"number\">25</span></span><br></pre></td></tr></table></figure><p>它甚至可能从右往左执行，对最右边的<code>num</code>（++作用的num）使用5，对第2个num和最左边的num使用6，结果打印出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">6</span>　　　　　　 <span class=\"number\">30</span></span><br></pre></td></tr></table></figure><p>在C语言中，编译器可以自行选择先对函数中的哪个参数求值。这样做提高了编译器的效率，但是如果在函数的参数中使用了递增运算符，就会有一些问题。</p>\n<p>类似这样的语句，也会导致一些麻烦：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ans = num/<span class=\"number\">2</span> + <span class=\"number\">5</span>*(<span class=\"number\">1</span> + num++);</span><br></pre></td></tr></table></figure><p>同样，该语句的问题是：编译器可能不会按预想的顺序来执行。你可能认为，先计算第1项（<code>num/2</code>），接着计算第2项（<code>5*(1 + num++)</code>）。但是，编译器可能先计算第2项，递增<code>num</code>，然后在<code>num/2</code>中使用<code>num</code>递增后的新值。因此，无法保证编译器到底先计算哪一项。</p>\n<p>还有一种情况，也不确定：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n=<span class=\"number\">3</span>;</span><br><span class=\"line\">y=n++ + n++;</span><br></pre></td></tr></table></figure><p>可以肯定的是，执行完这两条语句后，<code>n</code>的值会比旧值大2。但是，<code>y</code>的值不确定。在对<code>y</code>求值时，编译器可以使用n的旧值（3）两次，然后把n递增1两次，这使得y的值为6，n的值为5。或者，编译器使用n的旧值（3）一次，立即递增n，再对表达式中的第2个n使用递增后的新值，然后再递增n，这使得 y 的值为 7，n 的值为 5。两种方案都可行。对于这种情况更精确地说，结果是未定义的，这意味着 C标准并未定义结果应该是什么。</p>\n<p>遵循以下规则，很容易避免类似的问题：</p>\n<p>如果一个变量出现在一个函数的多个参数中，不要对该变量使用递增或递减运算符；</p>\n<p>如果一个变量多次出现在一个表达式中，不要对该变量使用递增或递减运算符。</p>\n<p>另一方面，对于何时执行递增，C 还是做了一些保证。我们在本章后面的“副作用和序列点”中学到序列点时再来讨论这部分内容。</p>\n<h2 id=\"表达式和语句\">表达式和语句<a href=\"#表达式和语句\" title=\"表达式和语句\"></a></h2><p>在前几章中，我们已经多次使用了术语表达式（expression）和语句（statement）。现在，我们来进一步学习它们。C的基本程序步骤由语句组成，而大多数语句都由表达式构成。因此，我们先学习表达式。</p>\n<h3 id=\"表达式\">表达式<a href=\"#表达式\" title=\"表达式\"></a></h3><p>表达式（expression）由运算符和运算对象组成（前面介绍过，运算对象是运算符操作的对象）。最简单的表达式是一个单独的运算对象，以此为基础可以建立复杂的表达式。下面是一些表达式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\"><span class=\"number\">-6</span></span><br><span class=\"line\"><span class=\"number\">4</span>+<span class=\"number\">21</span></span><br><span class=\"line\">a*(b+c/d)/<span class=\"number\">20</span></span><br><span class=\"line\">q=<span class=\"number\">5</span>*<span class=\"number\">2</span></span><br><span class=\"line\">x=++q%<span class=\"number\">3</span></span><br><span class=\"line\">q&gt;<span class=\"number\">3</span></span><br></pre></td></tr></table></figure><p>如你所见，运算对象可以是常量、变量或二者的组合。一些表达式由子表达式（subexpression）组成（子表达式即较小的表达式）。例如，c/d是上面例子中<code>a*(b + c/d)/20</code>的子表达式。</p>\n<p>每个表达式都有一个值</p>\n<p>C 表达式的一个最重要的特性是，每个表达式都有一个值。要获得这个值，必须根据运算符优先级规定的顺序来执行操作。在上面我们列出的表达式中，前几个都很清晰明了。但是，有赋值运算符（=）的表达式的值是什么？这些表达式的值与赋值运算符左侧变量的值相同。因此，表达式<code>q = 5*2</code>作为一个整体的值是10。那么，表达式<code>q &gt; 3</code>的值是多少？这种关系表达式的值不是0就是1，如果条件为真，表达式的值为1；如果条件为假，表达式的值为0。表5.2列出了一些表达式及其值：</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/一些表达式及其值.png\" class=\"φcy\"></p>\n<p>虽然最后一个表达式看上去很奇怪，但是在C中完全合法（但不建议使用），因为它是两个子表达式的和，每个子表达式都有一个值。</p>\n<h3 id=\"语句\">语句<a href=\"#语句\" title=\"语句\"></a></h3><p>语句（statement）是C程序的基本构建块。一条语句相当于一条完整的计算机指令。在C中，大部分语句都以分号结尾。因此，</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legs = <span class=\"number\">4</span></span><br></pre></td></tr></table></figure><p>只是一个表达式（它可能是一个较大表达式的一部分），而下面的代码则是一条语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">legs = <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure><p>最简单的语句是空语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">;　　 <span class=\"comment\">//空语句</span></span><br></pre></td></tr></table></figure><p>C把末尾加上一个分号的表达式都看作是一条语句（即，表达式语句）。因此，像下面这样写也没问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"number\">3</span> + <span class=\"number\">4</span>;</span><br></pre></td></tr></table></figure><p>但是，这些语句在程序中什么也不做，不算是真正有用的语句。更确切地说，语句可以改变值或调用函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">25</span>;</span><br><span class=\"line\">++x;</span><br><span class=\"line\">y = <span class=\"built_in\">sqrt</span>(x);</span><br></pre></td></tr></table></figure><p>虽然一条语句（或者至少是一条有用的语句）相当于一条完整的指令，但并不是所有的指令都是语句。考虑下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">6</span> + (y = <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure><p>该语句中的子表达式y = 5是一条完整的指令，但是它只是语句的一部分。因为一条完整的指令不一定是一条语句，所以分号用于识别在这种情况下的语句（即，简单语句）。</p>\n<p>到目前为止，读者已经见过多种语句（不包括空语句）。程序清单5.13演示了一些常见的语句。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">5.13</span> addemup.c程序</span><br><span class=\"line\"><span class=\"comment\">/* addemup.c -- 几种常见的语句 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>　　　　　　　　 <span class=\"comment\">/* 计算前20个整数的和　 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count, sum;　　　　　<span class=\"comment\">/* 声明[[1\\]](part0010.xhtml#annot17)　　　　　　 */</span></span><br><span class=\"line\">    count = <span class=\"number\">0</span>;　　　　　　　　 <span class=\"comment\">/* 表达式语句　　　　　 */</span></span><br><span class=\"line\">    sum = <span class=\"number\">0</span>;　　　　　　　　　 <span class=\"comment\">/* 表达式语句　　　　　 */</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (count++ &lt; <span class=\"number\">20</span>)　　　 <span class=\"comment\">/* 迭代语句　　　　　　*/</span></span><br><span class=\"line\">    sum　=　sum　+　count;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"sum = %d\\n\"</span>, sum); <span class=\"comment\">/* 表达式语句[[2\\]](part0010.xhtml#annot18)　　　 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;　　　　　　　<span class=\"comment\">/* 跳转语句　　　　　　　　 */</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面我们讨论程序清单 5.13。到目前为止，相信读者已经很熟悉声明了。尽管如此，我们还是要提醒读者：声明创建了名称和类型，并为其分配内存位置。注意，声明不是表达式语句。也就是说，如果删除声明后面的分号，剩下的部分不是一个<strong>表达式</strong>，也没有值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> port <span class=\"comment\">/* 不是表达式，没有值 */</span></span><br></pre></td></tr></table></figure><p>赋值表达式语句在程序中很常用：它为变量分配一个值。赋值表达式语句的结构是，一个变量名，后面是一个赋值运算符，再跟着一个表达式，最后以分号结尾。注意，在<code>while</code>循环中有一个赋值表达式语句。赋值表达式语句是表达式语句的一个示例。</p>\n<p>函数表达式语句会引起函数调用。在该例中，调用<code>printf()</code>函数打印结果。<code>while</code>语句有3个不同的部分（见图5.6）。首先是关键字<code>while</code>；然后，圆括号中是待测试的条件；最后如果测试条件为真，则执行<code>while</code>循环体中的语句。该例的<code>while</code>循环中只有一条语句。可以是本例那样的一条语句，不需要用花括号括起来，也可以像其他例子中那样包含多条语句。多条语句需要用花括号括起来。这种语句是复合语句，稍后马上介绍。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/简单的while循环结构.png\" class=\"φcy\"></p>\n<p><code>while</code>语句是一种迭代语句，有时也被称为结构化语句，因为它的结构比简单的赋值表达式语句复杂。在后面的章节里，我们会遇到许多这样的语句。</p>\n<p>副作用和序列点</p>\n<p>我们再讨论一个C语言的术语副作用（side effect）。副作用是对数据对象或文件的修改。例如，语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">states = <span class=\"number\">50</span>;</span><br></pre></td></tr></table></figure><p>它的副作用是将变量的值设置为50。副作用？这似乎更像是主要目的！但是从C语言的角度看，主要目的是对表达式求值。给出表达式4 + 6，C会对其求值得10；给出表达式<code>states = 50</code>，C会对其求值得50。对该表达式求值的副作用是把变量states的值改为50。跟赋值运算符一样，递增和递减运算符也有副作用，使用它们的主要目的就是使用其副作用。</p>\n<p>类似地，调用 printf()函数时，它显示的信息其实是副作用（printf()的返回值是待显示字符的个数）。</p>\n<p>序列点（sequence point）是程序执行的点，在该点上，所有的副作用都在进入下一步之前发生。在 C语言中，语句中的分号标记了一个序列点。意思是，在一个语句中，赋值运算符、递增运算符和递减运算符对运算对象做的改变必须在程序执行下一条语句之前完成。后面我们要讨论的一些运算符也有序列点。另外，任何一个完整表达式的结束也是一个序列点。</p>\n<p>什么是完整表达式？所谓完整表达式（full expression），就是指这个表达式不是另一个更大表达式的子表达式。例如，表达式语句中的表达式和while循环中的作为测试条件的表达式，都是完整表达式。</p>\n<p>序列点有助于分析后缀递增何时发生。例如，考虑下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(guests++&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d　\\n\"</span>,guests);</span><br></pre></td></tr></table></figure><p>对于该例，C语言的初学者认为“先使用值，再递增它”的意思是，在printf()语句中先使用guests，再递增它。但是，表达式guests++ &lt; 10是一个完整的表达式，因为它是while循环的测试条件，所以该表达式的结束就是一个序列点。因此，<strong>C 保证了在程序转至执行 printf()之前发生副作用（即，递增guests）</strong>。<strong>同时，使用后缀形式保证了guests在完成与10的比较后才进行递增。</strong></p>\n<p>现在，考虑下面这条语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">y=(<span class=\"number\">4</span>+x++)+(<span class=\"number\">6</span>+x++);</span><br></pre></td></tr></table></figure><p>表达式<code>4+x++</code>不是一个完整的表达式，所以C无法保证<code>x</code>在子表达式<code>4+x++</code>求值后立即递增<code>x</code>。这里，完整表达式是整个赋值表达式语句，分号标记了序列点。所以，C 保证程序在执行下一条语句之前递增x两次。C并未指明是在对子表达式求值以后递增x，还是对所有表达式求值后再递增x。因此，要尽量避免编写类似的语句。</p>\n<h3 id=\"复合语句（块）\">复合语句（块）<a href=\"#复合语句（块）\" title=\"复合语句（块）\"></a></h3><p>复合语句（compound statement）是用花括号括起来的一条或多条语句，复合语句也称为块（block）。shoes2.c程序使用块让<code>while</code>语句包含多条语句。比较下面两个程序段：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 程序段 1 */</span></span><br><span class=\"line\">index　=　<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(index++&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">sam = <span class=\"number\">10</span> * index + <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"sam　=　%d\\n\"</span>,　sam);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/* 程序段 2 */</span></span><br><span class=\"line\">index　=　<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(index++&lt;<span class=\"number\">10</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    sam = <span class=\"number\">10</span> * index + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"sam　=　%d\\n\"</span>,　sam);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>程序段1，<code>while</code>循环中只有一条赋值表达式语句。没有花括号，<code>while</code>语句从<code>while</code>这行运行至下一个分号。循环结束后，<code>printf()</code>函数只会被调用一次。</p>\n<p>程序段2，花括号确保两条语句都是<code>while</code>循环的一部分，每执行一次循环就调用一次<code>printf()</code>函数。根据<code>while</code>语句的结构，整个复合语句被视为一条语句（见图5.7）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/带复合语句的while循环.png\" class=\"φcy\"></p>\n<p>提示 风格提示</p>\n<p>再看一下前面的两个<code>while</code>程序段，注意循环体中的缩进。缩进对编译器不起作用，编译器通过花括号和<code>while</code>循环的结构来识别和解释指令。这里，缩进是为了让读者一眼就可以看出程序是如何组织的。</p>\n<p>程序段2中，块或复合语句放置花括号的位置是一种常见的风格。另一种常用的风格是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(index++&lt;<span class=\"number\">10</span>)&#123;</span><br><span class=\"line\">    sam = <span class=\"number\">10</span>*index + <span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"sam　=　%d　\\n\"</span>,　sam);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这种风格突出了块附属于<code>while</code>循环，而前一种风格则强调语句形成一个块。对编译器而言，这两种风格完全相同。</p>\n<p>总而言之，使用缩进可以为读者指明程序的结构。</p>\n<p>总结 表达式和语句</p>\n<p><strong>表达式</strong>：</p>\n<p>表达式由运算符和运算对象组成。最简单的表达式是不带运算符的一个常量或变量（如，22 或beebop）。更复杂的例子是5<code>5 + 22</code>和<code>vap = 2 * (vip + (vup = 4))</code>。</p>\n<p><strong>语句：</strong></p>\n<p>到目前为止，读者接触到的语句可分为简单语句和复合语句。简单语句以一个分号结尾。如下所示：</p>\n<p>赋值表达式语句:　　　<code>toes = 12;</code></p>\n<p>函数表达式语句:　　　<code>printf(&quot;%d\\n&quot;, toes);</code></p>\n<p>空语句:　　　　　</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">　;　 <span class=\"comment\">/* 什么也不做 */</span></span><br></pre></td></tr></table></figure><p>复合语句（或块）由花括号括起来的一条或多条语句组成。如下面的while语句所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>(years&lt;<span class=\"number\">100</span>)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    wisdom=wisdom * <span class=\"number\">1.05</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d　%d\\n\"</span>,　years,　wisdom);</span><br><span class=\"line\">    years=　years　+　<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"类型转换\">类型转换<a href=\"#类型转换\" title=\"类型转换\"></a></h2><p>通常，在语句和表达式中应使用类型相同的变量和常量。但是，如果使用混合类型，C 不会像 Pascal那样停在那里死掉，而是采用一套规则进行自动类型转换。虽然这很便利，但是有一定的危险性，尤其是在无意间混合使用类型的情况下（许多UNIX系统都使用<code>lint</code>程序检查类型“冲突”。如果选择更高错误级别，许多非UNIX C编译器也可能报告类型问题）。最好先了解一些基本的类型转换规则。</p>\n<p>1.当类型转换出现在表达式时，无论是<code>unsigned</code>还是<code>signed</code>的<code>char</code>和<code>short</code>都会被自动转换成<code>int</code>，如有必要会被转换成<code>unsigned int</code>（如果<code>short</code>与<code>int</code>的大小相同，<code>unsigned short</code>就比<code>int</code>大。这种情况下，<code>unsigned short</code>会被转换成<code>unsigned int</code>）。在K&amp;R那时的C中，<code>float</code>会被自动转换成<code>double</code>（目前的C不是这样）。由于都是从较小类型转换为较大类型，所以这些转换被称为<strong>升级</strong>（promotion）。</p>\n<p>2.涉及两种类型的运算，两个值会被分别转换成两种类型的更高级别。</p>\n<p>3.类型的级别从高至低依次是<code>long double</code>、<code>double</code>、<code>float</code>、<code>unsignedlong long</code>、<code>long long</code>、<code>unsigned long</code>、<code>long</code>、<code>unsigned int</code>、<code>int</code>。例外的情况是，当 <code>long</code> 和 <code>int</code> 的大小相同时，<code>unsigned int</code>比<code>long</code>的级别高。之所以<code>short</code>和<code>char</code>类型没有列出，是因为它们已经被升级到<code>int</code>或<code>unsigned int</code>。</p>\n<p>4.在赋值表达式语句中，计算的最终结果会被转换成被赋值变量的类型。这个过程可能导致类型升级或降级（demotion）。所谓降级，是指把一种类型转换成更低级别的类型。</p>\n<p>5.当作为函数参数传递时，<code>char</code>和<code>short</code>被转换成<code>int</code>，<code>float</code>被转换成<code>double</code>。第9章将介绍，函数原型会覆盖自动升级。</p>\n<p>类型升级通常都不会有什么问题，但是类型降级会导致真正的麻烦。原因很简单：较低类型可能放不下整个数字。</p>\n<p>例如，一个8位的<code>char</code>类型变量储存整数101没问题，但是存不下22334。</p>\n<p>如果待转换的值与目标类型不匹配怎么办？这取决于转换涉及的类型。待赋值的值与目标类型不匹配时，规则如下。</p>\n<p>1.目标类型是无符号整型，且待赋的值是整数时，额外的位将被忽略。例如，如果目标类型是 8 位<code>unsigned char</code>，待赋的值是原始值求模256。</p>\n<p>2.如果目标类型是一个有符号整型，且待赋的值是整数，结果因实现而异。</p>\n<p>3.如果目标类型是一个整型，且待赋的值是浮点数，该行为是未定义的。</p>\n<p><strong>如果把一个浮点值转换成整数类型会怎样？当浮点类型被降级为整数类型时，原来的浮点值会被截断。例如，23.12和23.99都会被截断为23，-23.5会被截断为-23。</strong></p>\n<p>程序清单5.14演示了这些规则。</p>\n<p>程序清单5.14 convert.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* convert.c -- 自动类型转换 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">float</span>　fl;</span><br><span class=\"line\">    fl=i=ch=<span class=\"string\">'C'</span>;　　　　　　　　　　　　　　　　　 <span class=\"comment\">/* 第9行　*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ch = %c, i = %d, fl = %2.2f\\n\"</span>, ch, i, fl);　<span class=\"comment\">/* 第10行 */</span></span><br><span class=\"line\">    ch=ch+<span class=\"number\">1</span>;　　　　　　　　　　　　　　　　　　　　 <span class=\"comment\">/* 第11行 */</span></span><br><span class=\"line\">    i=fl+<span class=\"number\">2</span> * ch;　　　　　　　　　　　　　　　　　　 <span class=\"comment\">/* 第12行 */</span></span><br><span class=\"line\">    fl=<span class=\"number\">2.0</span> * ch + i;　　　　　　　　　　　　　　　　　 <span class=\"comment\">/* 第13行 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ch = %c, i = %d, fl = %2.2f\\n\"</span>, ch, i, fl);　<span class=\"comment\">/* 第14行 */</span></span><br><span class=\"line\">    ch= <span class=\"number\">1107</span>;　　　　　　　　　　　　　　　　　　　　　 <span class=\"comment\">/* 第15行 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Now ch = %c\\n\"</span>, ch);　　　　　　　　　　　　 <span class=\"comment\">/* 第16行 */</span></span><br><span class=\"line\">    ch= <span class=\"number\">80.89</span>;　　　　　　　　　　　　　　　　　　　　　<span class=\"comment\">/* 第17行 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Now ch = %c\\n\"</span>, ch);　　　　　　　　　　　　 <span class=\"comment\">/* 第18行 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行convert.c后输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ch=C,　i=<span class=\"number\">67</span>,fl=<span class=\"number\">67.00</span></span><br><span class=\"line\">ch=D,　i=<span class=\"number\">203</span>,fl=<span class=\"number\">339.00</span></span><br><span class=\"line\">Now ch=S</span><br><span class=\"line\">Now　ch=P</span><br></pre></td></tr></table></figure><p>在我们的系统中，<code>char</code>是8位，<code>int</code>是32位。程序的分析如下。</p>\n<p>第9行和第10行：字符<code>&#39;C&#39;</code>被作为1字节的ASCII值储存在<code>ch</code>中。整数变量i接受由<code>&#39;C&#39;</code>转换的整数，即按4字节储存<code>67</code>。最后，<code>fl</code>接受由<code>67</code>转换的浮点数<code>67.00</code>。</p>\n<p>第11行和第14行：字符变量<code>&#39;C&#39;</code>被转换成整数<code>67</code>，然后加<code>1</code>。计算结果是4字节整数<code>68</code>，被截断成1字节储存在<code>ch</code>中。根据<code>%c</code>转换说明打印时，68被解释成<code>&#39;D&#39;</code>的ASCII码。</p>\n<p>第12行和第14行：ch的值被转换成4字节的整数（68），然后2乘以ch。为了和fl相加，乘积整数（136）被转换成浮点数。计算结果（203.00f）被转换成int类型，并储存在i中。</p>\n<p>第13行和第14行：ch的值（’D’，或68）被转换成浮点数，然后2乘以ch。为了做加法，i的值（203）被转换为浮点类型。计算结果（339.00）被储存在fl中。</p>\n<p>第15行和第16行：演示了<strong>类型降级</strong>的示例。把ch设置为一个超出其类型范围的值，忽略额外的位后，最终ch的值是字符S的ASCII码。或者，更确切地说，ch的值是<code>1107 % 256</code>，即83。</p>\n<p>第17行和第18行：演示了另一个<strong>类型降级</strong>的示例。把ch设置为一个浮点数，发生截断后，ch的值是字符P的ASCII码。</p>\n<h3 id=\"强制类型转换运算符\">强制类型转换运算符<a href=\"#强制类型转换运算符\" title=\"强制类型转换运算符\"></a></h3><p>通常，应该避免自动类型转换，尤其是类型降级。但是如果能小心使用，类型转换也很方便。我们前面讨论的类型转换都是自动完成的。然而，有时需要进行精确的类型转换，或者在程序中表明类型转换的意图。这种情况下要用到强制类型转换（cast），即在某个量的前面放置用圆括号括起来的类型名，该类型名即是希望转换成的目标类型。圆括号和它括起来的类型名构成了强制类型转换运算符（cast operator），其通用形式是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(type)</span><br></pre></td></tr></table></figure><p>用实际需要的类型（如，<code>long</code>）替换<code>type</code>即可。</p>\n<p>考虑下面两行代码，其中<code>mice</code>是<code>int</code>类型的变量。第2行包含两次<code>int</code>强制类型转换。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mice = <span class=\"number\">1.6</span> + <span class=\"number\">1.7</span>;</span><br><span class=\"line\">mice = (<span class=\"keyword\">int</span>)<span class=\"number\">1.6</span> + (<span class=\"keyword\">int</span>)<span class=\"number\">1.7</span>;</span><br></pre></td></tr></table></figure><p>第1 行使用自动类型转换。首先，1.6和1.7相加得3.3。然后，为了匹配<code>int</code> 类型的变量，3.3被类型转换截断为整数3。第2行，1.6和1.7在相加之前都被转换成整数（1），所以把1+1的和赋给变量mice。本质上，两种类型转换都好不到哪里去，要考虑程序的具体情况再做取舍。</p>\n<p>一般而言，不应该混合使用类型（因此有些语言直接不允许这样做），但是偶尔这样做也是有用的。C语言的原则是避免给程序员设置障碍，但是程序员必须承担使用的风险和责任。</p>\n<p>总结 C的一些运算符</p>\n<p>下面是我们学过的一些运算符。</p>\n<p>赋值运算符：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">=</span><br></pre></td></tr></table></figure><p>将其右侧的值赋给左侧的变量</p>\n<p>算术运算符：</p>\n<p>+　　　 将其左侧的值与右侧的值相加</p>\n<p>-　　　　将其左侧的值减去右侧的值</p>\n<p>-　　　　作为一元运算符，改变其右侧值的符号</p>\n<p>*　　　 将其左侧的值乘以右侧的值</p>\n<p><code>/</code>　　　　将其左侧的值除以右侧的值，如果两数都是整数，计算结果将被截断</p>\n<p><code>%</code>　　　　当其左侧的值除以右侧的值时，取其余数（只能应用于整数）</p>\n<p><code>++</code>　　　 对其右侧的值加1（前缀模式），或对其左侧的值加1（后缀模式）</p>\n<p><code>--</code>　　　 对其右侧的值减1（前缀模式），或对其左侧的值减1（后缀模式）</p>\n<p>其他运算符：</p>\n<p><code>sizeof</code>　　　 获得其右侧运算对象的大小（以字节为单位），运算对象可以是一个被圆括号括起来的类型说明符，如<code>sizeof(float)</code>，或者是一个具体的变量名、数组名等，如<code>sizeoffoo</code>(类型名)</p>\n<p>强制类型转换运算符将其右侧的值转换成圆括号中指定的类型，如<code>(float)9</code>把整数9转换成浮点数<code>9.0</code></p>\n<h2 id=\"带参数的函数\">带参数的函数<a href=\"#带参数的函数\" title=\"带参数的函数\"></a></h2><p>现在，相信读者已经熟悉了带参数的函数。要掌握函数，还要学习如何编写自己的函数（在此之前，读者可能要复习一下程序清单2.3中的<code>butler()</code>函数，该函数不带任何参数）。程序清单5.15中有一个<code>pound()</code>函数，<strong>打印指定数量的#号</strong>（该符号也叫作编号符号或井号）。该程序还演示了类型转换的应用。</p>\n<p>程序清单5.15 pound.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* pound.c -- 定义一个带一个参数的函数　*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pound</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;<span class=\"comment\">// ANSI函数原型声明</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> times=<span class=\"number\">5</span>;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> ch=<span class=\"string\">'!'</span>;　　 <span class=\"comment\">// ASCII码是33</span></span><br><span class=\"line\">    <span class=\"keyword\">float</span>　f=<span class=\"number\">6.0f</span>;</span><br><span class=\"line\">    pound(times);　　　<span class=\"comment\">// int类型的参数</span></span><br><span class=\"line\">    pound(ch);　　　　　<span class=\"comment\">// 和pound((int)ch);相同</span></span><br><span class=\"line\">    pound(f);　　　　　 <span class=\"comment\">// 和pound((int)f);相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pound</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span>　　　<span class=\"comment\">// ANSI风格函数头</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;　　　　　　　　　　　　 <span class=\"comment\">// 表明该函数接受一个int类型的参数</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span>(n--&gt;<span class=\"number\">0</span>)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"#\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序后，输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#####</span><br><span class=\"line\">#################################</span><br><span class=\"line\">######</span><br></pre></td></tr></table></figure><p>首先，看程序的函数头：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pound</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br></pre></td></tr></table></figure><p><mark><strong>如果函数不接受任何参数，函数头的圆括号中应该写上关键字 void</strong></mark>。由于该函数接受一个 <code>int</code> 类型的参数，所以圆括号中包含一个<code>int</code>类型变量<code>n</code>的声明。参数名应遵循C语言的命名规则。</p>\n<p>声明参数就创建了被称为形式参数（formal argument或formal parameter，简称形参）的变量。该例中，形式参数是 <code>int</code> 类型的变量 n。像 <code>pound(10)</code>这样的函数调用会把 10 赋给 n。在该程序中，调用<code>pound(times)</code>就是把 <code>times</code> 的值<code>（5）</code>赋给 <code>n</code>。我们称函数调用传递的值为实际参数（actual argument或actual parameter），简称实参。所以，函数调用<code>pound(10)</code>把实际参数<code>10</code>传递给函数，然后该函数把10赋给形式参数（<strong>变量n</strong>）。也就是说，<code>main()</code>中的变量<code>times</code>的值被拷贝给<code>pound()</code>中的新变量<code>n</code>。</p>\n<p>注意 实参和形参</p>\n<p><mark>形参为变量</mark></p>\n<p>在英文中，argument和parameter经常可以互换使用，但是C99标准规定了：对于actual argument或actual parameter使用术语<mark><strong><code>argument</code></strong>（译为实参）</mark>；对于formal argument或formal parameter使用术语<mark><strong><code>parameter</code></strong>（译为形参）</mark>。为遵循这一规定，我们可以说形参是变量，实参是函数调用提供的值，实参被赋给相应的形参。因此，在程序清单5.15中，<code>times</code>是<code>pound()</code>的<strong>实参</strong>，<code>n</code>是<code>pound()</code>的<strong>形参</strong>。类似地，在函数调用<code>pound(times + 4)</code>中，表达式<code>times + 4</code>的值是该函数的<strong>实参</strong>。</p>\n<p>变量名是函数私有的，即在函数中定义的函数名不会和别处的相同名称发生冲突。如果在<code>pound()</code>中用<code>times</code>代替<code>n</code>，那么这个times与main()中的times不同。也就是说，<strong>程序中出现了两个同名的变量，但是程序可以区分它们。</strong></p>\n<p>现在，我们来学习函数调用。第1 个函数调用是<code>pound(times)</code>，times的值5被赋给n。因此， <code>printf()</code>函数打印了5个井号和1个换行符。第2个函数调用是<code>pound(ch)</code>。这里，<code>ch</code>是<code>char</code>类型，被初始化为<code>!</code>字符，在ASCII中<code>ch</code>的数值是<code>33</code>。但是<code>pound()</code>函数的参数类型是<code>int</code>，与<code>char</code>不匹配。程序开头的函数原型在这里发挥了作用。原型（prototype）即是函数的声明，描述了函数的返回值和参数。<code>pound()</code>函数的原型说明了两点：</p>\n<p>该函数没有返回值（函数名前面有<code>void</code>关键字）；</p>\n<p>该函数有一个<code>int</code>类型的参数。</p>\n<p>该例中，函数原型告诉编译器<code>pound()</code>需要一个<code>int</code>类型的参数。相应地，当编译器执行到<code>pound(ch)</code>表达式时，会把参数<code>ch</code>自动转换成<code>int</code>类型。在我们的系统中，该参数从1字节的33变成4字节的33，所以现在33的类型满足函数的要求。与此类似，最后一次调用是<code>pound(f)</code>，使得<code>float</code>类型的变量被转换成合适的类型。</p>\n<p>在ANSI C之前，C使用的是函数声明，而不是函数原型。函数声明只指明了函数名和返回类型，没有指明参数类型。为了向下兼容，C现在仍然允许这样的形式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">pound</span><span class=\"params\">()</span></span>; <span class=\"comment\">/* ANSI C乊前的函数声明 */</span></span><br></pre></td></tr></table></figure><p>如果用这条函数声明代替<code>pound.c</code>程序中的函数原型会怎样？第 1 次函数调用，<code>pound(times)</code>没问题，因为<code>times</code>是<code>int</code>类型。第2次函数调用，<code>pound(ch)</code>也没问题，因为即使缺少函数原型，C也会把<code>char</code>和<code>short</code>类型自动升级为<code>int</code>类型。第3次函数调用，<code>pound(f)</code>会失败，因为缺少函数原型，<code>float</code> 会被自动升级为 <code>double</code>，这没什么用。虽然程序仍然能运行，但是输出的内容不正确。在函数调用中显式使用强制类型转换，可以修复这个问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pound ((<span class=\"keyword\">int</span>)f); <span class=\"comment\">// 把f强制类型转换为正确的类型</span></span><br></pre></td></tr></table></figure><p>注意，如果<code>f</code>的值太大，超过了<code>int</code>类型表示的范围，这样做也不行。</p>\n<h2 id=\"示例程序\">示例程序<a href=\"#示例程序\" title=\"示例程序\"></a></h2><p>程序清单5.16演示了本章介绍的几个概念，这个程序对某些人很有用。程序看起来很长，但是所有的计算都在程序的后面几行中。我们尽量使用大量的注释，让程序看上去清晰明了。请通读该程序，稍后我们会分析几处要点。</p>\n<p>程序清单5.16 running.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　running.c　--　A　useful　program　for　runners</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> S_PER_M=<span class=\"number\">60</span>;　　　　　　　 <span class=\"comment\">// 1分钟的秒数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> S_PER_H=<span class=\"number\">3600</span>;　　　　　　<span class=\"comment\">// 1小时的分钟数</span></span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> M_PER_K=<span class=\"number\">0.62137</span>;　　 <span class=\"comment\">// 1公里的英里数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> distk, distm;　 <span class=\"comment\">// 跑过的距离（分别以公里和英里为单位）</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> rate;　　　　　　 <span class=\"comment\">// 平均速度（以英里/小时为单位）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">min</span>, sec;　　　　　 <span class=\"comment\">// 跑步用时（以分钟和秒为单位）</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> time;　　　　　　　　<span class=\"comment\">// 跑步用时（以秒为单位）</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> mtime;　　　　　 <span class=\"comment\">// 跑1英里需要的时间，以秒为单位</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> mmin, msec;　　　　 <span class=\"comment\">// 跑1英里需要的时间，以分钟和秒为单位</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"This　program　converts　your　time　for　a　metric　race\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"to　a　time　for　running　a　mile　and　to　your　average\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"speed　in　miles　per　hour.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Please　enter,　in　kilometers,　the　distance　run.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lf\"</span>, &amp;distk);　　　　　　<span class=\"comment\">// %lf表示读取一个double类型的值</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Next　enter　the　time　in　minutes　and　seconds.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Begin　by　entering　the　minutes.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,　&amp;<span class=\"built_in\">min</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Now　enter　the　seconds.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,　&amp;sec);</span><br><span class=\"line\">    time=S_PER_M * <span class=\"built_in\">min</span>+sec;　　 <span class=\"comment\">// 把时间转换成秒</span></span><br><span class=\"line\">    distm=M_PER_K*distk;　　　　<span class=\"comment\">// 把公里转换成英里</span></span><br><span class=\"line\">    rate=distm/time * S_PER_H;　<span class=\"comment\">// 英里/秒×秒/小时 = 英里/小时</span></span><br><span class=\"line\">    mtime=(<span class=\"keyword\">double</span>)time / distm;　<span class=\"comment\">// 时间/距离 = 跑1英里所用的时间</span></span><br><span class=\"line\">    mmin=(<span class=\"keyword\">int</span>)mtime / S_PER_M;　 <span class=\"comment\">// 求出分钟数</span></span><br><span class=\"line\">    msec=(<span class=\"keyword\">int</span>)mtime % S_PER_M;　 <span class=\"comment\">// 求出剩余的秒数</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"You　ran　%1.2f　km　(%1.2f　miles)　in　%d　min,　%d　sec.\\n\"</span>,</span><br><span class=\"line\">    distk,　distm,　<span class=\"built_in\">min</span>,　sec);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"That　pace　corresponds　to　running　a　mile　in　%d　min,　\"</span>,</span><br><span class=\"line\">    mmin);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%d　sec.\\nYour　average　speed　was　%1.2f　mph.\\n\"</span>,　msec,</span><br><span class=\"line\">    rate);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>程序清单5.16使用了<strong>min_sec</strong>程序（程序清单5.9）中的方法把时间转换成分钟和秒，除此之外还使用了类型转换。为什么要进行类型转换？因为程序在秒转换成分钟的部分需要整型参数，但是在公里转换成英里的部分需要浮点运算。我们使用强制类型转换运算符进行了显式转换。</p>\n<p>实际上，我们曾经利用自动类型转换编写这个程序，即使用<code>int</code>类型的<code>mtime</code>来强制时间计算转换成整数形式。但是，在测试的11个系统中，这个版本的程序在1个系统上无法运行，这是由于编译器（版本比较老）没有遵循C规则。而使用强制类型转换就没有问题。对读者而言，强制类型转换强调了转换类型的意图，对编译器而言也是如此。</p>\n<p>下面是程序清单5.16的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This　program　converts　your　time　<span class=\"keyword\">for</span>　a　metric　race</span><br><span class=\"line\">to　a　time　<span class=\"keyword\">for</span>　<span class=\"built_in\">running</span>　a　mile　<span class=\"keyword\">and</span>　to　your　average</span><br><span class=\"line\">speed　in　miles　per　hour.</span><br><span class=\"line\">Please　enter,　in　kilometers,　the　distance　<span class=\"built_in\">run</span>.</span><br><span class=\"line\"><span class=\"number\">10.0</span></span><br><span class=\"line\">Next　enter　the　time　in　minutes　<span class=\"keyword\">and</span>　seconds.</span><br><span class=\"line\">Begin　by　entering　the　minutes.</span><br><span class=\"line\"><span class=\"number\">36</span></span><br><span class=\"line\">Now　enter　the　seconds.</span><br><span class=\"line\"><span class=\"number\">23</span></span><br><span class=\"line\">You　ran　<span class=\"number\">10.00</span>　km　(<span class=\"number\">6.21</span>　miles)　in　<span class=\"number\">36</span>　<span class=\"built_in\">min</span>,　<span class=\"number\">23</span>　sec.</span><br><span class=\"line\">That　pace　corresponds　to　<span class=\"built_in\">running</span>　a　mile　in　<span class=\"number\">5</span>　<span class=\"built_in\">min</span>,　<span class=\"number\">51</span>　sec.</span><br><span class=\"line\">Your average speed was <span class=\"number\">10.25</span> mph.</span><br></pre></td></tr></table></figure><h2 id=\"关键概念\">关键概念<a href=\"#关键概念\" title=\"关键概念\"></a></h2><p>C 通过运算符提供多种操作。每个运算符的特性包括运算对象的数量、优先级和结合律。当两个运算符共享一个运算对象时，优先级和结合律决定了先进行哪项运算。每个 C表达式都有一个值。如果不了解运算符的优先级和结合律，写出的表达式可能不合法或者表达式的值与预期不符。这会影响你成为一名优秀的程序员。</p>\n<p>虽然C允许编写混合数值类型的表达式，但是算术运算要求运算对象都是相同的类型。因此，C会进行自动类型转换。尽管如此，<mark><strong>不要养成依赖自动类型转换的习惯，应该显式选择合适的类型或使用强制类型转换。</strong></mark>这样，就不用担心出现不必要的自动类型转换。</p>\n<h2 id=\"本章小结\">本章小结<a href=\"#本章小结\" title=\"本章小结\"></a></h2><p>C 语言有许多运算符，如本章讨论的赋值运算符和算术运算符。一般而言，运算符需要一个或多个运算对象才能完成运算生成一个值。只需要一个运算对象的运算符（如负号和 <code>sizeof</code>）称为一元运算符，需要两个运算对象的运算符（如加法运算符和乘法运算符）称为<strong>二元运算符</strong>。</p>\n<p>表达式由运算符和运算对象组成。在C语言中，每个表达式都有一个值，包括赋值表达式和比较表达式。运算符优先级规则决定了表达式中各项的求值顺序。当两个运算符共享一个运算对象时，先进行优先级高的运算。如果运算符的优先级相等，由结合律（从左往右或从右往左）决定求值顺序。</p>\n<p>大部分语句都以分号结尾。最常用的语句是表达式语句。<strong>用花括号括起来的一条或多条语句构成了复合语句（或称为块）</strong>。<strong>while</strong>语句是一种迭代语句，只要测试条件为真，就重复执行循环体中的语句。</p>\n<p><strong>在C语言中，许多类型转换都是自动进行的</strong>。<mark>当<code>char</code>和<code>short</code>类型出现在表达式里或作为函数的参数（函数原型除外）时，都会被升级为<code>int</code>类型</mark>；<mark><code>float</code>类型在函数参数中时，会被升级为<code>double</code>类型。</mark>在K&amp;R C（不是ANSI C）下，表达式中的<code>float</code>也会被升级为<code>double</code>类型。当把一种类型的值赋给另一种类型的变量时，值将被转换成与变量的类型相同。当把较大类型转换成较小类型时（如，<code>long</code>转换成<code>short</code>，或 <code>double</code> 转换成 <code>float</code>），可<strong>能会丢失数据</strong>。根据本章介绍的规则，在混合类型的运算中，<strong>较小类型会被转换成较大类型</strong>。</p>\n<p>定义带一个参数的函数时，便在函数定义中声明了一个变量，或称为<strong>形式参数</strong>。然后，在函数调用中传入的值会被赋给这个变量。这样，在函数中就可以使用该值了。</p>\n","prev":{"title":"Step4 C控制语句：循环","link":"posts/287f677b"},"next":{"title":"string.h中常用函数","link":"posts/52078792"},"plink":"https://dxsummer.gitee.io/posts/d0061c8b/","toc":[{"id":"运算符、表达式和语句","title":"[运算符、表达式和语句]","index":"1","children":[{"id":"循环简介","title":"循环简介","index":"1.1"},{"id":"基本运算符","title":"基本运算符","index":"1.2","children":[{"id":"赋值运算符：","title":"赋值运算符：&#x3D;","index":"1.2.1"},{"id":"加法运算符：","title":"加法运算符：+","index":"1.2.2"},{"id":"减法运算符：-","title":"减法运算符：-","index":"1.2.3"},{"id":"符号运算符：-和","title":"符号运算符：-和+","index":"1.2.4"},{"id":"乘法运算符：","title":"乘法运算符：*","index":"1.2.5","children":[{"id":"指数增长","title":"指数增长","index":"1.2.5.1"}]},{"id":"除法运算符：","title":"除法运算符：&#x2F;","index":"1.2.6"},{"id":"运算符优先级","title":"运算符优先级","index":"1.2.7"},{"id":"优先级和求值顺序","title":"优先级和求值顺序","index":"1.2.8"}]},{"id":"其他运算符","title":"其他运算符","index":"1.3","children":[{"id":"sizeof运算符和size_t类型","title":"sizeof运算符和size_t类型","index":"1.3.1"},{"id":"求模运算符：","title":"求模运算符：%","index":"1.3.2"},{"id":"递增运算符：","title":"递增运算符：++","index":"1.3.3"},{"id":"递减运算符：","title":"递减运算符：–","index":"1.3.4"},{"id":"优先级","title":"优先级","index":"1.3.5"},{"id":"不要自作聪明","title":"不要自作聪明","index":"1.3.6"}]},{"id":"表达式和语句","title":"表达式和语句","index":"1.4","children":[{"id":"表达式","title":"表达式","index":"1.4.1"},{"id":"语句","title":"语句","index":"1.4.2"},{"id":"复合语句（块）","title":"复合语句（块）","index":"1.4.3"}]},{"id":"类型转换","title":"类型转换","index":"1.5","children":[{"id":"强制类型转换运算符","title":"强制类型转换运算符","index":"1.5.1"}]},{"id":"带参数的函数","title":"带参数的函数","index":"1.6"},{"id":"示例程序","title":"示例程序","index":"1.7"},{"id":"关键概念","title":"关键概念","index":"1.8"},{"id":"本章小结","title":"本章小结","index":"1.9"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/d0061c8b/\" title=\"Step3 运算符、表达式和语句\">https://dxsummer.gitee.io/posts/d0061c8b/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年5月30日","updated":"2020年6月8日"}}