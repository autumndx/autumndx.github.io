{"title":"树和二叉树","date":"2020-11-07T12:20:23.000Z","date_formatted":{"ll":"2020年11月7日","L":"2020/11/07","MM-DD":"11-07"},"link":"posts/ec2e91f9","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2020-11-21T08:12:47.848Z","content":"<h1 id=\"逻辑结构\">逻辑结构<a href=\"#逻辑结构\" title=\"逻辑结构\"></a></h1><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107202313.png\" style=\"zoom:67%;\" /><h1 id=\"树\">树<a href=\"#树\" title=\"树\"></a></h1><p>n（n≥0）个结点的有限集，它或为<strong>空树（n = 0）</strong>；或为<strong>非空树</strong>，对于非空树T：</p>\n<ol><li>有且<strong>仅有一个称之为根的结点</strong></li>\n<li>除根结点以外的其余结点可分为m（m＞0）个互不相交的有限集T1, T2, …, Tm, 其中每一个集合本身又是一棵树，并且称为根的<strong>子树</strong>（SubTree）</li>\n</ol><blockquote>\n<p>树是n个结点的有限集</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107204231.png\" style=\"zoom: 67%;\" /><h2 id=\"基本术语\">基本术语<a href=\"#基本术语\" title=\"基本术语\"></a></h2><ul><li><p><strong>根</strong>：即根结点(没有前驱)</p>\n</li>\n<li><p><strong>叶子</strong>：即终端结点(没有后继)</p>\n</li>\n<li><p><strong><font color=\"red\">森林</font></strong>：指m棵不相交的树的集合(例如删除A后的子树个数)</p>\n</li>\n<li><p><strong><font color=\"red\">有序树</font></strong>：结点各子树从左至右有序，不能互换（<strong>左为第一</strong>）</p>\n</li>\n<li><p><strong>无序树</strong>：结点各子树可互换位置</p>\n</li>\n<li><p><strong><font color=\"red\">双亲</font></strong>：即上层的那个结点(<strong>直接前驱</strong>)</p>\n</li>\n<li><p><strong><font color=\"red\">孩子</font></strong>：即下层结点的子树的根(<strong>直接后继</strong>)</p>\n</li>\n<li><p><strong>兄弟</strong>：同一双亲下的同层结点（孩子之间互称兄弟）</p>\n</li>\n<li><p><strong>堂兄弟</strong>：即双亲位于同一层的结点（但并非同一双亲）</p>\n</li>\n<li><p><strong>祖先</strong>：即从根到该结点所经分支的所有结点</p>\n</li>\n<li><p><strong>子孙</strong>：即该结点下层子树中的任一结点</p>\n</li>\n<li><p><strong>结点</strong>：即树的数据元素</p>\n</li>\n<li><p><strong><font color=\"red\">结点的度</font></strong>：结点挂接的子树数</p>\n</li>\n<li><p><strong><font color=\"red\">结点的层次</font></strong>：从根到该结点的层数（根结点算第一层）</p>\n</li>\n<li><p><strong>终端结点</strong>：即度为0的结点，即叶子</p>\n</li>\n<li><p><strong>分支结点</strong>：即度不为0的结点（也称为内部结点）</p>\n</li>\n<li><p><strong><font color=\"red\">树的度</font></strong>：所有结点度中的最大值</p>\n</li>\n<li><p><strong><font color=\"red\">树的深度(或高度)</font></strong>：指所有结点中最大的层数</p>\n</li>\n</ul><h1 id=\"二叉树\">二叉树<a href=\"#二叉树\" title=\"二叉树\"></a></h1><p>n（n≥0）个结点所构成的集合，它或为空树（n = 0）；或为非空树，对于非空树T：</p>\n<ol><li>有且仅有一个称之为根的结点；</li>\n<li>除根结点以外的其余结点分为两个互不相交的子集T1和T2，分别称为T的左子树和右子树，且T1和T2本身又都是二叉树。</li>\n</ol><h2 id=\"特点\">特点<a href=\"#特点\" title=\"特点\"></a></h2><ol><li>结点的度小于等于2</li>\n<li>有序树（子树有序，不能颠倒）</li>\n</ol><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107220242.png\" style=\"zoom:67%;\" /><h2 id=\"性质🍑\">性质🍑<a href=\"#性质🍑\" title=\"性质🍑\"></a></h2><p><mark>1. </mark>在二叉树的第 <strong>i</strong> 层上至多有2<sup>i-1</sup>个结点( i &gt;= 1 )</p>\n<p><mark>2. </mark>深度为 k 的二叉树至多有 2<sup>k</sup> - 1个结点( k &gt;= 1 )</p>\n<p><mark>3. </mark><font color=\"#729CBD\">对于任何一棵二叉树，<strong>终端结点数</strong>（叶子数）为 n<sub>0</sub> ，若度为2的结点数有n<sub>2</sub>个，则叶子数n<sub>0</sub>=n<sub>2</sub>+1</font></p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107221855.png\" style=\"zoom:67%;\" /><p><mark>4. </mark>具有n个结点的完全二叉树的深度必为[log<sub>2</sub>n]＋1 （<code>[x]</code>不大于<code>x</code>的最大整数，[5.7]=[5] ）</p>\n<p><mark>5. </mark> </p>\n<ul><li><p>对完全二叉树，若从上至下、从左至右编号，则编号为<code>i</code> 的结点，其左孩子编号必为<code>2i</code>，其右孩子编号必为<code>2i＋1</code>；</p>\n</li>\n<li><p>其双亲的编号必为<code>i/2</code>。</p>\n</li>\n</ul><h2 id=\"特殊形态的二叉树\">特殊形态的二叉树<a href=\"#特殊形态的二叉树\" title=\"特殊形态的二叉树\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107222147.png\" style=\"zoom:67%;\" /><ul><li>满二叉树是叶子一个也不少的树，而完全二叉树虽然前n-1层是满的，但最底层却允许在右边缺少连续若干个结点。<strong>满二叉树是完全二叉树的一个特例。</strong></li>\n</ul><h2 id=\"顺序存储\">顺序存储<a href=\"#顺序存储\" title=\"顺序存储\"></a></h2><p>按<strong>满二叉树</strong>的结点层次编号，依次存放二叉树中的数据元素。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107224115.png\" style=\"zoom:67%;\" /><h3 id=\"问题\">问题<a href=\"#问题\" title=\"问题\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201107224215.png\" style=\"zoom: 50%;\" /><h2 id=\"链式存储\">链式存储<a href=\"#链式存储\" title=\"链式存储\"></a></h2><blockquote>\n<p>含有两个指针域的节点结构、三个指针域的结点结构</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/html/20201116200410.png\" style=\"zoom:50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">BiNode</span>&#123;</span></span><br><span class=\"line\">   TElemType   data;</span><br><span class=\"line\">   <span class=\"class\"><span class=\"keyword\">struct</span>  <span class=\"title\">BiNode</span>   *<span class=\"title\">lchild</span>,*<span class=\"title\">rchild</span>;</span> <span class=\"comment\">//左右孩子指针</span></span><br><span class=\"line\">&#125;BiNode,*BiTree;</span><br></pre></td></tr></table></figure><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/html/20201116201425.png\" style=\"zoom:67%;\" /><blockquote>\n<p>eg</p>\n<p><mark>在n个结点的二叉链表中，有<code>n+1</code>个<strong>空指针域</strong></mark></p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/html/20201116201612.png\" style=\"zoom:67%;\" /><h1 id=\"遍历二叉树\">遍历二叉树<a href=\"#遍历二叉树\" title=\"遍历二叉树\"></a></h1><ul><li>指按某条搜索路线遍访每个结点且不重复（又称周游）。</li>\n<li>它是树结构<strong>插入、删除、修改、查找和排序</strong>运算的前提，是二叉树一切运算的基础和核心。</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117174739.png\" style=\"zoom:50%;\" /><h2 id=\"先序遍历算法\">先序遍历算法<a href=\"#先序遍历算法\" title=\"先序遍历算法\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117212150.png\" style=\"zoom: 50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PreOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK; <span class=\"comment\">//空二叉树</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">     <span class=\"built_in\">cout</span>&lt;&lt;T-&gt;data; <span class=\"comment\">//访问根结点</span></span><br><span class=\"line\">     PreOrderTraverse(T-&gt;lchild); <span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">     PreOrderTraverse(T-&gt;rchild); <span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"中序遍历算法\">中序遍历算法<a href=\"#中序遍历算法\" title=\"中序遍历算法\"></a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK; <span class=\"comment\">//空二叉树</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">     InOrderTraverse(T-&gt;lchild); <span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">  <span class=\"built_in\">cout</span>&lt;&lt;T-&gt;data; <span class=\"comment\">//访问根结点</span></span><br><span class=\"line\">     InOrderTraverse(T-&gt;rchild); <span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"后序遍历算法\">后序遍历算法<a href=\"#后序遍历算法\" title=\"后序遍历算法\"></a></h2><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">PostOrderTraverse</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> OK; <span class=\"comment\">//空二叉树</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>&#123;    </span><br><span class=\"line\">     PostOrderTraverse(T-&gt;lchild); <span class=\"comment\">//递归遍历左子树</span></span><br><span class=\"line\">     PostOrderTraverse(T-&gt;rchild); <span class=\"comment\">//递归遍历右子树</span></span><br><span class=\"line\">     <span class=\"built_in\">cout</span>&lt;&lt;T-&gt;data; <span class=\"comment\">//访问根结点</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"计算二叉树结点总数\">计算二叉树结点总数<a href=\"#计算二叉树结点总数\" title=\"计算二叉树结点总数\"></a></h2><ol><li><p>如果是空树，则结点个数为0；</p>\n</li>\n<li><p>否则，结点个数为<strong>左子树的结点个数+右子树的结点个数再+1</strong>。</p>\n</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">NodeCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\">  <span class=\"keyword\">if</span>(T == <span class=\"literal\">NULL</span> ) <span class=\"keyword\">return</span> <span class=\"number\">0</span>;  \t\t\t    </span><br><span class=\"line\">  <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> NodeCount(T-&gt;lchild)+NodeCount(T-&gt;rchild)+<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"计算二叉树叶子结点总数\">计算二叉树叶子结点总数<a href=\"#计算二叉树叶子结点总数\" title=\"计算二叉树叶子结点总数\"></a></h2><ol><li><p>如果是空树，则叶子结点个数为0；</p>\n</li>\n<li><p>否则，为<strong>左子树的叶子结点个数+右子树的叶子结点个数</strong>。</p>\n</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LeadCount</span><span class=\"params\">(BiTree T)</span></span>&#123;</span><br><span class=\"line\"> \t<span class=\"keyword\">if</span>(T==<span class=\"literal\">NULL</span>) \t<span class=\"comment\">//如果是空树返回0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (T-&gt;lchild == <span class=\"literal\">NULL</span> &amp;&amp; T-&gt;rchild == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> <span class=\"number\">1</span>; <span class=\"comment\">//如果是叶子结点返回1</span></span><br><span class=\"line\">\t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> LeafCount(T-&gt;lchild) + LeafCount(T-&gt;rchild);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"计算二叉树深度\">计算二叉树深度<a href=\"#计算二叉树深度\" title=\"计算二叉树深度\"></a></h2><ol><li>如果是空树，则深度为0；</li>\n<li>否则，递归计算<strong>左子树的深度记为m</strong>，递归计算<strong>右子树的深度记为n</strong>，二叉树的深度则为<strong>m与n的较大者加1</strong>。 </li>\n</ol><h1 id=\"结论\">结论<a href=\"#结论\" title=\"结论\"></a></h1><ul><li>由二叉树的<strong>前序序列</strong>和<strong>中序序列</strong>，或由其<strong>后序序列</strong>和<strong>中序序列</strong>均能<strong>唯一地确定一棵二叉树</strong>，</li>\n<li>但由<strong>前序序列</strong>和<strong>后序序列</strong>却<strong>不一定能</strong>唯一地确定一棵二叉树。 </li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117220605.png\" style=\"zoom:50%;\" /><h1 id=\"线索化二叉树\">线索化二叉树<a href=\"#线索化二叉树\" title=\"线索化二叉树\"></a></h1><ol><li>若结点有<strong>左子树</strong>，则<code>lchild</code>指向其<strong>左孩子</strong>；否则， <code>lchild</code>指向其<strong>直接前驱</strong>(即<strong>线索</strong>)；</li>\n<li>若结点有<strong>右子树</strong>，则<code>rchild</code>指向其<strong>右孩子</strong>；否则， <code>rchild</code>指向其<strong>直接后继</strong>(即<strong>线索</strong>) 。</li>\n</ol><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201117221216.png\" style=\"zoom:50%;\" /><p><code>LTag</code>  :若 <code>LTag=0</code>, <code>lchild</code>域指向<strong>左孩子</strong>；若 <code>LTag=1,</code> <code>lchild</code>域指向其<strong>前驱</strong>。<br><code>RTag</code>  :若 <code>RTag=0</code>, <code>rchild</code>域指向<strong>右孩子</strong>；若 <code>RTag=1</code>, <code>rchild</code>域指向其<strong>后继</strong>。 </p>\n<ul><li><strong>线索</strong>：指向结点<strong>前驱和后继</strong>的指针</li>\n<li><strong>线索链表</strong>：加上线索二叉链表</li>\n<li><strong>线索二叉树</strong>：加上线索的二叉树（图形式样）</li>\n<li><strong>线索化</strong>：对二叉树以某种次序遍历使其变为线索二叉树的过程</li>\n</ul><h2 id=\"先序线索二叉树\">先序线索二叉树<a href=\"#先序线索二叉树\" title=\"先序线索二叉树\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201119175212.png\" style=\"zoom:67%;\" /><h2 id=\"中序线索二叉树\">中序线索二叉树<a href=\"#中序线索二叉树\" title=\"中序线索二叉树\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201120171923.png\" style=\"zoom: 67%;\" /><h2 id=\"后序线索二叉树\">后序线索二叉树<a href=\"#后序线索二叉树\" title=\"后序线索二叉树\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201120172019.png\" style=\"zoom: 80%;\" /><h1 id=\"树的存储结构\">树的存储结构<a href=\"#树的存储结构\" title=\"树的存储结构\"></a></h1><h2 id=\"二叉链表\">二叉链表<a href=\"#二叉链表\" title=\"二叉链表\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201120172640.png\" style=\"zoom:50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CSNode</span>&#123;</span></span><br><span class=\"line\">  ElemType data;</span><br><span class=\"line\">  <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">CSNode</span> *<span class=\"title\">firstchild</span>,*<span class=\"title\">nextsibling</span>;</span></span><br><span class=\"line\">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h1 id=\"哈夫曼编码远程通讯\">哈夫曼编码(远程通讯)<a href=\"#哈夫曼编码远程通讯\" title=\"哈夫曼编码(远程通讯)\"></a></h1><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121150740.png\" style=\"zoom:67%;\" /><p><strong>基本思想</strong>：使权大的结点靠近根</p>\n<p><strong>操作要点</strong>：对权值的合并、删除与替换，总是合并当前值最小的两个</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121151522.png\" style=\"zoom:67%;\" /><p><strong>基本思想</strong>：概率大的字符用短码，小的用长码，构造哈夫曼树</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121152532.png\" style=\"zoom:67%;\" /><ol><li><p>根据给定的n个权值{w<sub>1</sub>,w<sub>2</sub>,……w<sub>n</sub>}，构造<strong>n棵只有根结点的二叉树</strong>。</p>\n</li>\n<li><p>在森林中选取两棵根结点<strong>权值最小的树作左右子树</strong>，构造一棵新的二叉树，置新二叉树根结点权值为其左右子树根结点权值之和。</p>\n</li>\n<li><p>在森林中<strong>删除这两棵树</strong>，同时将新得到的二叉树加入森林中。<br>重复上述两步，<strong>直到只含一棵树为止</strong>，这棵树即<strong>哈夫曼树</strong>。</p>\n</li>\n</ol><h2 id=\"构造算法的实现\">构造算法的实现<a href=\"#构造算法的实现\" title=\"构造算法的实现\"></a></h2><p><strong>一棵有n个叶子结点的Huffman树有<code>2n-1</code>个结点</strong></p>\n<ul><li>采用顺序存储结构——一维结构数组</li>\n<li>结点类型定义</li>\n</ul><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span>  <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span>  <span class=\"keyword\">int</span> weght;\t<span class=\"comment\">//结点的权值\t</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span> parent,lch,rch;\t<span class=\"comment\">//双亲、左孩子、右孩子下标</span></span><br><span class=\"line\">&#125;*HuffmanTree;\t<span class=\"comment\">//动态分配数组存储哈夫曼树</span></span><br></pre></td></tr></table></figure><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121160449.png\" style=\"zoom:67%;\" /><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算法5.10 构造赫夫曼树</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span><span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span></span></span><br><span class=\"line\"><span class=\"class\">&#123;</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> weight;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> parent,lchild,rchild;</span><br><span class=\"line\">&#125;HTNode,*HuffmanTree;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">Select</span><span class=\"params\">(HuffmanTree HT,<span class=\"keyword\">int</span> len,<span class=\"keyword\">int</span> &amp;s1,<span class=\"keyword\">int</span> &amp;s2)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i,min1=<span class=\"number\">0x3f3f3f3f</span>,min2=<span class=\"number\">0x3f3f3f3f</span>;<span class=\"comment\">//先赋予最大值</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=len;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(HT[i].weight&lt;min1&amp;&amp;HT[i].parent==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tmin1=HT[i].weight;</span><br><span class=\"line\">\t\t\ts1=i;</span><br><span class=\"line\">\t\t&#125;\t</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> temp=HT[s1].weight;<span class=\"comment\">//将原值存放起来，然后先赋予最大值，防止s1被重复选择</span></span><br><span class=\"line\">\tHT[s1].weight=<span class=\"number\">0x3f3f3f3f</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=len;i++)</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(HT[i].weight&lt;min2&amp;&amp;HT[i].parent==<span class=\"number\">0</span>)</span><br><span class=\"line\">\t\t&#123;</span><br><span class=\"line\">\t\t\tmin2=HT[i].weight;</span><br><span class=\"line\">\t\t\ts2=i;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\tHT[s1].weight=temp;<span class=\"comment\">//恢复原来的值</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">CreatHuffmanTree</span><span class=\"params\">(HuffmanTree &amp;HT,<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造赫夫曼树HT</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> m,s1,s2,i;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(n&lt;=<span class=\"number\">1</span>) <span class=\"keyword\">return</span>;</span><br><span class=\"line\">\tm=<span class=\"number\">2</span>*n<span class=\"number\">-1</span>;</span><br><span class=\"line\">\tHT=<span class=\"keyword\">new</span> HTNode[m+<span class=\"number\">1</span>];  \t\t<span class=\"comment\">//0号单元未用，所以需要动态分配m+1个单元，HT[m]表示根结点   </span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=m;++i)        \t<span class=\"comment\">//将1~m号单元中的双亲、左孩子，右孩子的下标都初始化为0   </span></span><br><span class=\"line\">\t   &#123; HT[i].parent=<span class=\"number\">0</span>;  HT[i].lchild=<span class=\"number\">0</span>;  HT[i].rchild=<span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"请输入叶子结点的权值：\\n\"</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=<span class=\"number\">1</span>;i&lt;=n;++i)        \t<span class=\"comment\">//输入前n个单元中叶子结点的权值  </span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span>&gt;&gt;HT[i].weight;  </span><br><span class=\"line\">\t<span class=\"comment\">/*――――――――――初始化工作结束，下面开始创建赫夫曼树――――――――――*/</span> </span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i=n+<span class=\"number\">1</span>;i&lt;=m;++i) </span><br><span class=\"line\">\t&#123;  \t<span class=\"comment\">//通过n-1次的选择、删除、合并来创建赫夫曼树</span></span><br><span class=\"line\">\t\tSelect(HT,i<span class=\"number\">-1</span>,s1,s2);</span><br><span class=\"line\">\t\t<span class=\"comment\">//在HT[k](1≤k≤i-1)中选择两个其双亲域为0且权值最小的结点,</span></span><br><span class=\"line\">\t\t<span class=\"comment\">// 并返回它们在HT中的序号s1和s2</span></span><br><span class=\"line\">\t\tHT[s1].parent=i; \t</span><br><span class=\"line\">\t\tHT[s2].parent=i;   </span><br><span class=\"line\">\t\t<span class=\"comment\">//得到新结点i，从森林中删除s1，s2，将s1和s2的双亲域由0改为i</span></span><br><span class=\"line\">\t\tHT[i].lchild=s1;   </span><br><span class=\"line\">\t\tHT[i].rchild=s2 ;\t\t\t\t\t\t\t<span class=\"comment\">//s1,s2分别作为i的左右孩子</span></span><br><span class=\"line\">\t\tHT[i].weight=HT[s1].weight+HT[s2].weight; \t<span class=\"comment\">//i 的权值为左右孩子权值之和</span></span><br><span class=\"line\">\t&#125;\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">//for</span></span><br><span class=\"line\"> &#125;\t\t\t\t\t\t\t\t\t\t\t\t\t<span class=\"comment\">// CreatHuffmanTree</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\tHuffmanTree HT;</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> n;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"请输入叶子结点的个数：\\n\"</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span>&gt;&gt;n;</span><br><span class=\"line\">\tCreatHuffmanTree(HT,n);</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span>&lt;&lt;<span class=\"string\">\"哈夫曼树建立完毕！\\n\"</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>哈夫曼编码是<strong>不等长编码</strong>。<br>哈夫曼编码是<strong>前缀编码</strong>，即任一字符的编码都不是另一字符编码的前缀。<br>哈夫曼编码树中没有度为1的结点。若叶子结点的个数为n，则哈夫曼编码树的<strong>结点总数为 2n-1</strong>。<br>发送过程：根据由<strong>哈夫曼树得到的编码表</strong>送出字符数据<br>接收过程：按<strong>左0、右1</strong>的规定，从根结点走到一个叶结点，完成一个字符的译码。反复此过程，直到接收数据结束。</p>\n","prev":{"title":"DIV+CSS布局","link":"posts/f02a39f0"},"next":{"title":"表格和表单","link":"posts/80afbc07"},"plink":"https://dxsummer.gitee.io/posts/ec2e91f9/","toc":[{"id":"逻辑结构","title":"逻辑结构","index":"1"},{"id":"树","title":"树","index":"2","children":[{"id":"基本术语","title":"基本术语","index":"2.1"}]},{"id":"二叉树","title":"二叉树","index":"3","children":[{"id":"特点","title":"特点","index":"3.1"},{"id":"性质🍑","title":"性质🍑","index":"3.2"},{"id":"特殊形态的二叉树","title":"特殊形态的二叉树","index":"3.3"},{"id":"顺序存储","title":"顺序存储","index":"3.4","children":[{"id":"问题","title":"问题","index":"3.4.1"}]},{"id":"链式存储","title":"链式存储","index":"3.5"}]},{"id":"遍历二叉树","title":"遍历二叉树","index":"4","children":[{"id":"先序遍历算法","title":"先序遍历算法","index":"4.1"},{"id":"中序遍历算法","title":"中序遍历算法","index":"4.2"},{"id":"后序遍历算法","title":"后序遍历算法","index":"4.3"},{"id":"计算二叉树结点总数","title":"计算二叉树结点总数","index":"4.4"},{"id":"计算二叉树叶子结点总数","title":"计算二叉树叶子结点总数","index":"4.5"},{"id":"计算二叉树深度","title":"计算二叉树深度","index":"4.6"}]},{"id":"结论","title":"结论","index":"5"},{"id":"线索化二叉树","title":"线索化二叉树","index":"6","children":[{"id":"先序线索二叉树","title":"先序线索二叉树","index":"6.1"},{"id":"中序线索二叉树","title":"中序线索二叉树","index":"6.2"},{"id":"后序线索二叉树","title":"后序线索二叉树","index":"6.3"}]},{"id":"树的存储结构","title":"树的存储结构","index":"7","children":[{"id":"二叉链表","title":"二叉链表","index":"7.1"}]},{"id":"哈夫曼编码远程通讯","title":"哈夫曼编码(远程通讯)","index":"8","children":[{"id":"构造算法的实现","title":"构造算法的实现","index":"8.1"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/ec2e91f9/\" title=\"树和二叉树\">https://dxsummer.gitee.io/posts/ec2e91f9/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年11月7日","updated":"2020年11月21日"}}