{"title":"Step9 字符串和字符串函数","date":"2020-06-27T06:47:03.000Z","date_formatted":{"ll":"2020年6月27日","L":"2020/06/27","MM-DD":"06-27"},"thumbnail":"https://gitee.com/DxSummer/pic/raw/master/img/c/Step9fengmian.jpg","link":"posts/9e369547","comments":true,"tags":["C语言基础"],"updated":"2020-07-12T06:09:18.849Z","content":"<h2 id=\"字符串和字符串函数\">字符串和字符串函数<a href=\"#字符串和字符串函数\" title=\"字符串和字符串函数\"></a></h2><p>本章介绍以下内容：</p>\n<p><strong>函数</strong>：<code>gets()</code>、<code>gets_s()</code>、<code>fgets()</code>、<code>puts()</code>、<code>fputs()</code>、<code>strcat()</code>、<code>strncat()</code>、<code>strcmp()</code>、<code>strncmp()</code>、<code>strcpy()</code>、<code>strncpy()</code>、<code>sprintf()</code>、<code>strchr()</code></p>\n<p><strong>创建并使用字符串</strong></p>\n<p><strong>使用C库中的字符和字符串函数，并创建自定义的字符串函数</strong></p>\n<p><strong>使用命令行参数</strong></p>\n<p>字符串是C语言中最有用、最重要的数据类型之一。虽然我们一直在使用字符串，但是要学的东西还很多。C 库提供大量的函数用于读写字符串、拷贝字符串、比较字符串、合并字符串、查找字符串等。通过本章的学习，读者将进一步提高自己的编程水平。</p>\n<h2 id=\"表示字符串和字符串io\">表示字符串和字符串I/O<a href=\"#表示字符串和字符串io\" title=\"表示字符串和字符串I/O\"></a></h2><p>第4章介绍过，字符串是以空字符（<code>\\0</code>）结尾的<code>char</code>类型数组。因此，可以把上一章学到的数组和指针的知识应用于字符串。不过，由于字符串十分常用，所以 C提供了许多专门用于处理字符串的函数。本章将讨论字符串的性质、如何声明并初始化字符串、如何在程序中输入和输出字符串，以及如何操控字符串。</p>\n<p>程序清单11.1演示了在程序中表示字符串的几种方式。</p>\n<p>程序清单11.1 strings1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　 strings1.c</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MSG　<span class=\"meta-string\">\"I　am　a　symbolic　string　constant.\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MAXLENGTH　81</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>　words[MAXLENGTH]　=　<span class=\"string\">\"I　am　a　string　in　an　array.\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pt1 = <span class=\"string\">\"Something is pointing at me.\"</span>;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"Here　are　some　strings:\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(MSG);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(words);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(pt1);</span><br><span class=\"line\">    words[<span class=\"number\">8</span>]　=　<span class=\"string\">'p'</span>;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(words);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>和<code>printf()</code>函数一样，<code>puts()</code>函数也属于<code>stdio.h</code>系列的输入/输出函数。但是，与<code>printf()</code>不同的是，<strong><code>puts()</code>函数只显示字符串，而且自动在显示的字符串末尾加上换行符。</strong>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Here　are　some　strings:</span><br><span class=\"line\">I　am　an　old-fashioned　symbolic　<span class=\"built_in\">string</span>　constant.</span><br><span class=\"line\">I　am　a　<span class=\"built_in\">string</span>　in　an　<span class=\"built_in\">array</span>.</span><br><span class=\"line\">Something　is　pointing　at　me.</span><br><span class=\"line\">I　am　a　spring　in　an　<span class=\"built_in\">array</span>.</span><br></pre></td></tr></table></figure><p>我们先分析一下该程序中定义字符串的几种方法，然后再讲解把字符串读入程序涉及的一些操作，最后学习如何输出字符串。</p>\n<h3 id=\"在程序中定义字符串\">在程序中定义字符串<a href=\"#在程序中定义字符串\" title=\"在程序中定义字符串\"></a></h3><p>程序清单11.1中使用了多种方法（即字符串常量、<code>char</code>类型数组、指向<code>char</code>的指针）定义字符串。程序应该确保有足够的空间储存字符串，这一点我们稍后讨论。</p>\n<ol><li><p><strong>字符串字面量（字符串常量）</strong></p>\n<p> 用双引号括起来的内容称为<strong>字符串字面量</strong>（string literal），也叫作<strong>字符串常量</strong>（string constant）。双引号中的字符和编译器自动加入末尾的<code>\\0</code>字符，都作为字符串储存在内存中，所以<code>&quot;I am a symbolic stringconstant.&quot;、&quot;I am a string in an array.&quot;、&quot;Something is pointed at me.&quot;、&quot;Here are some strings:&quot;</code>都是字符串字面量。</p>\n<p> 从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分隔，C会将其视为串联起来的字符串字面量。例如：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span>　greeting[<span class=\"number\">50</span>]=<span class=\"string\">\"Hello,　and \"</span><span class=\"string\">\"how　are\"</span><span class=\"string\">\"　you\"</span> <span class=\"string\">\"　today!\"</span>;</span><br></pre></td></tr></table></figure><p> 与下面的代码等价：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> greeting[<span class=\"number\">50</span>] = <span class=\"string\">\"Hello, and how are you today!\"</span>;</span><br></pre></td></tr></table></figure><p> 如果要在字符串内部使用双引号，必须在双引号前面加上一个反斜杠（<code>\\</code>）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"\\\"Run, Spot, run!\\\" exclaimed Dick.\\n\"</span>);</span><br></pre></td></tr></table></figure><p> 输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"string\">\"Run, Spot, run!\"</span> exclaimed Dick.</span><br></pre></td></tr></table></figure><p> 字符串常量属于<strong>静态存储类别</strong>（static storage class），这说明如果在函数中使用字符串常量，该字符串只会被储存一次，在整个程序的生命期内存在，即使函数被调用多次。用双引号括起来的内容被视为<strong>指向该字符串储存位置的指针</strong>。这类似于把数组名作为指向该数组位置的指针。如果确实如此，程序清单11.2中的程序会输出什么？</p>\n<p> 程序清单11.2 strptr.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* strptr.c -- 把字符串看作指针 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s, %p, %c\\n\"</span>, <span class=\"string\">\"We\"</span>, <span class=\"string\">\"are\"</span>, *<span class=\"string\">\"space farers\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> <code>printf()</code>根据<code>%s</code> 转换说明打印 We，根据<code>%p</code> 转换说明打印一个地址。因此，如果”are”代表一个地址，<code>printf()</code>将打印该<strong>字符串首字符的地址</strong>（如果使用ANSI之前的实现，可能要用<code>%u</code>或<code>%lu</code>代替<code>%p</code>）。最后，<code>*&quot;space farers&quot;</code>表示该字符串所指向地址上储存的值，应该是字符串<code>*&quot;space farers&quot;</code>的首字符。是否真的是这样？下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">We, <span class=\"number\">0x100000f61</span>, s</span><br></pre></td></tr></table></figure></li>\n<li><p><strong>字符串数组和初始化</strong></p>\n<p> 定义字符串数组时，必须让编译器知道需要多少空间。一种方法是用足够空间的数组储存字符串。在下面的声明中，用指定的字符串初始化数组m1：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> m1[<span class=\"number\">40</span>] = <span class=\"string\">\"Limit yourself to one line's worth.\"</span>;</span><br></pre></td></tr></table></figure><p> <code>const</code>表明不会更改这个字符串。</p>\n<p> 这种形式的初始化比标准的数组初始化形式简单得多：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">const char m1[40] = &#123; 'L','i', 'm', 'i', 't', ' ', 'y', 'o', 'u', 'r', 's', 'e', 'l','f', ' ', 't', 'o', ' ', 'o', 'n', 'e', ' ','l', 'i', 'n', 'e','\\\",　's',　'　',　'w',　'o',　'r','t',　'h',　'.',　'\\0'&#125;;</span><br></pre></td></tr></table></figure><p> 注意最后的空字符。没有这个空字符，这就不是一个字符串，而是一个字符数组。</p>\n<p> <strong>在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）</strong>。所有未被使用的元素都被自动初始化为0（这里的0指的是<code>char</code>形式的空字符，不是数字字符0），如图11.1所示。</p>\n</li>\n</ol><p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/11.1数组的数组.png\" class=\"φcy\"></p>\n<pre><code>通常，让编译器确定数组的大小很方便。回忆一下，省略数组初始化声明中的大小，编译器会自动计算数组的大小：\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> m2[] = <span class=\"string\">\"If you can't think of anything, fake it.\"</span>;</span><br></pre></td></tr></table></figure>\n\n让编译器确定初始化字符数组的大小很合理。因为处理字符串的函数通常都不知道数组的大小，这些函数通过查找字符串末尾的空字符确定字符串在何处结束。\n\n让编译器计算数组的大小只能用在初始化数组时。如果创建一个稍后再填充的数组，就必须在声明时指定大小。声明数组时，数组大小必须是可求值的整数。在C99新增变长数组之前，数组的大小必须是整型常量，包括由整型常量组成的表达式。\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n=<span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">char</span> cookies[<span class=\"number\">1</span>];　　　　<span class=\"comment\">// 有效</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> cakes[<span class=\"number\">2</span> + <span class=\"number\">5</span>];\t<span class=\"comment\">// 有效，数组大小是整型常量表达式</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> pies[<span class=\"number\">2</span>*<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">long</span> <span class=\"keyword\">double</span>) + <span class=\"number\">1</span>]; <span class=\"comment\">// 有效</span></span><br><span class=\"line\"><span class=\"keyword\">char</span> crumbs[n];　　　　 <span class=\"comment\">// 在C99标准之前无效，C99标准之后这种数组是变长数组</span></span><br></pre></td></tr></table></figure>\n\n字符数组名和其他数组名一样，是该数组首元素的地址。因此，假设有下面的初始化：\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> car[<span class=\"number\">10</span>] = <span class=\"string\">\"Tata\"</span>;</span><br></pre></td></tr></table></figure>\n\n那么，以下表达式都为真：\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">car == &amp;car[<span class=\"number\">0</span>]、*car == <span class=\"string\">'T'</span>、*(car+<span class=\"number\">1</span>) == car[<span class=\"number\">1</span>] == <span class=\"string\">'a'</span>。</span><br></pre></td></tr></table></figure>\n\n还可以使用指针表示法创建字符串。例如，程序清单11.1中使用了下面的声明：\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pt1 = <span class=\"string\">\"Something is pointing at me.\"</span>;</span><br></pre></td></tr></table></figure>\n\n该声明和下面的声明几乎相同：\n\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> ar1[] = <span class=\"string\">\"Something is pointing at me.\"</span>;</span><br></pre></td></tr></table></figure>\n\n以上两个声明表明，`pt1`和`ar1`都是该字符串的地址。在这两种情况下，带双引号的字符串本身决定了预留给字符串的存储空间。尽管如此，这两种形式并不完全相同。</code></pre><ol><li><p><strong>数组和指针</strong></p>\n<p> 数组形式和指针形式有何不同？以上面的声明为例，数组形式（<code>ar1[]</code>）在计算机的内存中分配为一个内含29个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符<code>&#39;\\0&#39;</code>），每个元素被初始化为字符串字面量对应的字符。通常，字符串都作为可执行文件的一部分储存在数据段中。当把程序载入内存时，也载入了程序中的字符串。字符串储存在<strong>静态存储区（static memory）</strong>中。但是，程序在开始运行时才会为该数组分配内存。此时，才将字符串拷贝到数组中（第 12 章将详细讲解）。注意，此时字符串有两个副本。一个是在静态内存中的字符串字面量，另一个是储存在<code>ar1</code>数组中的字符串。</p>\n<p> 此后，编译器便把数组名<code>ar1</code>识别为该数组首元素地址（<code>&amp;ar1[0]</code>）的别名。这里关键要理解，在数组形式中，<code>ar1</code>是地址常量。不能更改<code>ar1</code>，如果改变了<code>ar1</code>，则意味着改变了数组的存储位置（即地址）。可以进行类似<code>ar1+1</code>这样的操作，标识数组的下一个元素。但是不允许进行<code>++ar1</code>这样的操作。递增运算符只能用于变量名前（或概括地说，只能用于可修改的左值），不能用于常量。</p>\n<p> 指针形式（<code>*pt1</code>）也使得编译器为字符串在静态存储区预留29个元素的空间。另外，一旦开始执行程序，它会为指针变量<code>pt1</code>留出一个储存位置，并把字符串的地址储存在指针变量中。该变量最初指向该字符串的首字符，但是它的值可以改变。因此，可以使用递增运算符。例如，<code>++pt1</code>将指向第 2 个字符（<code>o</code>）。</p>\n<p> 字符串字面量被视为<code>const</code>数据。由于<code>pt1</code>指向这个<code>const</code>数据，所以应该把<code>pt1</code>声明为指向<code>const</code>数据的指针。这意味着不能用<code>pt1</code>改变它所指向的数据，但是仍然可以改变<code>pt1</code>的值（即，<code>pt1</code>指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为<code>const</code>。</p>\n<p> 总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。程序清单11.3演示了这一点。</p>\n<p> 程序清单11.3 addresses.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　addresses.c　-- 字符串的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MSG　<span class=\"meta-string\">\"I'm　special\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span>　ar[]　=　MSG;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pt = MSG;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　\\\"I'm　special\\\":　%p　\\n\"</span>,　<span class=\"string\">\"I'm　special\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　address　ar:　%p\\n\"</span>,　ar);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　address　pt:　%p\\n\"</span>,　pt);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　address　of　MSG:　%p\\n\"</span>,　MSG);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　\\\"I'm　special\\\":　%p　\\n\"</span>,　<span class=\"string\">\"I'm　special\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 下面是在我们的系统中运行该程序后的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">address　of　<span class=\"string\">\"I'm　special\"</span>:　<span class=\"number\">0x100000f10</span></span><br><span class=\"line\">address　ar:　<span class=\"number\">0x7fff5fbff858</span></span><br><span class=\"line\">address　pt:　<span class=\"number\">0x100000f10</span></span><br><span class=\"line\">address　of　MSG:　<span class=\"number\">0x100000f10</span></span><br><span class=\"line\">address　of　<span class=\"string\">\"I'm　special\"</span>:　<span class=\"number\">0x100000f10</span></span><br></pre></td></tr></table></figure><p> 该程序的输出说明了什么？第一，<code>pt</code>和<code>MSG</code>的地址相同，而<code>ar</code>的地址不同，这与我们前面讨论的内容一致。第二，虽然字符串字面量<code>&quot;I&#39;m special&quot;</code>在程序的两个 <code>printf()</code>函数中出现了两次，但是编译器只使用了一个存储位置，而且与<code>MSG</code>的地址相同。编译器可以把多次使用的相同字面量储存在一处或多处。另一个编译器可能在不同的位置储存3个<code>&quot;I&#39;m special&quot;</code>。第三，静态数据使用的内存与<code>ar</code>使用的动态内存不同。不仅值不同，特定编译器甚至使用不同的位数表示两种内存。</p>\n<p> 数组和指针表示字符串的区别是否很重要？通常不太重要，但是这取决于想用程序做什么。我们来进一步讨论这个主题。</p>\n</li>\n<li><p>数组和指针的区别</p>\n<p> 初始化字符数组来储存字符串和初始化指针来指向字符串有何区别（“指向字符串”的意思是指向字符串的首字符）？例如，假设有下面两个声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> heart[] = <span class=\"string\">\"I love Tillie!\"</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *head = <span class=\"string\">\"I love Millie!\"</span>;</span><br></pre></td></tr></table></figure><p> 两者主要的区别是：数组名<code>heart</code>是常量，而指针名<code>head</code>是变量。那么，实际使用有什么区别？</p>\n<p> 首先，两者都可以使用数组表示法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　<span class=\"number\">6</span>;　i++)</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(heart[i]);</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　<span class=\"number\">6</span>;　i++)</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(head[i]);</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure><p> 上面两段代码的输出是：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I　love</span><br><span class=\"line\">I　love</span><br></pre></td></tr></table></figure><p> 其次，两者都能进行指针加法操作：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>　(i　=　<span class=\"number\">0</span>;　i　&lt;　<span class=\"number\">6</span>;　i++)</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(*(heart + i));</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\"><span class=\"keyword\">for</span>　(i　=　<span class=\"number\">0</span>;　i　&lt;　<span class=\"number\">6</span>;　i++)</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(*(head + i));</span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br></pre></td></tr></table></figure><p> 输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I　love</span><br><span class=\"line\">I　love</span><br></pre></td></tr></table></figure><p> 但是，<strong>只有指针表示法可以进行递增操作</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (*(head) != <span class=\"string\">'\\0'</span>)　　<span class=\"comment\">/* 在字符串末尾处停止*/</span></span><br><span class=\"line\"><span class=\"built_in\">putchar</span>(*(head++));　　<span class=\"comment\">/* 打印字符，指针指向下一个位置 */</span></span><br></pre></td></tr></table></figure><p> 这段代码的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">I love Millie!</span><br></pre></td></tr></table></figure><p> 假设想让head和heart统一，可以这样做：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">head = heart;　　 <span class=\"comment\">/* head现在指向数组heart */</span></span><br></pre></td></tr></table></figure><p> 这使得<code>head</code>指针指向<code>heart</code>数组的首元素。</p>\n<p> 但是，不能这样做：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heart = head;　　 <span class=\"comment\">/* 非法构造，不能这样写 */</span></span><br></pre></td></tr></table></figure><p> 这类似于<code>x = 3;</code>和<code>3 = x;</code>的情况。赋值运算符的左侧必须是变量（或概括地说是可修改的左值），如<code>*pt_int</code>。顺带一提，<code>head = heart;</code>不会导致<code>head</code>指向的字符串消失，这样做只是改变了储存在<code>head</code>中的地址。除非已经保存了<code>&quot;I love Millie!&quot;</code>的地址，否则当<code>head</code>指向别处时，就无法再访问该字符串。</p>\n<p> 另外，还可以改变<code>heart</code>数组中元素的信息：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">heart[<span class=\"number\">7</span>]= <span class=\"string\">'M'</span>;或者 *(heart + <span class=\"number\">7</span>) = <span class=\"string\">'M'</span>;</span><br></pre></td></tr></table></figure><p> 数组的元素是变量（除非数组被声明为<code>const</code>），但是数组名不是变量。</p>\n<p> 我们来看一下未使用<code>const</code>限定符的指针初始化：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *<span class=\"keyword\">word</span> = <span class=\"string\">\"frame\"</span>;</span><br></pre></td></tr></table></figure><p> 是否能使用该指针修改这个字符串？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">word</span>[<span class=\"number\">1</span>] = <span class=\"string\">'l'</span>; <span class=\"comment\">// 是否允许？</span></span><br></pre></td></tr></table></figure><p> 编译器可能允许这样做，但是对当前的C标准而言，这样的行为是未定义的。例如，这样的语句可能导致内存访问错误。原因前面提到过，编译器可以使用内存中的一个副本来表示所有完全相同的字符串字面量。例如，下面的语句都引用字符串<code>&quot;Klingon&quot;</code>的一个内存位置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *p1 = <span class=\"string\">\"Klingon\"</span>;</span><br><span class=\"line\">p1[<span class=\"number\">0</span>] = <span class=\"string\">'F'</span>; <span class=\"comment\">// ok?</span></span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"Klingon\"</span>);</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\": Beware the %ss!\\n\"</span>, <span class=\"string\">\"Klingon\"</span>);</span><br></pre></td></tr></table></figure><p> 也就是说，编译器可以用相同的地址替换每个<code>&quot;Klingon&quot;</code>实例。如果编译器使用这种单次副本表示法，并允许<code>p1[0]</code>修改<code>&#39;F&#39;</code>，那将影响所有使用该字符串的代码。所以以上语句打印字符串字面量<code>&quot;Klingon&quot;</code>时实际上显示的是<code>&quot;Flingon&quot;</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Flingon: Beware the Flingons!</span><br></pre></td></tr></table></figure><p> 实际上在过去，一些编译器由于这方面的原因，其行为难以捉摸，而另一些编译器则导致程序异常中断。因此，建议在把指针初始化为字符串字面量时使用<code>const</code>限定符：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *pl = <span class=\"string\">\"Klingon\"</span>;　 <span class=\"comment\">// 推荐用法</span></span><br></pre></td></tr></table></figure><p> 然而，把非<code>const</code>数组初始化为字符串字面量却不会导致类似的问题。因为数组获得的是原始字符串的副本。</p>\n<p> 总之，如果不修改字符串，不要用指针指向字符串字面量。</p>\n</li>\n<li><p><strong>字符串数组</strong></p>\n<p> 如果创建一个字符数组会很方便，可以通过数组下标访问多个不同的字符串。程序清单11.4演示了两种方法：指向字符串的指针数组和<code>char</code>类型数组的数组。</p>\n<p> 程序清单11.4 arrchar.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//　arrchar.c -- 指针数组，字符串数组</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SLEN　40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　LIM　5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mytalents[LIM] = &#123;</span><br><span class=\"line\">    <span class=\"string\">\"Adding　numbers　swiftly\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Multiplying　accurately\"</span>,　<span class=\"string\">\"Stashing　data\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Following　instructions　to　the　letter\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Understanding　the　C　language\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> yourtalents[LIM][SLEN]　=　&#123;</span><br><span class=\"line\">    <span class=\"string\">\"Walking　in　a　straight　line\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Sleeping\"</span>,　<span class=\"string\">\"Watching　television\"</span>,</span><br><span class=\"line\">    <span class=\"string\">\"Mailing　letters\"</span>,　<span class=\"string\">\"Reading　email\"</span></span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"Let's　compare　talents.\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%-36s　 %-25s\\n\"</span>,　<span class=\"string\">\"My　Talents\"</span>,　<span class=\"string\">\"Your　Talents\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　LIM;　i++)</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%-36s　 %-25s\\n\"</span>,　mytalents[i],　yourtalents[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nsizeof　mytalents:　%zd,　sizeof　yourtalents:　%zd\\n\"</span>,</span><br><span class=\"line\">    <span class=\"keyword\">sizeof</span>(mytalents),<span class=\"keyword\">sizeof</span>(yourtalents));</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p> 下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Let<span class=\"number\">'</span>s　compare　talents.</span><br><span class=\"line\">My　Talents　　　　　　　　　　　　　　　　　　　　　　　 Your　Talents</span><br><span class=\"line\">Adding　numbers　swiftly　　　　　　　　　　　　　　Walking　in　a　straight　<span class=\"built_in\">line</span></span><br><span class=\"line\">Multiplying　accurately　　　　　　　　　　　　　　Sleeping</span><br><span class=\"line\">Stashing　data　　　　　　　　　　　　　　　　　　　　　Watching　television</span><br><span class=\"line\">Following　instructions　to　the　letter　　　Mailing　letters</span><br><span class=\"line\">Understanding　the　C　language　　　　　　　　　 Reading　email</span><br><span class=\"line\"><span class=\"keyword\">sizeof</span>　mytalents:　<span class=\"number\">40</span>,　<span class=\"keyword\">sizeof</span>　yourtalents:　<span class=\"number\">200</span></span><br></pre></td></tr></table></figure><p> 从某些方面来看，<code>mytalents</code>和<code>yourtalents</code>非常相似。两者都代表5个字符串。使用一个下标时都分别表示一个字符串，如<code>mytalents[0]</code>和<code>yourtalents[0]；</code>使用两个下标时都分别表示一个字符，例如 <code>mytalents[1][2]</code>表示 <code>mytalents</code> 数组中第 2 个指针所指向的字符串的第 3 个字符<code>&#39;l&#39;</code>， <code>yourtalents[1][2]</code>表示<code>youttalentes</code>数组的第2个字符串的第3个字符<code>&#39;e&#39;</code>。而且，两者的初始化方式也相同。</p>\n<p> 但是，它们也有区别。<code>mytalents</code>数组是一个内含5个指针的数组，在我们的系统中共占用40字节。而<code>yourtalents</code>是一个内含5个数组的数组，每个数组内含40个<code>char</code>类型的值，共占用200字节。所以，虽然<code>mytalents[0]</code>和<code>yourtalents[0]</code>都分别表示一个字符串，但<code>mytalents</code>和<code>yourtalents</code>的类型并不相同。<strong><code>mytalents</code>中的指针指向初始化时所用的字符串字面量的位置，这些字符串字面量被储存在静态内存中；而 <code>yourtalents</code> 中的数组则储存着字符串字面量的副本，所以每个字符串都被储存了两次。</strong>此外，为字符串数组分配内存的使用率较低。<code>yourtalents</code> 中的每个元素的大小必须相同，而且必须是能储存最长字符串的大小。</p>\n<p> 我们可以把<code>yourtalents</code>想象成矩形二维数组，每行的长度都是40字节；把<code>mytalents</code>想象成不规则的数组，每行的长度不同。图 11.2 演示了这两种数组的情况（实际上，<code>mytalents</code> 数组的指针元素所指向的字符串不必储存在连续的内存中，图中所示只是为了强调两种数组的不同）。</p>\n</li>\n</ol><p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/矩形数组和不规则数组.png\" class=\"φcy\"></p>\n<p>综上所述，如果要用数组表示一系列待显示的字符串，请使用指针数组，因为它比二维字符数组的效率高。但是，指针数组也有自身的缺点。<code>mytalents</code> 中的指针指向的字符串字面量不能更改；而<code>yourtalentsde</code> 中的内容可以更改。所以，如果要改变字符串或为字符串输入预留空间，不要使用指向字符串字面量的指针。</p>\n<h3 id=\"指针和字符串\">指针和字符串<a href=\"#指针和字符串\" title=\"指针和字符串\"></a></h3><p>读者可能已经注意到了，在讨论字符串时或多或少会涉及指针。实际上，字符串的绝大多数操作都是通过指针完成的。例如，考虑程序清单11.5中的程序。</p>\n<p>程序清单11.5 p_and_s.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* p_and_s.c -- 指针和字符串 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *mesg = <span class=\"string\">\"Don't be a fool!\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *copy;</span><br><span class=\"line\">    copy　=　mesg;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,copy);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"mesg　=　%s;　&amp;mesg　=　%p;　value　=　%p\\n\"</span>,　mesg,　&amp;mesg,　mesg);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"copy　=　%s;　&amp;copy　=　%p;　value　=　%p\\n\"</span>,　copy,　&amp;copy,　copy);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>注意</p>\n<p>如果编译器不识别<code>%p</code>，用<code>%u</code>或<code>%lu</code>代替<code>%p</code>。</p>\n<p>你可能认为该程序拷贝了字符串<code>&quot;Don&#39;t be a fool!&quot;</code>，程序的输出似乎也验证了你的猜测：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Don<span class=\"number\">'</span>t　be　a　fool!</span><br><span class=\"line\">mesg　=　Don<span class=\"number\">'</span>t　be　a　fool!;　&amp;mesg　=　<span class=\"number\">0x0012ff48</span>;　value　=　<span class=\"number\">0x0040a000</span></span><br><span class=\"line\">copy　=　Don<span class=\"number\">'</span>t　be　a　fool!;　&amp;copy　=　<span class=\"number\">0x0012ff44</span>;　value　=　<span class=\"number\">0x0040a000</span></span><br></pre></td></tr></table></figure><p>我们来仔细分析最后两个<code>printf()</code>的输出。首先第1项，<code>mesg</code>和<code>copy</code>都以字符串形式输出（<code>%s</code>转换说明）。这里没问题，两个字符串都是<code>&quot;Don&#39;t be a fool!&quot;</code>。</p>\n<p>接着第2项，打印两个指针的地址。如上输出所示，指针<code>mesg</code>和<code>copy</code>分别储存在地址为<code>0x0012ff48</code>和<code>0x0012ff44</code>的内存中。</p>\n<p>注意最后一项，显示两个指针的值。所谓指针的值就是它储存的地址。<code>mesg</code> 和 <code>copy</code> 的值都是<code>0x0040a000</code>，说明它们都指向的同一个位置。因此，程序并未拷贝字符串。语句<code>copy = mesg;</code>把<code>mesg</code>的值赋给<code>copy</code>，即让<code>copy</code>也指向<code>mesg</code>指向的字符串。</p>\n<p>为什么要这样做？为何不拷贝整个字符串？假设数组有<code>50</code>个元素，考虑一下哪种方法更效率：拷贝一个地址还是拷贝整个数组？通常，程序要完成某项操作只需要知道地址就可以了。如果确实需要拷贝整个数组，可以使用<code>strcpy()</code>或<code>strncpy()</code>函数，本章稍后介绍这两个函数。</p>\n<p>我们已经讨论了如何在程序中定义字符串，接下来看看如何从键盘输入字符串。</p>\n<h2 id=\"字符串输入\">字符串输入<a href=\"#字符串输入\" title=\"字符串输入\"></a></h2><p>如果想把一个字符串读入程序，首先必须预留储存该字符串的空间，然后用输入函数获取该字符串。</p>\n<h3 id=\"分配空间\">分配空间<a href=\"#分配空间\" title=\"分配空间\"></a></h3><p>要做的第 1 件事是分配空间，以储存稍后读入的字符串。前面提到过，这意味着必须要为字符串分配足够的空间。不要指望计算机在读取字符串时顺便计算它的长度，然后再分配空间（计算机不会这样做，除非你编写一个处理这些任务的函数）。假设编写了如下代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> *name;</span><br><span class=\"line\"><span class=\"built_in\">scanf</span>(<span class=\"string\">\"%s\"</span>, name);</span><br></pre></td></tr></table></figure><p>虽然可能会通过编译（编译器很可能给出警告），但是在读入<code>name</code>时，<code>name</code>可能会擦写掉程序中的数据或代码，从而导致程序异常中止。因为<code>scanf()</code>要把信息拷贝至参数指定的地址上，而此时该参数是个未初始化的指针，<code>name</code>可能会指向任何地方。大多数程序员都认为出现这种情况很搞笑，但仅限于评价别人的程序时。</p>\n<p>最简单的方法是，在声明时显式指明数组的大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">char</span> name[<span class=\"number\">81</span>];</span><br></pre></td></tr></table></figure><p>现在<code>name</code>是一个已分配块（81字节）的地址。还有一种方法是使用C库函数来分配内存，第12章将详细介绍。</p>\n<p>为字符串分配内存后，便可读入字符串。C 库提供了许多读取字符串的函数：<code>scanf()</code>、<code>gets()</code>和<code>fgets()</code>。我们先讨论最常用<code>gets()</code>函数。</p>\n<h3 id=\"不幸的gets函数\">不幸的gets()函数<a href=\"#不幸的gets函数\" title=\"不幸的gets()函数\"></a></h3><p>在读取字符串时，<code>scanf()</code>和转换说明<code>%s</code>只能读取一个单词。可是在程序中经常要读取一整行输入，而不仅仅是一个单词。许多年前，<code>gets()</code>函数就用于处理这种情况。<code>gets()</code>函数简单易用，它读取整行输入，直至遇到换行符，然后丢弃换行符，储存其余字符，并在这些字符的末尾添加一个空字符使其成为一个 C 字符串。它经常和 <code>puts()</code>函数配对使用，该函数用于显示字符串，并在末尾添加换行符。程序清单11.6中演示了这两个函数的用法。</p>\n<p>程序清单11.6 getsputs.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*　getsputs.c　-- 使用 gets() 和 puts() */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　STLEN　81</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">char</span> words[STLEN];</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"Enter　a　string,　please.\"</span>);</span><br><span class=\"line\">    gets(words);　<span class=\"comment\">// 典型用法</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Your　string　twice:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,　words);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(words);</span><br><span class=\"line\">    <span class=\"built_in\">puts</span>(<span class=\"string\">\"Done.\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序在某些编译器（或者至少是旧式编译器）中的运行示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter　a　<span class=\"built_in\">string</span>,　please.</span><br><span class=\"line\">I　want　to　learn　about　<span class=\"built_in\">string</span>　theory!</span><br><span class=\"line\">Your　<span class=\"built_in\">string</span>　twice:</span><br><span class=\"line\">I　want　to　learn　about　<span class=\"built_in\">string</span>　theory!</span><br><span class=\"line\">I　want　to　learn　about　<span class=\"built_in\">string</span>　theory!</span><br><span class=\"line\">Done.</span><br></pre></td></tr></table></figure><p>整行输入（除了换行符）都被储存在 <code>words</code> 中，<code>puts(words)</code>和 <code>printf(&quot;%s\\n, words&quot;)</code>的效果相同。</p>\n<p>下面是该程序在另一个编译器中的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter　a　<span class=\"built_in\">string</span>,　please.</span><br><span class=\"line\">warning:　this　program　uses　gets(),　which　is　unsafe.</span><br><span class=\"line\">Oh,　no!</span><br><span class=\"line\">Your　<span class=\"built_in\">string</span>　twice:</span><br><span class=\"line\">Oh,　no!</span><br><span class=\"line\">Oh,　no!</span><br><span class=\"line\">Done.</span><br></pre></td></tr></table></figure><p>编译器在输出中插入了一行警告消息。每次运行这个程序，都会显示这行消息。但是，并非所有的编译器都会这样做。其他编译器可能在编译过程中给出警告，但不会引起你的注意。</p>\n<p>这是怎么回事？问题出在 <code>gets()</code>唯一的参数是 <code>words</code>，它无法检查数组是否装得下输入行。上一章介绍过，数组名会被转换成该数组首元素的地址，因此，<code>gets()</code>函数只知道数组的开始处，并不知道数组中有多少个元素。</p>\n<p>如果输入的字符串过长，会导致<strong>缓冲区溢出（buffer overflow）</strong>，即多余的字符超出了指定的目标空间。如果这些多余的字符只是占用了尚未使用的内存，就不会立即出现问题；如果它们擦写掉程序中的其他数据，会导致程序异常中止；或者还有其他情况。为了让输入的字符串容易溢出，把程序中的<code>STLEN</code>设置为5，程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter　a　<span class=\"built_in\">string</span>,　please.</span><br><span class=\"line\">warning:　this　program　uses　gets(),　which　is　unsafe.</span><br><span class=\"line\">I　think　I<span class=\"number\">'l</span>l　be　just　fine.</span><br><span class=\"line\">Your　<span class=\"built_in\">string</span>　twice:</span><br><span class=\"line\">I　think　I<span class=\"number\">'l</span>l　be　just　fine.</span><br><span class=\"line\">I　think　I<span class=\"number\">'l</span>l　be　just　fine.</span><br><span class=\"line\">Done.</span><br><span class=\"line\">Segmentation　fault:　<span class=\"number\">11</span></span><br></pre></td></tr></table></figure><p><code>“Segmentation fault”</code>（分段错误）似乎不是个好提示，的确如此。在UNIX系统中，这条消息说明该程序试图访问未分配的内存。</p>\n<p>C 提供解决某些编程问题的方法可能会导致陷入另一个尴尬棘手的困境。但是，为什么要特别提到<code>gets()</code>函数？因为该函数的不安全行为造成了安全隐患。过去，有些人通过系统编程，利用<code>gets()</code>插入和运行一些破坏系统安全的代码。</p>\n<p>不久，C 编程社区的许多人都建议在编程时摒弃 <code>gets()</code>。制定 C99 标准的委员会把这些建议放入了标准，承认了<code>gets()</code>的问题并建议不要再使用它。尽管如此，在标准中保留<code>gets()</code>也合情合理，因为现有程序中含有大量使用该函数的代码。而且，只要使用得当，它的确是一个很方便的函数。</p>\n<p>好景不长，C11标准委员会采取了更强硬的态度，直接从标准中废除了<code>gets()</code>函数。既然标准已经发布，那么编译器就必须根据标准来调整支持什么，不支持什么。然而在实际应用中，编译器为了能兼容以前的代码，大部分都继续支持<code>gets()</code>函数。不过，我们使用的编译器，可没那么大方。</p>\n<h3 id=\"gets的替代品\">gets()的替代品<a href=\"#gets的替代品\" title=\"gets()的替代品\"></a></h3><p>过去通常用fgets()来代替gets()，fgets()函数稍微复杂些，在处理输入方面与gets()略有不同。C11标准新增的gets_s()函数也可代替gets()。该函数与gets()函数更接近，而且可以替换现有代码中的gets()。但是，它是stdio.h输入/输出函数系列中的可选扩展，所以支持C11的编译器也不一定支持它。</p>\n<p>1.fgets()函数（和fputs()）</p>\n<p>fgets()函数通过第2个参数限制读入的字符数来解决溢出的问题。该函数专门设计用于处理文件输入，所以一般情况下可能不太好用。fgets()和gets()的区别如下。</p>\n<p>fgets()函数的第2个参数指明了读入字符的最大数量。如果该参数的值是n，那么fgets()将读入n-1个字符，或者读到遇到的第一个换行符为止。</p>\n<p>如果fgets()读到一个换行符，会把它储存在字符串中。这点与gets()不同，gets()会丢弃换行符。</p>\n<p>fgets()函数的第3 个参数指明要读入的文件。如果读入从键盘输入的数据，则以stdin（标准输入）作为参数，该标识符定义在stdio.h中。</p>\n<p>因为 fgets()函数把换行符放在字符串的末尾（假设输入行不溢出），通常要与 fputs()函数（和puts()类似）配对使用，除非该函数不在字符串末尾添加换行符。fputs()函数的第2个参数指明它要写入的文件。如果要显示在计算机显示器上，应使用stdout（标准输出）作为该参数。程序清单11.7演示了fgets()和fputs()函数的用法。</p>\n<p>程序清单11.7 fgets1.c程序</p>\n<p>/*　fgets1.c　– 使用 fgets() 和 fputs() */</p>\n<p>#include　&lt;stdio.h&gt;</p>\n<p>#define　STLEN　14</p>\n<p>int　main(void)</p>\n<p>{</p>\n<p>char　words[STLEN];</p>\n<p>puts(“Enter　a　string,　please.”);</p>\n<p>fgets(words,　STLEN,　stdin);</p>\n<p>printf(“Your　string　twice　(puts(),　then　fputs()):\\n”);</p>\n<p>puts(words);</p>\n<p>fputs(words,　stdout);</p>\n<p>puts(“Enter　another　string,　please.”);</p>\n<p>fgets(words,　STLEN,　stdin);</p>\n<p>printf(“Your　string　twice　(puts(),　then　fputs()):\\n”);</p>\n","prev":{"title":"Step 3　该如何使用进阶的句子？","link":"posts/1b9f695a"},"next":{"title":"台儿庄之旅","link":"posts/1dc37cc8"},"plink":"https://dxsummer.gitee.io/posts/9e369547/","toc":[{"id":"字符串和字符串函数","title":"字符串和字符串函数","index":"1"},{"id":"表示字符串和字符串io","title":"表示字符串和字符串I&#x2F;O","index":"2","children":[{"id":"在程序中定义字符串","title":"在程序中定义字符串","index":"2.1"},{"id":"指针和字符串","title":"指针和字符串","index":"2.2"}]},{"id":"字符串输入","title":"字符串输入","index":"3","children":[{"id":"分配空间","title":"分配空间","index":"3.1"},{"id":"不幸的gets函数","title":"不幸的gets()函数","index":"3.2"},{"id":"gets的替代品","title":"gets()的替代品","index":"3.3"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/9e369547/\" title=\"Step9 字符串和字符串函数\">https://dxsummer.gitee.io/posts/9e369547/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年6月27日","updated":"2020年7月12日"}}