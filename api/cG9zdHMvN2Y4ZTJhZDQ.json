{"title":"python数据结构","date":"2021-04-20T06:11:38.000Z","date_formatted":{"ll":"2021年4月20日","L":"2021/04/20","MM-DD":"04-20"},"link":"posts/7f8e2ad4","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2021-04-21T06:30:45.739Z","content":"<p>常用算法时间和空间复杂度汇总：</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>排序算法</th><th>平均时间复杂度</th><th>最优时间复杂度</th><th>最差时间复杂度</th><th>空间复杂度</th></tr>\n</thead><tbody><tr>\n<td><strong>选择排序</strong></td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>插入排序</strong></td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>冒泡排序</strong></td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>快速排序</strong></td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td></tr>\n<tr>\n<td><strong>堆排序</strong></td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>归并排序</strong></td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛)</td></tr>\n</tbody></table></div></div><h1 id=\"排序\">排序<a href=\"#排序\" title=\"排序\"></a></h1><h2 id=\"插入排序\">插入排序<a href=\"#插入排序\" title=\"插入排序\"></a></h2><p>插入排序的<strong>平均时间复杂度</strong>是O(n2)，最好情况下的时间复杂度是O(n), 最坏情况下的时间复杂度是O(n<sup>2</sup>)。它的<strong>空间复杂度</strong>是O(1)。</p>\n<blockquote>\n<p>排序开始时，我们对范例数组的每一个元素进行遍历。虚线的左侧表示已经有序的元素，右侧表示待排序的元素；递增排序。</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420143721.png\" style=\"zoom:50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420143828.png\" style=\"zoom:50%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(nums)):\t<span class=\"comment\">#遍历未排序的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):\t\t\t<span class=\"comment\">#遍历已有序的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[j]&gt;nums[i]):</span><br><span class=\"line\">\t\t\tins = nums[i]</span><br><span class=\"line\">\t\t\tnums.pop(i)</span><br><span class=\"line\">\t\t\tnums.insert(j,ins)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"选择排序\">选择排序<a href=\"#选择排序\" title=\"选择排序\"></a></h2><h3 id=\"思想\">思想<a href=\"#思想\" title=\"思想\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420190602.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420190733.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420190909.png\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\">res = []       <span class=\"comment\">#用于存储已排序元素的数组</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> len(nums): <span class=\"comment\">#当未排序数组内还有元素时，重复执行选择最小数的代码</span></span><br><span class=\"line\">\tminInd = <span class=\"number\">0</span> <span class=\"comment\">#初始化存储最小数下标的变量，默认为第一个数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>, len(nums)):</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[i] &lt; nums[minInd]): <span class=\"comment\">#更新最小数的下标</span></span><br><span class=\"line\">\t\t\tminInd = i</span><br><span class=\"line\">\ttemp = nums[minInd]</span><br><span class=\"line\">\tnums.pop(minInd) <span class=\"comment\">#把最小数从未排序数组中删除</span></span><br><span class=\"line\">\tres.append(temp) <span class=\"comment\">#把最小数插入到已排序数组的末尾</span></span><br><span class=\"line\">print(res)</span><br></pre></td></tr></table></figure><h3 id=\"程序逻辑\">程序逻辑<a href=\"#程序逻辑\" title=\"程序逻辑\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420191101.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420191156.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420191353.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420191858.png\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>): <span class=\"comment\">#更新有序数组的末尾位置</span></span><br><span class=\"line\">\t\t\tminInd = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i,len(nums)): <span class=\"comment\">#找出未排序数组中最小值的下标</span></span><br><span class=\"line\">\t\t\t\t\t <span class=\"keyword\">if</span> nums[j] &lt; nums[minInd]:</span><br><span class=\"line\">\t\t\t\t\t\t\t\tminInd = j</span><br><span class=\"line\">\t\t\tnums[i],nums[minInd] = nums[minInd],nums[i] <span class=\"comment\">#把最小值加到有序数组末尾</span></span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"冒泡排序\">冒泡排序<a href=\"#冒泡排序\" title=\"冒泡排序\"></a></h2><p>冒泡排序采用来<strong>重复遍历数组并比较相邻两个元素</strong>的方法来排序。</p>\n<p>由于使用冒泡排序算法进行排序的过程中，最大数/最小数会慢慢“浮”到数组的末尾，所以算法由此得名。</p>\n<p>冒泡排序的平均时间复杂度是O(n<sup>2</sup>)，最好情况下的时间复杂度是O(n), 最坏情况下的时间复杂度是O(n<sup>2</sup>)。它的空间复杂度是O(1)。它也是一个稳定的排序算法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003130453.gif\" class=\"φcy\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums),<span class=\"number\">0</span>,<span class=\"number\">-1</span>): <span class=\"comment\">#更新本趟遍历确定的元素位置</span></span><br><span class=\"line\">\t  flag = <span class=\"number\">0</span> \t\t<span class=\"comment\">#flag用于标记是否有元素交换发生</span></span><br><span class=\"line\">\t  <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>): <span class=\"comment\">#遍历未排序的数组</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> nums[j]&gt;nums[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">\t\t\t\t\tnums[j],nums[j+<span class=\"number\">1</span>] = nums[j+<span class=\"number\">1</span>],nums[j]</span><br><span class=\"line\">\t\t\t\t\tflag = <span class=\"number\">1</span> <span class=\"comment\">#标记存在元素交换</span></span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> flag: </span><br><span class=\"line\">\t\t\t <span class=\"keyword\">break</span> <span class=\"comment\">#如果本趟遍历没有发生元素交换，直接跳出循环         </span></span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"归并排序\">归并排序<a href=\"#归并排序\" title=\"归并排序\"></a></h2><p>归并排序算法就是一个先把数列拆分为<strong>子数列</strong>，对子数列进行排序后，再把有序的子数列合并为完整的有序数列的算法。它实际上采用了<strong>分治的思想</strong>。</p>\n<p>归并排序的平均时间复杂度是O(nlogn)，最好情况下的时间复杂度是O(nlogn), 最坏情况下的时间复杂度也是O(nlogn)。它的空间复杂度是O(1)，同时也是一个稳定的排序算法。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421142159.png\" style=\"zoom:67%;\" /><p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131501.gif\" class=\"φcy\"></p>\n<h2 id=\"快速排序\">快速排序<a href=\"#快速排序\" title=\"快速排序\"></a></h2><h2 id=\"希尔排序\">希尔排序<a href=\"#希尔排序\" title=\"希尔排序\"></a></h2><h2 id=\"堆排序\">堆排序<a href=\"#堆排序\" title=\"堆排序\"></a></h2><p>堆是一种数据结构。它是一种<strong>特殊的完全二叉树</strong>。堆排序就是根据堆的特性设计的排序算法。</p>\n<p>如果这个堆是一个<strong>大顶堆</strong>（最大的元素在堆顶），那么每个节点上的元素都应该比它的孩子节点上的元素要大，最大的元素在根节点上。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420143404.png\" alt=\"大顶堆\" style=\"zoom:50%;\" /><p>如果是<strong>小顶堆</strong>，那么每个节点上的元素都应该比它的孩子节点小，最小的元素在根节点上。</p>\n<h2 id=\"桶排序\">桶排序<a href=\"#桶排序\" title=\"桶排序\"></a></h2>","next":{"title":"Java笔记","link":"posts/b6543913"},"plink":"https://dxsummer.gitee.io/posts/7f8e2ad4/","toc":[{"id":"排序","title":"排序","index":"1","children":[{"id":"插入排序","title":"插入排序","index":"1.1"},{"id":"选择排序","title":"选择排序","index":"1.2","children":[{"id":"思想","title":"思想","index":"1.2.1"},{"id":"程序逻辑","title":"程序逻辑","index":"1.2.2"}]},{"id":"冒泡排序","title":"冒泡排序","index":"1.3"},{"id":"归并排序","title":"归并排序","index":"1.4"},{"id":"快速排序","title":"快速排序","index":"1.5"},{"id":"希尔排序","title":"希尔排序","index":"1.6"},{"id":"堆排序","title":"堆排序","index":"1.7"},{"id":"桶排序","title":"桶排序","index":"1.8"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/7f8e2ad4/\" title=\"python数据结构\">https://dxsummer.gitee.io/posts/7f8e2ad4/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2021年4月20日","updated":"2021年4月21日"}}