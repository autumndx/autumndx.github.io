{"title":"python数据结构","date":"2021-04-20T06:11:38.000Z","date_formatted":{"ll":"2021年4月20日","L":"2021/04/20","MM-DD":"04-20"},"link":"posts/7f8e2ad4","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2021-05-31T12:38:49.958Z","content":"<p>常用算法时间和空间复杂度汇总：</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>排序算法</th><th>平均时间复杂度</th><th>最优时间复杂度</th><th>最差时间复杂度</th><th>空间复杂度</th></tr>\n</thead><tbody><tr>\n<td><strong>选择排序</strong></td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>插入排序</strong></td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>冒泡排序</strong></td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>快速排序</strong></td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛<sup>2</sup>)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td></tr>\n<tr>\n<td><strong>堆排序</strong></td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(1)</td></tr>\n<tr>\n<td><strong>归并排序</strong></td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛𝑙𝑜𝑔𝑛)</td><td>𝑂(𝑛)</td></tr>\n</tbody></table></div></div><h1 id=\"排序\">排序<a href=\"#排序\" title=\"排序\"></a></h1><h2 id=\"插入排序\">插入排序<a href=\"#插入排序\" title=\"插入排序\"></a></h2><p>插入排序的<strong>平均时间复杂度</strong>是O(n2)，最好情况下的时间复杂度是O(n), 最坏情况下的时间复杂度是O(n<sup>2</sup>)。它的<strong>空间复杂度</strong>是O(1)。</p>\n<blockquote>\n<p>排序开始时，我们对范例数组的每一个元素进行遍历。虚线的左侧表示已经有序的元素，右侧表示待排序的元素；递增排序。</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420143721.png\" style=\"zoom:50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420143828.png\" style=\"zoom:50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131210.gif\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(nums)):\t<span class=\"comment\">#遍历未排序的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i):\t\t\t<span class=\"comment\">#遍历已有序的元素</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(nums[j]&gt;nums[i]):</span><br><span class=\"line\">\t\t\tins = nums[i]</span><br><span class=\"line\">\t\t\tnums.pop(i)</span><br><span class=\"line\">\t\t\tnums.insert(j,ins)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">break</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"选择排序\">选择排序<a href=\"#选择排序\" title=\"选择排序\"></a></h2><p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131349.gif\" class=\"φcy\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>): <span class=\"comment\">#更新有序数组的末尾位置</span></span><br><span class=\"line\">\t\t\tminInd = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i,len(nums)): <span class=\"comment\">#找出未排序数组中最小值的下标</span></span><br><span class=\"line\">\t\t\t\t\t <span class=\"keyword\">if</span> nums[j] &lt; nums[minInd]:</span><br><span class=\"line\">\t\t\t\t\t\t\t\tminInd = j</span><br><span class=\"line\">\t\t\tnums[i],nums[minInd] = nums[minInd],nums[i] <span class=\"comment\">#把最小值加到有序数组末尾</span></span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"冒泡排序\">冒泡排序<a href=\"#冒泡排序\" title=\"冒泡排序\"></a></h2><p>冒泡排序采用来<strong>重复遍历数组并比较相邻两个元素</strong>的方法来排序。</p>\n<p>由于使用冒泡排序算法进行排序的过程中，最大数/最小数会慢慢“浮”到数组的末尾，所以算法由此得名。</p>\n<p>冒泡排序的平均时间复杂度是O(n<sup>2</sup>)，最好情况下的时间复杂度是O(n), 最坏情况下的时间复杂度是O(n<sup>2</sup>)。它的空间复杂度是O(1)。它也是一个稳定的排序算法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003130453.gif\" class=\"φcy\"></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums),<span class=\"number\">0</span>,<span class=\"number\">-1</span>): <span class=\"comment\">#更新本趟遍历确定的元素位置</span></span><br><span class=\"line\">\t  flag = <span class=\"number\">0</span> \t\t<span class=\"comment\">#flag用于标记是否有元素交换发生</span></span><br><span class=\"line\">\t  <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>): <span class=\"comment\">#遍历未排序的数组</span></span><br><span class=\"line\">\t\t\t <span class=\"keyword\">if</span> nums[j]&gt;nums[j+<span class=\"number\">1</span>]:</span><br><span class=\"line\">\t\t\t\t\tnums[j],nums[j+<span class=\"number\">1</span>] = nums[j+<span class=\"number\">1</span>],nums[j]</span><br><span class=\"line\">\t\t\t\t\tflag = <span class=\"number\">1</span> <span class=\"comment\">#标记存在元素交换</span></span><br><span class=\"line\">\t  <span class=\"keyword\">if</span> <span class=\"keyword\">not</span> flag: </span><br><span class=\"line\">\t\t\t <span class=\"keyword\">break</span> <span class=\"comment\">#如果本趟遍历没有发生元素交换，直接跳出循环         </span></span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"归并排序\">归并排序<a href=\"#归并排序\" title=\"归并排序\"></a></h2><p>归并排序算法就是一个先把数列拆分为<strong>子数列</strong>，对子数列进行排序后，再把有序的子数列合并为完整的有序数列的算法。它实际上采用了<strong>分治的思想</strong>。</p>\n<p>归并排序的平均时间复杂度是O(nlogn)，最好情况下的时间复杂度是O(nlogn), 最坏情况下的时间复杂度也是O(nlogn)。它的空间复杂度是O(1)，同时也是一个稳定的排序算法。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131501.gif\" class=\"φcy\"></p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421142159.png\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#归并排序</span></span><br><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MergeSort</span><span class=\"params\">(num)</span>:</span> </span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(len(num)&lt;=<span class=\"number\">1</span>): \t\t\t\t<span class=\"comment\">#递归边界条件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> num \t\t\t\t\t<span class=\"comment\">#到达边界时返回当前的子数组</span></span><br><span class=\"line\">\tmid = int(len(num)/<span class=\"number\">2</span>) \t\t\t<span class=\"comment\">#求出数组的中位数</span></span><br><span class=\"line\">\tllist,rlist = MergeSort(num[:mid]),MergeSort(num[mid:])<span class=\"comment\">#调用函数分别为左右数组排序</span></span><br><span class=\"line\">\tresult = []</span><br><span class=\"line\">\ti,j = <span class=\"number\">0</span>,<span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> i &lt; len(llist) <span class=\"keyword\">and</span> j &lt; len(rlist): <span class=\"comment\">#while循环用于合并两个有序数组</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> rlist[j]&lt;llist[i]:</span><br><span class=\"line\">\t\t\tresult.append(rlist[j])</span><br><span class=\"line\">\t\t\tj += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tresult.append(llist[i])</span><br><span class=\"line\">\t\t\ti += <span class=\"number\">1</span></span><br><span class=\"line\">\tresult += llist[i:]+rlist[j:] \t<span class=\"comment\">#把数组未添加的部分加到结果数组末尾</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> result \t\t\t\t\t<span class=\"comment\">#返回已排序的数组</span></span><br><span class=\"line\">print(MergeSort(nums))</span><br></pre></td></tr></table></figure><h2 id=\"快速排序\">快速排序<a href=\"#快速排序\" title=\"快速排序\"></a></h2><p>快速排序（Quick Sort），是冒泡排序的改进版，之所以“快速”，是因为使用了<strong>分治法</strong>。它也属于<strong>交换排序</strong>，通过元素之间的位置交换来达到排序的目的。</p>\n<p><strong>基本思想</strong></p>\n<p>在序列中随机<strong>挑选一个元素作基准</strong>，将<strong>小于基准的元素放在基准之前</strong>，<strong>大于基准的元素放在基准之后</strong>，再分别对小数区与大数区进行排序。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131038.gif\" class=\"φcy\" alt=\"img\"></p>\n<blockquote>\n<p>基础版</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">QuickSort</span><span class=\"params\">(num)</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> len(num) &lt;= <span class=\"number\">1</span>: <span class=\"comment\">#边界条件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> num</span><br><span class=\"line\">\tkey = num[<span class=\"number\">0</span>] <span class=\"comment\">#取数组的第一个数为基准数</span></span><br><span class=\"line\">\tllist,rlist,mlist = [],[],[key] <span class=\"comment\">#定义空列表，分别存储小于/大于/等于基准数的元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(num)): <span class=\"comment\">#遍历数组，把元素归类到3个列表中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> num[i] &gt; key:</span><br><span class=\"line\">\t\t\trlist.append(num[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">elif</span> num[i] &lt; key:</span><br><span class=\"line\">\t\t\tllist.append(num[i])</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>:</span><br><span class=\"line\">\t\t\tmlist.append(num[i])</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> QuickSort(llist)+mlist+QuickSort(rlist) <span class=\"comment\">#对左右子列表快排，拼接3个列表并返回</span></span><br><span class=\"line\">print(QuickSort(nums))</span><br></pre></td></tr></table></figure><blockquote>\n<p>原版</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">QSort</span><span class=\"params\">(left,right)</span>:</span> <span class=\"comment\">#子数组第一个元素和最后一个元素在原数组中的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(left &gt;= right): <span class=\"comment\">#边界条件</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\tl,r,key = left,right,nums[left] <span class=\"comment\">#初始化左指针，右指针和基准值</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span>(l &lt; r): <span class=\"comment\">#调整元素位置</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[r] &gt;= key:</span><br><span class=\"line\">\t\t\tr -= <span class=\"number\">1</span></span><br><span class=\"line\">\t\tnums[l] = nums[r]</span><br><span class=\"line\">\t\t<span class=\"keyword\">while</span> l &lt; r <span class=\"keyword\">and</span> nums[l] &lt; key:</span><br><span class=\"line\">\t\t\tl += <span class=\"number\">1</span></span><br><span class=\"line\">\t\tnums[r] = nums[l]</span><br><span class=\"line\">\tnums[l] = key <span class=\"comment\">#把基准值赋给左指针和右指针共同指向的位置</span></span><br><span class=\"line\">\tQSort(left,l<span class=\"number\">-1</span>) <span class=\"comment\">#左侧数组排序</span></span><br><span class=\"line\">\tQSort(l+<span class=\"number\">1</span>,right) <span class=\"comment\">#右侧数组排序</span></span><br><span class=\"line\">QSort(<span class=\"number\">0</span>,len(nums)<span class=\"number\">-1</span>)</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"希尔排序\">希尔排序<a href=\"#希尔排序\" title=\"希尔排序\"></a></h2><p>希尔排序，又叫“缩小增量排序”，是对插入排序进行优化后产生的一种排序算法。它的执行思路是：把数组内的元素按下标增量分组，对每一组元素进行插入排序后，缩小增量并重复之前的步骤，直到增量到达1。</p>\n<p>一般来说，希尔排序的时间复杂度在O(n1.3)到O(n2)之间，这视增量大小而定。希尔排序的空间复杂度是O(1)，它是一个不稳定的排序算法。进行希尔排序时，元素一次移动可能跨越多个元素，从而可能抵消多次移动，提高了效率。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131254.gif\" alt=\"img\" style=\"zoom: 80%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421155200.png\" style=\"zoom: 50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421155328.png\" style=\"zoom:50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421155426.png\" style=\"zoom:50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421155540.png\" style=\"zoom: 50%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">4</span>,<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>,<span class=\"number\">7</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">ShellSort</span><span class=\"params\">(nums)</span>:</span></span><br><span class=\"line\">\tstep = len(nums)//<span class=\"number\">2</span> \t<span class=\"comment\">#初始化增量为数组长度的一半</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> step &gt; <span class=\"number\">0</span>: \t<span class=\"comment\">#增量必须是大于0的整数</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(step,len(nums)): <span class=\"comment\">#遍历需要进行插入排序的数</span></span><br><span class=\"line\">\t\t\tind = i</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span> ind &gt;= step <span class=\"keyword\">and</span> nums[ind] &lt; nums[ind-step]: <span class=\"comment\">#对每组进行插入排序</span></span><br><span class=\"line\">\t\t\t\tnums[ind],nums[ind-step] = nums[ind-step],nums[ind]</span><br><span class=\"line\">\t\t\t\tind -= step</span><br><span class=\"line\">\t\tstep //= <span class=\"number\">2</span> \t\t<span class=\"comment\">#增量缩小一半</span></span><br><span class=\"line\">\tprint(nums)</span><br><span class=\"line\">ShellSort(nums)</span><br></pre></td></tr></table></figure><h2 id=\"堆排序\">堆排序<a href=\"#堆排序\" title=\"堆排序\"></a></h2><p>堆是一种数据结构。它是一种<strong>特殊的完全二叉树</strong>。堆排序就是根据堆的特性设计的排序算法。</p>\n<p>如果这个堆是一个<strong>大顶堆</strong>（最大的元素在堆顶），那么每个节点上的元素都应该比它的孩子节点上的元素要大，最大的元素在根节点上。</p>\n<p>如果是<strong>小顶堆</strong>，那么每个节点上的元素都应该比它的孩子节点小，最小的元素在根节点上。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210420143404.png\" alt=\"大顶堆\" style=\"zoom:50%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131424.gif\" alt=\"img\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210421192600.png\" style=\"zoom:50%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">61</span>,<span class=\"number\">8</span>,<span class=\"number\">953</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">72</span>,<span class=\"number\">310</span>,<span class=\"number\">113</span>,<span class=\"number\">93</span>,<span class=\"number\">112</span>,<span class=\"number\">32</span>,<span class=\"number\">43</span>,<span class=\"number\">15</span>,<span class=\"number\">5</span>,<span class=\"number\">20</span>,<span class=\"number\">999</span>,<span class=\"number\">678</span>,<span class=\"number\">34</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>]</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Heapify</span><span class=\"params\">(start,end)</span>:</span> <span class=\"comment\">#向下调整的函数，传入数据为堆顶节点的编号和堆末尾的界限值</span></span><br><span class=\"line\">\tfather = start</span><br><span class=\"line\">\tson = father * <span class=\"number\">2</span> <span class=\"comment\">#son存储较大的子节点的编号，初始化为左子节点</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> son &lt;= end: <span class=\"comment\">#当目前数据所处的节点还有子节点时，继续循环调整</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> son+<span class=\"number\">1</span> &lt;= end <span class=\"keyword\">and</span> nums[son+<span class=\"number\">1</span>] &gt; nums[son]: </span><br><span class=\"line\">\t\t\t<span class=\"comment\">#如果存在右节点且其值大于左子节点的值，son存储右子节点的编号</span></span><br><span class=\"line\">\t\t\tson += <span class=\"number\">1</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> nums[father] &lt; nums[son]:<span class=\"comment\">#如果父亲节点的值小于子节点</span></span><br><span class=\"line\">\t\t\tnums[father],nums[son] = nums[son],nums[father] <span class=\"comment\">#交换父亲和子节点</span></span><br><span class=\"line\">\t\t\tfather = son</span><br><span class=\"line\">\t\t\tson = father * <span class=\"number\">2</span> <span class=\"comment\">#进入下一层继续调整</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>: <span class=\"comment\">#如果父亲节点大于等于子节点，调整完成</span></span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">HeapInit</span><span class=\"params\">()</span>:</span> <span class=\"comment\">#初始化大顶堆的函数</span></span><br><span class=\"line\">\tnums.insert(<span class=\"number\">0</span>,<span class=\"number\">0</span>) </span><br><span class=\"line\">\t<span class=\"comment\">#堆顶编号从开始，在位置0插入一个数使得堆中元素的编号与在数组中的下标一样</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range((len(nums)<span class=\"number\">-1</span>)//<span class=\"number\">2</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>): <span class=\"comment\">#从最底层最右侧的的非叶子节点开始调整</span></span><br><span class=\"line\">\t\tHeapify(i,len(nums)<span class=\"number\">-1</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">HeapSort</span><span class=\"params\">()</span>:</span> <span class=\"comment\">#堆排序函数</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(nums)<span class=\"number\">-1</span>,<span class=\"number\">0</span>,<span class=\"number\">-1</span>): <span class=\"comment\">#从堆末尾开始进行元素交换</span></span><br><span class=\"line\">\t\tnums[<span class=\"number\">1</span>],nums[i] = nums[i],nums[<span class=\"number\">1</span>]</span><br><span class=\"line\">\t\tHeapify(<span class=\"number\">1</span>,i<span class=\"number\">-1</span>)</span><br><span class=\"line\">HeapInit()</span><br><span class=\"line\">HeapSort()</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure><h2 id=\"桶排序\">桶排序<a href=\"#桶排序\" title=\"桶排序\"></a></h2><p>桶排序（Bucket sort）是<a href=\"https://blog.fiteen.top/2019/sorting-algorithm#counting-sort\" target=\"_blank\">计数排序</a>的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。</p>\n<p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（也有可能是使用别的排序算法或是以递归方式继续用桶排序进行排序）。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/c/20201003131527.gif\" alt=\"img\" style=\"zoom: 67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">countn = [<span class=\"number\">0</span>]*<span class=\"number\">51</span> <span class=\"comment\">#建立足够的桶</span></span><br><span class=\"line\">nums,result = [<span class=\"number\">1</span>,<span class=\"number\">1</span>,<span class=\"number\">3</span>,<span class=\"number\">19</span>,<span class=\"number\">35</span>,<span class=\"number\">49</span>,<span class=\"number\">50</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">16</span>],[]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> nums:</span><br><span class=\"line\">\tcountn[i] += <span class=\"number\">1</span> <span class=\"comment\">#统计每个元素出现的次数</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,len(countn)):</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> countn[i]: <span class=\"comment\">#如果桶内有元素</span></span><br><span class=\"line\">\t\tresult += [i]*countn[i] <span class=\"comment\">#往结果数组中加上相应数量的元素。</span></span><br><span class=\"line\">print(result)</span><br></pre></td></tr></table></figure><h1 id=\"查找\">查找<a href=\"#查找\" title=\"查找\"></a></h1><p><strong>静态查找</strong>：程序只对查找表进行<strong>查询并返回信息</strong><br><strong>动态查找</strong>：在静态查找的基础上，还增加了<strong>增删查找表中数据元素的操作</strong>。</p>\n<h2 id=\"顺序查找\">顺序查找<a href=\"#顺序查找\" title=\"顺序查找\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210424195412.png\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">4</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">1</span>]</span><br><span class=\"line\">key = int(input())\t<span class=\"comment\">#输入关键字</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (len(arr)):  <span class=\"comment\">#顺序遍历列表</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> arr[i] == key:</span><br><span class=\"line\">        print(i)</span><br><span class=\"line\">        <span class=\"keyword\">break</span>   <span class=\"comment\">#保证只输出第一个位置就跳出遍历循环</span></span><br><span class=\"line\">    <span class=\"comment\">#关键字不存在于列表中</span></span><br><span class=\"line\">    print(<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure><h2 id=\"二分查找\">二分查找<a href=\"#二分查找\" title=\"二分查找\"></a></h2><p>二分查找，也叫<strong>折半查找</strong>，是一种适用于<strong>顺序存储结构</strong>的查找方法。它是一种效率较高的查找方法，时间复杂度为<code>O(log n)</code>，但它仅能用于有序表中——也就是说，表中的元素需按关键字大小有序排列。</p>\n<p>二分查找用左右两个指针来标注查找范围。程序开始时，查找范围是整个线性表，左指针指向第一个元素，右指针指向最后一个元素；每一次循环过后，查找范围都缩小为原先的一半，直到左右指针重叠。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210424203040.gif\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">l = [<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">10</span>,<span class=\"number\">15</span>,<span class=\"number\">16</span>,<span class=\"number\">18</span>,<span class=\"number\">22</span>,<span class=\"number\">26</span>,<span class=\"number\">30</span>]</span><br><span class=\"line\">l,r = <span class=\"number\">0</span>, len(arr)<span class=\"number\">-1</span>     <span class=\"comment\">#初始化左右指针</span></span><br><span class=\"line\">n = int (input())       <span class=\"comment\">#输入关键字</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> l &lt;= r:       <span class=\"comment\">#判断是否存在合理的查找范围</span></span><br><span class=\"line\">    mid = (l+r)//<span class=\"number\">2</span>  <span class=\"comment\">#求出左右指针的平均数</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> arr[mid] &lt; n:    <span class=\"comment\">#折半缩小查找范围</span></span><br><span class=\"line\">        l = mid + <span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">elif</span> arr[mid] &gt; n:</span><br><span class=\"line\">        r= mid <span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:   <span class=\"comment\">#如果mid指向的元素与关键字相等，直接输出下标并跳出循环</span></span><br><span class=\"line\">        print(mid)</span><br><span class=\"line\">        <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"comment\">#while循环自然结束，说明没有查找到与关键字相等的元素</span></span><br><span class=\"line\">print(<span class=\"number\">-1</span>)</span><br></pre></td></tr></table></figure><h2 id=\"树\">树<a href=\"#树\" title=\"树\"></a></h2><p>树是一种由n个元素组成的集合。<br>当n=0时，树被称作<strong>空树</strong>。<br>当n&gt;0时，树被称作<strong>非空树</strong>。</p>\n<p>对于非空树，最基本的概念有三：</p>\n<ol><li><p>树中的每个元素被称为<strong>节点</strong></p>\n</li>\n<li><p>树最顶层的节点称作<strong>根节点</strong>；每棵树只有一个特定的<strong>根节点</strong>，它没有直接前驱。</p>\n</li>\n<li><p>当n&gt;1时，根节点及其之下的所有节点构成原树，而根节点之外的节点可以被划分为m个互不相交的有限集T1, T2, …Tm。每个集合Ti本身也是一棵树，被称作<strong>根的子树</strong>。</p>\n</li>\n</ol><p>由若干棵互不重合的树构成的集合称作<strong>森林</strong>。</p>\n<p>对于树中的每个节点而言，其<strong>所有子树的集合</strong>就为森林。</p>\n<p>而树还分为两种，<strong>有序树</strong>和<strong>无序树</strong>。有序树中的节点有顺序关系，不能轻易改变其中的排列；而无序树中的节点没有顺序关系，又被称作<strong>自由树</strong>。</p>\n<h3 id=\"二叉树\">二叉树<a href=\"#二叉树\" title=\"二叉树\"></a></h3><p><a href=\"https://dxsummer.gitee.io/posts/ec2e91f9\" target=\"_blank\">树和二叉树 - Dx (gitee.io)</a></p>\n<p><strong>类的定义</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>:</span>\t<span class=\"comment\">#二叉树节点的定义</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, val)</span>:</span></span><br><span class=\"line\">\t\tself.val = val\t<span class=\"comment\">#二叉树的值</span></span><br><span class=\"line\">\t\tself.left = <span class=\"literal\">None</span>\t<span class=\"comment\">#左孩子的节点</span></span><br><span class=\"line\">\t\tself.right= <span class=\"literal\">None</span>\t<span class=\"comment\">#右孩子的节点</span></span><br></pre></td></tr></table></figure><p><strong>创建树</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Input=[<span class=\"number\">0</span>]\t<span class=\"comment\">#Input列表用于存储输入</span></span><br><span class=\"line\">tree=[<span class=\"number\">0</span>]\t<span class=\"comment\">#tree列表用于存储节点</span></span><br><span class=\"line\">Input=Input+input().split()\t</span><br><span class=\"line\">\t<span class=\"comment\">#a1,a2,…,an = input().split()用在接收多个用户输入的时候。（空格分开）</span></span><br><span class=\"line\">cnt=<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> Input:\t<span class=\"comment\">#将所有节点转换为treenode类型</span></span><br><span class=\"line\">    tmp=TreeNode(item)</span><br><span class=\"line\">    tree.append(tmp)</span><br><span class=\"line\"><span class=\"keyword\">for</span> item <span class=\"keyword\">in</span> tree:</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> item.val==<span class=\"string\">\"null\"</span>:\t<span class=\"comment\">#若节点为“null”，则不加入tree中</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">continue</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"number\">2</span>*cnt &lt;= len(Input) <span class=\"keyword\">and</span> tree[<span class=\"number\">2</span>*cnt].val != <span class=\"string\">\"null\"</span>:<span class=\"comment\">#找到每个节点的左子节点</span></span><br><span class=\"line\">\t\titem.left = tree[<span class=\"number\">2</span>*cnt]</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> <span class=\"number\">2</span>*cnt + <span class=\"number\">1</span> &lt;= len(Input) <span class=\"keyword\">and</span> tree[<span class=\"number\">2</span>*cnt + <span class=\"number\">1</span>].val != <span class=\"string\">\"null\"</span>:<span class=\"comment\">#找到每个节点的右子节点</span></span><br><span class=\"line\">\t\titem.right = tree[<span class=\"number\">2</span> * cnt + <span class=\"number\">1</span>]</span><br><span class=\"line\">\tcnt += <span class=\"number\">1</span></span><br></pre></td></tr></table></figure><p><strong>遍历二叉树</strong></p>\n<p><strong>列表下标表示二叉树遍历</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder</span><span class=\"params\">(i)</span>:</span> <span class=\"comment\">#先序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> tree[i]==<span class=\"number\">0</span>:</span><br><span class=\"line\">        <span class=\"keyword\">return</span></span><br><span class=\"line\">\tprint(tree[i])</span><br><span class=\"line\">\tpreorder(<span class=\"number\">2</span>*i)</span><br><span class=\"line\">\tpreorder(<span class=\"number\">2</span>*i+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(i)</span>:</span>\t<span class=\"comment\">#中序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> tree[i] == <span class=\"number\">0</span>:</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">\tinorder(<span class=\"number\">2</span>*i)</span><br><span class=\"line\">\tprint(tree[i])</span><br><span class=\"line\">\tinorder(<span class=\"number\">2</span>*i+<span class=\"number\">1</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(i)</span>:</span>\t<span class=\"comment\">#后序遍历</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> tree[i] == <span class=\"number\">0</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> </span><br><span class=\"line\">\tpostorder(<span class=\"number\">2</span>*i)</span><br><span class=\"line\">\tpostorder(<span class=\"number\">2</span>*i+<span class=\"number\">1</span>)</span><br><span class=\"line\">\tprint(tree[i])</span><br></pre></td></tr></table></figure><p><strong>以存储的左右孩子地址表示二叉树 遍历函数写在类的内部</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TreeNode</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self,x)</span>:</span></span><br><span class=\"line\">\t\tself.val = x</span><br><span class=\"line\">\t\tself.left = <span class=\"literal\">None</span></span><br><span class=\"line\">\t\tself.right = <span class=\"literal\">None</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BST</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, tlist)</span>:</span></span><br><span class=\"line\">\t\tself.root = TreeNode(tlist[<span class=\"number\">0</span>])</span><br><span class=\"line\">\t\t<span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> tlist[<span class=\"number\">1</span>:]:</span><br><span class=\"line\">\t\t\tself.insert(i)</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">preorder</span><span class=\"params\">(self,node)</span>:</span>\t<span class=\"comment\">#先序遍历</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\tprint(node.val)</span><br><span class=\"line\">\t\tself.preorder(node.left)</span><br><span class=\"line\">\t\tself.preorder(node.right)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">inorder</span><span class=\"params\">(self,node)</span>:</span> <span class=\"comment\">#中序遍历</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\tself.inorder(node.left)</span><br><span class=\"line\">\t\tprint(node.val)</span><br><span class=\"line\">\t\tself.inorder(node.right)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">postorder</span><span class=\"params\">(self,node)</span>:</span>  <span class=\"comment\">#后序遍历</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span> node <span class=\"keyword\">is</span> <span class=\"literal\">None</span>:</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span></span><br><span class=\"line\">\t\tself.postorder(node.left)</span><br><span class=\"line\">\t\tself.postorder(node.right)</span><br><span class=\"line\">\t\tprint(node.val)</span><br></pre></td></tr></table></figure><h3 id=\"二叉搜索树\">二叉搜索树<a href=\"#二叉搜索树\" title=\"二叉搜索树\"></a></h3><p>二叉树(Binary Search Tree)是一种特殊的二叉树，树中的元素排列符合二叉搜索树性质。二叉搜索树中，每一个节点存储的元素称作该节点的<strong>键值</strong></p>\n<p>二叉搜索树可以是一棵空树，也可以是具有如下几条性质的一棵二叉树：</p>\n<ol><li><p>若任意一个节点的左子树非空，那么左子树中所有的元素都小于当前节点存储的元素。</p>\n</li>\n<li><p>若任意一个节点的右子树非空，那么右子树中所有的元素都大于当前节点存储的元素。</p>\n</li>\n<li><p>任意一个节点的左右子树也为二叉搜索树。</p>\n</li>\n<li><p>二叉搜索树中<strong>没有两个节点有相同的键值</strong>。</p>\n</li>\n</ol><p>根据这些性质可以推出, 插入, 删除和查找操作的时间复杂度都是O(log n)。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210425201609.webp\" style=\"zoom: 67%;\" /><blockquote>\n<p>二叉搜索树支持的操作有：</p>\n</blockquote>\n<p>(1)建立二叉搜索树<br>(2)插入键值为x的节点<br>(3)查询键值为x的节点在二叉搜索树中的排名<br>(4)删除键值为x的节点<br>(5)求键值为x的节点的前驱与后继</p>\n<h3 id=\"平衡二叉树\">平衡二叉树<a href=\"#平衡二叉树\" title=\"平衡二叉树\"></a></h3><p>平衡二叉树是一种特别形式的二叉搜索树，它采用平衡化旋转来避免二叉搜索树出现退化的情况</p>\n<h4 id=\"avl树\">AVL树<a href=\"#avl树\" title=\"AVL树\"></a></h4><p>平衡二叉树，又称<strong>AVL树</strong>。它维持二叉搜索树平衡的根本在于持续维护这样一个性质：二叉搜索树中，每一个节点的<strong>左右子树深度差的绝对值不大于1</strong>。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210425202101.png\" style=\"zoom: 50%;\" /><blockquote>\n<p>如何判断一棵树是否符合AVL树的性质？答案就是维护每个节点的平衡因子。</p>\n</blockquote>\n<p>每个节点的平衡因子即为节点左子树的深度减去右子树的深度得到的差。在符合AVL性质的情况下，平衡因子只能取-1, 0, 1。</p>\n<p>正因这样，在插入或删除一个节点之后，在它们路径上的节点的平衡因子都需要被更新。</p>\n<h1 id=\"双指针问题\">双指针问题<a href=\"#双指针问题\" title=\"双指针问题\"></a></h1><h2 id=\"指针的概念\">指针的概念<a href=\"#指针的概念\" title=\"指针的概念\"></a></h2><p>指针存储着计算机中一个内存空间的地址，是编程语言中的一个对象。通过它存储的地址，计算机可以找到存储在计算机存储器中另一个地方的变量单元。一个特定的地址指针指向一个特定的变量单元。在重复读取数据的情况下，使用指针可以改善程序性能。同时，指针还可以有效利用存储器中非连续的内存。</p>\n<h2 id=\"链表的概念\">链表的概念<a href=\"#链表的概念\" title=\"链表的概念\"></a></h2><p>链表是用指针<strong>连接的用于存储数据的数组</strong>。在很多编程语言中，定义数组的大小后不能随便更改，而且数组中只能存储同一类型的变量。为解决这个问题，程序员使用链表来达到随时向数组中添加各种数据的目的。</p>\n<p>在Python中，并不存在实际意义上的指针，所以也不存在实际意义上的链表。即便如此，Python中列表的工作原理就是链表。所以，我们用模拟指针的方法来实现链表，以表现链表连接各个元素的逻辑思维。</p>\n<h2 id=\"单链表\">单链表<a href=\"#单链表\" title=\"单链表\"></a></h2><p>链表的每个元素不仅仅存储这个元素的值，还要存储与它相连的元素的地址，起到连接元素的效果。这个存储在元素中的地址就是指向下一个元素的指针。</p>\n<p>单链表的每个元素包含本身的值和一个指向下一个元素的指针。因为链表的最后一个数没有下一个数，所以它的指针为空指针。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426192920.png\" style=\"zoom: 67%;\" /><h3 id=\"遍历单链表\">遍历单链表<a href=\"#遍历单链表\" title=\"遍历单链表\"></a></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListValue = [<span class=\"number\">1</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">3</span>]</span><br><span class=\"line\">ListPointer = [<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">-1</span>,<span class=\"number\">5</span>,<span class=\"number\">1</span>,<span class=\"number\">4</span>]</span><br><span class=\"line\">head = <span class=\"number\">0</span>                    \t\t<span class=\"comment\">#head是指向链表第一个元素的指针，需要自己定义</span></span><br><span class=\"line\">next = head    \t\t\t\t<span class=\"comment\">#给next赋初始值</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> next != <span class=\"number\">-1</span>:            \t<span class=\"comment\">#next是指向下一个元素的指针，不等于-1代表后面还有元素</span></span><br><span class=\"line\">\tprint(ListValue[next])   \t<span class=\"comment\">#输出下一个元素中存储的值</span></span><br><span class=\"line\">\tnext = ListPointer[next] \t<span class=\"comment\">#把指针变为下一个元素中存储的指针</span></span><br></pre></td></tr></table></figure><h3 id=\"插入元素\">插入元素<a href=\"#插入元素\" title=\"插入元素\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426194103.png\" style=\"zoom:67%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListValue = [<span class=\"number\">1</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">2</span>]</span><br><span class=\"line\">ListRight = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">head = <span class=\"number\">0</span>                              <span class=\"comment\">#初始化头指针</span></span><br><span class=\"line\">num = <span class=\"number\">3</span>                               <span class=\"comment\">#num为要插入的元素    </span></span><br><span class=\"line\">next,last = head,head              <span class=\"comment\">#初始化表示插入位置的下一个元素和上一个元素的指针</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">Output</span><span class=\"params\">()</span>:</span>                    <span class=\"comment\">#定义一个函数用于输出链表</span></span><br><span class=\"line\">   next = head</span><br><span class=\"line\">   <span class=\"keyword\">while</span> next != <span class=\"number\">-1</span>:</span><br><span class=\"line\">      print(ListValue[next])</span><br><span class=\"line\">      next = ListRight[next]</span><br><span class=\"line\"></span><br><span class=\"line\">Output()                              <span class=\"comment\">#输出列表查看插入前的顺序</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">while</span> ListValue[next] &lt;= num <span class=\"keyword\">and</span> next != <span class=\"number\">-1</span>:      <span class=\"comment\">#找到适合插入元素的位置</span></span><br><span class=\"line\">   last = next</span><br><span class=\"line\">   next = ListRight[next]</span><br><span class=\"line\"></span><br><span class=\"line\">ListValue.append(num)                    <span class=\"comment\">#向数组末尾加上新元素的值</span></span><br><span class=\"line\">ListRight.append(ListRight[last])           <span class=\"comment\">#加上新元素指针指向的位置（下一个元素）</span></span><br><span class=\"line\">ListRight[last] = len(ListValue)<span class=\"number\">-1</span>          <span class=\"comment\">#上一个元素的指针指向新元素</span></span><br><span class=\"line\"></span><br><span class=\"line\">Output()                              <span class=\"comment\">#输出列表查看结果</span></span><br></pre></td></tr></table></figure><h3 id=\"删除单链表第n个数\">删除单链表第n个数<a href=\"#删除单链表第n个数\" title=\"删除单链表第n个数\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426202654.png\" style=\"zoom:50%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">ListValue = [<span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">3</span>]                        <span class=\"comment\">#建立单链表</span></span><br><span class=\"line\">ListRight = [<span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">-1</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">head = <span class=\"number\">0</span>                                                <span class=\"comment\">#确定头指针</span></span><br><span class=\"line\">prepos = <span class=\"number\">5</span>                                          <span class=\"comment\">#确定要删除的元素的前一个数的位置</span></span><br><span class=\"line\">ListRight[prepos] = ListRight[ListRight[prepos]]      <span class=\"comment\">#删除元素</span></span><br></pre></td></tr></table></figure><h2 id=\"双指针的应用\">双指针的应用<a href=\"#双指针的应用\" title=\"双指针的应用\"></a></h2><p>在算法中，指针的概念常常被应用。比如说二分查找中存储查找范围最左和最右元素的两个变量，就可以理解为左指针和右指针，因为它们起到了“存储数据储存位置”的作用。</p>\n<p>在Python中，标准意义上的指针并不存在。不过，Python语言的许多内置函数和功能都使用了指针来编写——比如说列表，实际上是以链表的形式存在的。不过，程序员无法在用Python编写程序的时候直接使用真正意义上的指针；所以，本书会以模拟指针的形式在Python中传达指针的概念。</p>\n<h3 id=\"数组合并问题\">数组合并问题<a href=\"#数组合并问题\" title=\"数组合并问题\"></a></h3><ol><li><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426203621.png\" style=\"zoom:80%;\" /></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426203635.png\" style=\"zoom:50%;\" /></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426203716.png\" style=\"zoom:50%;\" /></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426203836.png\" style=\"zoom:50%;\" /></li>\n<li><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210426204026.png\" style=\"zoom:50%;\" /></li>\n</ol><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr1 = [<span class=\"number\">3</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>,<span class=\"number\">12</span>,<span class=\"number\">15</span>]             <span class=\"comment\">#初始化两个数组</span></span><br><span class=\"line\">arr2 = [<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">7</span>,<span class=\"number\">13</span>,<span class=\"number\">14</span>]</span><br><span class=\"line\">i,j = <span class=\"number\">0</span>,<span class=\"number\">0</span>                    <span class=\"comment\">#指针初始化，指向列表第一个数</span></span><br><span class=\"line\">ans = []                     <span class=\"comment\">#ans初始化为空</span></span><br><span class=\"line\"><span class=\"keyword\">while</span> i &lt; len(arr1) <span class=\"keyword\">and</span> j &lt; len(arr2): <span class=\"comment\">#当有一个指针不再指向元素时停止循环</span></span><br><span class=\"line\">   <span class=\"keyword\">if</span> arr1[i] &lt;= arr2[j]:           <span class=\"comment\">#判断大小，把元素加入结果列表，挪动指针</span></span><br><span class=\"line\">      ans.append(arr1[i])</span><br><span class=\"line\">      i += <span class=\"number\">1</span></span><br><span class=\"line\">   <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      ans.append(arr2[j])</span><br><span class=\"line\">      j += <span class=\"number\">1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">if</span> i == len(arr1):                 <span class=\"comment\">#把还有剩余长度的列表中的元素加入结果列表</span></span><br><span class=\"line\">   ans += arr2[j:]</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">   ans += arr1[i:]</span><br><span class=\"line\">print(ans)</span><br></pre></td></tr></table></figure><h3 id=\"删除单链表倒数第n个数\">删除单链表倒数第n个数<a href=\"#删除单链表倒数第n个数\" title=\"删除单链表倒数第n个数\"></a></h3><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#节点定义</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListNode</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, v)</span>:</span></span><br><span class=\"line\">\t\t self.val = v</span><br><span class=\"line\">\t\t self.next = <span class=\"literal\">None</span></span><br><span class=\"line\"><span class=\"comment\">#删除倒数第n个数据</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">removeLastNth</span><span class=\"params\">(head, n)</span>:</span></span><br><span class=\"line\">\ttemp = ListNode(<span class=\"number\">0</span>)</span><br><span class=\"line\">\ttemp.next = head</span><br><span class=\"line\">\tfast = slow = temp</span><br><span class=\"line\">\tc = <span class=\"number\">0</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> c &lt; n:\t\t\t\t<span class=\"comment\">#fast先走n步</span></span><br><span class=\"line\">\t\tfast = fast.next</span><br><span class=\"line\">\t\tc += <span class=\"number\">1</span></span><br><span class=\"line\">\t<span class=\"keyword\">while</span> fast.next:</span><br><span class=\"line\">\t\tfast = fast.next</span><br><span class=\"line\">\t\tslow = slow.next</span><br><span class=\"line\">\tslow.next = slow.next.next</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> temp.next</span><br></pre></td></tr></table></figure><h1 id=\"哈希算法\">哈希算法<a href=\"#哈希算法\" title=\"哈希算法\"></a></h1><h2 id=\"hash\">Hash<a href=\"#hash\" title=\"Hash\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210427190348.png\" style=\"zoom:50%;\" /><h2 id=\"解决冲突\">解决冲突<a href=\"#解决冲突\" title=\"解决冲突\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210427200110.png\" style=\"zoom:67%;\" /><h2 id=\"两个数的和问题\">两个数的和问题<a href=\"#两个数的和问题\" title=\"两个数的和问题\"></a></h2><blockquote>\n<p>给定5个数字: 3，4，5，7，10，从中选择两个数使它们的和为<code>someValue</code>(例如someValue=11)</p>\n</blockquote>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210427200325.png\" style=\"zoom:50%;\" /><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#两个数的和</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSums</span> <span class=\"params\">( mynum, target )</span>:</span></span><br><span class=\"line\">    mydict = &#123;&#125; <span class=\"comment\">#建立一个字典，存储数据和下标的对应关系</span></span><br></pre></td></tr></table></figure><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#核心思想</span></span><br><span class=\"line\">i = <span class=\"comment\">#someValue  #i为给定的某个值</span></span><br><span class=\"line\">m = mynum[i]    <span class=\"comment\">#定义m为当前待查询的数字</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> target-m <span class=\"keyword\">in</span> mydict:  <span class=\"comment\">#判断target-m是否已经在字典中</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> (mydict[target-m],i) <span class=\"comment\">#如果已经存在，则返回这两个数的下标</span></span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    mydict[m]=i <span class=\"comment\">#如果不存在则记录键值对</span></span><br></pre></td></tr></table></figure><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">twoSums</span><span class=\"params\">(mynum, target)</span>:</span></span><br><span class=\"line\">    mydict = &#123;&#125;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(mynum)):</span><br><span class=\"line\">        m= mynum[i]              <span class=\"comment\">#定义m为当前待查询的数字</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> target-m <span class=\"keyword\">in</span> mydict:            <span class=\"comment\">#判定target-m是否已经在字典中</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> (mydict[target-m], i)   <span class=\"comment\">#如果已经存在，则返回这两个数的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">     mydict[m] = i            <span class=\"comment\">#如果不存在则记录键值对</span></span><br></pre></td></tr></table></figure><h2 id=\"团体赛问题\">团体赛问题<a href=\"#团体赛问题\" title=\"团体赛问题\"></a></h2><blockquote>\n<p>判断派出的选手是否合规</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#团体赛问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">pingpong</span><span class=\"params\">(games, players)</span>:</span></span><br><span class=\"line\">    game = games.split(<span class=\"string\">','</span>)</span><br><span class=\"line\">    player = players.split(<span class=\"string\">','</span>)    </span><br><span class=\"line\">    <span class=\"keyword\">if</span> len(player) != len(game):   <span class=\"comment\">#如果两个字符串的长度不一样，则肯定不匹配</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"literal\">False</span>    </span><br><span class=\"line\">    mydict = &#123;&#125;              <span class=\"comment\">#记录模式字符串和目标字符串的对应关系</span></span><br><span class=\"line\">    used= &#123;&#125;                 <span class=\"comment\">#记录目前已经使用过的字符串都有哪些</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(game)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> game[i] <span class=\"keyword\">in</span> mydict:   </span><br><span class=\"line\">            <span class=\"keyword\">if</span> mydict [game[i]] != player[i]:  <span class=\"comment\">#不是第一次出现，则检查映射关系是否一致</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> player[i] <span class=\"keyword\">in</span> used:         <span class=\"comment\">#检查这个选手是否已经出现过，出现过则返回不成立</span></span><br><span class=\"line\">               <span class=\"keyword\">return</span> <span class=\"literal\">False</span></span><br><span class=\"line\">            mydict [game[i]] = player[i]      <span class=\"comment\">#第一次出现，则加入哈希表</span></span><br><span class=\"line\">            used[player[i]] = <span class=\"literal\">True</span>        <span class=\"comment\">#在used中保存哪些单词已经使用过</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"literal\">True</span>                 <span class=\"comment\">#没有任何问题则返回成立</span></span><br></pre></td></tr></table></figure><h2 id=\"猜数字游戏\">猜数字游戏<a href=\"#猜数字游戏\" title=\"猜数字游戏\"></a></h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#猜数字游戏</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">guessGame</span><span class=\"params\">(secret, guess)</span>:</span></span><br><span class=\"line\">    secret_dict = &#123;&#125;</span><br><span class=\"line\">    guess_dict = &#123;&#125;</span><br><span class=\"line\">    count1 = <span class=\"number\">0</span></span><br><span class=\"line\">    count2 = <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(len(secret)):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> secret[i] == guess[i]:</span><br><span class=\"line\">            count1 += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">if</span> secret[i] <span class=\"keyword\">in</span> secret_dict:</span><br><span class=\"line\">                secret_dict[secret[i]] = secret_dict[secret[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                secret_dict[secret[i]]=<span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> guess[i] <span class=\"keyword\">in</span> guess_dict:</span><br><span class=\"line\">                    guess_dict[guess[i]] = guess_dict[guess[i]] + <span class=\"number\">1</span></span><br><span class=\"line\">                <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                    guess_dict[guess[i]]=<span class=\"number\">1</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> digit <span class=\"keyword\">in</span> secret_dict:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> digit <span class=\"keyword\">in</span> guess_dict:</span><br><span class=\"line\">            count2 += min(secret_dict[digit], guess_dict[digit])</span><br><span class=\"line\">    <span class=\"keyword\">return</span> str(count1)+<span class=\"string\">\",\"</span>+str(count2)</span><br></pre></td></tr></table></figure><h1 id=\"深度优先搜索算法\">深度优先搜索算法<a href=\"#深度优先搜索算法\" title=\"深度优先搜索算法\"></a></h1><ol><li>理解什么是搜索</li>\n<li>掌握图在算法中的基本应用</li>\n<li>掌握用<strong>深度优先搜索算法</strong>解题需要解决的问题</li>\n<li>掌握深度优先搜索算法的步骤</li>\n<li>理解常见问题如<strong>最大油田问题</strong>、<strong>职员派对问题</strong>、和<strong>城市危机问题</strong></li>\n</ol><h2 id=\"图上的深度优先搜索\">图上的深度优先搜索<a href=\"#图上的深度优先搜索\" title=\"图上的深度优先搜索\"></a></h2><p>图是一种计算机科学中的模型，往往可以作为生活中复杂联系的简化结构<br>图的使用，往往能解决“最近”，“最远”，“能否到达”，“不能到达”，“能到达哪”等问题。 </p>\n<h3 id=\"无向图\">无向图<a href=\"#无向图\" title=\"无向图\"></a></h3><p>准确定义：由一组顶点和一组能够将两个顶点相连而<strong>没有方向的边</strong>组成的图     <img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121183057.png\" alt=\"img\" style=\"zoom:50%;\" /></p>\n<p>注：绘图时，往往用圆圈表示顶点，用线段表示连接两个顶点的边 </p>\n<p><strong>相邻</strong>&amp;<strong>邻接点</strong>：当两个顶点通过一条边相连时，我们称这两个顶点是相邻的，也可以说这两个的顶点互为邻接点，并称这条边依附于这两个顶点，与这两个顶点相关联 </p>\n<p><strong>度</strong></p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/20201121230125.png\" alt=\"img\" style=\"zoom: 67%;\" />    <img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210525184943.png\" style=\"zoom:33%;\" /></p>\n<p><strong>子图</strong>：子图是指在一幅图中所有边的一个子集以及它们所依附的所有顶点组成的图，如下右图所示（左图的一个子图）。    <img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210525185210.png\" style=\"zoom: 40%;\" /></p>\n<p><strong>路径</strong>：接续的边构成的顶点序列。</p>\n<p><strong>路径长度</strong>：其所包含的边数的长度。</p>\n<p><strong>回路(环)</strong>：第一个顶点和最后一个顶点相同的路径。</p>\n<p><strong>简单路径</strong>：一条没有重复顶点的路径</p>\n<p><strong>简单回路(简单环)</strong>：一个没有重复顶点和边的环(除了起点和终点重复之外)</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/20201121230543.png\" alt=\"img\" style=\"zoom:67%;\" /><h2 id=\"最大油田问题\">最大油田问题<a href=\"#最大油田问题\" title=\"最大油田问题\"></a></h2><p>政府现勘探到一片油田，在这一片油田中有很多散落的石油资源。因为经费原因，政府只能开采一处油田，所以需找到最大的油田进行施工。油田的地理情况被简化成了一个矩阵，其中每一个方格代表一块土地，0代表陆地，1代表石油资源。如果一处石油资源和另一处石油相连接，则其算一块油田。现要找到最大的相互连接的石油资源，并输出它的面积。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/Dxsummer/cdn/img/python/20210531200355.png\" style=\"zoom:67%;\" /><p>上图为示例，其中灰色的区域都是不同大小的油田。那么对于这个例子来说，左上角的五块石油连在一起的区域就是最大的油田，其面积为5，如上右图阴影部分所示。</p>\n<p><strong>深度遍历策略：</strong></p>\n<p>为了知道一块油田有多大，我们可能需遍历每一个图中的方格。</p>\n<p>因为在一块油田中，石油资源一定是相邻的，因此只有四中情况：上，下，左，右。所以结合深度优先遍历算法，我们可以对每一个方格进行搜索来寻找该方格相邻处是否还有石油资源，从而快速得到每一块隔离的油田的面积</p>\n<p>我们可以用循环依此以每一块土地为起点进行搜索。如果该块土地含有石油资源，则继续搜索这个由石油资源土地的上下左右相邻的土地，反之则继续循环遍历其他土地。</p>\n<p>如此反复，将整幅图搜索完，即可求解出答案</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#最大的油田代码</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">MaxAreaOfIsland</span><span class=\"params\">(grid)</span>:</span>    \t<span class=\"comment\">#grid为题目给的二维数组，其中存储着地理信息</span></span><br><span class=\"line\">    row = len(grid)             \t<span class=\"comment\">#row记录二维数组的行数，也是地图的y轴长度</span></span><br><span class=\"line\">    col = len(grid[<span class=\"number\">0</span>])\t\t    \t<span class=\"comment\">#col记录二维数组的列数，也是地图的x轴长度</span></span><br><span class=\"line\">    arrived = [[<span class=\"literal\">False</span> <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(col)] <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(row)]</span><br><span class=\"line\">    \t\t\t\t\t\t\t<span class=\"comment\">#arrived为一个二维数组，存储一块土地是否被访问过</span></span><br><span class=\"line\">    ans = <span class=\"number\">0</span>                       \t<span class=\"comment\">#记录油田的最大面积</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">DFS</span><span class=\"params\">(x, y)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> x &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> x &lt; row <span class=\"keyword\">and</span> y &gt;= <span class=\"number\">0</span> <span class=\"keyword\">and</span> y &lt; col <span class=\"keyword\">and</span> <span class=\"keyword\">not</span> arrived[x][y] <span class=\"keyword\">and</span> grid[x][y] == <span class=\"number\">1</span>:       </span><br><span class=\"line\">            <span class=\"comment\">#判断现在搜索的土地是否出界，是否已经访问过，以及是否含有石油资源</span></span><br><span class=\"line\">            arrived[x][y] = <span class=\"literal\">True</span>\t<span class=\"comment\">#标记该块土地已经被搜索过</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span> + DFS(x - <span class=\"number\">1</span>, y) + DFS(x + <span class=\"number\">1</span>, y) + DFS(x, y - <span class=\"number\">1</span>) + DFS(x, y + <span class=\"number\">1</span>)</span><br><span class=\"line\">    \t\t\t\t\t\t\t<span class=\"comment\">#搜索其相邻的土地并将答案加上1</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">0</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(row):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(col):</span><br><span class=\"line\">            area = DFS(i, j)   \t<span class=\"comment\">#遍历搜索每一块土地</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> area &gt; ans:</span><br><span class=\"line\">                ans = area</span><br><span class=\"line\"><span class=\"keyword\">return</span> ans</span><br></pre></td></tr></table></figure><h2 id=\"二叉树上的遍历\">二叉树上的遍历<a href=\"#二叉树上的遍历\" title=\"二叉树上的遍历\"></a></h2><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th><strong>二叉树的术语</strong></th><th><strong>相关解释</strong></th></tr>\n</thead><tbody><tr>\n<td>度</td><td>节点的子树个数</td></tr>\n<tr>\n<td>根</td><td>二叉树的源头节点</td></tr>\n<tr>\n<td>深度</td><td>二叉树的层数</td></tr>\n<tr>\n<td>叶子节点</td><td>度为零的节点</td></tr>\n<tr>\n<td>分支节点</td><td>度不为零的节点</td></tr>\n<tr>\n<td>孩子节点</td><td>节点下一层的两个子节点</td></tr>\n<tr>\n<td>双亲节点</td><td>节点上一层的源头节点</td></tr>\n<tr>\n<td>兄弟节点</td><td>继承于同一个双亲节点的节点</td></tr>\n</tbody></table></div></div><p><strong>策略：</strong></p>\n<p>二叉树属于一种无环连通图。所以深度搜索也可以在二叉树中进行。进行的方式反而更加好理解——从根节点开始，以树的深度为标准向叶子节点搜索。</p>\n<p>深度搜索往往从一个树的根节点开始进行。算法中，会遍历父节点的每一个边。值得注意的是，深度优先搜索算法在找到第一条父节点通往子节点的边时，不会直接继续寻找通往其他子节点的边，而是直接以找到的子节点为起点，继续遍历已知子节点的子节点（或者不严谨的说，“孙节点”），从而做到“深度优先”。</p>\n<p>如此反复，直到当前子节点已经没有子节点（也可以被称为叶子节点）。待遍历到叶子节点后，深度优先搜索算法会在回溯到叶子节点的父节点，继续遍历其没有遍历过的子节点，直到该父节点的所有子节点均被遍历完，再回溯到当前父节点的父节点，遍历没有其没有遍历过的子节点……直到回到根节点，并把所有的节点遍历完。</p>\n<h2 id=\"职员派对\">职员派对<a href=\"#职员派对\" title=\"职员派对\"></a></h2><p><strong>问题描述：</strong></p>\n<p>公司要举办一个职员派对，而公司里所有的员工都有资格来参加。如图6.16所示，该公司的职员组织结构是一个二叉树结构。如果一个节点A有双亲节点B，则代表B是A的上司。实际上，每一个员工为派对所能带来的贡献不一样，有的人幽默，就能使派对更加有趣，而有的人恰恰相反。树上每一个节点圆圈里的数字便代表每一个员工为派对所能带来的贡献值。然而，该公司里的所有员工都对自己的上司不满意（如果其有上司的话），所以如果一个员工来到派对，其上司就不能来到派对，反之亦然。但员工和员工上司的上司是可以一起参加派对的因为他们互相不熟悉。如果你是董事长的秘书，并且在已知公司职员组织结构的情况下，应该怎么邀请员工，使得任何一组员工和上司不会同时出现在派对中，并且使得邀请的所有员工的贡献值之和最大？</p>\n","prev":{"title":"选词填空","link":"posts/b1228ca7"},"next":{"title":"Java笔记","link":"posts/b6543913"},"plink":"https://dxsummer.gitee.io/posts/7f8e2ad4/","toc":[{"id":"排序","title":"排序","index":"1","children":[{"id":"插入排序","title":"插入排序","index":"1.1"},{"id":"选择排序","title":"选择排序","index":"1.2"},{"id":"冒泡排序","title":"冒泡排序","index":"1.3"},{"id":"归并排序","title":"归并排序","index":"1.4"},{"id":"快速排序","title":"快速排序","index":"1.5"},{"id":"希尔排序","title":"希尔排序","index":"1.6"},{"id":"堆排序","title":"堆排序","index":"1.7"},{"id":"桶排序","title":"桶排序","index":"1.8"}]},{"id":"查找","title":"查找","index":"2","children":[{"id":"顺序查找","title":"顺序查找","index":"2.1"},{"id":"二分查找","title":"二分查找","index":"2.2"},{"id":"树","title":"树","index":"2.3","children":[{"id":"二叉树","title":"二叉树","index":"2.3.1"},{"id":"二叉搜索树","title":"二叉搜索树","index":"2.3.2"},{"id":"平衡二叉树","title":"平衡二叉树","index":"2.3.3","children":[{"id":"avl树","title":"AVL树","index":"2.3.3.1"}]}]}]},{"id":"双指针问题","title":"双指针问题","index":"3","children":[{"id":"指针的概念","title":"指针的概念","index":"3.1"},{"id":"链表的概念","title":"链表的概念","index":"3.2"},{"id":"单链表","title":"单链表","index":"3.3","children":[{"id":"遍历单链表","title":"遍历单链表","index":"3.3.1"},{"id":"插入元素","title":"插入元素","index":"3.3.2"},{"id":"删除单链表第n个数","title":"删除单链表第n个数","index":"3.3.3"}]},{"id":"双指针的应用","title":"双指针的应用","index":"3.4","children":[{"id":"数组合并问题","title":"数组合并问题","index":"3.4.1"},{"id":"删除单链表倒数第n个数","title":"删除单链表倒数第n个数","index":"3.4.2"}]}]},{"id":"哈希算法","title":"哈希算法","index":"4","children":[{"id":"hash","title":"Hash","index":"4.1"},{"id":"解决冲突","title":"解决冲突","index":"4.2"},{"id":"两个数的和问题","title":"两个数的和问题","index":"4.3"},{"id":"团体赛问题","title":"团体赛问题","index":"4.4"},{"id":"猜数字游戏","title":"猜数字游戏","index":"4.5"}]},{"id":"深度优先搜索算法","title":"深度优先搜索算法","index":"5","children":[{"id":"图上的深度优先搜索","title":"图上的深度优先搜索","index":"5.1","children":[{"id":"无向图","title":"无向图","index":"5.1.1"}]},{"id":"最大油田问题","title":"最大油田问题","index":"5.2"},{"id":"二叉树上的遍历","title":"二叉树上的遍历","index":"5.3"},{"id":"职员派对","title":"职员派对","index":"5.4"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/7f8e2ad4/\" title=\"python数据结构\">https://dxsummer.gitee.io/posts/7f8e2ad4/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2021年4月20日","updated":"2021年5月31日"}}