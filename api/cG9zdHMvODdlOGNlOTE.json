{"title":"Step8 数组和指针","date":"2020-06-13T02:39:24.000Z","date_formatted":{"ll":"2020年6月13日","L":"2020/06/13","MM-DD":"06-13"},"link":"posts/87e8ce91","comments":true,"tags":["C语言基础"],"categories":["C语言"],"updated":"2020-06-27T06:45:37.147Z","content":"<p>本章介绍以下内容：</p>\n<p>关键字：<code>static</code></p>\n<p>运算符：<code>&amp;</code>、<code>*</code>（一元）</p>\n<ul><li>如何创建并初始化数组</li>\n<li>指针（在已学过的基础上）、指针和数组的关系</li>\n<li>编写处理数组的函数</li>\n<li>二维数组</li>\n</ul><p>人们通常借助计算机完成统计每月的支出、日降雨量、季度销售额等任务。企业借助计算机管理薪资、库存和客户交易记录等。作为程序员，不可避免地要处理大量相关数据。通常，数组能高效便捷地处理这种数据。第 6 章简单地介绍了数组，本章将进一步地学习如何使用数组，着重分析如何编写处理数组的函数。这种函数把模块化编程的优势应用到数组。通过本章的学习，你将明白数组和指针关系密切。</p>\n<h2 id=\"数组\">数组<a href=\"#数组\" title=\"数组\"></a></h2><p>前面介绍过，数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。考虑下面的数组声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 一些数组声明*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> candy[<span class=\"number\">365</span>];　　　 <span class=\"comment\">/* 内含365个float类型元素的数组 */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> code[<span class=\"number\">12</span>];　　　　　<span class=\"comment\">/*内含12个char类型元素的数组*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> states[<span class=\"number\">50</span>];　　　　 <span class=\"comment\">/*内含50个int类型元素的数组 */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>方括号（<code>[]</code>）表明candy、code和states都是数组，方括号中的数字表明数组中的元素个数。</p>\n<p>要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。数组元素的编号从0开始，所以<code>candy[0]</code>表示candy数组的第1个元素，<code>candy[364]</code>表示第365个元素，也就是最后一个元素。读者对这些内容应该比较熟悉，下面我们介绍一些新内容。</p>\n<h3 id=\"初始化数组\">初始化数组<a href=\"#初始化数组\" title=\"初始化数组\"></a></h3><p>数组通常被用来储存程序需要的数据。例如，一个内含12个整数元素的数组可以储存12个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。</p>\n<p>只储存单个值的变量有时也称为标量变量（scalar variable），我们已经很熟悉如何初始化这种变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fix　=　<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> flax = PI * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure><p>代码中的PI已定义为宏。C使用新的语法来初始化数组，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> powers[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">16</span>,<span class=\"number\">32</span>,<span class=\"number\">64</span>&#125;; <span class=\"comment\">/* 从ANSI C开始支持这种初始化 */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（<code>powers[0]</code>），以此类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关键字<code>static</code>可解决此问题。第12章将详细讨论这个关键字）。</p>\n<p>程序清单10.1演示了一个小程序，打印每个月的天数。</p>\n<p>程序清单10.1 day_mon1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* day_mon1.c -- 打印每个月的天数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　days[MONTHS]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>　(index　=　<span class=\"number\">0</span>;　index　&lt;　MONTHS;　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Month　%2d　has　%2d　days.\\n\"</span>,　index　+　<span class=\"number\">1</span>,　days[index]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Month　<span class=\"number\">1</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">2</span>　has　<span class=\"number\">28</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">3</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">4</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">5</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">6</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">7</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">8</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">9</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">10</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">11</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">12</span>　has　<span class=\"number\">31</span>　days.</span><br></pre></td></tr></table></figure><p>这个程序还不够完善，每4年打错一个月份的天数（即，2月份的天数）。该程序用初始化列表初始化<code>days[]</code>，列表（用花括号括起来）中用逗号分隔各值。</p>\n<p>注意该例使用了符号常量 MONTHS 表示数组大小，这是我们推荐且常用的做法。例如，如果要采用一年13个月的记法，只需修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。</p>\n<p>注意 使用<code>const</code>声明数组</p>\n<p>有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用<code>const</code>声明和初始化数组。因此，程序清单10.1中初始化数组应改成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> days[MONTHS] = &#123;<span class=\"number\">31</span>,<span class=\"number\">28</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>&#125;;</span><br></pre></td></tr></table></figure><p>这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 <code>const</code> 数据，因为一旦声明为 <code>const</code>，便不能再给它赋值。明确了这一点，就可以在后面的例子中使用<code>const</code>了。</p>\n<p>如果初始化数组失败怎么办？程序清单10.2演示了这种情况。</p>\n<p>程序清单10.2 no_data.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* no_data.c -- 为初始化数组 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> no_data[SIZE];　<span class=\"comment\">/* 未初始化数组 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>　i;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2s%14s\\n\"</span>,　　　<span class=\"string\">\"i\"</span>,　<span class=\"string\">\"no_data[i]\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>　(i　=　<span class=\"number\">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d%14d\\n\"</span>,　i,　no_data[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下（系统不同，输出的结果可能不同）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i　　　no_data[i]</span><br><span class=\"line\"><span class=\"number\">0</span>　　　　　　　　　　<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>　　　　　 <span class=\"number\">4204937</span></span><br><span class=\"line\"><span class=\"number\">2</span>　　　　　 <span class=\"number\">4219854</span></span><br><span class=\"line\"><span class=\"number\">3</span>　　　<span class=\"number\">2147348480</span></span><br></pre></td></tr></table></figure><p>使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。</p>\n<p>注意 存储类别警告</p>\n<p>数组和其他变量类似，可以把数组创建成不同的<strong>存储类别</strong>（storage class）。第12章将介绍存储类别的相关内容，现在只需记住：本章描述的<strong>数组属于自动存储类别</strong>，意思是<strong>这些数组在函数内部声明，且声明时未使用关键字</strong><code>static</code>。到目前为止，本书所用的变量和数组都是自动存储类别。</p>\n<p>在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不能把本章的内容推广到其他存储类别。<strong>对于一些其他存储类别的变量和数组，如果在声明时未初始化，编译器会自动把它们的值设置为0</strong>。</p>\n<p>初始化列表中的项数应与数组的大小一致。如果不一致会怎样？我们还是以上一个程序为例，但初始化列表中缺少两个元素，如程序清单10.3所示：</p>\n<p>程序清单10.3 somedata.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* some_data.c -- 部分初始化数组 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> some_data[SIZE]　=　&#123;　<span class=\"number\">1492</span>,　<span class=\"number\">1066</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2s%14s\\n\"</span>,　　　<span class=\"string\">\"i\"</span>,　<span class=\"string\">\"some_data[i]\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d%14d\\n\"</span>,　i,　some_data[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i　some_data[i]</span><br><span class=\"line\"><span class=\"number\">0</span>　　　　　　　<span class=\"number\">1492</span></span><br><span class=\"line\"><span class=\"number\">1</span>　　　　　　　<span class=\"number\">1066</span></span><br><span class=\"line\"><span class=\"number\">2</span>　　　　　　　　　<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span>　　　　　　　　　<span class=\"number\">0</span></span><br></pre></td></tr></table></figure><p>如上所示，编译器做得很好。当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。</p>\n<p>如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会毫不留情地将其视为错误。但是，没必要因此嘲笑编译器。其实，可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数（见程序清单10.4）</p>\n<p>程序清单10.4 day_mon2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* day_mon2.c -- 让编译器计算元素个数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> days[]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(index　=　<span class=\"number\">0</span>;　index　&lt;　<span class=\"keyword\">sizeof</span>　days　/　<span class=\"keyword\">sizeof</span>　days[<span class=\"number\">0</span>];　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Month　%2d　has　%d　days.\\n\"</span>,　index　+　<span class=\"number\">1</span>,　days[index]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在程序清单10.4中，要注意以下两点。</p>\n<p>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。</p>\n<p>注意<code>for</code>循环中的测试条件。由于人工计算容易出错，所以让计算机来计算数组的大小。<code>sizeof</code>运算符给出它的运算对象的大小（以字节为单位）。所以<code>sizeof days</code>是整个数组的大小（以字节为单位），<code>sizeof day[0]</code>是数组中一个元素的大小（以字节为单位）。<strong>整个数组的大小除以单个元素的大小就是数组元素的个数。</strong></p>\n<p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Month　<span class=\"number\">1</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">2</span>　has　<span class=\"number\">28</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">3</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">4</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">5</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">6</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">7</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">8</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">9</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">10</span>　has　<span class=\"number\">31</span>　days.</span><br></pre></td></tr></table></figure><p>我们的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小。我们初始化时用了10个值，结果就只打印了10个值！这就是自动计数的弊端：无法察觉初始化列表中的项数有误。</p>\n<p>还有一种初始化数组的方法，但这种方法仅限于初始化字符数组。我们在下一章中介绍。</p>\n<h3 id=\"指定初始化器（c99）\">指定初始化器（C99）<a href=\"#指定初始化器（c99）\" title=\"指定初始化器（C99）\"></a></h3><p>C99 增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">6</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">212</span>&#125;; <span class=\"comment\">// 传统的语法</span></span><br></pre></td></tr></table></figure><p>而C99规定，可以<strong>在初始化列表中使用带方括号的下标指明待初始化的元素</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">6</span>] = &#123;[<span class=\"number\">5</span>] = <span class=\"number\">212</span>&#125;; <span class=\"comment\">// 把arr[5]初始化为212</span></span><br></pre></td></tr></table></figure><p>对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。程序清单10.5中的初始化比较复杂。</p>\n<p>程序清单10.5 designate.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// designate.c -- 使用指定初始化器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> days[MONTHS]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　[<span class=\"number\">4</span>]　=　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　[<span class=\"number\">1</span>]　=　<span class=\"number\">29</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　MONTHS;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d　 %d\\n\"</span>,　i　+　<span class=\"number\">1</span>,　days[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序在支持C99的编译器中输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>　　 <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">2</span>　　 <span class=\"number\">29</span></span><br><span class=\"line\"><span class=\"number\">3</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">5</span>　　 <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">6</span>　　 <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"number\">7</span>　　 <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">8</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">9</span>　　　<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">10</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">11</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">12</span>　　 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><p>以上输出揭示了指定初始化器的两个重要特性。第一，<strong>如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：<code>[4] = 31,30,31</code>，那么后面这些值将被用于初始化指定元素后面的元素。</strong>也就是说，在<code>days[4]</code>被初始化为31后，<code>days[5]</code>和<code>days[6]</code>将分别被初始化为30和31。第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清单10.5中，初始化列表开始时把<code>days[1]</code>初始化为28，但是<code>days[1]</code>又被后面的指定初始化<code>[1] = 29</code>初始化为29。</p>\n<p>如果未指定元素大小会怎样？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> stuff[] = &#123;<span class=\"number\">1</span>, [<span class=\"number\">6</span>] = <span class=\"number\">23</span>&#125;;　　　　 <span class=\"comment\">//会发生什么？</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> staff[] = &#123;<span class=\"number\">1</span>, [<span class=\"number\">6</span>] = <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;　<span class=\"comment\">//会发生什么？</span></span><br></pre></td></tr></table></figure><p>编译器会把数组的大小设置为足够装得下初始化的值。所以，<code>stuff</code>数组有7个元素，编号为<code>0～6</code>；而<code>staff</code>数组的元素比<code>stuff</code>数组多两个（即有9个元素）。</p>\n<h3 id=\"给数组元素赋值\">给数组元素赋值<a href=\"#给数组元素赋值\" title=\"给数组元素赋值\"></a></h3><p>声明数组后，可以借助数组下标（或索引）给数组元素赋值。例如，下面的程序段给数组的所有元素赋值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 给数组的元素赋值 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　50</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span>　counter,　evens[SIZE];</span><br><span class=\"line\"><span class=\"keyword\">for</span>　(counter　=　<span class=\"number\">0</span>;　counter　&lt;　SIZE;　counter++)</span><br><span class=\"line\">evens[counter]　=　<span class=\"number\">2</span>　*　counter;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>注意这段代码中使用循环给数组的元素依次赋值。C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。下面的代码段演示了一些错误的赋值形式:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 一些无效的数组赋值 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> oxen[SIZE] = &#123;<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>&#125;;　　　　 <span class=\"comment\">/* 初始化没问题 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> yaks[SIZE];</span><br><span class=\"line\">yaks = oxen;　　　　　　　　　 <span class=\"comment\">/* 不允许 */</span></span><br><span class=\"line\">yaks[SIZE] = oxen[SIZE];　　　 <span class=\"comment\">/* 数组下标越界 */</span></span><br><span class=\"line\">yaks[SIZE] = &#123;<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>&#125;;　　　　<span class=\"comment\">/* 不起作用 */</span></span><br></pre></td></tr></table></figure><p>oxen数组的最后一个元素是<code>oxen[SIZE-1]</code>，所以<code>oxen[SIZE]</code>和<code>yaks[SIZE]</code>都超出了两个数组的末尾。</p>\n<h3 id=\"数组边界\">数组边界<a href=\"#数组边界\" title=\"数组边界\"></a></h3><p>在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> doofi[<span class=\"number\">20</span>];</span><br></pre></td></tr></table></figure><p>那么在使用该数组时，要确保程序中使用的数组下标在0～19的范围内，因为编译器不会检查出这种错误（但是，一些编译器发出警告，然后继续编译程序）。</p>\n<p>考虑程序清单10.6的问题。该程序创建了一个内含4个元素的数组，然后错误地使用了-1～6的下标。</p>\n<p>程序清单10.6 bounds.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bounds.c -- 数组下标越界</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value1　=　<span class=\"number\">44</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value2　=　<span class=\"number\">88</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"value1　=　%d,　value2　=　%d\\n\"</span>,　value1,　value2);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">-1</span>;　i　&lt;=　SIZE;　i++)</span><br><span class=\"line\">    \tarr[i] = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">-1</span>;　i　&lt;　<span class=\"number\">7</span>;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d　%d\\n\"</span>,　i,　arr[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"value1　=　%d,　value2　=　%d\\n\"</span>,　value1,　value2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　arr[-1]:　%p\\n\"</span>,　&amp;arr[<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　arr[4]:　%p\\n\"</span>,　&amp;arr[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　value1:　%p\\n\"</span>,　&amp;value1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　value2:　%p\\n\"</span>,　&amp;value2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。下面是使用GCC的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value1　=　<span class=\"number\">44</span>,　value2　=　<span class=\"number\">88</span></span><br><span class=\"line\"><span class=\"number\">-1</span>　<span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">0</span>　<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>　<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span>　<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">3</span>　<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">4</span>　<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">5</span>　<span class=\"number\">1624678494</span></span><br><span class=\"line\"><span class=\"number\">6</span>　<span class=\"number\">32767</span></span><br><span class=\"line\">value1　=　<span class=\"number\">9</span>,　value2　=　<span class=\"number\">-1</span></span><br><span class=\"line\">address　of　arr[<span class=\"number\">-1</span>]:　 <span class=\"number\">0x7fff5fbff8cc</span></span><br><span class=\"line\">address　of　arr[<span class=\"number\">4</span>]:　　<span class=\"number\">0x7fff5fbff8e0</span></span><br><span class=\"line\">address　of　value1:　　<span class=\"number\">0x7fff5fbff8e0</span></span><br><span class=\"line\">address　of　value2:　　<span class=\"number\">0x7fff5fbff8cc</span></span><br></pre></td></tr></table></figure><p>注意，该编译器似乎把<code>value2</code>储存在数组的前一个位置，把<code>value1</code>储存在数组的后一个位置（其他编译器在内存中储存数据的顺序可能不同）。在上面的输出中，<code>arr[-1]</code>与<code>value2</code>对应的内存地址相同， <code>arr[4]</code>和<code>value1</code>对应的内存地址相同。因此，使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。</p>\n<p>C 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。</p>\n<p>还要记住一点：数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class=\"line\">    \t....</span><br></pre></td></tr></table></figure><p>这样做能确保整个程序中的数组大小始终一致。</p>\n<h3 id=\"指定数组的大小\">指定数组的大小<a href=\"#指定数组的大小\" title=\"指定数组的大小\"></a></h3><p>本章前面的程序示例都使用整型常量来声明数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[SIZE];　　　　　<span class=\"comment\">// 整数符号常量</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> lots[<span class=\"number\">144</span>];　　　 <span class=\"comment\">// 整数字面常量</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure><p>在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。<code>sizeof</code>表达式被视为整型常量，但是（与C++不同）<code>const</code>值不是。另外，<strong>表达式的值必须大于0</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n　=　<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m　=　<span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> a1[<span class=\"number\">5</span>];　　　　　　　　 <span class=\"comment\">// 可以</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a2[<span class=\"number\">5</span>*<span class=\"number\">2</span> + <span class=\"number\">1</span>];　　　　 <span class=\"comment\">//可以</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a3[<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) + <span class=\"number\">1</span>]; <span class=\"comment\">//可以</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a4[<span class=\"number\">-4</span>];　　　　　　　　<span class=\"comment\">// 不可以，数组大小必须大于0</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a5[<span class=\"number\">0</span>];　　　　　　　　 <span class=\"comment\">// 不可以，数组大小必须大于0</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a6[<span class=\"number\">2.5</span>];　　　　　　　 <span class=\"comment\">// 不可以，数组大小必须是整数</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a7[(<span class=\"keyword\">int</span>)<span class=\"number\">2.5</span>];　　　　 <span class=\"comment\">// 可以，已被强制转换为整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a8[n];　　　　　　　　 <span class=\"comment\">// C99之前不允许</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a9[m];　　　　　　　　 <span class=\"comment\">// C99之前不允许</span></span><br></pre></td></tr></table></figure><p>上面的注释表明，以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为<strong>变长数组</strong>（variable-length array）或简称 <strong>VLA</strong>（C11 放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性）。</p>\n<p>C99引入变长数组主要是为了让C成为更好的数值计算语言。例如，VLA简化了把FORTRAN现有的数值计算例程库转换为C代码的过程。VLA有一些限制，例如，声明VLA时不能进行初始化。在充分了解经典的C数组后，我们再详细介绍VLA。</p>\n<h2 id=\"多维数组\">多维数组<a href=\"#多维数组\" title=\"多维数组\"></a></h2><p>气象研究员Tempest Cloud为完成她的研究项目要分析5年内每个月的降水量数据，她首先要解决的问题是如何表示数据。一个方案是创建60个变量，每个变量储存一个数据项（我们曾经提到过这一笨拙的方案，和以前一样，这个方案并不合适）。使用一个内含60个元素的数组比将建60个变量好，但是如果能把各年的数据分开储存会更好，即创建5个数组，每个数组12个元素。然而，这样做也很麻烦，如果Tempest决定研究50年的降水量，岂不是要创建50个数组。是否能有更好的方案？</p>\n<p>处理这种情况应该使用数组的数组。主数组（master array）有5个元素（每个元素表示一年），每个元素是内含12个元素的数组（每个元素表示一个月）。下面是该数组的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> rain[<span class=\"number\">5</span>][<span class=\"number\">12</span>]; <span class=\"comment\">// 内含5个数组元素的数组，每个数组元素内含12个float类型的元素</span></span><br></pre></td></tr></table></figure><p>理解该声明的一种方法是，先查看中间部分（粗体部分）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> rain[<span class=\"number\">5</span>][<span class=\"number\">12</span>]; <span class=\"comment\">// rain是一个内含5个元素的数组</span></span><br></pre></td></tr></table></figure><p>这说明数组<code>rain</code>有5个元素，至于每个元素的情况，要查看声明的其余部分（粗体部分）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">floatrain[<span class=\"number\">5</span>][<span class=\"number\">12</span>] ; <span class=\"comment\">// 一个内含12个float类型元素的数组</span></span><br></pre></td></tr></table></figure><p>这说明每个元素的类型是<code>float[12]</code>，也就是说，<code>rain</code>的每个元素本身都是一个内含12个<code>float</code>类型值的数组。</p>\n<p>根据以上分析可知，rain的首元素<code>rain[0]</code>是一个内含12个<code>float</code>类型值的数组。所以，<code>rain[1]</code>、<code>rain[2]</code>等也是如此。如果 <code>rain[0]</code>是一个数组，那么它的首元素就是 <code>rain[0][0]</code>，第 2 个元素是<code>rain[0][1]</code>，以此类推。简而言之，数组<code>rain</code>有5个元素，每个元素都是内含12个<code>float</code>类型元素的数组，<code>rain[0]</code>是内含12个<code>float</code>值的数组，<code>rain[0][0]</code>是一个<code>float</code>类型的值。假设要访问位于2行3列的值，则使用<code>rain[2][3]</code>（记住，数组元素的编号从0开始，所以2行指的是第3行）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/二维数组.png\" class=\"φcy\"></p>\n<p>该二维视图有助于帮助读者理解二维数组的两个下标。在计算机内部，这样的数组是按顺序储存的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。</p>\n<p>我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数组很直观，实现这些操作也很容易。程序清单10.7演示了这个程序。</p>\n<p>程序清单10.7 rain.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* rain.c　-- 计算每年的总降水量、年平均降水量和5年中每月的平均降水量 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MONTHS 12　　　<span class=\"comment\">// 一年的月份数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> YEARS　 5　　　 <span class=\"comment\">// 年数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用2010～2014年的降水量数据初始化数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">float</span> rain[YEARS][MONTHS]　=</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;　<span class=\"number\">4.3</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">3.0</span>,　<span class=\"number\">2.0</span>,　<span class=\"number\">1.2</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.4</span>,　<span class=\"number\">2.4</span>,　<span class=\"number\">3.5</span>,　<span class=\"number\">6.6</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">8.5</span>,　<span class=\"number\">8.2</span>,　<span class=\"number\">1.2</span>,　<span class=\"number\">1.6</span>,　<span class=\"number\">2.4</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">5.2</span>,　<span class=\"number\">0.9</span>,　<span class=\"number\">0.3</span>,　<span class=\"number\">0.9</span>,　<span class=\"number\">1.4</span>,　<span class=\"number\">7.3</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">9.1</span>,　<span class=\"number\">8.5</span>,　<span class=\"number\">6.7</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">2.1</span>,　<span class=\"number\">0.8</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">1.1</span>,　<span class=\"number\">2.3</span>,　<span class=\"number\">6.1</span>,　<span class=\"number\">8.4</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">7.2</span>,　<span class=\"number\">9.9</span>,　<span class=\"number\">8.4</span>,　<span class=\"number\">3.3</span>,　<span class=\"number\">1.2</span>,　<span class=\"number\">0.8</span>,　<span class=\"number\">0.4</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">0.6</span>,　<span class=\"number\">1.7</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">6.2</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">7.6</span>,　<span class=\"number\">5.6</span>,　<span class=\"number\">3.8</span>,　<span class=\"number\">2.8</span>,　<span class=\"number\">3.8</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">1.3</span>,　<span class=\"number\">2.6</span>,　<span class=\"number\">5.2</span>　&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> year,month;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> subtot,total;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　YEAR　　 RAINFALL　 (inches)\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(year　=　<span class=\"number\">0</span>,　total　=　<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">    &#123;　　　　　　　　　　　　 <span class=\"comment\">// 每一年，各月的降水量总和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(month　=　<span class=\"number\">0</span>,　subtot　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">        subtot+=rain[year][month];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%5d　%15.1f\\n\"</span>,　<span class=\"number\">2010</span>　+　year,　subtot);</span><br><span class=\"line\">        total += subtot;　 <span class=\"comment\">// 5年的总降水量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nThe　yearly　average　is　%.1f　inches.\\n\\n\"</span>,　total　/　YEARS);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"MONTHLY　AVERAGES:\\n\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　Jan　 Feb　 Mar　 Apr　 May　 Jun　 Jul　 Aug　 Sep　 Oct　\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　Nov　 Dec\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(month　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">    &#123;　　　　　　　　　　　　 <span class=\"comment\">// 每个月，5年的总降水量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(year　=　<span class=\"number\">0</span>,　subtot　=　<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">        \tsubtot　+=　rain[year][month];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4.1f　\"</span>,　subtot　/　YEARS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">YEAR　　　<span class=\"title\">RAINFALL</span>　 <span class=\"params\">(inches)</span></span></span><br><span class=\"line\">2010　　　　　　　 32.4</span><br><span class=\"line\"><span class=\"number\">2011</span>　　　　　　　 <span class=\"number\">37.9</span></span><br><span class=\"line\"><span class=\"number\">2012</span>　　　　　　　 <span class=\"number\">49.8</span></span><br><span class=\"line\"><span class=\"number\">2013</span>　　　　　　　 <span class=\"number\">44.0</span></span><br><span class=\"line\"><span class=\"number\">2014</span>　　　　　　　 <span class=\"number\">32.9</span></span><br><span class=\"line\">The　yearly　average　is　<span class=\"number\">39.4</span>　inches.</span><br><span class=\"line\">MONTHLY　AVERAGES:</span><br><span class=\"line\">Jan　Feb　Mar　Apr　May　Jun　Jul　Aug　Sep　Oct　Nov　Dec</span><br><span class=\"line\"><span class=\"number\">7.3</span>　<span class=\"number\">7.3</span>　<span class=\"number\">4.9</span>　<span class=\"number\">3.0</span>　<span class=\"number\">2.3</span>　<span class=\"number\">0.6</span>　<span class=\"number\">1.2</span>　<span class=\"number\">0.3</span>　<span class=\"number\">0.5</span>　<span class=\"number\">1.7</span>　<span class=\"number\">3.6</span>　<span class=\"number\">6.7</span></span><br></pre></td></tr></table></figure><p>学习该程序的重点是数组初始化和计算方案。初始化二维数组比较复杂，我们先来看较为简单的计算部分。</p>\n<p>程序使用了两个嵌套<code>for</code>循环。第1个嵌套<code>for</code>循环的内层循环，在<code>year</code>不变的情况下，遍历<code>month</code>计算某年的总降水量；而外层循环，改变<code>year</code>的值，重复遍历<code>month</code>，计算5年的总降水量。这种嵌套循环结构常用于处理二维数组，一个循环处理数组的第1个下标，另一个循环处理数组的第2个下标：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>　(year　=　<span class=\"number\">0</span>,　total　=　<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 处理每一年的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(month　=　<span class=\"number\">0</span>,　subtot　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">    ...<span class=\"comment\">// 处理每月的数据</span></span><br><span class=\"line\">    ...<span class=\"comment\">//处理每一年的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>第2个嵌套<code>for</code>循环和第1个的结构相同，但是内层循环遍历<code>year</code>，外层循环遍历<code>month</code>。记住，每执行一次外层循环，就完整遍历一次内层循环。因此，在改变月份之前，先遍历完年，得到某月 5 年间的平均降水量，以此类推：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>　(month　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 处理每月的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(year　=　<span class=\"number\">0</span>,　subtot　=<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">    ...<span class=\"comment\">// 处理每年的数据</span></span><br><span class=\"line\">    ...<span class=\"comment\">// 处理每月的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"初始化二维数组\">初始化二维数组<a href=\"#初始化二维数组\" title=\"初始化二维数组\"></a></h3><p>初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sometype ar1[<span class=\"number\">5</span>] = &#123;val1, val2, val3, val4, val5&#125;;</span><br></pre></td></tr></table></figure><p>这里，<code>val1</code>、<code>val2</code>等表示<code>sometype</code>类型的值。例如，如果<code>sometype</code>是<code>int</code>，那么<code>val1</code>可能是7；如果<code>sometype</code>是<code>double</code>，那么<code>val1</code>可能是11.34，诸如此类。但是<code>rain</code>是一个内含5个元素的数组，每个元素又是内含12个<code>float</code>类型元素的数组。所以，对<code>rain</code>而言，<code>val1</code>应该包含12个值，用于初始化内含12个<code>float</code>类型元素的一维数组，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">3.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">1.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.4</span>,<span class=\"number\">2.4</span>,<span class=\"number\">3.5</span>,<span class=\"number\">6.6</span>&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果<code>sometype</code>是一个内含12个<code>double</code>类型元素的数组，那么val1就是一个由12个<code>double</code>类型值构成的数值列表。因此，为了初始化二维数组<code>rain</code>，要用逗号分隔5个这样的数值列表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> rain[YEARS][MONTHS]　=</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">3.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">1.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.4</span>,<span class=\"number\">2.4</span>,<span class=\"number\">3.5</span>,<span class=\"number\">6.6</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">8.5</span>,<span class=\"number\">8.2</span>,<span class=\"number\">1.2</span>,<span class=\"number\">1.6</span>,<span class=\"number\">2.4</span>,<span class=\"number\">0.0</span>,<span class=\"number\">5.2</span>,<span class=\"number\">0.9</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.4</span>,<span class=\"number\">7.3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">9.1</span>,<span class=\"number\">8.5</span>,<span class=\"number\">6.7</span>,<span class=\"number\">4.3</span>,<span class=\"number\">2.1</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">1.1</span>,<span class=\"number\">2.3</span>,<span class=\"number\">6.1</span>,<span class=\"number\">8.4</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">7.2</span>,<span class=\"number\">9.9</span>,<span class=\"number\">8.4</span>,<span class=\"number\">3.3</span>,<span class=\"number\">1.2</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.6</span>,<span class=\"number\">1.7</span>,<span class=\"number\">4.3</span>,<span class=\"number\">6.2</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">7.6</span>,<span class=\"number\">5.6</span>,<span class=\"number\">3.8</span>,<span class=\"number\">2.8</span>,<span class=\"number\">3.8</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.3</span>,<span class=\"number\">2.6</span>,<span class=\"number\">5.2</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>这个初始化使用了5个数值列表，每个数值列表都用花括号括起来。第1个列表的数据用于初始化数组的第1行，第2个列表的数据用于初始化数组的第2行，以此类推。前面讨论的数据个数和数组大小不匹配的问题同样适用于这里的每一行。也就是说，如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。</p>\n<p>初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。图10.2演示了这种初始化数组的方法。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/初始化二维数组的两种方法.png\" class=\"φcy\"></p>\n<p>因为储存在数组<code>rain</code>中的数据不能修改，所以程序使用了<code>const</code>关键字声明该数组。</p>\n<h3 id=\"其他多维数组\">其他多维数组<a href=\"#其他多维数组\" title=\"其他多维数组\"></a></h3><p>前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> box[<span class=\"number\">10</span>][<span class=\"number\">20</span>][<span class=\"number\">30</span>];</span><br></pre></td></tr></table></figure><p>可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组<code>box</code>想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。</p>\n<p>还有一种理解<code>box</code>的方法是，把<code>box</code>看作数组的数组。也就是说，<code>box</code>内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。或者，可以简单地根据所需的下标值去理解数组。</p>\n<p>通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推。在后面的程序示例中，我们只使用二维数组。</p>\n<h2 id=\"指针和数组\">指针和数组<a href=\"#指针和数组\" title=\"指针和数组\"></a></h2><p>第9章介绍过指针，指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。我们很快就会学到，数组表示法其实是在变相地使用指针。</p>\n<p>我们举一个变相使用指针的例子：<mark><strong>数组名是数组首元素的地址</strong></mark>。也就是说，如果<code>flizny</code>是一个数组，下面的语句成立：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flizny == &amp;flizny[<span class=\"number\">0</span>]; <span class=\"comment\">// 数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure><p><code>flizny</code> 和<code>&amp;flizny[0]</code>都表示数组首元素的内存地址（<code>&amp;</code>是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值，如程序清单10.8所示。注意指针加上一个数时，它的值发生了什么变化（<strong>转换说明<code>%p</code>通常以十六进制显示指针的值</strong>）。</p>\n<p>程序清单10.8 pnt_add.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pnt_add.c -- 指针地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    short dates[SIZE];</span><br><span class=\"line\">    short * pti;</span><br><span class=\"line\">    short index;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> bills[SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> * ptf;</span><br><span class=\"line\">    pti = dates;　<span class=\"comment\">// 把数组地址赋给指针</span></span><br><span class=\"line\">    ptf　=　bills;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%23s　%15s\\n\"</span>,　<span class=\"string\">\"short\"</span>,　<span class=\"string\">\"double\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(index　=　<span class=\"number\">0</span>;　index　&lt;　SIZE;　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"pointers　+　%d:　%10p　%10p\\n\"</span>,　index,　pti　+　index,　ptf　+　index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该例的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short　　　　　　　　<span class=\"keyword\">double</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">0</span>:　<span class=\"number\">0x7fff5fbff8dc</span>　<span class=\"number\">0x7fff5fbff8a0</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">1</span>:　<span class=\"number\">0x7fff5fbff8de</span>　<span class=\"number\">0x7fff5fbff8a8</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">2</span>:　<span class=\"number\">0x7fff5fbff8e0</span>　<span class=\"number\">0x7fff5fbff8b0</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">3</span>:　<span class=\"number\">0x7fff5fbff8e2</span>　<span class=\"number\">0x7fff5fbff8b8</span></span><br></pre></td></tr></table></figure><p>第2行打印的是两个数组开始的地址，下一行打印的是指针加1后的地址，以此类推。注意，地址是十六进制的，因此<code>dd</code>比<code>dc</code>大1，<code>a1</code>比<code>a0</code>大1。但是，显示的地址是怎么回事？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x7fff5fbff8dc</span> + <span class=\"number\">1</span>是否是<span class=\"number\">0x7fff5fbff8de</span>?</span><br><span class=\"line\"><span class=\"number\">0x7fff5fbff8a0</span> + <span class=\"number\">1</span>是否是<span class=\"number\">0x7fff5fbff8a8</span>?</span><br></pre></td></tr></table></figure><p>我们的系统中，地址按字节编址，<code>short</code>类型占用<strong>2字节</strong>，<code>double</code>类型占用<strong>8字节</strong>。<mark><strong>在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址</strong></mark>（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使<strong>指针指向的是标量变量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值</strong>）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/数组和指针加法.png\" class=\"φcy\"></p>\n<p>现在可以更清楚地定义指向<code>int</code>的指针、指向<code>float</code>的指针，以及指向其他数据对象的指针。</p>\n<p>指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如<code>double</code>类型的变量）通常是该对象第一个字节的地址。</p>\n<p>在指针前面使用<code>*</code>运算符可以得到该指针所指向对象的值。</p>\n<p><strong>指针加1，指针的值递增它所指向类型的大小（以字节为单位）</strong>。</p>\n<p>下面的等式体现了C语言的灵活性：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dates + <span class=\"number\">2</span> == &amp;date[<span class=\"number\">2</span>]　　　 <span class=\"comment\">// 相同的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">*(dates + <span class=\"number\">2</span>) == dates[<span class=\"number\">2</span>]　 <span class=\"comment\">// 相同的值</span></span><br></pre></td></tr></table></figure><p>以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义<code>ar[n]</code>的意思是<code>*(ar + n)</code>。可以认为<code>*(ar + n)</code>的意思是“<strong>到内存的ar位置，然后移动n个单元，检索储存在那里的值</strong>”。</p>\n<p>顺带一提，不要混淆 <code>*(dates+2)</code>和<code>*dates+2</code>。间接运算符<code>（*）</code>的优先级高于<code>+</code>，所以<code>*dates+2</code>相当于<code>(*dates)+2</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(dates + <span class=\"number\">2</span>)　<span class=\"comment\">// dates第3个元素的值</span></span><br><span class=\"line\">*dates + <span class=\"number\">2</span>　　<span class=\"comment\">// dates第1个元素的值加2</span></span><br></pre></td></tr></table></figure><p>明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指针表示法。运行程序清单 10.9后输出的结果和程序清单10.1输出的结果相同。</p>\n<p>程序清单10.9 day_mon3.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* day_mon3.c -- uses pointer notation */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> days[MONTHS]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(index　=　<span class=\"number\">0</span>;　index　&lt;　MONTHS;　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Month　%2d　has　%d　days.\\n\"</span>,　index　+　<span class=\"number\">1</span>,</span><br><span class=\"line\">    *(days + index));　<span class=\"comment\">//与 days[index]相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>days</code>是数组首元素的地址，<code>days + index</code>是元素<code>days[index]</code>的地址，而<code>*(days + index)</code>则是该元素的值，相当于<code>days[index]</code>。<code>for</code>循环依次引用数组中的每个元素，并打印各元素的内容。</p>\n<p>这样编写程序是否有优势？不一定。编译器编译这两种写法生成的代码相同。程序清单 10.9 要注意的是，指针表示法和数组表示法是两种等效的方法。该例演示了可以用指针表示数组，反过来，也可以用数组表示指针。在使用以数组为参数的函数时要注意这点。</p>\n<h2 id=\"函数、数组和指针\">函数、数组和指针<a href=\"#函数、数组和指针\" title=\"函数、数组和指针\"></a></h2><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为<code>marbles</code>的<code>int</code>类型数组。应该如何调用该函数？也许是下面这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total = sum(marbles); <span class=\"comment\">// 可能的函数调用</span></span><br></pre></td></tr></table></figure><p>那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以实际参数<code>marbles</code>是一个储存<code>int</code>类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向<code>int</code>的指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar)</span></span>; <span class=\"comment\">// 对应的函数原型</span></span><br></pre></td></tr></table></figure><p><code>sum()</code>从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar)</span> <span class=\"comment\">// 相应的函数定义</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)　　<span class=\"comment\">// 假设数组有10个元素</span></span><br><span class=\"line\">    \ttotal += ar[i];　　　　<span class=\"comment\">// ar[i] 与 *(ar + i) 相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>既然能使用指针表示数组名，也可以用数组名表示指针。另外，回忆一下，<code>+=</code>运算符把右侧运算对象加到左侧运算对象上。因此，<code>total</code>是当前数组元素之和。</p>\n<p>该函数定义有限制，只能计算10个<code>int</code>类型的元素。另一个比较灵活的方法是把数组大小作为第2个参数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar,<span class=\"keyword\">int</span> n)</span>　　　 <span class=\"comment\">// 更通用的方法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)　　 <span class=\"comment\">// 使用 n 个元素</span></span><br><span class=\"line\">    total += ar[i];　　　　<span class=\"comment\">// ar[i] 和 *(ar + i) 相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里，第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数。</p>\n<p>关于函数的形参，还有一点要注意。<strong>只有在<code>函数原型</code>或<code>函数定义头</code>中，才可以用<code>int ar[]</code>代替<code>int * ar</code></strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span> <span class=\"params\">(<span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p><code>int *ar</code>形式和<code>int ar[]</code>形式都表示<code>ar</code>是一个指向<code>int</code>的指针。但是，<code>int ar[]</code>只能用于声明形式参数。第2种形式（<code>int ar[]</code>）提醒读者指针<code>ar</code>指向的不仅仅一个<code>int</code>类型值，还是一个<code>int</code>类型数组的元素。</p>\n<p>注意 声明数组形参</p>\n<p>因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把<code>int ar[]</code>和<code>int * ar</code>解释成一样。也就是说，ar是指向<code>int</code>的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar, <span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>　[],　<span class=\"keyword\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 其他代码已省略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[],　<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//其他代码已省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以使用以上提到的任意一种函数原型和函数定义。</p>\n<p>程序清单 10.10 演示了一个程序，使用 <code>sum()</code>函数。该程序打印原始数组的大小和表示该数组的函数形参的大小（如果你的编译器不支持用转换说明<code>%zd</code>打印<code>sizeof</code>返回值，可以用<code>%u</code>或<code>%lu</code>来代替）。</p>\n<p>程序清单10.10 sum_arr1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sum_arr1.c -- 数组元素之和</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果编译器不支持 %zd，用 %u 或 %lu 替换它</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> marbles[SIZE]　=　&#123;　<span class=\"number\">20</span>,　<span class=\"number\">10</span>,　<span class=\"number\">5</span>,　<span class=\"number\">39</span>,　<span class=\"number\">4</span>,　<span class=\"number\">16</span>,　<span class=\"number\">19</span>,　<span class=\"number\">26</span>,　<span class=\"number\">31</span>,　<span class=\"number\">20</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> answer;</span><br><span class=\"line\">    answer　=　sum(marbles,　SIZE);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　total　number　of　marbles　is　%ld.\\n\"</span>,　answer);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　size　of　marbles　is　%zd　bytes.\\n\"</span>,</span><br><span class=\"line\">    <span class=\"keyword\">sizeof</span>　marbles);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span>　　 <span class=\"comment\">// 这个数组的大小是？</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \ttotal　+=　ar[i];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　size　of　ar　is　%zd　bytes.\\n\"</span>,　<span class=\"keyword\">sizeof</span>　ar);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The　<span class=\"built_in\">size</span>　of　ar　is　<span class=\"number\">8</span>　bytes.</span><br><span class=\"line\">The　total　number　of　marbles　is　<span class=\"number\">190.</span></span><br><span class=\"line\">The　<span class=\"built_in\">size</span>　of　marbles　is　<span class=\"number\">40</span>　bytes.</span><br></pre></td></tr></table></figure><p>注意，<code>marbles</code>的大小是40字节。这没问题，因为<code>marbles</code>内含10个<code>int</code>类型的值，每个值占4字节，所以整个<code>marbles</code>的大小是40字节。但是，<code>ar</code>才8字节。这是因为<code>ar</code>并不是数组本身，它是一个指向 <code>marbles</code> 数组首元素的指针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8字节（其他系统中地址的大小可能不是8字节）。简而言之，在程序清单10.10中，<code>marbles</code>是一个数组， <code>ar</code>是一个指向<code>marbles</code>数组首元素的指针，利用C中数组和指针的特殊关系，可以用数组表示法来表示指针<code>ar</code>。</p>\n<h3 id=\"使用指针形参\">使用指针形参<a href=\"#使用指针形参\" title=\"使用指针形参\"></a></h3><p>函数要处理数组必须知道何时开始、何时结束。<code>sum()</code>函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。程序清单10.11演示了这种方法，同时该程序也表明了指针形参是变量，这意味着可以用索引表明访问数组中的哪一个元素。</p>\n<p>程序清单10.11 sum_arr2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sump</span><span class=\"params\">(<span class=\"keyword\">int</span> *start, <span class=\"keyword\">int</span> *<span class=\"built_in\">end</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> marbles[SIZE]　=　&#123;　<span class=\"number\">20</span>,　<span class=\"number\">10</span>,　<span class=\"number\">5</span>,　<span class=\"number\">39</span>,　<span class=\"number\">4</span>,　<span class=\"number\">16</span>,　<span class=\"number\">19</span>,　<span class=\"number\">26</span>,　<span class=\"number\">31</span>,　<span class=\"number\">20</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> answer;</span><br><span class=\"line\">    answer　=　sump(marbles,　marbles　+　SIZE);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　total　number　of　marbles　is　%ld.\\n\"</span>,　answer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 使用指针算法 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sump</span><span class=\"params\">(<span class=\"keyword\">int</span> * start, <span class=\"keyword\">int</span> * <span class=\"built_in\">end</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start　&lt;　<span class=\"built_in\">end</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        total += *start;　 <span class=\"comment\">// 把数组元素的值加起来</span></span><br><span class=\"line\">        start++;　　　　　　<span class=\"comment\">// 让指针指向下一个元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>指针<code>start</code>开始指向<code>marbles</code>数组的首元素，所以赋值表达式<code>total += *start</code>把首元素（20）加给<code>total</code>。然后，表达式<code>start++</code>递增指针变量<code>start</code>，使其指向数组的下一个元素。因为<code>start</code>是指向<code>int</code>的指针，<code>start</code>递增1相当于其值递增<code>int</code>类型的大小。</p>\n<p>注意，<code>sump()</code>函数用另一种方法结束加法循环。<code>sum()</code>函数把元素的个数作为第2个参数，并把该参数作为循环测试的一部分：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br></pre></td></tr></table></figure><p>而<code>sump()</code>函数则使用第2个指针来结束循环：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (start &lt; <span class=\"built_in\">end</span>)</span><br></pre></td></tr></table></figure><p>因为<code>while</code>循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素是<code>end</code>所指向位置的前一个元素。这意味着<code>end</code>指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。这使得 <code>while</code>循环的测试条件是有效的，因为 <code>start</code>在循环中最后的值是<code>end</code>。注意，使用这种“越界”指针的函数调用更为简洁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = sump(marbles, marbles + SIZE);</span><br></pre></td></tr></table></figure><p>因为下标从0开始，所以<code>marbles + SIZE</code>指向数组末尾的下一个位置。如果<code>end</code>指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = sump(marbles, marbles + SIZE - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><p>这种写法既不简洁也不好记，很容易导致编程错误。顺带一提，虽然C保证了<code>marbles + SIZE</code>有效，但是对<code>marbles[SIZE]</code>（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。</p>\n<p>还可以把循环体压缩成一行代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total += *start++;</span><br></pre></td></tr></table></figure><p>一元运算符<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code>。也就是说，指针start先递增后指向。使用后缀形式（即<code>start++</code>而不是<code>++start</code>）意味着先把指针指向位置上的值加到<code>total</code>上，然后再递增指针。如果使用<code>*++start</code>，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用<code>(*start)++</code>，则先使用<code>start</code>指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然<code>*start++</code>的写法比较常用，但是<code>*(start++)</code>这样写更清楚。程序清单10.12的程序演示了这些优先级的情况。</p>\n<p>程序清单10.12 order.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* order.c -- 指针运算中的优先级 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">2</span>]　=　&#123;　<span class=\"number\">100</span>,　<span class=\"number\">200</span>　&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> moredata[<span class=\"number\">2</span>]　=　&#123;　<span class=\"number\">300</span>,　<span class=\"number\">400</span>　&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> * p1, *p2, *p3;</span><br><span class=\"line\">    p1　=　p2　=　data;</span><br><span class=\"line\">    p3　=　moredata;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\"</span>,*p1, *p2, *p3);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*p1++ = %d, *++p2 = %d, (*p3)++ = %d\\n\"</span>,*p1++, *++p2, (*p3)++);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\"</span>,*p1, *p2, *p3);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*p1 = <span class=\"number\">100</span>,　 *p2 = <span class=\"number\">100</span>,　　　*p3 = <span class=\"number\">300</span></span><br><span class=\"line\">*p1++ = <span class=\"number\">100</span>, *++p2 = <span class=\"number\">200</span>,　(*p3)++ = <span class=\"number\">300</span></span><br><span class=\"line\">*p1 = <span class=\"number\">200</span>,　 *p2 = <span class=\"number\">200</span>,　　　*p3 = <span class=\"number\">301</span></span><br></pre></td></tr></table></figure><p>只有<code>(*p3)++</code>改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。</p>\n<h3 id=\"指针表示法和数组表示法\">指针表示法和数组表示法<a href=\"#指针表示法和数组表示法\" title=\"指针表示法和数组表示法\"></a></h3><p>从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。如程序清单10.10所示，使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然，如程序清单10.11所示。</p>\n<p>至于C语言，<code>ar[i]</code>和<code>*(ar+1)</code>这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用<code>ar++</code>这样的表达式。</p>\n<p>指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。</p>\n<h2 id=\"指针操作\">指针操作<a href=\"#指针操作\" title=\"指针操作\"></a></h2><p>可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作。为了显示每种操作的结果，该程序打印了指针的值（该指针指向的地址）、储存在指针指向地址上的值，以及指针自己的地址。如果编译器不支持<code>%p</code> 转换说明，可以用<code>%u</code> 或<code>%lu</code> 代替<code>%p</code>；如果编译器不支持用<code>%td</code>转换说明打印地址的差值，可以用<code>%d</code>或<code>%ld</code>来代替。</p>\n<p>程序清单10.13演示了指针变量的 8种基本操作。除了这些操作，还可以使用关系运算符来比较指针。</p>\n<p>程序清单10.13 ptr_ops.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ptr_ops.c -- 指针操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　urn[<span class=\"number\">5</span>]　=　&#123;　<span class=\"number\">100</span>,　<span class=\"number\">200</span>,　<span class=\"number\">300</span>,　<span class=\"number\">400</span>,　<span class=\"number\">500</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *ptr1,*ptr2,*ptr3;</span><br><span class=\"line\">    ptr1 = urn;　　　　　　　<span class=\"comment\">// 把一个地址赋给指针</span></span><br><span class=\"line\">    ptr2 = &amp;urn[<span class=\"number\">2</span>];　　　　 <span class=\"comment\">// 把一个地址赋给指针</span></span><br><span class=\"line\">    <span class=\"comment\">// 解引用指针，以及获得指针的地址</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"pointer　value,　dereferenced　pointer,　pointer　address:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class=\"line\">    <span class=\"comment\">// 指针加法</span></span><br><span class=\"line\">    ptr3　=　ptr1　+　<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nadding　an　int　to　a　pointer:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1 + 4 = %p, *(ptr1 + 4) = %d\\n\"</span>, ptr1 + <span class=\"number\">4</span>, *(ptr1 + <span class=\"number\">4</span>));</span><br><span class=\"line\">    ptr1++;　　　　　　　　　<span class=\"comment\">// 递增指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nvalues　after　ptr1++:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class=\"line\">    ptr2--;　　　　　　　　　<span class=\"comment\">// 递减指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nvalues　after　--ptr2:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\\n\"</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class=\"line\">    --ptr1;　　　　　　　　　<span class=\"comment\">// 恢复为初始值</span></span><br><span class=\"line\">    ++ptr2;　　　　　　　　　<span class=\"comment\">// 恢复为初始值</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nPointers　reset　to　original　values:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1　=　%p,　ptr2　=　%p\\n\"</span>,　ptr1,　ptr2);</span><br><span class=\"line\">    <span class=\"comment\">// 一个指针减去另一个指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nsubtracting　one　pointer　from　another:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\\n\"</span>,　ptr2,　ptr1,　ptr2　-　ptr1);</span><br><span class=\"line\">    <span class=\"comment\">// 一个指针减去一个整数</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nsubtracting　an　int　from　a　pointer:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr3　=　%p,　ptr3　-　2　=　%p\\n\"</span>,　ptr3,　ptr3　-　<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是我们的系统运行该程序后的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pointer value, dereferenced pointer, pointer address:</span><br><span class=\"line\">ptr1 = <span class=\"number\">0x7fff5fbff8d0</span>, *ptr1 =<span class=\"number\">100</span>, &amp;ptr1 = <span class=\"number\">0x7fff5fbff8c8</span></span><br><span class=\"line\">adding an <span class=\"keyword\">int</span> to a pointer:</span><br><span class=\"line\">ptr1 + <span class=\"number\">4</span> = <span class=\"number\">0x7fff5fbff8e0</span>, *(ptr1 + <span class=\"number\">4</span>) = <span class=\"number\">500</span></span><br><span class=\"line\">values after ptr1++:</span><br><span class=\"line\">ptr1 = <span class=\"number\">0x7fff5fbff8d4</span>, *ptr1 =<span class=\"number\">200</span>, &amp;ptr1 = <span class=\"number\">0x7fff5fbff8c8</span></span><br><span class=\"line\">values after --ptr2:</span><br><span class=\"line\">ptr2 = <span class=\"number\">0x7fff5fbff8d4</span>, *ptr2 = <span class=\"number\">200</span>, &amp;ptr2 = <span class=\"number\">0x7fff5fbff8c0</span></span><br><span class=\"line\">Pointers reset to original values:</span><br><span class=\"line\">ptr1 = <span class=\"number\">0x7fff5fbff8d0</span>, ptr2 = <span class=\"number\">0x7fff5fbff8d8</span></span><br><span class=\"line\">subtracting one pointer from another:</span><br><span class=\"line\">ptr2 = <span class=\"number\">0x7fff5fbff8d8</span>, ptr1 = <span class=\"number\">0x7fff5fbff8d0</span>, ptr2 - ptr1 = <span class=\"number\">2</span></span><br><span class=\"line\">subtracting an <span class=\"keyword\">int</span> from a pointer:</span><br><span class=\"line\">ptr3 = <span class=\"number\">0x7fff5fbff8e0</span>, ptr3 - <span class=\"number\">2</span> = <span class=\"number\">0x7fff5fbff8d8</span></span><br></pre></td></tr></table></figure><p>下面分别描述了指针变量的基本操作。</p>\n<p><strong>赋值</strong>：可以把地址赋给指针。例如，用数组名、带地址运算符（<code>&amp;</code>）的变量名、另一个指针进行赋值。在该例中，把urn数组的首地址赋给了ptr1，该地址的编号恰好是0x7fff5fbff8d0。变量ptr2获得数组urn的第3个元素（urn[2]）的地址。注意，地址应该和指针类型兼容。也就是说，不能把<code>double</code>类型的地址赋给指向<code>int</code>的指针，至少要避免不明智的类型转换。C99/C11已经强制不允许这样做。</p>\n<p><strong>解引用</strong>：<code>*</code>运算符给出指针指向地址上储存的值。因此，<code>*ptr1</code>的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。</p>\n<p><strong>取址</strong>：和所有变量一样，指针变量也有自己的地址和值。对指针而言，<code>&amp;</code>运算符给出指针本身的地址。本例中，<code>ptr1</code> 储存在内存编号为 0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即<code>urn</code>的地址。因此<code>&amp;ptr1</code>是指向<code>ptr1</code>的指针，而<code>ptr1</code>是指向<code>utn[0]</code>的指针。</p>\n<p><strong>指针与整数相加</strong>：可以使用<code>+</code>运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此<code>ptr1 +4</code>与<code>&amp;urn[4]</code>等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</p>\n<p><strong>递增指针</strong>：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，<code>ptr1++</code>相当于把<code>ptr1</code>的值加上4（我们的系统中<code>int</code>为4字节），<code>ptr1</code>指向<code>urn[1]</code>（见图10.4，该图中使用了简化的地址）。现在<code>ptr1</code>的值是0x7fff5fbff8d4（数组的下一个元素的地址），<code>*ptr</code>的值为200（即urn[1]的值）。注意，<code>ptr1</code>本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/递增指向int的指针.png\" class=\"φcy\"></p>\n<p><strong>指针减去一个整数</strong>：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以<code>ptr3 - 2</code>与<code>&amp;urn[2]</code>等价，因为<code>ptr3</code>指向的是<code>&amp;arn[4]</code>。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</p>\n<p><strong>递减指针</strong>：当然，除了递增指针还可以递减</p>\n<p><strong>递减指针</strong>：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素<code>urn[1]</code>。</p>\n<p><strong>指针求差</strong>：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，<code>ptr2 - ptr1</code>得2，意思是这两个指针所指向的两个元素相隔两个<code>int</code>，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。</p>\n<p><strong>比较</strong>：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</p>\n<p>注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。</p>\n<p>在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。</p>\n<p>解引用未初始化的指针</p>\n<p>说到注意事项，一定要牢记一点：<mark><strong>千万不要解引用未初始化的指针</strong></mark>。例如，考虑下面的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pt;<span class=\"comment\">// 未初始化的指针</span></span><br><span class=\"line\">*pt = <span class=\"number\">5</span>;　　　<span class=\"comment\">// 严重的错误</span></span><br></pre></td></tr></table></figure><p>为何不行？第2行的意思是把5储存在pt指向的位置。但是<code>pt</code>未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使用第12章将介绍的<code>malloc()</code>函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> *pd;　<span class=\"comment\">// 未初始化的指针</span></span><br><span class=\"line\">*pd =<span class=\"number\">2.4</span>;　　<span class=\"comment\">// 不要这样做</span></span><br><span class=\"line\">假设</span><br><span class=\"line\"><span class=\"keyword\">int</span> urn[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptr1,*ptr2;</span><br></pre></td></tr></table></figure><p>下面是一些有效和无效的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有效语句　　　　　　　　　　\t   无效语句</span><br><span class=\"line\">ptr1++;　　　　　　　　　　　　  urn++;</span><br><span class=\"line\">ptr2　=　ptr1　+　<span class=\"number\">2</span>;　　　　　  ptr2　=　ptr2　+　ptr1;</span><br><span class=\"line\">ptr2　=　urn　+　<span class=\"number\">1</span>;　　　　　　 ptr2　=　urn　*　ptr1;</span><br></pre></td></tr></table></figure><p>基于这些有效的操作，C 程序员创建了指针数组、函数指针、指向指针的指针数组、指向函数的指针数组等。别紧张，接下来我们将根据已学的内容介绍指针的一些基本用法。指针的第 1 个基本用法是在函数间传递信息。前面学过，<strong>如果希望在被调函数中改变主调函数的变量，必须使用指针</strong>。指针的第 2 个基本用法是用在处理数组的函数中。下面我们再来看一个使用函数和数组的编程示例。</p>\n<h2 id=\"保护数组中的数据\">保护数组中的数据<a href=\"#保护数组中的数据\" title=\"保护数组中的数据\"></a></h2><p>编写一个处理基本类型（如，<code>int</code>）的函数时，要选择是传递<code>int</code>类型的值还是传递指向<code>int</code>的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p>\n<p>传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的。例如，下面的函数给数组的每个元素都加上一个相同的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_to</span><span class=\"params\">(<span class=\"keyword\">double</span> ar[],<span class=\"keyword\">int</span> n,<span class=\"keyword\">double</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    \tar[i]+=val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>因此，调用该函数后，<code>prices</code>数组中的每个元素的值都增加了2.5：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add_to(prices, <span class=\"number\">100</span>, <span class=\"number\">2.50</span>);</span><br></pre></td></tr></table></figure><p>该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。</p>\n<p>然而，其他函数并不需要修改数据。例如，下面的函数计算数组中所有元素之和，它不用改变数组的数据。但是，由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。例如，下面示例中的<code>ar[i]++</code>会导致数组中每个元素的值都加1：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">// 错误的代码</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    \ttotal += ar[i]++;　<span class=\"comment\">// 错误递增了每个元素的值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"对形式参数使用const\">对形式参数使用const<a href=\"#对形式参数使用const\" title=\"对形式参数使用const\"></a></h3><p>在K&amp;R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字<code>const</code>。例如，<code>sum()</code>函数的原型和定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/* 函数原型 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">/* 函数定义 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(　i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \ttotal　+=　ar[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中的<code>const</code>告诉编译器，该函数不能修改ar指向的数组中的内容。如果在函数中不小心使用类似<code>ar[i]++</code>的表达式，编译器会捕获这个错误，并生成一条错误信息。</p>\n<p>这里一定要理解，这样使用<code>const</code>并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用<code>const</code>可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用<code>const</code>；如果编写的函数不用修改数组，那么在声明数组形参时最好使用<code>const</code>。</p>\n<p>程序清单10.14的程序中，一个函数显示数组的内容，另一个函数给数组每个元素都乘以一个给定值。因为第1个函数不用改变数组，所以在声明数组形参时使用了<code>const</code>；而第2个函数需要修改数组元素的值，所以不使用<code>const</code>。</p>\n<p>程序清单10.14 arf.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* arf.c -- 处理数组的函数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_array</span><span class=\"params\">(<span class=\"keyword\">const</span>　<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mult_array</span><span class=\"params\">(<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n,　<span class=\"keyword\">double</span>　mult)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> dip[SIZE]　=　&#123;　<span class=\"number\">20.0</span>,　<span class=\"number\">17.66</span>,　<span class=\"number\">8.2</span>,　<span class=\"number\">15.3</span>,　<span class=\"number\">22.22</span>　&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　original　dip　array:\\n\"</span>);</span><br><span class=\"line\">    show_array(dip,　SIZE);</span><br><span class=\"line\">    mult_array(dip,　SIZE,　<span class=\"number\">2.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　dip　array　after　calling　mult_array():\\n\"</span>);</span><br><span class=\"line\">    show_array(dip,　SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 显示数组的内容 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_array</span><span class=\"params\">(<span class=\"keyword\">const</span>　<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%8.3f　\"</span>,　ar[i]);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 把数组的每个元素都乘以相同的值 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mult_array</span><span class=\"params\">(<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n,　<span class=\"keyword\">double</span>　mult)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \tar[i] *= mult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The　original　dip　<span class=\"built_in\">array</span>:</span><br><span class=\"line\"><span class=\"number\">20.000</span>　　<span class=\"number\">17.660</span>　　　<span class=\"number\">8.200</span>　　　<span class=\"number\">15.300</span>　　<span class=\"number\">22.220</span></span><br><span class=\"line\"><span class=\"function\">The　dip　<span class=\"built_in\">array</span>　after　calling　<span class=\"title\">mult_array</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">50.000　　44.150　　　20.500　　38.250　　55.550</span><br></pre></td></tr></table></figure><p>注意该程序中两个函数的返回类型都是<code>void</code>。虽然<code>mult_array()</code>函数更新了<code>dip</code>数组的值，但是并未使用<code>return</code>机制。</p>\n<h3 id=\"const的其他内容\">const的其他内容<a href=\"#const的其他内容\" title=\"const的其他内容\"></a></h3><p>我们在前面使用<code>const</code>创建过变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.14159</span>;</span><br></pre></td></tr></table></figure><p>虽然用<code>#define</code>指令可以创建类似功能的符号常量，但是<code>const</code>的用法更加灵活。可以创建<code>const</code>数组、<code>const</code>指针和指向<code>const</code>的指针。</p>\n<p>程序清单10.4演示了如何使用<code>const</code>关键字保护数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> days[MONTHS] =&#123;<span class=\"number\">31</span>,<span class=\"number\">28</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">days[<span class=\"number\">9</span>] = <span class=\"number\">44</span>;　　 <span class=\"comment\">/* 编译错误 */</span></span><br></pre></td></tr></table></figure><p>指向<code>const</code>的指针不能用于改变值。考虑下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *pd = rates;　　 <span class=\"comment\">// pd指向数组的首元素</span></span><br></pre></td></tr></table></figure><p>第2行代码把pd指向的<code>double</code>类型的值声明为<code>const</code>，这表明不能使用pd来更改它所指向的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*pd = <span class=\"number\">29.89</span>;　　　<span class=\"comment\">// 不允许</span></span><br><span class=\"line\">pd[<span class=\"number\">2</span>] = <span class=\"number\">222.22</span>;　　<span class=\"comment\">//不允许</span></span><br><span class=\"line\">rates[<span class=\"number\">0</span>] = <span class=\"number\">99.99</span>; <span class=\"comment\">// 允许，因为rates未被const限定</span></span><br></pre></td></tr></table></figure><p>无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。但是要注意，因为<code>rates</code>并未被声明为<code>const</code>，所以仍然可以通过<code>rates</code>修改元素的值。另外，可以让pd指向别处：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pd++; <span class=\"comment\">/* 让pd指向rates[1] -- 没问题 */</span></span><br></pre></td></tr></table></figure><p>指向 <code>const</code> 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。例如，程序清单 10.14中的<code>show_array()</code>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_array</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *ar, <span class=\"keyword\">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>关于指针赋值和<code>const</code>需要注意一些规则。首先，<strong>把<code>const</code>数据或非<code>const</code>数据的地址初始化为指向<code>const</code>的指针或为其赋值是合法的</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> locked[<span class=\"number\">4</span>]　=　&#123;<span class=\"number\">0.08</span>,　<span class=\"number\">0.075</span>,　<span class=\"number\">0.0725</span>,　<span class=\"number\">0.07</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *pc = rates; <span class=\"comment\">// 有效</span></span><br><span class=\"line\">pc = locked;　　　　　　　　 <span class=\"comment\">//有效</span></span><br><span class=\"line\">pc = &amp;rates[<span class=\"number\">3</span>];　　　　　　　<span class=\"comment\">//有效</span></span><br></pre></td></tr></table></figure><p>然而，<strong>只能把非<code>const</code>数据的地址赋给普通指针</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> locked[<span class=\"number\">4</span>]　=　&#123;<span class=\"number\">0.08</span>,　<span class=\"number\">0.075</span>,　<span class=\"number\">0.0725</span>,　<span class=\"number\">0.07</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pnc = rates;　<span class=\"comment\">// 有效</span></span><br><span class=\"line\">pnc = locked;　　　　　 <span class=\"comment\">// 无效</span></span><br><span class=\"line\">pnc = &amp;rates[<span class=\"number\">3</span>];　　　　<span class=\"comment\">// 有效</span></span><br></pre></td></tr></table></figure><p>这个规则非常合理。否则，通过指针就能改变<code>const</code>数组中的数据。</p>\n<p>应用以上规则的例子，如 <code>show_array()</code>函数可以接受普通数组名和 <code>const</code> 数组名作为参数，因为这两种参数都可以用来初始化指向<code>const</code>的指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show_array(rates,<span class=\"number\">5</span>);　　　 <span class=\"comment\">// 有效</span></span><br><span class=\"line\">show_array(locked,<span class=\"number\">4</span>);　　　<span class=\"comment\">// 有效</span></span><br></pre></td></tr></table></figure><p>因此，对函数的形参使用<code>const</code>不仅能保护数据，还能让函数处理<code>const</code>数组。</p>\n<p>另外，不应该把<code>const</code>数组名作为实参传递给<code>mult_array()</code>这样的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mult_array(rates,<span class=\"number\">5</span>,<span class=\"number\">1.2</span>);　　　<span class=\"comment\">// 有效</span></span><br><span class=\"line\">mult_array(locked,<span class=\"number\">4</span>,<span class=\"number\">1.2</span>);　　 <span class=\"comment\">// 不要这样做</span></span><br></pre></td></tr></table></figure><p>C标准规定，使用非<code>const</code>标识符（如，<code>mult_arry()</code>的形参ar）修改<code>const</code>数据（如，<code>locked</code>）导致的结果是未定义的。</p>\n<blockquote>\n<p><code>const</code>还有其他的用法。</p>\n</blockquote>\n<ol><li><p>例如，可以声明并初始化一个不能指向别处的指针，关键是<code>const</code>的位置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pc = rates; <span class=\"comment\">// pc指向数组的开始</span></span><br><span class=\"line\">pc = &amp;rates[<span class=\"number\">2</span>];　　　　　　　<span class=\"comment\">// 不允许，因为该指针不能指向别处</span></span><br><span class=\"line\">*pc = <span class=\"number\">92.99</span>;　　　　　　　 <span class=\"comment\">// 没问题 -- 更改rates[0]的值</span></span><br></pre></td></tr></table></figure><p><mark><strong>可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。</strong></mark></p>\n</li>\n<li><p>最后，<mark><strong>在创建指针时还可以使用<code>const</code>两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值</strong></mark>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span>　rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> * <span class=\"keyword\">const</span> pc = rates;</span><br><span class=\"line\">pc = &amp;rates[<span class=\"number\">2</span>];　　<span class=\"comment\">//不允许</span></span><br><span class=\"line\">*pc = <span class=\"number\">92.99</span>;　　　<span class=\"comment\">//不允许</span></span><br></pre></td></tr></table></figure></li>\n</ol><h2 id=\"指针和多维数组\">指针和多维数组<a href=\"#指针和多维数组\" title=\"指针和多维数组\"></a></h2><blockquote>\n<p><strong>像<code>a[2][3]</code> 这样的数组</strong><br>    <strong><code>a</code> <code>a[0]</code> <code>&amp;a[0][0]</code> 相同</strong><br>    <strong>只要未完全说明的数组 像<code>a</code> <code>a[0]</code> <code>a[1]</code>都是地址 无需加<code>&amp;</code></strong><br>    <strong><code>a[1]+1==&amp;a[1][1]</code> <code>a[0]+1==a[0][1]</code> <code>a==&amp;a[0][0]</code></strong></p>\n</blockquote>\n<blockquote>\n<p><strong><code>p1</code>  <code>&amp;*p1</code> 是<code>&amp;x</code>的地址</strong><br>    <strong><code>&amp;p1</code> 是指针的地址</strong></p>\n</blockquote>\n<p>指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数组。假设有下面的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> zippo[<span class=\"number\">4</span>][<span class=\"number\">2</span>]; <span class=\"comment\">/* 内含int数组的数组 */</span></span><br></pre></td></tr></table></figure><p>然后数组名<code>zippo</code>是该数组首元素的地址。在本例中，<code>zippo</code>的首元素是一个内含两个<code>int</code>值的数组，所以<code>zippo</code>是这个内含两个<code>int</code>值的数组的地址。下面，我们从指针的属性进一步分析。</p>\n<p>因为<code>zippo</code>是数组首元素的地址，所以<code>zippo</code>的值和<code>&amp;zippo[0]</code>的值相同。而<code>zippo[0]</code>本身是一个内含两个整数的数组，所以<code>zippo[0]</code>的值和它首元素（一个整数）的地址（即<code>&amp;zippo[0][0]</code>的值）相同。简而言之，<code>zippo[0]</code>是一个占用一个<code>int</code>大小对象的地址，而<code>zippo</code>是一个占用两个<code>int</code>大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以<code>zippo</code>和<code>zippo[0]</code>的值相同。</p>\n<p>给指针或地址加1，其值会增加对应类型大小的数值。在这方面，<code>zippo</code>和<code>zippo[0]</code>不同，因为<code>zippo</code>指向的对象占用了两个<code>int</code>大小，而<code>zippo[0]</code>指向的对象只占用一个<code>int</code>大小。因此， <code>zippo + 1</code>和<code>zippo[0] + 1</code>的值不同。</p>\n<p>解引用一个指针（在指针前使用<code>*</code>运算符）或在数组名后使用带下标的<code>[]</code>运算符，得到引用对象代表的值。因为<code>zippo[0]</code>是该数组首元素（<code>zippo[0][0]</code>）的地址，所以<code>*(zippo[0])</code>表示储存在<code>zippo[0][0]</code>上的值（即一个<code>int</code>类型的值）。与此类似，<code>*zippo</code>代表该数组首元素（<code>zippo[0]</code>）的值，但是<code>zippo[0]</code>本身是一个<code>int</code>类型值的地址。该值的地址是<code>&amp;zippo[0][0]</code>，所以<code>*zippo</code>就是<code>&amp;zippo[0][0]</code>。对两个表达式应用解引用运算符表明，<code>**zippo</code>与<code>*&amp;zippo[0][0]</code>等价，这相当于<code>zippo[0][0]</code>，即一个<code>int</code>类型的值。简而言之，<code>zippo</code>是地址的地址，必须解引用两次才能获得原始值。地址的地址或指针的指针是就是<strong>双重间接</strong>（double indirection）的例子。</p>\n<p>显然，增加数组维数会增加指针的复杂度。现在，大部分初学者都开始意识到指针为什么是 C 语言中最难的部分。认真思考上述内容，看看是否能用所学的知识解释程序清单10.15中的程序。该程序显示了一些<strong>地址值</strong>和<strong>数组</strong>的内容。</p>\n<p>程序清单10.15 zippo1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* zippo1.c --　zippo的相关信息 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zippo[<span class=\"number\">4</span>][<span class=\"number\">2</span>]=&#123; &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>&#125;, &#123;<span class=\"number\">6</span>,<span class=\"number\">8</span>&#125;, &#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;, &#123;<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" zippo=%p, zippo+1=%p\\n\"</span>,zippo,zippo+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"zippo[0]=%p,zippo[0]+1=%p\\n\"</span>,zippo[<span class=\"number\">0</span>],zippo[<span class=\"number\">0</span>]+<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*zippo = %p,*zippo+1=%p\\n\"</span>,*zippo, *zippo + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"zippo[0][0]　=　%d\\n\"</span>,　zippo[<span class=\"number\">0</span>][<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" *zippo[0] = %d\\n\"</span>, *zippo[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" **zippo = %d\\n\"</span>, **zippo);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\" zippo[2][1]　=　%d\\n\"</span>,　zippo[<span class=\"number\">2</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*(*(zippo+2) + 1) = %d\\n\"</span>, *(*(zippo + <span class=\"number\">2</span>) + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是我们的系统运行该程序后的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zippo=<span class=\"number\">0x0064fd38</span>,　　　　 zippo+<span class=\"number\">1</span>　=　<span class=\"number\">0x0064fd40</span></span><br><span class=\"line\">zippo[<span class=\"number\">0</span>]=<span class=\"number\">0x0064fd38</span>,　　zippo[<span class=\"number\">0</span>]+<span class=\"number\">1</span>　=　<span class=\"number\">0x0064fd3c</span></span><br><span class=\"line\">*zippo = <span class=\"number\">0x0064fd38</span>,　　 *zippo+<span class=\"number\">1</span> = <span class=\"number\">0x0064fd3c</span></span><br><span class=\"line\">zippo[<span class=\"number\">0</span>][<span class=\"number\">0</span>] =<span class=\"number\">2</span></span><br><span class=\"line\">*zippo[<span class=\"number\">0</span>] =<span class=\"number\">2</span></span><br><span class=\"line\">**zippo =<span class=\"number\">2</span></span><br><span class=\"line\">zippo[<span class=\"number\">2</span>][<span class=\"number\">1</span>]　=<span class=\"number\">3</span></span><br><span class=\"line\">*(*(zippo+<span class=\"number\">2</span>) + <span class=\"number\">1</span>) = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure><p>其他系统显示的地址值和地址形式可能不同，但是地址之间的关系与以上输出相同。该输出显示了二维数组<code>zippo</code>的地址和一维数组<code>zippo[0]</code>的地址相同。它们的地址都是各自数组首元素的地址，因而与<code>&amp;zippo[0][0]</code>的值也相同。</p>\n<p>尽管如此，它们也有差别。在我们的系统中，<code>int</code>是4 字节。前面讨论过，<code>zippo[0]</code>指向一个4 字节的数据对象。<code>zippo[0]</code>加1，其值加4（十六进制中，<strong>38+4得3c</strong>）。数组名<code>zippo</code> 是一个内含2个<code>int</code>类型值的数组的地址，所以<code>zippo</code>指向一个8字节的数据对象。因此，<code>zippo</code>加1，它所指向的地址加8字节（十六进制中，<strong>38+8得40</strong>）。</p>\n<p>该程序演示了<code>zippo[0]</code>和<code>*zippo</code>完全相同，实际上确实如此。然后，对二维数组名解引用两次，得到储存在数组中的值。使用两个间接运算符（<code>*</code>）或者使用两对方括号（<code>[]</code>）都能获得该值（还可以使用一个<code>*</code>和一对<code>[]</code>，但是我们暂不讨论这么多情况）。</p>\n<p>要特别注意，与 <code>zippo[2][1]</code>等价的指针表示法是<em>(</em><code>(zippo+2) + 1</code>)。看上去比较复杂，应最好能理解。下面列出了理解该表达式的思路：</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/指针表示法.png\" class=\"φcy\"></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> zippo[<span class=\"number\">3</span>][<span class=\"number\">3</span>]=&#123;&#123;<span class=\"number\">5</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>&#125;,&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>&#125;,&#123;<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>&#125;&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">zippo  : <span class=\"number\">000000000062F</span>DF0 </span><br><span class=\"line\">zippo+<span class=\"number\">2</span>: <span class=\"number\">000000000062F</span>E08 \t<span class=\"comment\">// zippo + 2个 * 3个数 * int大小4B == &amp;zippo[2]</span></span><br><span class=\"line\">    </span><br><span class=\"line\">*(zippo+<span class=\"number\">2</span>)\t: <span class=\"number\">000000000062F</span>E08 <span class=\"comment\">//zippo[2]</span></span><br><span class=\"line\">*(zippo+<span class=\"number\">2</span>)+<span class=\"number\">1</span>: <span class=\"number\">000000000062F</span>E0C   <span class=\"comment\">// zippo[2]+1 即&amp;zippo[2][1]</span></span><br><span class=\"line\">*(*(zippo+<span class=\"number\">2</span>)+<span class=\"number\">1</span>): <span class=\"number\">0000000000000008</span>   <span class=\"comment\">// zippo[2][1]</span></span><br><span class=\"line\">*zippo[<span class=\"number\">0</span>]==zippo[<span class=\"number\">0</span>][<span class=\"number\">0</span>]</span><br><span class=\"line\">*zippo[<span class=\"number\">0</span>]+<span class=\"number\">1</span>==zippo[<span class=\"number\">0</span>][<span class=\"number\">0</span>]+<span class=\"number\">1</span></span><br></pre></td></tr></table></figure><p>以上分析并不是为了说明用指针表示法（<code>*(*(zippo+2) + 1)</code>）代替数组表示法（<code>zippo[2][1]</code>），而是提示读者，如果程序恰巧使用一个指向二维数组的指针，而且要通过该指针获取值时，最好用简单的数组表示法，而不是指针表示法。</p>\n<p>图10.5以另一种视图演示了数组地址、数组内容和指针之间的关系。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/数组的数组.png\" class=\"φcy\"></p>\n<h3 id=\"指向多维数组的指针\">指向多维数组的指针<a href=\"#指向多维数组的指针\" title=\"指向多维数组的指针\"></a></h3><p>如何声明一个指针变量<code>pz</code>指向一个二维数组（如，<code>zippo</code>）？在编写处理类似<code>zippo</code>这样的二维数组时会用到这样的指针。把指针声明为指向<code>int</code>的类型还不够。因为指向<code>int</code>只能与<code>zippo[0]</code>的类型匹配，说明该指针指向一个<code>int</code>类型的值。但是<code>zippo</code>是它首元素的地址，该元素是一个内含两个<code>int</code>类型值的一维数组。因此，<code>pz</code>必须指向一个内含两个<code>int</code>类型值的数组，而不是指向一个int<code>类型</code>值，其声明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (* pz)[<span class=\"number\">2</span>];　　<span class=\"comment\">// pz指向一个内含两个int类型值的数组</span></span><br></pre></td></tr></table></figure><p>以上代码把<code>pz</code>声明为指向一个数组的指针，该数组内含两个<code>int</code>类型值。</p>\n<p><strong><code>*</code>先与<code>pz</code>结合，因此声明的是一个指向数组（内含两个<code>int</code>类型的值）的指针</strong></p>\n<p>为什么要在声明中使用圆括号？因为<code>[]</code>的优先级高于<code>*</code>。考虑下面的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pax[<span class=\"number\">2</span>];　　 <span class=\"comment\">// pax是一个内含两个指针元素的数组，每个元素都指向int的指针</span></span><br></pre></td></tr></table></figure><p>由于<code>[]</code>优先级高，先与<code>pax</code>结合，所以<code>pax</code>成为一个内含两个元素的数组。然后<code>*</code>表示<code>pax</code>数组内含两个指针。最后，<code>int</code>表示<code>pax</code>数组中的指针都指向<code>int</code>类型的值。因此，这行代码声明了两个指向<code>int</code>的指针。<strong>而前面有圆括号的版本，<code>*</code>先与<code>pz</code>结合，因此声明的是一个指向数组（内含两个<code>int</code>类型的值）的指针。</strong>程序清单10.16演示了如何使用指向二维数组的指针。</p>\n<p>程序清单10.16 zippo2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* zippo2.c --　通过指针获取zippo的信息 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> zippo[<span class=\"number\">4</span>][<span class=\"number\">2</span>]　=　&#123;　&#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>&#125;,　&#123;<span class=\"number\">6</span>,<span class=\"number\">8</span>&#125;,　&#123;<span class=\"number\">1</span>,<span class=\"number\">3</span>&#125;,　&#123;<span class=\"number\">5</span>,<span class=\"number\">7</span>&#125;　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>(*pz)[<span class=\"number\">2</span>];</span><br><span class=\"line\">    pz　=　zippo;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　pz　=　%p,　pz　+　1　=　%p\\n\"</span>,pz,　pz　+　<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"pz[0]　=　%p,　pz[0]　+　1　=　%p\\n\"</span>,　 pz[<span class=\"number\">0</span>],　pz[<span class=\"number\">0</span>]　+　<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　*pz = %p,　 *pz + 1 = %p\\n\"</span>,　 *pz, *pz + <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"pz[0][0]　=　%d\\n\"</span>,　pz[<span class=\"number\">0</span>][<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　*pz[0] = %d\\n\"</span>, *pz[<span class=\"number\">0</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　**pz = %d\\n\"</span>, **pz);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　pz[2][1]　=　%d\\n\"</span>,　pz[<span class=\"number\">2</span>][<span class=\"number\">1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*(*(pz+2) + 1) = %d\\n\"</span>, *(*(pz + <span class=\"number\">2</span>) + <span class=\"number\">1</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pz　=　<span class=\"number\">0x0064fd38</span>,\t\tpz　+　<span class=\"number\">1</span>　=　<span class=\"number\">0x0064fd40</span></span><br><span class=\"line\">pz[<span class=\"number\">0</span>]　=　<span class=\"number\">0x0064fd38</span>,\t\tpz[<span class=\"number\">0</span>]　+　<span class=\"number\">1</span>　=　<span class=\"number\">0x0064fd3c</span></span><br><span class=\"line\">*pz = <span class=\"number\">0x0064fd38</span>,\t\t*pz + <span class=\"number\">1</span> = <span class=\"number\">0x0064fd3c</span></span><br><span class=\"line\">pz[<span class=\"number\">0</span>][<span class=\"number\">0</span>]　=　<span class=\"number\">2</span></span><br><span class=\"line\">*pz[<span class=\"number\">0</span>] = <span class=\"number\">2</span></span><br><span class=\"line\">**pz = <span class=\"number\">2</span></span><br><span class=\"line\">pz[<span class=\"number\">2</span>][<span class=\"number\">1</span>]　=　<span class=\"number\">3</span></span><br><span class=\"line\">*(*(pz+<span class=\"number\">2</span>) + <span class=\"number\">1</span>) = <span class=\"number\">3</span></span><br></pre></td></tr></table></figure><p>系统不同，输出的地址可能不同，但是地址之间的关系相同。如前所述，虽然<code>pz</code>是一个指针，不是数组名，但是也可以使用 <code>pz[2][1]</code>这样的写法。可以用数组表示法或指针表示法来表示一个数组元素，既可以使用数组名，也可以使用指针名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">zippo[m][n] == *(*(zippo + m) + n)</span><br><span class=\"line\">pz[m][n] == *(*(pz + m) + n)</span><br></pre></td></tr></table></figure><h3 id=\"指针的兼容性\">指针的兼容性<a href=\"#指针的兼容性\" title=\"指针的兼容性\"></a></h3><p>指针之间的赋值比数值类型之间的赋值要严格。例如，不用类型转换就可以把 <code>int</code> 类型的值赋给<code>double</code>类型的变量，但是两个类型的指针不能这样做。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>　n=<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span>　x;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1=&amp;n;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pd=&amp;x;</span><br><span class=\"line\">x = n;　　　　　　　<span class=\"comment\">// 隐式类型转换</span></span><br><span class=\"line\">pd = p1;　　　　　　<span class=\"comment\">// 编译时错误</span></span><br></pre></td></tr></table></figure><p>更复杂的类型也是如此。假设有如下声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pt;</span><br><span class=\"line\"><span class=\"keyword\">int</span> (*pa)[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ar1[<span class=\"number\">2</span>][<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> ar2[<span class=\"number\">3</span>][<span class=\"number\">2</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> **p2; <span class=\"comment\">// 一个指向指针的指针</span></span><br></pre></td></tr></table></figure><p>有如下的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pt = &amp;ar1[<span class=\"number\">0</span>][<span class=\"number\">0</span>];　<span class=\"comment\">// 都是指向int的指针</span></span><br><span class=\"line\">pt = ar1[<span class=\"number\">0</span>];　　　 <span class=\"comment\">// 都是指向int的指针</span></span><br><span class=\"line\">pt = ar1;　　　　　 <span class=\"comment\">// 无效</span></span><br><span class=\"line\">pa = ar1;　　　　　 <span class=\"comment\">// 都是指向内含3个int类型元素数组的指针</span></span><br><span class=\"line\">pa = ar2;　　　　　 <span class=\"comment\">// 无效</span></span><br><span class=\"line\">p2 = &amp;pt;　　　　 <span class=\"comment\">// both pointer-to-int *</span></span><br><span class=\"line\">*p2 = ar2[<span class=\"number\">0</span>];　　 <span class=\"comment\">// 都是指向int的指针</span></span><br><span class=\"line\">p2 = ar2;　　　　　 <span class=\"comment\">// 无效 解释加粗</span></span><br></pre></td></tr></table></figure><p>注意，以上无效的赋值表达式语句中涉及的两个指针都是指向不同的类型。例如，<code>pt</code> 指向一个 <code>int</code>类型值，而<code>ar1</code>指向一个内含<code>3</code>和<code>int</code>类型元素的数组。类似地，<code>pa</code>指向一个内含2个<code>int</code>类型元素的数组，所以它与<code>ar1</code>的类型兼容，但是<code>ar2</code>指向一个内含2个<code>int</code>类型元素的数组，所以<code>pa</code>与<code>ar2</code>不兼容。</p>\n<p>上面的最后两个例子有些棘手。<strong>变量<code>p2</code>是指向指针的指针，它指向的指针指向<code>int</code>，而<code>ar2</code>是指向数组的指针，该数组内含2个<code>int</code>类型的元素。所以，<code>p2</code>和<code>ar2</code>的类型不同，不能把<code>ar2</code>赋给<code>p2</code>。</strong>但是，<code>*p2</code>是指向<code>int</code>的指针，与<code>ar2[0]</code>兼容。因为<code>ar2[0]</code>是指向该数组首元素（<code>ar2[0][0]</code>）的指针，所以<code>ar2[0]</code>也是指向<code>int</code>的指针。</p>\n<p>一般而言，多重解引用让人费解。例如，考虑下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span>　x=<span class=\"number\">20</span>;</span><br><span class=\"line\"><span class=\"keyword\">const</span>　<span class=\"keyword\">int</span>　y=<span class=\"number\">23</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1 = &amp;x;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p2=&amp;y;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> **pp2;</span><br><span class=\"line\">p1 = p2;　　　 <span class=\"comment\">// 不安全 -- 把const指针赋给非const指针</span></span><br><span class=\"line\">p2 = p1;　　　 <span class=\"comment\">// 有效 -- 把非const指针赋给const指针</span></span><br><span class=\"line\">pp2 = &amp;p1;　　<span class=\"comment\">// 不安全 –- 嵌套指针类型赋值</span></span><br></pre></td></tr></table></figure><p>前面提到过，把<code>const</code>指针赋给非<code>const</code>指针不安全，因为这样可以使用新的指针改变<code>const</code>指针指向的数据。编译器在编译代码时，可能会给出警告，执行这样的代码是未定义的。但是把非<code>const</code>指针赋给<code>const</code>指针没问题，前提是只进行一级解引用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">p2 = p1; <span class=\"comment\">// 有效 -- 把非const指针赋给const指针</span></span><br></pre></td></tr></table></figure><p>但是进行两级解引用时，这样的赋值也不安全，例如，考虑下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> **pp2; <span class=\"comment\">//pp2是p1指针的地址&amp;p1, *pp2是p1指向值的地址，即p1 **pp2是*p1的值</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> n=<span class=\"number\">13</span>;</span><br><span class=\"line\">pp2 = &amp;p1;　　<span class=\"comment\">// 允许，但是这导致const限定符失效（根据第1行代码，不能通过*pp2修改它所指向的内容）</span></span><br><span class=\"line\">*pp2 = &amp;n;　　<span class=\"comment\">// 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修改）</span></span><br><span class=\"line\">*p1 = <span class=\"number\">10</span>;<span class=\"comment\">//有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）</span></span><br></pre></td></tr></table></figure><p>发生了什么？如前所示，标准规定了通过非<code>const</code>指针更改<code>const</code>数据是未定义的。例如，在Terminal中（OS X对底层UNIX系统的访问）使用gcc编译包含以上代码的小程序，导致n最终的值是13，但是在相同系统下使用clang来编译，n最终的值是10。两个编译器都给出指针类型不兼容的警告。当然，可以忽略这些警告，但是最好不要相信该程序运行的结果，这些结果都是未定义的。</p>\n<p><strong>C const和C++ const</strong></p>\n<p>C和C++中<code>const</code>的用法很相似，但是并不完全相同。区别之一是，C++允许在声明数组大小时使用<code>const</code>整数，而C却不允许。区别之二是，C++的指针赋值检查更严格：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> y;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> *p2=&amp;y;</span><br><span class=\"line\"><span class=\"keyword\">int</span> *p1;</span><br><span class=\"line\">p1=p2; <span class=\"comment\">// C++中不允许这样做，但是C可能只给出警告</span></span><br></pre></td></tr></table></figure><p><strong>C++不允许把<code>const</code>指针赋给非<code>const</code>指针</strong>。<strong>而C则允许这样做，但是如果通过<code>p1</code>更改<code>y</code>，其行为是未定义的。</strong></p>\n<h3 id=\"函数和多维数组\">函数和多维数组<a href=\"#函数和多维数组\" title=\"函数和多维数组\"></a></h3><p>如果要编写处理二维数组的函数，首先要能正确地理解指针才能写出声明函数的形参。在函数体中，通常使用数组表示法进行相关操作。</p>\n<p>下面，我们编写一个处理二维数组的函数。一种方法是，利用<code>for</code>循环把处理一维数组的函数应用到二维数组的每一行。如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> junk[<span class=\"number\">3</span>][<span class=\"number\">4</span>]　=　&#123;　&#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">8</span>&#125;,　&#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">9</span>&#125;,　&#123;<span class=\"number\">12</span>,<span class=\"number\">10</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>&#125;　&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\"><span class=\"keyword\">int</span> total=<span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;<span class=\"number\">3</span>;i++)</span><br><span class=\"line\">total += sum(junk[i], <span class=\"number\">4</span>); <span class=\"comment\">// junk[i]是一维数组</span></span><br></pre></td></tr></table></figure><p>记住，如果 <code>junk</code> 是二维数组，<code>junk[i]</code>就是一维数组，可将其视为二维数组的一行。这里，<code>sum()</code>函数计算二维数组的每行的总和，然后<code>for</code>循环再把每行的总和加起来。</p>\n<p>然而，这种方法无法记录行和列的信息。用这种方法计算总和，行和列的信息并不重要。但如果每行代表一年，每列代表一个月，就还需要一个函数计算某列的总和。该函数要知道行和列的信息，可以通过声明正确类型的形参变量来完成，以便函数能正确地传递数组。在这种情况下，数组 <code>junk</code> 是一个内含 3个数组元素的数组，每个元素是内含4个<code>int</code>类型值的数组（即<code>junk</code>是一个3行4列的二维数组）。通过前面的讨论可知，这表明<code>junk</code>是一个指向数组（内含4个<code>int</code>类型值）的指针。可以这样声明函数的形参：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">somefunction</span><span class=\"params\">(<span class=\"keyword\">int</span> (*pt)[<span class=\"number\">4</span>])</span></span>;</span><br></pre></td></tr></table></figure><p>另外，如果当且仅当pt是一个函数的形式参数时，可以这样声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">somefunction</span><span class=\"params\">(<span class=\"keyword\">int</span> pt[][<span class=\"number\">4</span>] )</span></span>;</span><br></pre></td></tr></table></figure><p>注意，第1个方括号是空的。空的方括号表明<code>pt</code>是一个指针。这样的变量稍后可以用作相同方法作为<code>junk</code>。下面的程序示例中就是这样做的，如程序清单10.17所示。注意该程序清单演示了3种等价的原型语法。</p>\n<p>程序清单10.17 array2d.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// array2d.c -- 处理二维数组的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　ROWS　3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　COLS　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_rows</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][COLS],<span class=\"keyword\">int</span> rows)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_cols</span><span class=\"params\">(<span class=\"keyword\">int</span> [][COLS],<span class=\"keyword\">int</span>)</span></span>;　　　　<span class=\"comment\">// 省略形参名，没问题</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span>(*ar)[COLS], <span class=\"keyword\">int</span> rows)</span></span>;　　<span class=\"comment\">// 另一种语法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> junk[ROWS][COLS]　=　&#123; &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>&#125;,&#123;<span class=\"number\">12</span>,<span class=\"number\">10</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>&#125;&#125;;</span><br><span class=\"line\">    sum_rows(junk,ROWS);</span><br><span class=\"line\">    sum_cols(junk,　ROWS);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Sum　of　all　elements　=　%d\\n\"</span>,　sum2d(junk,　ROWS));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_rows</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][COLS],<span class=\"keyword\">int</span> rows)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r=<span class=\"number\">0</span>;r&lt;rows;r++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tot　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(c=<span class=\"number\">0</span>;c&lt;COLS;c++)</span><br><span class=\"line\">        \ttot+=ar[r][c];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"row　%d:　sum　=　%d\\n\"</span>,r,tot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sum_cols</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][COLS],<span class=\"keyword\">int</span> rows)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(c=<span class=\"number\">0</span>;c&lt;COLS;c++)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        tot=<span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span>(r=<span class=\"number\">0</span>;r&lt;rows;r++)</span><br><span class=\"line\">        \ttot+=ar[r][c];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"col　%d:　sum　=　%d\\n\"</span>,c,tot);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span>　ar[][COLS],　<span class=\"keyword\">int</span>　rows)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r=<span class=\"number\">0</span>;r&lt;rows;r++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(c=<span class=\"number\">0</span>;c&lt;COLS;c++)</span><br><span class=\"line\">    \t\ttot+=ar[r][c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">row <span class=\"number\">0</span>: sum = <span class=\"number\">20</span></span><br><span class=\"line\">row <span class=\"number\">1</span>: sum = <span class=\"number\">24</span></span><br><span class=\"line\">row <span class=\"number\">2</span>: sum = <span class=\"number\">36</span></span><br><span class=\"line\">col <span class=\"number\">0</span>: sum = <span class=\"number\">17</span></span><br><span class=\"line\">col <span class=\"number\">1</span>: sum = <span class=\"number\">19</span></span><br><span class=\"line\">col <span class=\"number\">2</span>: sum = <span class=\"number\">21</span></span><br><span class=\"line\">col <span class=\"number\">3</span>: sum = <span class=\"number\">23</span></span><br><span class=\"line\">Sum of all elements = <span class=\"number\">80</span></span><br></pre></td></tr></table></figure><p>程序清单10.17中的程序把数组名<code>junk</code>（即，指向数组首元素的指针，首元素是子数组）和符号常量<code>ROWS</code>（代表行数3）作为参数传递给函数。每个函数都把<code>ar</code>视为内含数组元素（每个元素是内含4个<code>int</code>类型值的数组）的数组。列数内置在函数体中，但是行数靠函数传递得到。如果传入函数的行数是12，那么函数要处理的是12×4的数组。因为<code>rows</code>是元素的个数，然而，因为每个元素都是数组，或者视为一行，<code>rows</code>也可以看成是行数。</p>\n<p>注意，<code>ar</code>和<code>main()</code>中的<code>junk</code>都使用数组表示法。因为<code>ar</code>和<code>junk</code>的类型相同，它们都是指向内含4个<code>int</code>类型值的数组的指针。</p>\n<p>注意，下面的声明不正确：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][], <span class=\"keyword\">int</span> rows)</span></span>; <span class=\"comment\">// 错误的声明</span></span><br></pre></td></tr></table></figure><p>前面介绍过，编译器会把数组表示法转换成指针表示法。例如，编译器会把 <code>ar[1]</code>转换成 <code>ar+1</code>。编译器对<code>ar+1</code>求值，要知道<code>ar</code>所指向的对象大小。下面的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][<span class=\"number\">4</span>], <span class=\"keyword\">int</span> rows)</span></span>;　　<span class=\"comment\">// 有效声明</span></span><br></pre></td></tr></table></figure><p>表示ar指向一个内含4个<code>int</code>类型值的数组（在我们的系统中，<code>ar</code>指向的对象占16字节），所以<code>ar+1</code>的意思是“<strong>该地址加上16字节</strong>”。如果第2对方括号是空的，编译器就不知道该怎样处理。</p>\n<p>也可以在第1对方括号中写上大小，如下所示，但是编译器会忽略该值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[<span class=\"number\">3</span>][<span class=\"number\">4</span>], <span class=\"keyword\">int</span> rows)</span></span>; <span class=\"comment\">// 有效声明，但是3将被忽略</span></span><br></pre></td></tr></table></figure><p>与使用<code>typedef</code>（第5章和第14章中讨论）相比，这种形式方便得多：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> arr4[<span class=\"number\">4</span>];　　　　　　　　　<span class=\"comment\">// arr4是一个内含 4 个int的数组</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> arr4 arr3x4[<span class=\"number\">3</span>];　　　　　　　 <span class=\"comment\">// arr3x4 是一个内含3个 arr4的数组</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2</span><span class=\"params\">(arr3x4 ar, <span class=\"keyword\">int</span> rows)</span></span>;　　　<span class=\"comment\">// 与下面的声明相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[<span class=\"number\">3</span>][<span class=\"number\">4</span>], <span class=\"keyword\">int</span> rows)</span></span>;　 <span class=\"comment\">// 与下面的声明相同</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][<span class=\"number\">4</span>], <span class=\"keyword\">int</span> rows)</span></span>;　　<span class=\"comment\">// 标准形式</span></span><br></pre></td></tr></table></figure><p><strong>一般而言，声明一个指向N维数组的指针时，只能省略最左边方括号中的值</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum4d</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][<span class=\"number\">12</span>][<span class=\"number\">20</span>][<span class=\"number\">30</span>],<span class=\"keyword\">int</span> rows)</span></span>;</span><br></pre></td></tr></table></figure><p>因为第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。下面的声明与该声明等价：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum4d</span><span class=\"params\">(<span class=\"keyword\">int</span> (*ar)[<span class=\"number\">12</span>][<span class=\"number\">20</span>][<span class=\"number\">30</span>], <span class=\"keyword\">int</span> rows)</span></span>; <span class=\"comment\">// ar是一个指针</span></span><br></pre></td></tr></table></figure><p>这里，<code>ar</code>指向一个12×20×30的<code>int</code>数组。</p>\n<h2 id=\"变长数组（vla）\">变长数组（VLA）<a href=\"#变长数组（vla）\" title=\"变长数组（VLA）\"></a></h2><p>读者在学习处理二维数组的函数中可能不太理解，为何只把数组的行数作为函数的形参，而列数却内置在函数体内。例如，函数定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　COLS　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[][COLS],<span class=\"keyword\">int</span> rows)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r=<span class=\"number\">0</span>;r&lt;rows;r++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(c=<span class=\"number\">0</span>;c&lt;COLS;c++)</span><br><span class=\"line\">    \t\ttot+=ar[r][c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>假设声明了下列数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> array1[<span class=\"number\">5</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> array2[<span class=\"number\">100</span>][<span class=\"number\">4</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> array3[<span class=\"number\">2</span>][<span class=\"number\">4</span>];</span><br></pre></td></tr></table></figure><p>可以用<code>sum2d()</code>函数分别计算这些数组的元素之和：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">tot = sum2d(array1, <span class=\"number\">5</span>);　　<span class=\"comment\">// 5×4 数组的元素之和</span></span><br><span class=\"line\">tot = sum2d(array2, <span class=\"number\">100</span>);　<span class=\"comment\">// 100×4数组的元素之和</span></span><br><span class=\"line\">tot = sum2d(array3, <span class=\"number\">2</span>);　　<span class=\"comment\">// 2×4数组的元素之和</span></span><br></pre></td></tr></table></figure><p><code>sum2d()</code>函数之所以能处理这些数组，是因为这些数组的列数固定为4，而行数被传递给形参<code>rows</code>， <code>rows</code>是一个变量。但是如果要计算6×5的数组（即6行5列），就不能使用这个函数，必须重新创建一个<code>CLOS</code>为5的函数。因为C规定，数组的维数必须是常量，不能用变量来代替<code>COLS</code>。</p>\n<p>要创建一个能处理任意大小二维数组的函数，比较繁琐（必须把数组作为一维数组传递，然后让函数计算每行的开始处）。而且，这种方法不好处理<code>FORTRAN</code>的子例程，这些子例程都允许在函数调用中指定两个维度。虽然 <code>FORTRAN</code> 是比较老的编程语言，但是在过去的几十年里，数值计算领域的专家已经用<code>FORTRAN</code>开发出许多有用的计算库。C正逐渐替代<code>FORTRAN</code>，如果能直接转换现有的<code>FORTRAN</code>库就好了。</p>\n<p>鉴于此，C99新增了<strong>变长数组</strong>（variable-length array，VLA），允许使用变量表示数组的维度。如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> quarters　=　<span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> regions　=　<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">double</span> sales[regions][quarters];　　<span class=\"comment\">// 一个变长数组（VLA）</span></span><br></pre></td></tr></table></figure><p>前面提到过，变长数组有一些限制。<strong>变长数组必须是自动存储类别</strong>，这意味着无论在函数中声明还是作为函数形参声明，都不能使用<code>static</code>或<code>extern</code>存储类别说明符（第12章介绍）。而且，不能在声明中初始化它们。最终，C11把<strong>变长数组</strong>作为一个可选特性，而不是必须强制实现的特性。</p>\n<p><strong>注意 变长数组不能改变大小</strong></p>\n<p><strong>变长数组</strong>中的“变”不是指可以修改已创建数组的大小。一旦创建了变长数组，它的大小则保持不变。这里的“变”指的是：<strong>在创建数组时，可以使用变量指定数组的维度。</strong></p>\n<p>由于变长数组是C语言的新特性，目前完全支持这一特性的编译器不多。下面我们来看一个简单的例子：如何编写一个函数，计算int的二维数组所有元素之和。</p>\n<p>首先，要声明一个带二维变长数组参数的函数，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span> rows,<span class=\"keyword\">int</span> cols,<span class=\"keyword\">int</span> ar[rows][cols])</span></span>; <span class=\"comment\">// ar是一个变长数组（VLA）</span></span><br></pre></td></tr></table></figure><p>注意前两个形参（<code>rows</code>和<code>cols</code>）用作第3个形参二维数组<code>ar</code>的两个维度。因为<code>ar</code>的声明要使用<code>rows</code>和<code>cols</code>，所以在形参列表中必须在声明<code>ar</code>之前先声明这两个形参。因此，下面的原型是错误的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[rows][cols],<span class=\"keyword\">int</span> rows,<span class=\"keyword\">int</span> cols)</span></span>; <span class=\"comment\">// 无效的顺序</span></span><br></pre></td></tr></table></figure><p>C99/C11标准规定，可以省略原型中的形参名，但是在这种情况下，必须用星号来代替省略的维度：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span> ar[*][*])</span></span>; <span class=\"comment\">// ar是一个变长数组（VLA），省略了维度形参名</span></span><br></pre></td></tr></table></figure><p>其次，该函数的定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span> rows,<span class=\"keyword\">int</span> cols,<span class=\"keyword\">int</span> ar[rows][cols])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r=<span class=\"number\">0</span>;r&lt;rows;r++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(c=<span class=\"number\">0</span>;c&lt;cols;c++)</span><br><span class=\"line\">    \t\ttot+=ar[r][c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该函数除函数头与传统的C函数（程序清单10.17）不同外，还把符号常量<code>COLS</code>替换成变量<code>cols</code>。这是因为在函数头中使用了变长数组。由于用变量代表行数和列数，所以新的<code>sum2d()</code>现在可以处理任意大小的二维<code>int</code>数组，如程序清单10.18所示。但是，该程序要求编译器支持变长数组特性。另外，该程序还演示了以变长数组作为形参的函数既可处理传统C数组，也可处理变长数组。</p>\n<p>程序清单10.18 vararr2d.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//vararr2d.c -- 使用变长数组的函数</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　ROWS　3</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　COLS　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span>　rows,　<span class=\"keyword\">int</span>　cols,　<span class=\"keyword\">int</span>　ar[rows][cols])</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i,j;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> rs=<span class=\"number\">3</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> cs=<span class=\"number\">10</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> junk[ROWS][COLS]=&#123; &#123;<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>&#125;,&#123;<span class=\"number\">3</span>,<span class=\"number\">5</span>,<span class=\"number\">7</span>,<span class=\"number\">9</span>&#125;,&#123;<span class=\"number\">12</span>,<span class=\"number\">10</span>,<span class=\"number\">8</span>,<span class=\"number\">6</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> morejunk[ROWS<span class=\"number\">-1</span>][COLS + <span class=\"number\">2</span>]=&#123;&#123;<span class=\"number\">20</span>,<span class=\"number\">30</span>,<span class=\"number\">40</span>,<span class=\"number\">50</span>,<span class=\"number\">60</span>,<span class=\"number\">70</span>&#125;,&#123;<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">7</span>,<span class=\"number\">8</span>,<span class=\"number\">9</span>,<span class=\"number\">10</span>&#125;&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> varr[rs][cs];　<span class=\"comment\">// 变长数组（VLA）</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;rs;i++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(j=<span class=\"number\">0</span>;j&lt;cs;j++)</span><br><span class=\"line\">    \t\tvarr[i][j] = i * j + j;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"3x5　array\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Sum　of　all　elements　=　%d\\n\"</span>,sum2d(ROWS,COLS,　junk));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"2x6　array\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Sum　of　all　elements　=　%d\\n\"</span>,sum2d(ROWS　-　<span class=\"number\">1</span>,　COLS　+　<span class=\"number\">2</span>,　morejunk));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"3x10　VLA\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Sum　of　all　elements　=　%d\\n\"</span>,　sum2d(rs,　cs,　varr));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">// 带变长数组形参的函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">int</span> rows,<span class=\"keyword\">int</span> cols,<span class=\"keyword\">int</span> ar[rows][cols])</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r　=　<span class=\"number\">0</span>;　r　&lt;　rows;　r++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(c　=　<span class=\"number\">0</span>;　c　&lt;　cols;　c++)</span><br><span class=\"line\">    \t\ttot　+=　ar[r][c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">3</span>x5　<span class=\"built_in\">array</span></span><br><span class=\"line\">Sum　of　all　elements　=　<span class=\"number\">80</span></span><br><span class=\"line\"><span class=\"number\">2</span>x6　<span class=\"built_in\">array</span></span><br><span class=\"line\">Sum　of　all　elements　=　<span class=\"number\">315</span></span><br><span class=\"line\"><span class=\"number\">3</span>x10　VLA</span><br><span class=\"line\">Sum　of　all　elements　=　<span class=\"number\">270</span></span><br></pre></td></tr></table></figure><p>需要注意的是，在函数定义的形参列表中声明的变长数组并未实际创建数组。和传统的语法类似，变长数组名实际上是一个指针。这说明带变长数组形参的函数实际上是在原始数组中处理数组，因此可以修改传入的数组。下面的代码段指出指针和实际数组是何时声明的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> thing[<span class=\"number\">10</span>][<span class=\"number\">6</span>];</span><br><span class=\"line\">twoset(<span class=\"number\">10</span>,<span class=\"number\">6</span>,thing);</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">twoset</span> <span class=\"params\">(<span class=\"keyword\">int</span> n, <span class=\"keyword\">int</span> m, <span class=\"keyword\">int</span> ar[n][m])</span> <span class=\"comment\">// ar是一个指向数组（内含m个int类型的值）的指针</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp[n][m];　　<span class=\"comment\">// temp是一个n×m的int数组</span></span><br><span class=\"line\">    temp[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">2</span>;　　<span class=\"comment\">// 设置temp的一个元素为2</span></span><br><span class=\"line\">    ar[<span class=\"number\">0</span>][<span class=\"number\">0</span>] = <span class=\"number\">2</span>;　　　<span class=\"comment\">// 设置thing[0][0]为2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如上代码所示调用<code>twoset()</code>时，<code>ar</code>成为指向<code>thing[0]</code>的指针，<code>temp</code>被创建为10×6的数组。因为<code>ar</code>和<code>thing</code>都是指向<code>thing[0]</code>的指针，<code>ar[0][0]</code>与<code>thing[0][0]</code>访问的数据位置相同。</p>\n<p><strong><code>const</code>和数组大小</strong></p>\n<p>是否可以在声明数组时使用<code>const</code>变量？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> SZ　=　<span class=\"number\">80</span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">double</span> ar[SZ]; <span class=\"comment\">// 是否允许？</span></span><br></pre></td></tr></table></figure><p>C90标准不允许（也可能允许）。数组的大小必须是给定的整型常量表达式，可以是整型常量组合，如20、<code>sizeof</code>表达式或其他不是<code>const</code>的内容。由于C实现可以扩大整型常量表达式的范围，所以可能会允许使用<code>const</code>，但是这种代码可能无法移植。</p>\n<p>C99/C11 标准允许在声明变长数组时使用 <code>const</code> 变量。所以该数组的定义必须是声明在块中的自动存储类别数组。</p>\n<p><strong>变长数组还允许动态内存分配</strong>，这说明可以在程序运行时指定数组的大小。普通 C数组都是静态内存分配，即在编译时确定数组的大小。由于数组大小是常量，所以编译器在编译时就知道了。第12章将详细介绍动态内存分配。</p>\n<h2 id=\"复合字面量\">复合字面量<a href=\"#复合字面量\" title=\"复合字面量\"></a></h2><p>假设给带<code>int</code>类型形参的函数传递一个值，要传递<code>int</code>类型的变量，但是也可以传递<code>int</code>类型常量，如5。在C99 标准以前，对于带数组形参的函数，情况不同，可以传递数组，但是没有等价的数组常量。C99新增了<strong>复合字面量</strong>（compound literal）。字面量是除符号常量外的常量。例如，5是<code>int</code>类型字面量， 81.3是<code>double</code>类型的字面量，<code>&#39;Y&#39;</code>是<code>char</code>类型的字面量，<code>&quot;elephant&quot;</code>是字符串字面量。发布C99标准的委员会认为，如果有代表数组和结构内容的复合字面量，在编程时会更方便。</p>\n<p>对于数组，复合字面量类似数组初始化列表，前面是用括号括起来的类型名。例如，下面是一个普通的数组声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> diva[<span class=\"number\">2</span>] = &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>&#125;;</span><br></pre></td></tr></table></figure><p>下面的复合字面量创建了一个和<code>diva</code>数组相同的匿名数组，也有两个<code>int</code>类型的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">int</span> [<span class=\"number\">2</span>])&#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>&#125;　　　<span class=\"comment\">// 复合字面量</span></span><br></pre></td></tr></table></figure><p>注意，去掉声明中的数组名，留下的<code>int [2]</code>即是<strong>复合字面量</strong>的类型名。</p>\n<p>初始化有数组名的数组时可以省略数组大小，复合字面量也可以省略大小，编译器会自动计算数组当前的元素个数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(<span class=\"keyword\">int</span> [])&#123;<span class=\"number\">50</span>, <span class=\"number\">20</span>, <span class=\"number\">90</span>&#125; <span class=\"comment\">// 内含3个元素的复合字面量</span></span><br></pre></td></tr></table></figure><p><strong><mark>因为复合字面量是匿名的，所以不能先创建然后再使用它，必须在创建的同时使用它。</mark></strong>使用指针记录地址就是一种用法。也就是说，可以这样用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pt1;</span><br><span class=\"line\">pt1 = (<span class=\"keyword\">int</span> [<span class=\"number\">2</span>]) &#123;<span class=\"number\">10</span>, <span class=\"number\">20</span>&#125;;</span><br></pre></td></tr></table></figure><p>注意，该复合字面量的字面常量与上面创建的 <code>diva</code> 数组的字面常量完全相同。与有数组名的数组类似，<strong>复合字面量的类型名也代表首元素的地址</strong>，所以可以把它赋给指向<code>int</code>的指针。然后便可使用这个指针。例如，本例中<code>*pt1</code>是10，<code>pt1[1]</code>是20。</p>\n<p>还可以把复合字面量作为实际参数传递给带有匹配形式参数的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[],<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">int</span> total3;</span><br><span class=\"line\">total3 = sum((<span class=\"keyword\">int</span> [])&#123;<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>,<span class=\"number\">5</span>&#125;, <span class=\"number\">6</span>);</span><br></pre></td></tr></table></figure><p>这里，第1个实参是内含6个<code>int</code>类型值的数组，和数组名类似，这同时也是该数组首元素的地址。<strong>这种用法的好处是，把信息传入函数前不必先创建数组，这是复合字面量的典型用法</strong>。</p>\n<p>可以把这种用法应用于二维数组或多维数组。例如，下面的代码演示了如何创建二维<code>int</code>数组并储存其地址：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> (*pt2)[<span class=\"number\">4</span>];　　 <span class=\"comment\">// 声明一个指向二维数组的指针，该数组内含2个数组元素，每个元素是内含4个int类型值的数组</span></span><br><span class=\"line\">pt2　=　(<span class=\"keyword\">int</span>　[<span class=\"number\">2</span>][<span class=\"number\">4</span>])　&#123;　&#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">3</span>,<span class=\"number\">-9</span>&#125;,　&#123;<span class=\"number\">4</span>,<span class=\"number\">5</span>,<span class=\"number\">6</span>,<span class=\"number\">-8</span>&#125;　&#125;;</span><br></pre></td></tr></table></figure><p>如上所示，该复合字面量的类型是<code>int [2][4]</code>，即一个2×4的<code>int</code>数组。</p>\n<p>程序清单10.19把上述例子放进一个完整的程序中。</p>\n<p>程序清单10.19 flc.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// flc.c -- 有趣的常量</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　COLS　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[][COLS],<span class=\"keyword\">int</span> rows)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[],<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total1,total2,total3;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> * pt1;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>(*pt2)[COLS];</span><br><span class=\"line\">    pt1　=　(<span class=\"keyword\">int</span>[<span class=\"number\">2</span>])　&#123;　<span class=\"number\">10</span>,　<span class=\"number\">20</span>　&#125;;</span><br><span class=\"line\">    pt2　=　(<span class=\"keyword\">int</span>[<span class=\"number\">2</span>][COLS])　&#123;　&#123;<span class=\"number\">1</span>,　<span class=\"number\">2</span>,　<span class=\"number\">3</span>,　<span class=\"number\">-9</span>&#125;,　&#123;　<span class=\"number\">4</span>,　<span class=\"number\">5</span>,　<span class=\"number\">6</span>,　<span class=\"number\">-8</span>　&#125;　&#125;;</span><br><span class=\"line\">    total1　=　sum(pt1,　<span class=\"number\">2</span>);</span><br><span class=\"line\">    total2　=　sum2d(pt2,　<span class=\"number\">2</span>);</span><br><span class=\"line\">    total3　=　sum((<span class=\"keyword\">int</span>　[])&#123;　<span class=\"number\">4</span>,　<span class=\"number\">4</span>,　<span class=\"number\">4</span>,　<span class=\"number\">5</span>,　<span class=\"number\">5</span>,　<span class=\"number\">5</span>　&#125;,　<span class=\"number\">6</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"total1　=　%d\\n\"</span>,　total1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"total2　=　%d\\n\"</span>,　total2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"total3　=　%d\\n\"</span>,　total3);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span>　<span class=\"keyword\">int</span>　ar　[],　<span class=\"keyword\">int</span>　n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \ttotal　+=　ar[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum2d</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[][COLS],<span class=\"keyword\">int</span> rows)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> tot　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(r　=　<span class=\"number\">0</span>;　r　&lt;　rows;　r++)</span><br><span class=\"line\">    \t<span class=\"keyword\">for</span>(c　=　<span class=\"number\">0</span>;　c　&lt;　COLS;　c++)</span><br><span class=\"line\">    \t\ttot　+=　ar[r][c];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>要支持C99的编译器才能正常运行该程序示例（目前并不是所有的编译器都支持），其输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total1　=　<span class=\"number\">30</span></span><br><span class=\"line\">total2　=　<span class=\"number\">4</span></span><br><span class=\"line\">total3　=　<span class=\"number\">27</span></span><br></pre></td></tr></table></figure><p>记住，<strong>复合字面量</strong>是提供只临时需要的值的一种手段。复合字面量具有<strong>块作用域</strong>（第12章将介绍相关内容），这意味着一旦离开定义复合字面量的块，程序将无法保证该字面量是否存在。也就是说，复合字面量的定义在最内层的花括号中。</p>\n<h2 id=\"关键概念\">关键概念<a href=\"#关键概念\" title=\"关键概念\"></a></h2><p>数组用于储存相同类型的数据。C 把数组看作是派生类型，因为数组是建立在其他类型的基础上。也就是说，无法简单地声明一个数组。在声明数组时必须说明其元素的类型，如<code>int</code>类型的数组、<code>float</code>类型的数组，或其他类型的数组。所谓的其他类型也可以是数组类型，这种情况下，创建的是数组的数组（或称为<strong>二维数组</strong>）。</p>\n<p>通常编写一个函数来处理数组，这样在特定的函数中解决特定的问题，有助于实现程序的模块化。在把数组名作为实际参数时，传递给函数的不是整个数组，而是数组的地址（因此，函数对应的形式参数是<strong>指针</strong>）。为了处理数组，函数必须知道从何处开始读取数据和要处理多少个数组元素。数组地址提供了“<strong>地址</strong>”，“<strong>元素个数</strong>”可以内置在函数中或作为单独的参数传递。第 2 种方法更普遍，因为这样做可以让同一个函数处理不同大小的数组。</p>\n<p>数组和指针的关系密切，同一个操作可以用数组表示法或指针表示法。它们之间的关系允许你在处理数组的函数中使用数组表示法，即使函数的形式参数是一个指针，而不是数组。</p>\n<p>对于传统的 C 数组，必须用常量表达式指明数组的大小，所以数组大小在编译时就已确定。C99/C11新增了<strong>变长数组</strong>，可以用变量表示数组大小。这意味着变长数组的大小延迟到程序运行时才确定。</p>\n<h2 id=\"本章小结\">本章小结<a href=\"#本章小结\" title=\"本章小结\"></a></h2><p>数组是一组数据类型相同的元素。数组元素按顺序储存在内存中，通过整数下标（或索引）可以访问各元素。在C中，数组首元素的下标是0，所以对于内含n个元素的数组，其最后一个元素的下标是<code>n-1</code>。作为程序员，要确保使用有效的数组下标，因为编译器和运行的程序都不会检查下标的有效性。</p>\n<p>声明一个简单的一维数组形式如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">type name [ <span class=\"built_in\">size</span> ];</span><br></pre></td></tr></table></figure><p>这里，<code>type</code>是数组中每个元素的数据类型，<code>name</code>是数组名，<code>size</code>是数组元素的个数。对于传统的C数组，要求<code>size</code>是整型常量表达式。但是C99/C11允许使用<strong>整型非常量表达式</strong>。这种情况下的数组被称为<strong>变长数组</strong>。</p>\n<p>C把数组名解释为该数组首元素的地址。换言之，<strong>数组名与指向该数组首元素的指针等价</strong>。概括地说，数组和指针的关系十分密切。如果ar是一个数组，那么表达式<code>ar[i]</code>和<code>*(ar+i)</code>等价。</p>\n<p><strong>对于 C 语言而言，不能把整个数组作为参数传递给函数，但是可以传递数组的地址。然后函数可以使用传入的地址操控原始数组。</strong>如果函数没有修改原始数组的意图，应在声明函数的形式参数时使用关键字<code>const</code>。在被调函数中可以使用数组表示法或指针表示法，无论用哪种表示法，实际上使用的都是指针变量。</p>\n<p>指针加上一个整数或递增指针，指针的值以所指向对象的大小为单位改变。也就是说，如果<code>pd</code>指向一个数组的8字节<code>double</code>类型值，那么<code>pd</code>加1意味着其值加8，以便它指向该数组的下一个元素。</p>\n<p>二维数组即是数组的数组。例如，下面声明了一个二维数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> sales[<span class=\"number\">5</span>][<span class=\"number\">12</span>];</span><br></pre></td></tr></table></figure><p>该数组名为<code>sales</code>，有5个元素（一维数组），每个元素都是一个内含12个<code>double</code>类型值的数组。第1个一维数组是<code>sales[0]</code>，第2个一维数组是<code>sales[1]</code>，以此类推，每个元素都是内含12个<code>double</code>类型值的数组。使用第2个下标可以访问这些一维数组中的特定元素。例如，<code>sales[2][5]</code>是<code>slaes[2]</code>的第6<code>个</code>元素，而<code>sales[2]</code>是<code>sales</code>的第3个元素。</p>\n<p><strong>C 语言传递多维数组的传统方法是把数组名（即数组的地址）传递给类型匹配的指针形参。</strong>声明这样的指针形参要指定所有的数组维度，除了第1个维度。传递的第1个维度通常作为第2个参数。例如，为了处理前面声明的<code>sales</code>数组，函数原型和函数调用如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">double</span> ar[][<span class=\"number\">12</span>],<span class=\"keyword\">int</span> rows)</span></span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">display</span>(sales, <span class=\"number\">5</span>);</span><br></pre></td></tr></table></figure><p>变长数组提供第2种语法，把数组维度作为参数传递。在这种情况下，对应函数原型和函数调用如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">display</span><span class=\"params\">(<span class=\"keyword\">int</span> rows,<span class=\"keyword\">int</span> cols,<span class=\"keyword\">double</span> ar[rows][cols])</span></span>;</span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"built_in\">display</span>(<span class=\"number\">5</span>, <span class=\"number\">12</span>, sales);</span><br></pre></td></tr></table></figure><p>虽然上述讨论中使用的是<code>int</code>类型的数组和<code>double</code>类型的数组，其他类型的数组也是如此。然而，字符串有一些特殊的规则，这是由于其末尾的空字符所致。有了这个空字符，不用传递数组的大小，函数通过检测字符串的末尾也知道在何处停止。我们将在第11章中详细介绍。</p>\n","prev":{"title":"Step1 Java程序设计概述","link":"posts/1fa13e13"},"next":{"title":"Inside Front-Matter","link":"posts/5a6efaf9"},"plink":"https://dxsummer.gitee.io/posts/87e8ce91/","toc":[{"id":"数组","title":"数组","index":"1","children":[{"id":"初始化数组","title":"初始化数组","index":"1.1"},{"id":"指定初始化器（c99）","title":"指定初始化器（C99）","index":"1.2"},{"id":"给数组元素赋值","title":"给数组元素赋值","index":"1.3"},{"id":"数组边界","title":"数组边界","index":"1.4"},{"id":"指定数组的大小","title":"指定数组的大小","index":"1.5"}]},{"id":"多维数组","title":"多维数组","index":"2","children":[{"id":"初始化二维数组","title":"初始化二维数组","index":"2.1"},{"id":"其他多维数组","title":"其他多维数组","index":"2.2"}]},{"id":"指针和数组","title":"指针和数组","index":"3"},{"id":"函数、数组和指针","title":"函数、数组和指针","index":"4","children":[{"id":"使用指针形参","title":"使用指针形参","index":"4.1"},{"id":"指针表示法和数组表示法","title":"指针表示法和数组表示法","index":"4.2"}]},{"id":"指针操作","title":"指针操作","index":"5"},{"id":"保护数组中的数据","title":"保护数组中的数据","index":"6","children":[{"id":"对形式参数使用const","title":"对形式参数使用const","index":"6.1"},{"id":"const的其他内容","title":"const的其他内容","index":"6.2"}]},{"id":"指针和多维数组","title":"指针和多维数组","index":"7","children":[{"id":"指向多维数组的指针","title":"指向多维数组的指针","index":"7.1"},{"id":"指针的兼容性","title":"指针的兼容性","index":"7.2"},{"id":"函数和多维数组","title":"函数和多维数组","index":"7.3"}]},{"id":"变长数组（vla）","title":"变长数组（VLA）","index":"8"},{"id":"复合字面量","title":"复合字面量","index":"9"},{"id":"关键概念","title":"关键概念","index":"10"},{"id":"本章小结","title":"本章小结","index":"11"}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/87e8ce91/\" title=\"Step8 数组和指针\">https://dxsummer.gitee.io/posts/87e8ce91/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年6月13日","updated":"2020年6月27日"}}