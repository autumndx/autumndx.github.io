{"title":"Step8 数组和指针","date":"2020-06-13T02:39:24.000Z","date_formatted":{"ll":"2020年6月13日","L":"2020/06/13","MM-DD":"06-13"},"link":"posts/87e8ce91","comments":true,"tags":["C语言基础"],"categories":["C语言"],"updated":"2020-06-16T09:36:59.265Z","content":"<p>本章介绍以下内容：</p>\n<p>关键字：<code>static</code></p>\n<p>运算符：<code>&amp;</code>、<code>*</code>（一元）</p>\n<ul><li>如何创建并初始化数组</li>\n<li>指针（在已学过的基础上）、指针和数组的关系</li>\n<li>编写处理数组的函数</li>\n<li>二维数组</li>\n</ul><p>人们通常借助计算机完成统计每月的支出、日降雨量、季度销售额等任务。企业借助计算机管理薪资、库存和客户交易记录等。作为程序员，不可避免地要处理大量相关数据。通常，数组能高效便捷地处理这种数据。第 6 章简单地介绍了数组，本章将进一步地学习如何使用数组，着重分析如何编写处理数组的函数。这种函数把模块化编程的优势应用到数组。通过本章的学习，你将明白数组和指针关系密切。</p>\n<h2 id=\"数组\">数组<a href=\"#数组\" title=\"数组\"></a></h2><p>前面介绍过，数组由数据类型相同的一系列元素组成。需要使用数组时，通过声明数组告诉编译器数组中内含多少元素和这些元素的类型。编译器根据这些信息正确地创建数组。普通变量可以使用的类型，数组元素都可以用。考虑下面的数组声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 一些数组声明*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> candy[<span class=\"number\">365</span>];　　　 <span class=\"comment\">/* 内含365个float类型元素的数组 */</span></span><br><span class=\"line\">    <span class=\"keyword\">char</span> code[<span class=\"number\">12</span>];　　　　　<span class=\"comment\">/*内含12个char类型元素的数组*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> states[<span class=\"number\">50</span>];　　　　 <span class=\"comment\">/*内含50个int类型元素的数组 */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>方括号（<code>[]</code>）表明candy、code和states都是数组，方括号中的数字表明数组中的元素个数。</p>\n<p>要访问数组中的元素，通过使用数组下标数（也称为索引）表示数组中的各元素。数组元素的编号从0开始，所以<code>candy[0]</code>表示candy数组的第1个元素，<code>candy[364]</code>表示第365个元素，也就是最后一个元素。读者对这些内容应该比较熟悉，下面我们介绍一些新内容。</p>\n<h3 id=\"初始化数组\">初始化数组<a href=\"#初始化数组\" title=\"初始化数组\"></a></h3><p>数组通常被用来储存程序需要的数据。例如，一个内含12个整数元素的数组可以储存12个月的天数。在这种情况下，在程序一开始就初始化数组比较好。下面介绍初始化数组的方法。</p>\n<p>只储存单个值的变量有时也称为标量变量（scalar variable），我们已经很熟悉如何初始化这种变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> fix　=　<span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> flax = PI * <span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure><p>代码中的PI已定义为宏。C使用新的语法来初始化数组，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> powers[<span class=\"number\">8</span>] = &#123;<span class=\"number\">1</span>,<span class=\"number\">2</span>,<span class=\"number\">4</span>,<span class=\"number\">6</span>,<span class=\"number\">8</span>,<span class=\"number\">16</span>,<span class=\"number\">32</span>,<span class=\"number\">64</span>&#125;; <span class=\"comment\">/* 从ANSI C开始支持这种初始化 */</span></span><br><span class=\"line\">    ...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>如上所示，用以逗号分隔的值列表（用花括号括起来）来初始化数组，各值之间用逗号分隔。在逗号和值之间可以使用空格。根据上面的初始化，把 1 赋给数组的首元素（<code>powers[0]</code>），以此类推（不支持ANSI的编译器会把这种形式的初始化识别为语法错误，在数组声明前加上关键字<code>static</code>可解决此问题。第12章将详细讨论这个关键字）。</p>\n<p>程序清单10.1演示了一个小程序，打印每个月的天数。</p>\n<p>程序清单10.1 day_mon1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* day_mon1.c -- 打印每个月的天数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　days[MONTHS]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>　(index　=　<span class=\"number\">0</span>;　index　&lt;　MONTHS;　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Month　%2d　has　%2d　days.\\n\"</span>,　index　+　<span class=\"number\">1</span>,　days[index]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Month　<span class=\"number\">1</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">2</span>　has　<span class=\"number\">28</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">3</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">4</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">5</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">6</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">7</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">8</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">9</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">10</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">11</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">12</span>　has　<span class=\"number\">31</span>　days.</span><br></pre></td></tr></table></figure><p>这个程序还不够完善，每4年打错一个月份的天数（即，2月份的天数）。该程序用初始化列表初始化<code>days[]</code>，列表（用花括号括起来）中用逗号分隔各值。</p>\n<p>注意该例使用了符号常量 MONTHS 表示数组大小，这是我们推荐且常用的做法。例如，如果要采用一年13个月的记法，只需修改#define这行代码即可，不用在程序中查找所有使用过数组大小的地方。</p>\n<p>注意 使用<code>const</code>声明数组</p>\n<p>有时需要把数组设置为只读。这样，程序只能从数组中检索值，不能把新值写入数组。要创建只读数组，应该用<code>const</code>声明和初始化数组。因此，程序清单10.1中初始化数组应改成：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> days[MONTHS] = &#123;<span class=\"number\">31</span>,<span class=\"number\">28</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>&#125;;</span><br></pre></td></tr></table></figure><p>这样修改后，程序在运行过程中就不能修改该数组中的内容。和普通变量一样，应该使用声明来初始化 <code>const</code> 数据，因为一旦声明为 <code>const</code>，便不能再给它赋值。明确了这一点，就可以在后面的例子中使用<code>const</code>了。</p>\n<p>如果初始化数组失败怎么办？程序清单10.2演示了这种情况。</p>\n<p>程序清单10.2 no_data.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* no_data.c -- 为初始化数组 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> no_data[SIZE];　<span class=\"comment\">/* 未初始化数组 */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>　i;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2s%14s\\n\"</span>,　　　<span class=\"string\">\"i\"</span>,　<span class=\"string\">\"no_data[i]\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>　(i　=　<span class=\"number\">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d%14d\\n\"</span>,　i,　no_data[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下（系统不同，输出的结果可能不同）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i　　　no_data[i]</span><br><span class=\"line\"><span class=\"number\">0</span>　　　　　　　　　　<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">1</span>　　　　　 <span class=\"number\">4204937</span></span><br><span class=\"line\"><span class=\"number\">2</span>　　　　　 <span class=\"number\">4219854</span></span><br><span class=\"line\"><span class=\"number\">3</span>　　　<span class=\"number\">2147348480</span></span><br></pre></td></tr></table></figure><p>使用数组前必须先初始化它。与普通变量类似，在使用数组元素之前，必须先给它们赋初值。编译器使用的值是内存相应位置上的现有值，因此，读者运行该程序后的输出会与该示例不同。</p>\n<p>注意 存储类别警告</p>\n<p>数组和其他变量类似，可以把数组创建成不同的<strong>存储类别</strong>（storage class）。第12章将介绍存储类别的相关内容，现在只需记住：本章描述的<strong>数组属于自动存储类别</strong>，意思是<strong>这些数组在函数内部声明，且声明时未使用关键字</strong><code>static</code>。到目前为止，本书所用的变量和数组都是自动存储类别。</p>\n<p>在这里提到存储类别的原因是，不同的存储类别有不同的属性，所以不能把本章的内容推广到其他存储类别。<strong>对于一些其他存储类别的变量和数组，如果在声明时未初始化，编译器会自动把它们的值设置为0</strong>。</p>\n<p>初始化列表中的项数应与数组的大小一致。如果不一致会怎样？我们还是以上一个程序为例，但初始化列表中缺少两个元素，如程序清单10.3所示：</p>\n<p>程序清单10.3 somedata.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* some_data.c -- 部分初始化数组 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> some_data[SIZE]　=　&#123;　<span class=\"number\">1492</span>,　<span class=\"number\">1066</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%2s%14s\\n\"</span>,　　　<span class=\"string\">\"i\"</span>,　<span class=\"string\">\"some_data[i]\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d%14d\\n\"</span>,　i,　some_data[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">i　some_data[i]</span><br><span class=\"line\"><span class=\"number\">0</span>　　　　　　　<span class=\"number\">1492</span></span><br><span class=\"line\"><span class=\"number\">1</span>　　　　　　　<span class=\"number\">1066</span></span><br><span class=\"line\"><span class=\"number\">2</span>　　　　　　　　　<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">3</span>　　　　　　　　　<span class=\"number\">0</span></span><br></pre></td></tr></table></figure><p>如上所示，编译器做得很好。当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。</p>\n<p>如果初始化列表的项数多于数组元素个数，编译器可没那么仁慈，它会毫不留情地将其视为错误。但是，没必要因此嘲笑编译器。其实，可以省略方括号中的数字，让编译器自动匹配数组大小和初始化列表中的项数（见程序清单10.4）</p>\n<p>程序清单10.4 day_mon2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* day_mon2.c -- 让编译器计算元素个数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">int</span> days[]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(index　=　<span class=\"number\">0</span>;　index　&lt;　<span class=\"keyword\">sizeof</span>　days　/　<span class=\"keyword\">sizeof</span>　days[<span class=\"number\">0</span>];　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Month　%2d　has　%d　days.\\n\"</span>,　index　+　<span class=\"number\">1</span>,　days[index]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在程序清单10.4中，要注意以下两点。</p>\n<p>如果初始化数组时省略方括号中的数字，编译器会根据初始化列表中的项数来确定数组的大小。</p>\n<p>注意<code>for</code>循环中的测试条件。由于人工计算容易出错，所以让计算机来计算数组的大小。<code>sizeof</code>运算符给出它的运算对象的大小（以字节为单位）。所以<code>sizeof days</code>是整个数组的大小（以字节为单位），<code>sizeof day[0]</code>是数组中一个元素的大小（以字节为单位）。<strong>整个数组的大小除以单个元素的大小就是数组元素的个数。</strong></p>\n<p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Month　<span class=\"number\">1</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">2</span>　has　<span class=\"number\">28</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">3</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">4</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">5</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">6</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">7</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">8</span>　has　<span class=\"number\">31</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">9</span>　has　<span class=\"number\">30</span>　days.</span><br><span class=\"line\">Month　<span class=\"number\">10</span>　has　<span class=\"number\">31</span>　days.</span><br></pre></td></tr></table></figure><p>我们的本意是防止初始化值的个数超过数组的大小，让程序找出数组大小。我们初始化时用了10个值，结果就只打印了10个值！这就是自动计数的弊端：无法察觉初始化列表中的项数有误。</p>\n<p>还有一种初始化数组的方法，但这种方法仅限于初始化字符数组。我们在下一章中介绍。</p>\n<h3 id=\"指定初始化器（c99）\">指定初始化器（C99）<a href=\"#指定初始化器（c99）\" title=\"指定初始化器（C99）\"></a></h3><p>C99 增加了一个新特性：指定初始化器（designated initializer）。利用该特性可以初始化指定的数组元素。例如，只初始化数组中的最后一个元素。对于传统的C初始化语法，必须初始化最后一个元素之前的所有元素，才能初始化它：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">6</span>] = &#123;<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">0</span>,<span class=\"number\">212</span>&#125;; <span class=\"comment\">// 传统的语法</span></span><br></pre></td></tr></table></figure><p>而C99规定，可以<strong>在初始化列表中使用带方括号的下标指明待初始化的元素</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> arr[<span class=\"number\">6</span>] = &#123;[<span class=\"number\">5</span>] = <span class=\"number\">212</span>&#125;; <span class=\"comment\">// 把arr[5]初始化为212</span></span><br></pre></td></tr></table></figure><p>对于一般的初始化，在初始化一个元素后，未初始化的元素都会被设置为0。程序清单10.5中的初始化比较复杂。</p>\n<p>程序清单10.5 designate.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// designate.c -- 使用指定初始化器</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> days[MONTHS]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　[<span class=\"number\">4</span>]　=　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　[<span class=\"number\">1</span>]　=　<span class=\"number\">29</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　MONTHS;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d　 %d\\n\"</span>,　i　+　<span class=\"number\">1</span>,　days[i]);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序在支持C99的编译器中输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">1</span>　　 <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">2</span>　　 <span class=\"number\">29</span></span><br><span class=\"line\"><span class=\"number\">3</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">4</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">5</span>　　 <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">6</span>　　 <span class=\"number\">30</span></span><br><span class=\"line\"><span class=\"number\">7</span>　　 <span class=\"number\">31</span></span><br><span class=\"line\"><span class=\"number\">8</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">9</span>　　　<span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">10</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">11</span>　　 <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"number\">12</span>　　 <span class=\"number\">0</span></span><br></pre></td></tr></table></figure><p>以上输出揭示了指定初始化器的两个重要特性。第一，<strong>如果指定初始化器后面有更多的值，如该例中的初始化列表中的片段：<code>[4] = 31,30,31</code>，那么后面这些值将被用于初始化指定元素后面的元素。</strong>也就是说，在<code>days[4]</code>被初始化为31后，<code>days[5]</code>和<code>days[6]</code>将分别被初始化为30和31。第二，如果再次初始化指定的元素，那么最后的初始化将会取代之前的初始化。例如，程序清单10.5中，初始化列表开始时把<code>days[1]</code>初始化为28，但是<code>days[1]</code>又被后面的指定初始化<code>[1] = 29</code>初始化为29。</p>\n<p>如果未指定元素大小会怎样？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> stuff[] = &#123;<span class=\"number\">1</span>, [<span class=\"number\">6</span>] = <span class=\"number\">23</span>&#125;;　　　　 <span class=\"comment\">//会发生什么？</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> staff[] = &#123;<span class=\"number\">1</span>, [<span class=\"number\">6</span>] = <span class=\"number\">4</span>, <span class=\"number\">9</span>, <span class=\"number\">10</span>&#125;;　<span class=\"comment\">//会发生什么？</span></span><br></pre></td></tr></table></figure><p>编译器会把数组的大小设置为足够装得下初始化的值。所以，<code>stuff</code>数组有7个元素，编号为<code>0～6</code>；而<code>staff</code>数组的元素比<code>stuff</code>数组多两个（即有9个元素）。</p>\n<h3 id=\"给数组元素赋值\">给数组元素赋值<a href=\"#给数组元素赋值\" title=\"给数组元素赋值\"></a></h3><p>声明数组后，可以借助数组下标（或索引）给数组元素赋值。例如，下面的程序段给数组的所有元素赋值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 给数组的元素赋值 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　50</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span>　counter,　evens[SIZE];</span><br><span class=\"line\"><span class=\"keyword\">for</span>　(counter　=　<span class=\"number\">0</span>;　counter　&lt;　SIZE;　counter++)</span><br><span class=\"line\">evens[counter]　=　<span class=\"number\">2</span>　*　counter;</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>注意这段代码中使用循环给数组的元素依次赋值。C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。下面的代码段演示了一些错误的赋值形式:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 一些无效的数组赋值 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span> oxen[SIZE] = &#123;<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>&#125;;　　　　 <span class=\"comment\">/* 初始化没问题 */</span></span><br><span class=\"line\"><span class=\"keyword\">int</span> yaks[SIZE];</span><br><span class=\"line\">yaks = oxen;　　　　　　　　　 <span class=\"comment\">/* 不允许 */</span></span><br><span class=\"line\">yaks[SIZE] = oxen[SIZE];　　　 <span class=\"comment\">/* 数组下标越界 */</span></span><br><span class=\"line\">yaks[SIZE] = &#123;<span class=\"number\">5</span>,<span class=\"number\">3</span>,<span class=\"number\">2</span>,<span class=\"number\">8</span>&#125;;　　　　<span class=\"comment\">/* 不起作用 */</span></span><br></pre></td></tr></table></figure><p>oxen数组的最后一个元素是<code>oxen[SIZE-1]</code>，所以<code>oxen[SIZE]</code>和<code>yaks[SIZE]</code>都超出了两个数组的末尾。</p>\n<h3 id=\"数组边界\">数组边界<a href=\"#数组边界\" title=\"数组边界\"></a></h3><p>在使用数组时，要防止数组下标超出边界。也就是说，必须确保下标是有效的值。例如，假设有下面的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> doofi[<span class=\"number\">20</span>];</span><br></pre></td></tr></table></figure><p>那么在使用该数组时，要确保程序中使用的数组下标在0～19的范围内，因为编译器不会检查出这种错误（但是，一些编译器发出警告，然后继续编译程序）。</p>\n<p>考虑程序清单10.6的问题。该程序创建了一个内含4个元素的数组，然后错误地使用了-1～6的下标。</p>\n<p>程序清单10.6 bounds.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// bounds.c -- 数组下标越界</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value1　=　<span class=\"number\">44</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">int</span> value2　=　<span class=\"number\">88</span>;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"value1　=　%d,　value2　=　%d\\n\"</span>,　value1,　value2);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">-1</span>;　i　&lt;=　SIZE;　i++)</span><br><span class=\"line\">    \tarr[i] = <span class=\"number\">2</span> * i + <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">-1</span>;　i　&lt;　<span class=\"number\">7</span>;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%2d　%d\\n\"</span>,　i,　arr[i]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"value1　=　%d,　value2　=　%d\\n\"</span>,　value1,　value2);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　arr[-1]:　%p\\n\"</span>,　&amp;arr[<span class=\"number\">-1</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　arr[4]:　%p\\n\"</span>,　&amp;arr[<span class=\"number\">4</span>]);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　value1:　%p\\n\"</span>,　&amp;value1);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"address　of　value2:　%p\\n\"</span>,　&amp;value2);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编译器不会检查数组下标是否使用得当。在C标准中，使用越界下标的结果是未定义的。这意味着程序看上去可以运行，但是运行结果很奇怪，或异常中止。下面是使用GCC的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">value1　=　<span class=\"number\">44</span>,　value2　=　<span class=\"number\">88</span></span><br><span class=\"line\"><span class=\"number\">-1</span>　<span class=\"number\">-1</span></span><br><span class=\"line\"><span class=\"number\">0</span>　<span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">1</span>　<span class=\"number\">3</span></span><br><span class=\"line\"><span class=\"number\">2</span>　<span class=\"number\">5</span></span><br><span class=\"line\"><span class=\"number\">3</span>　<span class=\"number\">7</span></span><br><span class=\"line\"><span class=\"number\">4</span>　<span class=\"number\">9</span></span><br><span class=\"line\"><span class=\"number\">5</span>　<span class=\"number\">1624678494</span></span><br><span class=\"line\"><span class=\"number\">6</span>　<span class=\"number\">32767</span></span><br><span class=\"line\">value1　=　<span class=\"number\">9</span>,　value2　=　<span class=\"number\">-1</span></span><br><span class=\"line\">address　of　arr[<span class=\"number\">-1</span>]:　 <span class=\"number\">0x7fff5fbff8cc</span></span><br><span class=\"line\">address　of　arr[<span class=\"number\">4</span>]:　　<span class=\"number\">0x7fff5fbff8e0</span></span><br><span class=\"line\">address　of　value1:　　<span class=\"number\">0x7fff5fbff8e0</span></span><br><span class=\"line\">address　of　value2:　　<span class=\"number\">0x7fff5fbff8cc</span></span><br></pre></td></tr></table></figure><p>注意，该编译器似乎把<code>value2</code>储存在数组的前一个位置，把<code>value1</code>储存在数组的后一个位置（其他编译器在内存中储存数据的顺序可能不同）。在上面的输出中，<code>arr[-1]</code>与<code>value2</code>对应的内存地址相同， <code>arr[4]</code>和<code>value1</code>对应的内存地址相同。因此，使用越界的数组下标会导致程序改变其他变量的值。不同的编译器运行该程序的结果可能不同，有些会导致程序异常中止。</p>\n<p>C 语言为何会允许这种麻烦事发生？这要归功于 C 信任程序员的原则。不检查边界，C 程序可以运行更快。编译器没必要捕获所有的下标错误，因为在程序运行之前，数组的下标值可能尚未确定。因此，为安全起见，编译器必须在运行时添加额外代码检查数组的每个下标值，这会降低程序的运行速度。C 相信程序员能编写正确的代码，这样的程序运行速度更快。但并不是所有的程序员都能做到这一点，所以就出现了下标越界的问题。</p>\n<p>还要记住一点：数组元素的编号从0开始。最好是在声明数组时使用符号常量来表示数组的大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　SIZE;　i++)</span><br><span class=\"line\">    \t....</span><br></pre></td></tr></table></figure><p>这样做能确保整个程序中的数组大小始终一致。</p>\n<h3 id=\"指定数组的大小\">指定数组的大小<a href=\"#指定数组的大小\" title=\"指定数组的大小\"></a></h3><p>本章前面的程序示例都使用整型常量来声明数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> arr[SIZE];　　　　　<span class=\"comment\">// 整数符号常量</span></span><br><span class=\"line\">    <span class=\"keyword\">double</span> lots[<span class=\"number\">144</span>];　　　 <span class=\"comment\">// 整数字面常量</span></span><br><span class=\"line\">    ...</span><br></pre></td></tr></table></figure><p>在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。<code>sizeof</code>表达式被视为整型常量，但是（与C++不同）<code>const</code>值不是。另外，<strong>表达式的值必须大于0</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> n　=　<span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> m　=　<span class=\"number\">8</span>;</span><br><span class=\"line\"><span class=\"keyword\">float</span> a1[<span class=\"number\">5</span>];　　　　　　　　 <span class=\"comment\">// 可以</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a2[<span class=\"number\">5</span>*<span class=\"number\">2</span> + <span class=\"number\">1</span>];　　　　 <span class=\"comment\">//可以</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a3[<span class=\"keyword\">sizeof</span>(<span class=\"keyword\">int</span>) + <span class=\"number\">1</span>]; <span class=\"comment\">//可以</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a4[<span class=\"number\">-4</span>];　　　　　　　　<span class=\"comment\">// 不可以，数组大小必须大于0</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a5[<span class=\"number\">0</span>];　　　　　　　　 <span class=\"comment\">// 不可以，数组大小必须大于0</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a6[<span class=\"number\">2.5</span>];　　　　　　　 <span class=\"comment\">// 不可以，数组大小必须是整数</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a7[(<span class=\"keyword\">int</span>)<span class=\"number\">2.5</span>];　　　　 <span class=\"comment\">// 可以，已被强制转换为整型常量</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a8[n];　　　　　　　　 <span class=\"comment\">// C99之前不允许</span></span><br><span class=\"line\"><span class=\"keyword\">float</span> a9[m];　　　　　　　　 <span class=\"comment\">// C99之前不允许</span></span><br></pre></td></tr></table></figure><p>上面的注释表明，以前支持C90标准的编译器不允许后两种声明方式。而C99标准允许这样声明，这创建了一种新型数组，称为<strong>变长数组</strong>（variable-length array）或简称 <strong>VLA</strong>（C11 放弃了这一创新的举措，把VLA设定为可选，而不是语言必备的特性）。</p>\n<p>C99引入变长数组主要是为了让C成为更好的数值计算语言。例如，VLA简化了把FORTRAN现有的数值计算例程库转换为C代码的过程。VLA有一些限制，例如，声明VLA时不能进行初始化。在充分了解经典的C数组后，我们再详细介绍VLA。</p>\n<h2 id=\"多维数组\">多维数组<a href=\"#多维数组\" title=\"多维数组\"></a></h2><p>气象研究员Tempest Cloud为完成她的研究项目要分析5年内每个月的降水量数据，她首先要解决的问题是如何表示数据。一个方案是创建60个变量，每个变量储存一个数据项（我们曾经提到过这一笨拙的方案，和以前一样，这个方案并不合适）。使用一个内含60个元素的数组比将建60个变量好，但是如果能把各年的数据分开储存会更好，即创建5个数组，每个数组12个元素。然而，这样做也很麻烦，如果Tempest决定研究50年的降水量，岂不是要创建50个数组。是否能有更好的方案？</p>\n<p>处理这种情况应该使用数组的数组。主数组（master array）有5个元素（每个元素表示一年），每个元素是内含12个元素的数组（每个元素表示一个月）。下面是该数组的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> rain[<span class=\"number\">5</span>][<span class=\"number\">12</span>]; <span class=\"comment\">// 内含5个数组元素的数组，每个数组元素内含12个float类型的元素</span></span><br></pre></td></tr></table></figure><p>理解该声明的一种方法是，先查看中间部分（粗体部分）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">float</span> rain[<span class=\"number\">5</span>][<span class=\"number\">12</span>]; <span class=\"comment\">// rain是一个内含5个元素的数组</span></span><br></pre></td></tr></table></figure><p>这说明数组<code>rain</code>有5个元素，至于每个元素的情况，要查看声明的其余部分（粗体部分）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">floatrain[<span class=\"number\">5</span>][<span class=\"number\">12</span>] ; <span class=\"comment\">// 一个内含12个float类型元素的数组</span></span><br></pre></td></tr></table></figure><p>这说明每个元素的类型是<code>float[12]</code>，也就是说，<code>rain</code>的每个元素本身都是一个内含12个<code>float</code>类型值的数组。</p>\n<p>根据以上分析可知，rain的首元素<code>rain[0]</code>是一个内含12个<code>float</code>类型值的数组。所以，<code>rain[1]</code>、<code>rain[2]</code>等也是如此。如果 <code>rain[0]</code>是一个数组，那么它的首元素就是 <code>rain[0][0]</code>，第 2 个元素是<code>rain[0][1]</code>，以此类推。简而言之，数组<code>rain</code>有5个元素，每个元素都是内含12个<code>float</code>类型元素的数组，<code>rain[0]</code>是内含12个<code>float</code>值的数组，<code>rain[0][0]</code>是一个<code>float</code>类型的值。假设要访问位于2行3列的值，则使用<code>rain[2][3]</code>（记住，数组元素的编号从0开始，所以2行指的是第3行）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/二维数组.png\" class=\"φcy\"></p>\n<p>该二维视图有助于帮助读者理解二维数组的两个下标。在计算机内部，这样的数组是按顺序储存的，从第1个内含12个元素的数组开始，然后是第2个内含12个元素的数组，以此类推。</p>\n<p>我们要在气象分析程序中用到这个二维数组。该程序的目标是，计算每年的总降水量、年平均降水量和月平均降水量。要计算年总降水量，必须对一行数据求和；要计算某月份的平均降水量，必须对一列数据求和。二维数组很直观，实现这些操作也很容易。程序清单10.7演示了这个程序。</p>\n<p>程序清单10.7 rain.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* rain.c　-- 计算每年的总降水量、年平均降水量和5年中每月的平均降水量 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MONTHS 12　　　<span class=\"comment\">// 一年的月份数</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> YEARS　 5　　　 <span class=\"comment\">// 年数</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// 用2010～2014年的降水量数据初始化数组</span></span><br><span class=\"line\">    <span class=\"keyword\">const</span> <span class=\"keyword\">float</span> rain[YEARS][MONTHS]　=</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        &#123;　<span class=\"number\">4.3</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">3.0</span>,　<span class=\"number\">2.0</span>,　<span class=\"number\">1.2</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.4</span>,　<span class=\"number\">2.4</span>,　<span class=\"number\">3.5</span>,　<span class=\"number\">6.6</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">8.5</span>,　<span class=\"number\">8.2</span>,　<span class=\"number\">1.2</span>,　<span class=\"number\">1.6</span>,　<span class=\"number\">2.4</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">5.2</span>,　<span class=\"number\">0.9</span>,　<span class=\"number\">0.3</span>,　<span class=\"number\">0.9</span>,　<span class=\"number\">1.4</span>,　<span class=\"number\">7.3</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">9.1</span>,　<span class=\"number\">8.5</span>,　<span class=\"number\">6.7</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">2.1</span>,　<span class=\"number\">0.8</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">1.1</span>,　<span class=\"number\">2.3</span>,　<span class=\"number\">6.1</span>,　<span class=\"number\">8.4</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">7.2</span>,　<span class=\"number\">9.9</span>,　<span class=\"number\">8.4</span>,　<span class=\"number\">3.3</span>,　<span class=\"number\">1.2</span>,　<span class=\"number\">0.8</span>,　<span class=\"number\">0.4</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">0.6</span>,　<span class=\"number\">1.7</span>,　<span class=\"number\">4.3</span>,　<span class=\"number\">6.2</span>　&#125;,</span><br><span class=\"line\">        &#123;　<span class=\"number\">7.6</span>,　<span class=\"number\">5.6</span>,　<span class=\"number\">3.8</span>,　<span class=\"number\">2.8</span>,　<span class=\"number\">3.8</span>,　<span class=\"number\">0.2</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">0.0</span>,　<span class=\"number\">1.3</span>,　<span class=\"number\">2.6</span>,　<span class=\"number\">5.2</span>　&#125;</span><br><span class=\"line\">    &#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> year,month;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> subtot,total;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　YEAR　　 RAINFALL　 (inches)\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(year　=　<span class=\"number\">0</span>,　total　=　<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">    &#123;　　　　　　　　　　　　 <span class=\"comment\">// 每一年，各月的降水量总和</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(month　=　<span class=\"number\">0</span>,　subtot　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">        subtot+=rain[year][month];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%5d　%15.1f\\n\"</span>,　<span class=\"number\">2010</span>　+　year,　subtot);</span><br><span class=\"line\">        total += subtot;　 <span class=\"comment\">// 5年的总降水量</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nThe　yearly　average　is　%.1f　inches.\\n\\n\"</span>,　total　/　YEARS);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"MONTHLY　AVERAGES:\\n\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　Jan　 Feb　 Mar　 Apr　 May　 Jun　 Jul　 Aug　 Sep　 Oct　\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　Nov　 Dec\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(month　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">    &#123;　　　　　　　　　　　　 <span class=\"comment\">// 每个月，5年的总降水量</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span>(year　=　<span class=\"number\">0</span>,　subtot　=　<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">        \tsubtot　+=　rain[year][month];</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"%4.1f　\"</span>,　subtot　/　YEARS);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">YEAR　　　<span class=\"title\">RAINFALL</span>　 <span class=\"params\">(inches)</span></span></span><br><span class=\"line\">2010　　　　　　　 32.4</span><br><span class=\"line\"><span class=\"number\">2011</span>　　　　　　　 <span class=\"number\">37.9</span></span><br><span class=\"line\"><span class=\"number\">2012</span>　　　　　　　 <span class=\"number\">49.8</span></span><br><span class=\"line\"><span class=\"number\">2013</span>　　　　　　　 <span class=\"number\">44.0</span></span><br><span class=\"line\"><span class=\"number\">2014</span>　　　　　　　 <span class=\"number\">32.9</span></span><br><span class=\"line\">The　yearly　average　is　<span class=\"number\">39.4</span>　inches.</span><br><span class=\"line\">MONTHLY　AVERAGES:</span><br><span class=\"line\">Jan　Feb　Mar　Apr　May　Jun　Jul　Aug　Sep　Oct　Nov　Dec</span><br><span class=\"line\"><span class=\"number\">7.3</span>　<span class=\"number\">7.3</span>　<span class=\"number\">4.9</span>　<span class=\"number\">3.0</span>　<span class=\"number\">2.3</span>　<span class=\"number\">0.6</span>　<span class=\"number\">1.2</span>　<span class=\"number\">0.3</span>　<span class=\"number\">0.5</span>　<span class=\"number\">1.7</span>　<span class=\"number\">3.6</span>　<span class=\"number\">6.7</span></span><br></pre></td></tr></table></figure><p>学习该程序的重点是数组初始化和计算方案。初始化二维数组比较复杂，我们先来看较为简单的计算部分。</p>\n<p>程序使用了两个嵌套<code>for</code>循环。第1个嵌套<code>for</code>循环的内层循环，在<code>year</code>不变的情况下，遍历<code>month</code>计算某年的总降水量；而外层循环，改变<code>year</code>的值，重复遍历<code>month</code>，计算5年的总降水量。这种嵌套循环结构常用于处理二维数组，一个循环处理数组的第1个下标，另一个循环处理数组的第2个下标：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>　(year　=　<span class=\"number\">0</span>,　total　=　<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 处理每一年的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(month　=　<span class=\"number\">0</span>,　subtot　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">    ...<span class=\"comment\">// 处理每月的数据</span></span><br><span class=\"line\">    ...<span class=\"comment\">//处理每一年的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>第2个嵌套<code>for</code>循环和第1个的结构相同，但是内层循环遍历<code>year</code>，外层循环遍历<code>month</code>。记住，每执行一次外层循环，就完整遍历一次内层循环。因此，在改变月份之前，先遍历完年，得到某月 5 年间的平均降水量，以此类推：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>　(month　=　<span class=\"number\">0</span>;　month　&lt;　MONTHS;　month++)</span><br><span class=\"line\">&#123; <span class=\"comment\">// 处理每月的数据</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span>(year　=　<span class=\"number\">0</span>,　subtot　=<span class=\"number\">0</span>;　year　&lt;　YEARS;　year++)</span><br><span class=\"line\">    ...<span class=\"comment\">// 处理每年的数据</span></span><br><span class=\"line\">    ...<span class=\"comment\">// 处理每月的数据</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"初始化二维数组\">初始化二维数组<a href=\"#初始化二维数组\" title=\"初始化二维数组\"></a></h3><p>初始化二维数组是建立在初始化一维数组的基础上。首先，初始化一维数组如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">sometype ar1[<span class=\"number\">5</span>] = &#123;val1, val2, val3, val4, val5&#125;;</span><br></pre></td></tr></table></figure><p>这里，<code>val1</code>、<code>val2</code>等表示<code>sometype</code>类型的值。例如，如果<code>sometype</code>是<code>int</code>，那么<code>val1</code>可能是7；如果<code>sometype</code>是<code>double</code>，那么<code>val1</code>可能是11.34，诸如此类。但是<code>rain</code>是一个内含5个元素的数组，每个元素又是内含12个<code>float</code>类型元素的数组。所以，对<code>rain</code>而言，<code>val1</code>应该包含12个值，用于初始化内含12个<code>float</code>类型元素的一维数组，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#123;<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">3.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">1.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.4</span>,<span class=\"number\">2.4</span>,<span class=\"number\">3.5</span>,<span class=\"number\">6.6</span>&#125;</span><br></pre></td></tr></table></figure><p>也就是说，如果<code>sometype</code>是一个内含12个<code>double</code>类型元素的数组，那么val1就是一个由12个<code>double</code>类型值构成的数值列表。因此，为了初始化二维数组<code>rain</code>，要用逗号分隔5个这样的数值列表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">float</span> rain[YEARS][MONTHS]　=</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    &#123;<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">4.3</span>,<span class=\"number\">3.0</span>,<span class=\"number\">2.0</span>,<span class=\"number\">1.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.4</span>,<span class=\"number\">2.4</span>,<span class=\"number\">3.5</span>,<span class=\"number\">6.6</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">8.5</span>,<span class=\"number\">8.2</span>,<span class=\"number\">1.2</span>,<span class=\"number\">1.6</span>,<span class=\"number\">2.4</span>,<span class=\"number\">0.0</span>,<span class=\"number\">5.2</span>,<span class=\"number\">0.9</span>,<span class=\"number\">0.3</span>,<span class=\"number\">0.9</span>,<span class=\"number\">1.4</span>,<span class=\"number\">7.3</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">9.1</span>,<span class=\"number\">8.5</span>,<span class=\"number\">6.7</span>,<span class=\"number\">4.3</span>,<span class=\"number\">2.1</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.2</span>,<span class=\"number\">1.1</span>,<span class=\"number\">2.3</span>,<span class=\"number\">6.1</span>,<span class=\"number\">8.4</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">7.2</span>,<span class=\"number\">9.9</span>,<span class=\"number\">8.4</span>,<span class=\"number\">3.3</span>,<span class=\"number\">1.2</span>,<span class=\"number\">0.8</span>,<span class=\"number\">0.4</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.6</span>,<span class=\"number\">1.7</span>,<span class=\"number\">4.3</span>,<span class=\"number\">6.2</span>&#125;,</span><br><span class=\"line\">    &#123;<span class=\"number\">7.6</span>,<span class=\"number\">5.6</span>,<span class=\"number\">3.8</span>,<span class=\"number\">2.8</span>,<span class=\"number\">3.8</span>,<span class=\"number\">0.2</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">0.0</span>,<span class=\"number\">1.3</span>,<span class=\"number\">2.6</span>,<span class=\"number\">5.2</span>&#125;</span><br><span class=\"line\">&#125;;</span><br></pre></td></tr></table></figure><p>这个初始化使用了5个数值列表，每个数值列表都用花括号括起来。第1个列表的数据用于初始化数组的第1行，第2个列表的数据用于初始化数组的第2行，以此类推。前面讨论的数据个数和数组大小不匹配的问题同样适用于这里的每一行。也就是说，如果第1个列表中只有10个数，则只会初始化数组第1行的前10个元素，而最后两个元素将被默认初始化为0。如果某列表中的数值个数超出了数组每行的元素个数，则会出错，但是这并不会影响其他行的初始化。</p>\n<p>初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。图10.2演示了这种初始化数组的方法。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/初始化二维数组的两种方法.png\" class=\"φcy\"></p>\n<p>因为储存在数组<code>rain</code>中的数据不能修改，所以程序使用了<code>const</code>关键字声明该数组。</p>\n<h3 id=\"其他多维数组\">其他多维数组<a href=\"#其他多维数组\" title=\"其他多维数组\"></a></h3><p>前面讨论的二维数组的相关内容都适用于三维数组或更多维的数组。可以这样声明一个三维数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> box[<span class=\"number\">10</span>][<span class=\"number\">20</span>][<span class=\"number\">30</span>];</span><br></pre></td></tr></table></figure><p>可以把一维数组想象成一行数据，把二维数组想象成数据表，把三维数组想象成一叠数据表。例如，把上面声明的三维数组<code>box</code>想象成由10个二维数组（每个二维数组都是20行30列）堆叠起来。</p>\n<p>还有一种理解<code>box</code>的方法是，把<code>box</code>看作数组的数组。也就是说，<code>box</code>内含10个元素，每个元素是内含20个元素的数组，这20个数组元素中的每个元素是内含30个元素的数组。或者，可以简单地根据所需的下标值去理解数组。</p>\n<p>通常，处理三维数组要使用3重嵌套循环，处理四维数组要使用4重嵌套循环。对于其他多维数组，以此类推。在后面的程序示例中，我们只使用二维数组。</p>\n<h2 id=\"指针和数组\">指针和数组<a href=\"#指针和数组\" title=\"指针和数组\"></a></h2><p>第9章介绍过指针，指针提供一种以符号形式使用地址的方法。因为计算机的硬件指令非常依赖地址，指针在某种程度上把程序员想要传达的指令以更接近机器的方式表达。因此，使用指针的程序更有效率。尤其是，指针能有效地处理数组。我们很快就会学到，数组表示法其实是在变相地使用指针。</p>\n<p>我们举一个变相使用指针的例子：<mark><strong>数组名是数组首元素的地址</strong></mark>。也就是说，如果<code>flizny</code>是一个数组，下面的语句成立：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">flizny == &amp;flizny[<span class=\"number\">0</span>]; <span class=\"comment\">// 数组名是该数组首元素的地址</span></span><br></pre></td></tr></table></figure><p><code>flizny</code> 和<code>&amp;flizny[0]</code>都表示数组首元素的内存地址（<code>&amp;</code>是地址运算符）。两者都是常量，在程序的运行过程中，不会改变。但是，可以把它们赋值给指针变量，然后可以修改指针变量的值，如程序清单10.8所示。注意指针加上一个数时，它的值发生了什么变化（<strong>转换说明<code>%p</code>通常以十六进制显示指针的值</strong>）。</p>\n<p>程序清单10.8 pnt_add.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// pnt_add.c -- 指针地址</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　4</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    short dates[SIZE];</span><br><span class=\"line\">    short * pti;</span><br><span class=\"line\">    short index;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> bills[SIZE];</span><br><span class=\"line\">    <span class=\"keyword\">double</span> * ptf;</span><br><span class=\"line\">    pti = dates;　<span class=\"comment\">// 把数组地址赋给指针</span></span><br><span class=\"line\">    ptf　=　bills;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%23s　%15s\\n\"</span>,　<span class=\"string\">\"short\"</span>,　<span class=\"string\">\"double\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(index　=　<span class=\"number\">0</span>;　index　&lt;　SIZE;　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"pointers　+　%d:　%10p　%10p\\n\"</span>,　index,　pti　+　index,　ptf　+　index);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该例的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">short　　　　　　　　<span class=\"keyword\">double</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">0</span>:　<span class=\"number\">0x7fff5fbff8dc</span>　<span class=\"number\">0x7fff5fbff8a0</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">1</span>:　<span class=\"number\">0x7fff5fbff8de</span>　<span class=\"number\">0x7fff5fbff8a8</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">2</span>:　<span class=\"number\">0x7fff5fbff8e0</span>　<span class=\"number\">0x7fff5fbff8b0</span></span><br><span class=\"line\">pointers　+　<span class=\"number\">3</span>:　<span class=\"number\">0x7fff5fbff8e2</span>　<span class=\"number\">0x7fff5fbff8b8</span></span><br></pre></td></tr></table></figure><p>第2行打印的是两个数组开始的地址，下一行打印的是指针加1后的地址，以此类推。注意，地址是十六进制的，因此<code>dd</code>比<code>dc</code>大1，<code>a1</code>比<code>a0</code>大1。但是，显示的地址是怎么回事？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">0x7fff5fbff8dc</span> + <span class=\"number\">1</span>是否是<span class=\"number\">0x7fff5fbff8de</span>?</span><br><span class=\"line\"><span class=\"number\">0x7fff5fbff8a0</span> + <span class=\"number\">1</span>是否是<span class=\"number\">0x7fff5fbff8a8</span>?</span><br></pre></td></tr></table></figure><p>我们的系统中，地址按字节编址，<code>short</code>类型占用<strong>2字节</strong>，<code>double</code>类型占用<strong>8字节</strong>。<mark><strong>在C中，指针加1指的是增加一个存储单元。对数组而言，这意味着把加1后的地址是下一个元素的地址，而不是下一个字节的地址</strong></mark>（见图10.3）。这是为什么必须声明指针所指向对象类型的原因之一。只知道地址不够，因为计算机要知道储存对象需要多少字节（即使<strong>指针指向的是标量变量，也要知道变量的类型，否则*pt 就无法正确地取回地址上的值</strong>）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/数组和指针加法.png\" class=\"φcy\"></p>\n<p>现在可以更清楚地定义指向<code>int</code>的指针、指向<code>float</code>的指针，以及指向其他数据对象的指针。</p>\n<p>指针的值是它所指向对象的地址。地址的表示方式依赖于计算机内部的硬件。许多计算机（包括PC和Macintosh）都是按字节编址，意思是内存中的每个字节都按顺序编号。这里，一个较大对象的地址（如<code>double</code>类型的变量）通常是该对象第一个字节的地址。</p>\n<p>在指针前面使用<code>*</code>运算符可以得到该指针所指向对象的值。</p>\n<p><strong>指针加1，指针的值递增它所指向类型的大小（以字节为单位）</strong>。</p>\n<p>下面的等式体现了C语言的灵活性：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dates + <span class=\"number\">2</span> == &amp;date[<span class=\"number\">2</span>]　　　 <span class=\"comment\">// 相同的地址</span></span><br><span class=\"line\"></span><br><span class=\"line\">*(dates + <span class=\"number\">2</span>) == dates[<span class=\"number\">2</span>]　 <span class=\"comment\">// 相同的值</span></span><br></pre></td></tr></table></figure><p>以上关系表明了数组和指针的关系十分密切，可以使用指针标识数组的元素和获得元素的值。从本质上看，同一个对象有两种表示法。实际上，C 语言标准在描述数组表示法时确实借助了指针。也就是说，定义<code>ar[n]</code>的意思是<code>*(ar + n)</code>。可以认为<code>*(ar + n)</code>的意思是“<strong>到内存的ar位置，然后移动n个单元，检索储存在那里的值</strong>”。</p>\n<p>顺带一提，不要混淆 <code>*(dates+2)</code>和<code>*dates+2</code>。间接运算符<code>（*）</code>的优先级高于<code>+</code>，所以<code>*dates+2</code>相当于<code>(*dates)+2</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*(dates + <span class=\"number\">2</span>)　<span class=\"comment\">// dates第3个元素的值</span></span><br><span class=\"line\">*dates + <span class=\"number\">2</span>　　<span class=\"comment\">// dates第1个元素的值加2</span></span><br></pre></td></tr></table></figure><p>明白了数组和指针的关系，便可在编写程序时适时使用数组表示法或指针表示法。运行程序清单 10.9后输出的结果和程序清单10.1输出的结果相同。</p>\n<p>程序清单10.9 day_mon3.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* day_mon3.c -- uses pointer notation */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> days[MONTHS]　=　&#123;　<span class=\"number\">31</span>,　<span class=\"number\">28</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>,　<span class=\"number\">30</span>,　<span class=\"number\">31</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> index;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(index　=　<span class=\"number\">0</span>;　index　&lt;　MONTHS;　index++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Month　%2d　has　%d　days.\\n\"</span>,　index　+　<span class=\"number\">1</span>,</span><br><span class=\"line\">    *(days + index));　<span class=\"comment\">//与 days[index]相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里，<code>days</code>是数组首元素的地址，<code>days + index</code>是元素<code>days[index]</code>的地址，而<code>*(days + index)</code>则是该元素的值，相当于<code>days[index]</code>。<code>for</code>循环依次引用数组中的每个元素，并打印各元素的内容。</p>\n<p>这样编写程序是否有优势？不一定。编译器编译这两种写法生成的代码相同。程序清单 10.9 要注意的是，指针表示法和数组表示法是两种等效的方法。该例演示了可以用指针表示数组，反过来，也可以用数组表示指针。在使用以数组为参数的函数时要注意这点。</p>\n<h2 id=\"函数、数组和指针\">函数、数组和指针<a href=\"#函数、数组和指针\" title=\"函数、数组和指针\"></a></h2><p>假设要编写一个处理数组的函数，该函数返回数组中所有元素之和，待处理的是名为<code>marbles</code>的<code>int</code>类型数组。应该如何调用该函数？也许是下面这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total = sum(marbles); <span class=\"comment\">// 可能的函数调用</span></span><br></pre></td></tr></table></figure><p>那么，该函数的原型是什么？记住，数组名是该数组首元素的地址，所以实际参数<code>marbles</code>是一个储存<code>int</code>类型值的地址，应把它赋给一个指针形式参数，即该形参是一个指向<code>int</code>的指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar)</span></span>; <span class=\"comment\">// 对应的函数原型</span></span><br></pre></td></tr></table></figure><p><code>sum()</code>从该参数获得了什么信息？它获得了该数组首元素的地址，知道要在该位置上找出一个整数。注意，该参数并未包含数组元素个数的信息。我们有两种方法让函数获得这一信息。第一种方法是，在函数代码中写上固定的数组大小：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar)</span> <span class=\"comment\">// 相应的函数定义</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">10</span>; i++)　　<span class=\"comment\">// 假设数组有10个元素</span></span><br><span class=\"line\">    \ttotal += ar[i];　　　　<span class=\"comment\">// ar[i] 与 *(ar + i) 相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>既然能使用指针表示数组名，也可以用数组名表示指针。另外，回忆一下，<code>+=</code>运算符把右侧运算对象加到左侧运算对象上。因此，<code>total</code>是当前数组元素之和。</p>\n<p>该函数定义有限制，只能计算10个<code>int</code>类型的元素。另一个比较灵活的方法是把数组大小作为第2个参数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar,<span class=\"keyword\">int</span> n)</span>　　　 <span class=\"comment\">// 更通用的方法</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; n; i++)　　 <span class=\"comment\">// 使用 n 个元素</span></span><br><span class=\"line\">    total += ar[i];　　　　<span class=\"comment\">// ar[i] 和 *(ar + i) 相同</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这里，第1个形参告诉函数该数组的地址和数据类型，第2个形参告诉函数该数组中元素的个数。</p>\n<p>关于函数的形参，还有一点要注意。<strong>只有在<code>函数原型</code>或<code>函数定义头</code>中，才可以用<code>int ar[]</code>代替<code>int * ar</code></strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span> <span class=\"params\">(<span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p><code>int *ar</code>形式和<code>int ar[]</code>形式都表示<code>ar</code>是一个指向<code>int</code>的指针。但是，<code>int ar[]</code>只能用于声明形式参数。第2种形式（<code>int ar[]</code>）提醒读者指针<code>ar</code>指向的不仅仅一个<code>int</code>类型值，还是一个<code>int</code>类型数组的元素。</p>\n<p>注意 声明数组形参</p>\n<p>因为数组名是该数组首元素的地址，作为实际参数的数组名要求形式参数是一个与之匹配的指针。只有在这种情况下，C才会把<code>int ar[]</code>和<code>int * ar</code>解释成一样。也就是说，ar是指向<code>int</code>的指针。由于函数原型可以省略参数名，所以下面4种原型都是等价的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar, <span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>　[],　<span class=\"keyword\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>但是，在函数定义中不能省略参数名。下面两种形式的函数定义等价：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> *ar, <span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 其他代码已省略</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[],　<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//其他代码已省略</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>可以使用以上提到的任意一种函数原型和函数定义。</p>\n<p>程序清单 10.10 演示了一个程序，使用 <code>sum()</code>函数。该程序打印原始数组的大小和表示该数组的函数形参的大小（如果你的编译器不支持用转换说明<code>%zd</code>打印<code>sizeof</code>返回值，可以用<code>%u</code>或<code>%lu</code>来代替）。</p>\n<p>程序清单10.10 sum_arr1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// sum_arr1.c -- 数组元素之和</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 如果编译器不支持 %zd，用 %u 或 %lu 替换它</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> marbles[SIZE]　=　&#123;　<span class=\"number\">20</span>,　<span class=\"number\">10</span>,　<span class=\"number\">5</span>,　<span class=\"number\">39</span>,　<span class=\"number\">4</span>,　<span class=\"number\">16</span>,　<span class=\"number\">19</span>,　<span class=\"number\">26</span>,　<span class=\"number\">31</span>,　<span class=\"number\">20</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> answer;</span><br><span class=\"line\">    answer　=　sum(marbles,　SIZE);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　total　number　of　marbles　is　%ld.\\n\"</span>,　answer);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　size　of　marbles　is　%zd　bytes.\\n\"</span>,</span><br><span class=\"line\">    <span class=\"keyword\">sizeof</span>　marbles);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span>　　 <span class=\"comment\">// 这个数组的大小是？</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \ttotal　+=　ar[i];</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　size　of　ar　is　%zd　bytes.\\n\"</span>,　<span class=\"keyword\">sizeof</span>　ar);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The　<span class=\"built_in\">size</span>　of　ar　is　<span class=\"number\">8</span>　bytes.</span><br><span class=\"line\">The　total　number　of　marbles　is　<span class=\"number\">190.</span></span><br><span class=\"line\">The　<span class=\"built_in\">size</span>　of　marbles　is　<span class=\"number\">40</span>　bytes.</span><br></pre></td></tr></table></figure><p>注意，<code>marbles</code>的大小是40字节。这没问题，因为<code>marbles</code>内含10个<code>int</code>类型的值，每个值占4字节，所以整个<code>marbles</code>的大小是40字节。但是，<code>ar</code>才8字节。这是因为<code>ar</code>并不是数组本身，它是一个指向 <code>marbles</code> 数组首元素的指针。我们的系统中用 8 字节储存地址，所以指针变量的大小是 8字节（其他系统中地址的大小可能不是8字节）。简而言之，在程序清单10.10中，<code>marbles</code>是一个数组， <code>ar</code>是一个指向<code>marbles</code>数组首元素的指针，利用C中数组和指针的特殊关系，可以用数组表示法来表示指针<code>ar</code>。</p>\n<h3 id=\"使用指针形参\">使用指针形参<a href=\"#使用指针形参\" title=\"使用指针形参\"></a></h3><p>函数要处理数组必须知道何时开始、何时结束。<code>sum()</code>函数使用一个指针形参标识数组的开始，用一个整数形参表明待处理数组的元素个数（指针形参也表明了数组中的数据类型）。但是这并不是给函数传递必备信息的唯一方法。还有一种方法是传递两个指针，第1个指针指明数组的开始处（与前面用法相同），第2个指针指明数组的结束处。程序清单10.11演示了这种方法，同时该程序也表明了指针形参是变量，这意味着可以用索引表明访问数组中的哪一个元素。</p>\n<p>程序清单10.11 sum_arr2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* sum_arr2.c -- 数组元素之和 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　10</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sump</span><span class=\"params\">(<span class=\"keyword\">int</span> *start, <span class=\"keyword\">int</span> *<span class=\"built_in\">end</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> marbles[SIZE]　=　&#123;　<span class=\"number\">20</span>,　<span class=\"number\">10</span>,　<span class=\"number\">5</span>,　<span class=\"number\">39</span>,　<span class=\"number\">4</span>,　<span class=\"number\">16</span>,　<span class=\"number\">19</span>,　<span class=\"number\">26</span>,　<span class=\"number\">31</span>,　<span class=\"number\">20</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> answer;</span><br><span class=\"line\">    answer　=　sump(marbles,　marbles　+　SIZE);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　total　number　of　marbles　is　%ld.\\n\"</span>,　answer);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 使用指针算法 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sump</span><span class=\"params\">(<span class=\"keyword\">int</span> * start, <span class=\"keyword\">int</span> * <span class=\"built_in\">end</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(start　&lt;　<span class=\"built_in\">end</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        total += *start;　 <span class=\"comment\">// 把数组元素的值加起来</span></span><br><span class=\"line\">        start++;　　　　　　<span class=\"comment\">// 让指针指向下一个元素</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>指针<code>start</code>开始指向<code>marbles</code>数组的首元素，所以赋值表达式<code>total += *start</code>把首元素（20）加给<code>total</code>。然后，表达式<code>start++</code>递增指针变量<code>start</code>，使其指向数组的下一个元素。因为<code>start</code>是指向<code>int</code>的指针，<code>start</code>递增1相当于其值递增<code>int</code>类型的大小。</p>\n<p>注意，<code>sump()</code>函数用另一种方法结束加法循环。<code>sum()</code>函数把元素的个数作为第2个参数，并把该参数作为循环测试的一部分：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span>( i = <span class=\"number\">0</span>; i &lt; n; i++)</span><br></pre></td></tr></table></figure><p>而<code>sump()</code>函数则使用第2个指针来结束循环：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span> (start &lt; <span class=\"built_in\">end</span>)</span><br></pre></td></tr></table></figure><p>因为<code>while</code>循环的测试条件是一个不相等的关系，所以循环最后处理的一个元素是<code>end</code>所指向位置的前一个元素。这意味着<code>end</code>指向的位置实际上在数组最后一个元素的后面。C保证在给数组分配空间时，指向数组后面第一个位置的指针仍是有效的指针。这使得 <code>while</code>循环的测试条件是有效的，因为 <code>start</code>在循环中最后的值是<code>end</code>。注意，使用这种“越界”指针的函数调用更为简洁：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = sump(marbles, marbles + SIZE);</span><br></pre></td></tr></table></figure><p>因为下标从0开始，所以<code>marbles + SIZE</code>指向数组末尾的下一个位置。如果<code>end</code>指向数组的最后一个元素而不是数组末尾的下一个位置，则必须使用下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = sump(marbles, marbles + SIZE - <span class=\"number\">1</span>);</span><br></pre></td></tr></table></figure><p>这种写法既不简洁也不好记，很容易导致编程错误。顺带一提，虽然C保证了<code>marbles + SIZE</code>有效，但是对<code>marbles[SIZE]</code>（即储存在该位置上的值）未作任何保证，所以程序不能访问该位置。</p>\n<p>还可以把循环体压缩成一行代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">total += *start++;</span><br></pre></td></tr></table></figure><p>一元运算符<code>*</code>和<code>++</code>的优先级相同，但结合律是从右往左，所以<code>start++</code>先求值，然后才是<code>*start</code>。也就是说，指针start先递增后指向。使用后缀形式（即<code>start++</code>而不是<code>++start</code>）意味着先把指针指向位置上的值加到<code>total</code>上，然后再递增指针。如果使用<code>*++start</code>，顺序则反过来，先递增指针，再使用指针指向位置上的值。如果使用<code>(*start)++</code>，则先使用<code>start</code>指向的值，再递增该值，而不是递增指针。这样，指针将一直指向同一个位置，但是该位置上的值发生了变化。虽然<code>*start++</code>的写法比较常用，但是<code>*(start++)</code>这样写更清楚。程序清单10.12的程序演示了这些优先级的情况。</p>\n<p>程序清单10.12 order.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* order.c -- 指针运算中的优先级 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">int</span> data[<span class=\"number\">2</span>]　=　&#123;　<span class=\"number\">100</span>,　<span class=\"number\">200</span>　&#125;;</span><br><span class=\"line\"><span class=\"keyword\">int</span> moredata[<span class=\"number\">2</span>]　=　&#123;　<span class=\"number\">300</span>,　<span class=\"number\">400</span>　&#125;;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> * p1, *p2, *p3;</span><br><span class=\"line\">    p1　=　p2　=　data;</span><br><span class=\"line\">    p3　=　moredata;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\"</span>,*p1, *p2, *p3);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"*p1++ = %d, *++p2 = %d, (*p3)++ = %d\\n\"</span>,*p1++, *++p2, (*p3)++);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"　*p1 = %d,　 *p2 = %d,　　*p3 = %d\\n\"</span>,*p1, *p2, *p3);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*p1 = <span class=\"number\">100</span>,　 *p2 = <span class=\"number\">100</span>,　　　*p3 = <span class=\"number\">300</span></span><br><span class=\"line\">*p1++ = <span class=\"number\">100</span>, *++p2 = <span class=\"number\">200</span>,　(*p3)++ = <span class=\"number\">300</span></span><br><span class=\"line\">*p1 = <span class=\"number\">200</span>,　 *p2 = <span class=\"number\">200</span>,　　　*p3 = <span class=\"number\">301</span></span><br></pre></td></tr></table></figure><p>只有<code>(*p3)++</code>改变了数组元素的值，其他两个操作分别把p1和p2指向数组的下一个元素。</p>\n<h3 id=\"指针表示法和数组表示法\">指针表示法和数组表示法<a href=\"#指针表示法和数组表示法\" title=\"指针表示法和数组表示法\"></a></h3><p>从以上分析可知，处理数组的函数实际上用指针作为参数，但是在编写这样的函数时，可以选择是使用数组表示法还是指针表示法。如程序清单10.10所示，使用数组表示法，让函数是处理数组的这一意图更加明显。另外，许多其他语言的程序员对数组表示法更熟悉，如FORTRAN、Pascal、Modula-2或BASIC。其他程序员可能更习惯使用指针表示法，觉得使用指针更自然，如程序清单10.11所示。</p>\n<p>至于C语言，<code>ar[i]</code>和<code>*(ar+1)</code>这两个表达式都是等价的。无论ar是数组名还是指针变量，这两个表达式都没问题。但是，只有当ar是指针变量时，才能使用<code>ar++</code>这样的表达式。</p>\n<p>指针表示法（尤其与递增运算符一起使用时）更接近机器语言，因此一些编译器在编译时能生成效率更高的代码。然而，许多程序员认为他们的主要任务是确保代码正确、逻辑清晰，而代码优化应该留给编译器去做。</p>\n<h2 id=\"指针操作\">指针操作<a href=\"#指针操作\" title=\"指针操作\"></a></h2><p>可以对指针进行哪些操作？C提供了一些基本的指针操作，下面的程序示例中演示了8种不同的操作。为了显示每种操作的结果，该程序打印了指针的值（该指针指向的地址）、储存在指针指向地址上的值，以及指针自己的地址。如果编译器不支持<code>%p</code> 转换说明，可以用<code>%u</code> 或<code>%lu</code> 代替<code>%p</code>；如果编译器不支持用<code>%td</code>转换说明打印地址的差值，可以用<code>%d</code>或<code>%ld</code>来代替。</p>\n<p>程序清单10.13演示了指针变量的 8种基本操作。除了这些操作，还可以使用关系运算符来比较指针。</p>\n<p>程序清单10.13 ptr_ops.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// ptr_ops.c -- 指针操作</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　urn[<span class=\"number\">5</span>]　=　&#123;　<span class=\"number\">100</span>,　<span class=\"number\">200</span>,　<span class=\"number\">300</span>,　<span class=\"number\">400</span>,　<span class=\"number\">500</span>　&#125;;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> *ptr1,*ptr2,*ptr3;</span><br><span class=\"line\">    ptr1 = urn;　　　　　　　<span class=\"comment\">// 把一个地址赋给指针</span></span><br><span class=\"line\">    ptr2 = &amp;urn[<span class=\"number\">2</span>];　　　　 <span class=\"comment\">// 把一个地址赋给指针</span></span><br><span class=\"line\">    <span class=\"comment\">// 解引用指针，以及获得指针的地址</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"pointer　value,　dereferenced　pointer,　pointer　address:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class=\"line\">    <span class=\"comment\">// 指针加法</span></span><br><span class=\"line\">    ptr3　=　ptr1　+　<span class=\"number\">4</span>;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nadding　an　int　to　a　pointer:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1 + 4 = %p, *(ptr1 + 4) = %d\\n\"</span>, ptr1 + <span class=\"number\">4</span>, *(ptr1 + <span class=\"number\">4</span>));</span><br><span class=\"line\">    ptr1++;　　　　　　　　　<span class=\"comment\">// 递增指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nvalues　after　ptr1++:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1 = %p, *ptr1 =%d, &amp;ptr1 = %p\\n\"</span>, ptr1, *ptr1, &amp;ptr1);</span><br><span class=\"line\">    ptr2--;　　　　　　　　　<span class=\"comment\">// 递减指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nvalues　after　--ptr2:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr2 = %p, *ptr2 = %d, &amp;ptr2 = %p\\n\"</span>, ptr2, *ptr2, &amp;ptr2);</span><br><span class=\"line\">    --ptr1;　　　　　　　　　<span class=\"comment\">// 恢复为初始值</span></span><br><span class=\"line\">    ++ptr2;　　　　　　　　　<span class=\"comment\">// 恢复为初始值</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nPointers　reset　to　original　values:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr1　=　%p,　ptr2　=　%p\\n\"</span>,　ptr1,　ptr2);</span><br><span class=\"line\">    <span class=\"comment\">// 一个指针减去另一个指针</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nsubtracting　one　pointer　from　another:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr2　=　%p,　ptr1　=　%p,　ptr2　-　ptr1　=　%td\\n\"</span>,　ptr2,　ptr1,　ptr2　-　ptr1);</span><br><span class=\"line\">    <span class=\"comment\">// 一个指针减去一个整数</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\nsubtracting　an　int　from　a　pointer:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"ptr3　=　%p,　ptr3　-　2　=　%p\\n\"</span>,　ptr3,　ptr3　-　<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是我们的系统运行该程序后的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pointer value, dereferenced pointer, pointer address:</span><br><span class=\"line\">ptr1 = <span class=\"number\">0x7fff5fbff8d0</span>, *ptr1 =<span class=\"number\">100</span>, &amp;ptr1 = <span class=\"number\">0x7fff5fbff8c8</span></span><br><span class=\"line\">adding an <span class=\"keyword\">int</span> to a pointer:</span><br><span class=\"line\">ptr1 + <span class=\"number\">4</span> = <span class=\"number\">0x7fff5fbff8e0</span>, *(ptr1 + <span class=\"number\">4</span>) = <span class=\"number\">500</span></span><br><span class=\"line\">values after ptr1++:</span><br><span class=\"line\">ptr1 = <span class=\"number\">0x7fff5fbff8d4</span>, *ptr1 =<span class=\"number\">200</span>, &amp;ptr1 = <span class=\"number\">0x7fff5fbff8c8</span></span><br><span class=\"line\">values after --ptr2:</span><br><span class=\"line\">ptr2 = <span class=\"number\">0x7fff5fbff8d4</span>, *ptr2 = <span class=\"number\">200</span>, &amp;ptr2 = <span class=\"number\">0x7fff5fbff8c0</span></span><br><span class=\"line\">Pointers reset to original values:</span><br><span class=\"line\">ptr1 = <span class=\"number\">0x7fff5fbff8d0</span>, ptr2 = <span class=\"number\">0x7fff5fbff8d8</span></span><br><span class=\"line\">subtracting one pointer from another:</span><br><span class=\"line\">ptr2 = <span class=\"number\">0x7fff5fbff8d8</span>, ptr1 = <span class=\"number\">0x7fff5fbff8d0</span>, ptr2 - ptr1 = <span class=\"number\">2</span></span><br><span class=\"line\">subtracting an <span class=\"keyword\">int</span> from a pointer:</span><br><span class=\"line\">ptr3 = <span class=\"number\">0x7fff5fbff8e0</span>, ptr3 - <span class=\"number\">2</span> = <span class=\"number\">0x7fff5fbff8d8</span></span><br></pre></td></tr></table></figure><p>下面分别描述了指针变量的基本操作。</p>\n<p><strong>赋值</strong>：可以把地址赋给指针。例如，用数组名、带地址运算符（<code>&amp;</code>）的变量名、另一个指针进行赋值。在该例中，把urn数组的首地址赋给了ptr1，该地址的编号恰好是0x7fff5fbff8d0。变量ptr2获得数组urn的第3个元素（urn[2]）的地址。注意，地址应该和指针类型兼容。也就是说，不能把<code>double</code>类型的地址赋给指向<code>int</code>的指针，至少要避免不明智的类型转换。C99/C11已经强制不允许这样做。</p>\n<p><strong>解引用</strong>：<code>*</code>运算符给出指针指向地址上储存的值。因此，<code>*ptr1</code>的初值是100，该值储存在编号为0x7fff5fbff8d0的地址上。</p>\n<p><strong>取址</strong>：和所有变量一样，指针变量也有自己的地址和值。对指针而言，<code>&amp;</code>运算符给出指针本身的地址。本例中，<code>ptr1</code> 储存在内存编号为 0x7fff5fbff8c8 的地址上，该存储单元储存的内容是0x7fff5fbff8d0，即<code>urn</code>的地址。因此<code>&amp;ptr1</code>是指向<code>ptr1</code>的指针，而<code>ptr1</code>是指向<code>utn[0]</code>的指针。</p>\n<p><strong>指针与整数相加</strong>：可以使用<code>+</code>运算符把指针与整数相加，或整数与指针相加。无论哪种情况，整数都会和指针所指向类型的大小（以字节为单位）相乘，然后把结果与初始地址相加。因此<code>ptr1 +4</code>与<code>&amp;urn[4]</code>等价。如果相加的结果超出了初始指针指向的数组范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</p>\n<p><strong>递增指针</strong>：递增指向数组元素的指针可以让该指针移动至数组的下一个元素。因此，<code>ptr1++</code>相当于把<code>ptr1</code>的值加上4（我们的系统中<code>int</code>为4字节），<code>ptr1</code>指向<code>urn[1]</code>（见图10.4，该图中使用了简化的地址）。现在<code>ptr1</code>的值是0x7fff5fbff8d4（数组的下一个元素的地址），<code>*ptr</code>的值为200（即urn[1]的值）。注意，<code>ptr1</code>本身的地址仍是 0x7fff5fbff8c8。毕竟，变量不会因为值发生变化就移动位置。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/递增指向int的指针.png\" class=\"φcy\"></p>\n<p><strong>指针减去一个整数</strong>：可以使用-运算符从一个指针中减去一个整数。指针必须是第1个运算对象，整数是第 2 个运算对象。该整数将乘以指针指向类型的大小（以字节为单位），然后用初始地址减去乘积。所以<code>ptr3 - 2</code>与<code>&amp;urn[2]</code>等价，因为<code>ptr3</code>指向的是<code>&amp;arn[4]</code>。如果相减的结果超出了初始指针所指向数组的范围，计算结果则是未定义的。除非正好超过数组末尾第一个位置，C保证该指针有效。</p>\n<p><strong>递减指针</strong>：当然，除了递增指针还可以递减</p>\n<p><strong>递减指针</strong>：当然，除了递增指针还可以递减指针。在本例中，递减ptr3使其指向数组的第2个元素而不是第3个元素。前缀或后缀的递增和递减运算符都可以使用。注意，在重置ptr1和ptr2前，它们都指向相同的元素<code>urn[1]</code>。</p>\n<p><strong>指针求差</strong>：可以计算两个指针的差值。通常，求差的两个指针分别指向同一个数组的不同元素，通过计算求出两元素之间的距离。差值的单位与数组类型的单位相同。例如，程序清单10.13的输出中，<code>ptr2 - ptr1</code>得2，意思是这两个指针所指向的两个元素相隔两个<code>int</code>，而不是2字节。只要两个指针都指向相同的数组（或者其中一个指针指向数组后面的第 1 个地址），C 都能保证相减运算有效。如果指向两个不同数组的指针进行求差运算可能会得出一个值，或者导致运行时错误。</p>\n<p><strong>比较</strong>：使用关系运算符可以比较两个指针的值，前提是两个指针都指向相同类型的对象。</p>\n<p>注意，这里的减法有两种。可以用一个指针减去另一个指针得到一个整数，或者用一个指针减去一个整数得到另一个指针。</p>\n<p>在递增或递减指针时还要注意一些问题。编译器不会检查指针是否仍指向数组元素。C 只能保证指向数组任意元素的指针和指向数组后面第 1 个位置的指针有效。但是，如果递增或递减一个指针后超出了这个范围，则是未定义的。另外，可以解引用指向数组任意元素的指针。但是，即使指针指向数组后面一个位置是有效的，也能解引用这样的越界指针。</p>\n<p>解引用未初始化的指针</p>\n<p>说到注意事项，一定要牢记一点：<mark><strong>千万不要解引用未初始化的指针</strong></mark>。例如，考虑下面的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> *pt;<span class=\"comment\">// 未初始化的指针</span></span><br><span class=\"line\">*pt = <span class=\"number\">5</span>;　　　<span class=\"comment\">// 严重的错误</span></span><br></pre></td></tr></table></figure><p>为何不行？第2行的意思是把5储存在pt指向的位置。但是<code>pt</code>未被初始化，其值是一个随机值，所以不知道5将储存在何处。这可能不会出什么错，也可能会擦写数据或代码，或者导致程序崩溃。切记：创建一个指针时，系统只分配了储存指针本身的内存，并未分配储存数据的内存。因此，在使用指针之前，必须先用已分配的地址初始化它。例如，可以用一个现有变量的地址初始化该指针（使用带指针形参的函数时，就属于这种情况）。或者还可以使用第12章将介绍的<code>malloc()</code>函数先分配内存。无论如何，使用指针时一定要注意，不要解引用未初始化的指针！</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> *pd;　<span class=\"comment\">// 未初始化的指针</span></span><br><span class=\"line\">*pd =<span class=\"number\">2.4</span>;　　<span class=\"comment\">// 不要这样做</span></span><br><span class=\"line\">假设</span><br><span class=\"line\"><span class=\"keyword\">int</span> urn[<span class=\"number\">3</span>];</span><br><span class=\"line\"><span class=\"keyword\">int</span> *ptr1,*ptr2;</span><br></pre></td></tr></table></figure><p>下面是一些有效和无效的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">有效语句　　　　　　　　　　\t   无效语句</span><br><span class=\"line\">ptr1++;　　　　　　　　　　　　  urn++;</span><br><span class=\"line\">ptr2　=　ptr1　+　<span class=\"number\">2</span>;　　　　　  ptr2　=　ptr2　+　ptr1;</span><br><span class=\"line\">ptr2　=　urn　+　<span class=\"number\">1</span>;　　　　　　 ptr2　=　urn　*　ptr1;</span><br></pre></td></tr></table></figure><p>基于这些有效的操作，C 程序员创建了指针数组、函数指针、指向指针的指针数组、指向函数的指针数组等。别紧张，接下来我们将根据已学的内容介绍指针的一些基本用法。指针的第 1 个基本用法是在函数间传递信息。前面学过，<strong>如果希望在被调函数中改变主调函数的变量，必须使用指针</strong>。指针的第 2 个基本用法是用在处理数组的函数中。下面我们再来看一个使用函数和数组的编程示例。</p>\n<h2 id=\"保护数组中的数据\">保护数组中的数据<a href=\"#保护数组中的数据\" title=\"保护数组中的数据\"></a></h2><p>编写一个处理基本类型（如，<code>int</code>）的函数时，要选择是传递<code>int</code>类型的值还是传递指向<code>int</code>的指针。通常都是直接传递数值，只有程序需要在函数中改变该数值时，才会传递指针。对于数组别无选择，必须传递指针，因为这样做效率高。如果一个函数按值传递数组，则必须分配足够的空间来储存原数组的副本，然后把原数组所有的数据拷贝至新的数组中。如果把数组的地址传递给函数，让函数直接处理原数组则效率要高。</p>\n<p>传递地址会导致一些问题。C 通常都按值传递数据，因为这样做可以保证数据的完整性。如果函数使用的是原始数据的副本，就不会意外修改原始数据。但是，处理数组的函数通常都需要使用原始数据，因此这样的函数可以修改原数组。有时，这正是我们需要的。例如，下面的函数给数组的每个元素都加上一个相同的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add_to</span><span class=\"params\">(<span class=\"keyword\">double</span> ar[],<span class=\"keyword\">int</span> n,<span class=\"keyword\">double</span> val)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    \tar[i]+=val;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>因此，调用该函数后，<code>prices</code>数组中的每个元素的值都增加了2.5：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">add_to(prices, <span class=\"number\">100</span>, <span class=\"number\">2.50</span>);</span><br></pre></td></tr></table></figure><p>该函数修改了数组中的数据。之所以可以这样做，是因为函数通过指针直接使用了原始数据。</p>\n<p>然而，其他函数并不需要修改数据。例如，下面的函数计算数组中所有元素之和，它不用改变数组的数据。但是，由于ar实际上是一个指针，所以编程错误可能会破坏原始数据。例如，下面示例中的<code>ar[i]++</code>会导致数组中每个元素的值都加1：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">// 错误的代码</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total=<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i=<span class=\"number\">0</span>;i&lt;n;i++)</span><br><span class=\"line\">    \ttotal += ar[i]++;　<span class=\"comment\">// 错误递增了每个元素的值</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"对形式参数使用const\">对形式参数使用const<a href=\"#对形式参数使用const\" title=\"对形式参数使用const\"></a></h3><p>在K&amp;R C的年代，避免类似错误的唯一方法是提高警惕。ANSI C提供了一种预防手段。如果函数的意图不是修改数组中的数据内容，那么在函数原型和函数定义中声明形式参数时应使用关键字<code>const</code>。例如，<code>sum()</code>函数的原型和定义如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span></span>; <span class=\"comment\">/* 函数原型 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">sum</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">int</span> ar[], <span class=\"keyword\">int</span> n)</span> <span class=\"comment\">/* 函数定义 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> total　=　<span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(　i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \ttotal　+=　ar[i];</span><br><span class=\"line\">    <span class=\"keyword\">return</span> total;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>以上代码中的<code>const</code>告诉编译器，该函数不能修改ar指向的数组中的内容。如果在函数中不小心使用类似<code>ar[i]++</code>的表达式，编译器会捕获这个错误，并生成一条错误信息。</p>\n<p>这里一定要理解，这样使用<code>const</code>并不是要求原数组是常量，而是该函数在处理数组时将其视为常量，不可更改。这样使用<code>const</code>可以保护数组的数据不被修改，就像按值传递可以保护基本数据类型的原始值不被改变一样。一般而言，如果编写的函数需要修改数组，在声明数组形参时则不使用<code>const</code>；如果编写的函数不用修改数组，那么在声明数组形参时最好使用<code>const</code>。</p>\n<p>程序清单10.14的程序中，一个函数显示数组的内容，另一个函数给数组每个元素都乘以一个给定值。因为第1个函数不用改变数组，所以在声明数组形参时使用了<code>const</code>；而第2个函数需要修改数组元素的值，所以不使用<code>const</code>。</p>\n<p>程序清单10.14 arf.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* arf.c -- 处理数组的函数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　5</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_array</span><span class=\"params\">(<span class=\"keyword\">const</span>　<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mult_array</span><span class=\"params\">(<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n,　<span class=\"keyword\">double</span>　mult)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> dip[SIZE]　=　&#123;　<span class=\"number\">20.0</span>,　<span class=\"number\">17.66</span>,　<span class=\"number\">8.2</span>,　<span class=\"number\">15.3</span>,　<span class=\"number\">22.22</span>　&#125;;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　original　dip　array:\\n\"</span>);</span><br><span class=\"line\">    show_array(dip,　SIZE);</span><br><span class=\"line\">    mult_array(dip,　SIZE,　<span class=\"number\">2.5</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　dip　array　after　calling　mult_array():\\n\"</span>);</span><br><span class=\"line\">    show_array(dip,　SIZE);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 显示数组的内容 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_array</span><span class=\"params\">(<span class=\"keyword\">const</span>　<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"%8.3f　\"</span>,　ar[i]);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* 把数组的每个元素都乘以相同的值 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">mult_array</span><span class=\"params\">(<span class=\"keyword\">double</span>　ar[],　<span class=\"keyword\">int</span>　n,　<span class=\"keyword\">double</span>　mult)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> i;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(i　=　<span class=\"number\">0</span>;　i　&lt;　n;　i++)</span><br><span class=\"line\">    \tar[i] *= mult;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是该程序的输出：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The　original　dip　<span class=\"built_in\">array</span>:</span><br><span class=\"line\"><span class=\"number\">20.000</span>　　<span class=\"number\">17.660</span>　　　<span class=\"number\">8.200</span>　　　<span class=\"number\">15.300</span>　　<span class=\"number\">22.220</span></span><br><span class=\"line\"><span class=\"function\">The　dip　<span class=\"built_in\">array</span>　after　calling　<span class=\"title\">mult_array</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\">50.000　　44.150　　　20.500　　38.250　　55.550</span><br></pre></td></tr></table></figure><p>注意该程序中两个函数的返回类型都是<code>void</code>。虽然<code>mult_array()</code>函数更新了<code>dip</code>数组的值，但是并未使用<code>return</code>机制。</p>\n<h3 id=\"const的其他内容\">const的其他内容<a href=\"#const的其他内容\" title=\"const的其他内容\"></a></h3><p>我们在前面使用<code>const</code>创建过变量：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> PI = <span class=\"number\">3.14159</span>;</span><br></pre></td></tr></table></figure><p>虽然用<code>#define</code>指令可以创建类似功能的符号常量，但是<code>const</code>的用法更加灵活。可以创建<code>const</code>数组、<code>const</code>指针和指向<code>const</code>的指针。</p>\n<p>程序清单10.4演示了如何使用<code>const</code>关键字保护数组：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　MONTHS　12</span></span><br><span class=\"line\">...</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">int</span> days[MONTHS] =&#123;<span class=\"number\">31</span>,<span class=\"number\">28</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>,<span class=\"number\">30</span>,<span class=\"number\">31</span>&#125;;</span><br></pre></td></tr></table></figure><p>如果程序稍后尝试改变数组元素的值，编译器将生成一个编译期错误消息：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">days[<span class=\"number\">9</span>] = <span class=\"number\">44</span>;　　 <span class=\"comment\">/* 编译错误 */</span></span><br></pre></td></tr></table></figure><p>指向<code>const</code>的指针不能用于改变值。考虑下面的代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *pd = rates;　　 <span class=\"comment\">// pd指向数组的首元素</span></span><br></pre></td></tr></table></figure><p>第2行代码把pd指向的<code>double</code>类型的值声明为<code>const</code>，这表明不能使用pd来更改它所指向的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">*pd = <span class=\"number\">29.89</span>;　　　<span class=\"comment\">// 不允许</span></span><br><span class=\"line\">pd[<span class=\"number\">2</span>] = <span class=\"number\">222.22</span>;　　<span class=\"comment\">//不允许</span></span><br><span class=\"line\">rates[<span class=\"number\">0</span>] = <span class=\"number\">99.99</span>; <span class=\"comment\">// 允许，因为rates未被const限定</span></span><br></pre></td></tr></table></figure><p>无论是使用指针表示法还是数组表示法，都不允许使用pd修改它所指向数据的值。但是要注意，因为<code>rates</code>并未被声明为<code>const</code>，所以仍然可以通过<code>rates</code>修改元素的值。另外，可以让pd指向别处：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pd++; <span class=\"comment\">/* 让pd指向rates[1] -- 没问题 */</span></span><br></pre></td></tr></table></figure><p>指向 <code>const</code> 的指针通常用于函数形参中，表明该函数不会使用指针改变数据。例如，程序清单 10.14中的<code>show_array()</code>函数原型如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_array</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *ar, <span class=\"keyword\">int</span> n)</span></span>;</span><br></pre></td></tr></table></figure><p>关于指针赋值和<code>const</code>需要注意一些规则。首先，<strong>把<code>const</code>数据或非<code>const</code>数据的地址初始化为指向<code>const</code>的指针或为其赋值是合法的</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> locked[<span class=\"number\">4</span>]　=　&#123;<span class=\"number\">0.08</span>,　<span class=\"number\">0.075</span>,　<span class=\"number\">0.0725</span>,　<span class=\"number\">0.07</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> *pc = rates; <span class=\"comment\">// 有效</span></span><br><span class=\"line\">pc = locked;　　　　　　　　 <span class=\"comment\">//有效</span></span><br><span class=\"line\">pc = &amp;rates[<span class=\"number\">3</span>];　　　　　　　<span class=\"comment\">//有效</span></span><br></pre></td></tr></table></figure><p>然而，<strong>只能把非<code>const</code>数据的地址赋给普通指针</strong>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> locked[<span class=\"number\">4</span>]　=　&#123;<span class=\"number\">0.08</span>,　<span class=\"number\">0.075</span>,　<span class=\"number\">0.0725</span>,　<span class=\"number\">0.07</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *pnc = rates;　<span class=\"comment\">// 有效</span></span><br><span class=\"line\">pnc = locked;　　　　　 <span class=\"comment\">// 无效</span></span><br><span class=\"line\">pnc = &amp;rates[<span class=\"number\">3</span>];　　　　<span class=\"comment\">// 有效</span></span><br></pre></td></tr></table></figure><p>这个规则非常合理。否则，通过指针就能改变<code>const</code>数组中的数据。</p>\n<p>应用以上规则的例子，如 <code>show_array()</code>函数可以接受普通数组名和 <code>const</code> 数组名作为参数，因为这两种参数都可以用来初始化指向<code>const</code>的指针：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show_array(rates,<span class=\"number\">5</span>);　　　 <span class=\"comment\">// 有效</span></span><br><span class=\"line\">show_array(locked,<span class=\"number\">4</span>);　　　<span class=\"comment\">// 有效</span></span><br></pre></td></tr></table></figure><p>因此，对函数的形参使用<code>const</code>不仅能保护数据，还能让函数处理<code>const</code>数组。</p>\n<p>另外，不应该把<code>const</code>数组名作为实参传递给<code>mult_array()</code>这样的函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">mult_array(rates,<span class=\"number\">5</span>,<span class=\"number\">1.2</span>);　　　<span class=\"comment\">// 有效</span></span><br><span class=\"line\">mult_array(locked,<span class=\"number\">4</span>,<span class=\"number\">1.2</span>);　　 <span class=\"comment\">// 不要这样做</span></span><br></pre></td></tr></table></figure><p>C标准规定，使用非<code>const</code>标识符（如，<code>mult_arry()</code>的形参ar）修改<code>const</code>数据（如，<code>locked</code>）导致的结果是未定义的。</p>\n<blockquote>\n<p><code>const</code>还有其他的用法。</p>\n</blockquote>\n<ol><li><p>例如，可以声明并初始化一个不能指向别处的指针，关键是<code>const</code>的位置：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span> rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">double</span> *<span class=\"keyword\">const</span> pc = rates; <span class=\"comment\">// pc指向数组的开始</span></span><br><span class=\"line\">pc = &amp;rates[<span class=\"number\">2</span>];　　　　　　　<span class=\"comment\">// 不允许，因为该指针不能指向别处</span></span><br><span class=\"line\">*pc = <span class=\"number\">92.99</span>;　　　　　　　 <span class=\"comment\">// 没问题 -- 更改rates[0]的值</span></span><br></pre></td></tr></table></figure><p><mark><strong>可以用这种指针修改它所指向的值，但是它只能指向初始化时设置的地址。</strong></mark></p>\n</li>\n<li><p>最后，<mark><strong>在创建指针时还可以使用<code>const</code>两次，该指针既不能更改它所指向的地址，也不能修改指向地址上的值</strong></mark>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">double</span>　rates[<span class=\"number\">5</span>]　=　&#123;<span class=\"number\">88.99</span>,　<span class=\"number\">100.12</span>,　<span class=\"number\">59.45</span>,　<span class=\"number\">183.11</span>,　<span class=\"number\">340.5</span>&#125;;</span><br><span class=\"line\"><span class=\"keyword\">const</span> <span class=\"keyword\">double</span> * <span class=\"keyword\">const</span> pc = rates;</span><br><span class=\"line\">pc = &amp;rates[<span class=\"number\">2</span>];　　<span class=\"comment\">//不允许</span></span><br><span class=\"line\">*pc = <span class=\"number\">92.99</span>;　　　<span class=\"comment\">//不允许</span></span><br></pre></td></tr></table></figure></li>\n</ol><h2 id=\"指针和多维数组\">指针和多维数组<a href=\"#指针和多维数组\" title=\"指针和多维数组\"></a></h2><p>指针和多维数组有什么关系？为什么要了解它们的关系？处理多维数组的函数要用到指针，所以在使用这种函数之前，先要更深入地学习指针。至于第 1 个问题，我们通过几个示例来回答。为简化讨论，我们使用较小的数组。假设有下面的声明：</p>\n<p>int zippo[4][2]; /* 内含int数组的数组 */</p>\n<p>然后数组名zippo是该数组首元素的地址。在本例中，zippo的首元素是一个内含两个int值的数组，所以zippo是这个内含两个int值的数组的地址。下面，我们从指针的属性进一步分析。</p>\n<p>因为zippo是数组首元素的地址，所以zippo的值和&amp;zippo[0]的值相同。而zippo[0]本身是一个内含两个整数的数组，所以zippo[0]的值和它首元素（一个整数）的地址（即&amp;zippo[0][0]的值）相同。简而言之，zippo[0]是一个占用一个int大小对象的地址，而zippo是一个占用两个int大小对象的地址。由于这个整数和内含两个整数的数组都开始于同一个地址，所以zippo和zippo[0]的值相同。</p>\n<p>给指针或地址加1，其值会增加对应类型大小的数值。在这方面，zippo和zippo[0]不同，因为zippo指向的对象占用了两个int大小，而zippo[0]指向的对象只占用一个int大小。因此， zippo + 1和zippo[0] + 1的值不同。</p>\n<p>解引用一个指针（在指针前使用<em>运算符）或在数组名后使用带下标的[]运算符，得到引用对象代表的值。因为zippo[0]是该数组首元素（zippo[0][0]）的地址，所以</em></p>\n","prev":{"title":"Step1 Java程序设计概述","link":"posts/1fa13e13"},"next":{"title":"Inside Front-Matter","link":"posts/5a6efaf9"},"plink":"https://dxsummer.gitee.io/posts/87e8ce91/","toc":[{"id":"数组","title":"数组","index":"1","children":[{"id":"初始化数组","title":"初始化数组","index":"1.1"},{"id":"指定初始化器（c99）","title":"指定初始化器（C99）","index":"1.2"},{"id":"给数组元素赋值","title":"给数组元素赋值","index":"1.3"},{"id":"数组边界","title":"数组边界","index":"1.4"},{"id":"指定数组的大小","title":"指定数组的大小","index":"1.5"}]},{"id":"多维数组","title":"多维数组","index":"2","children":[{"id":"初始化二维数组","title":"初始化二维数组","index":"2.1"},{"id":"其他多维数组","title":"其他多维数组","index":"2.2"}]},{"id":"指针和数组","title":"指针和数组","index":"3"},{"id":"函数、数组和指针","title":"函数、数组和指针","index":"4","children":[{"id":"使用指针形参","title":"使用指针形参","index":"4.1"},{"id":"指针表示法和数组表示法","title":"指针表示法和数组表示法","index":"4.2"}]},{"id":"指针操作","title":"指针操作","index":"5"},{"id":"保护数组中的数据","title":"保护数组中的数据","index":"6","children":[{"id":"对形式参数使用const","title":"对形式参数使用const","index":"6.1"},{"id":"const的其他内容","title":"const的其他内容","index":"6.2"}]},{"id":"指针和多维数组","title":"指针和多维数组","index":"7"}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/87e8ce91/\" title=\"Step8 数组和指针\">https://dxsummer.gitee.io/posts/87e8ce91/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年6月13日","updated":"2020年6月16日"}}