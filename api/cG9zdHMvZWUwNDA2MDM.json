{"title":"图","date":"2020-11-21T10:20:02.000Z","date_formatted":{"ll":"2020年11月21日","L":"2020/11/21","MM-DD":"11-21"},"link":"posts/ee040603","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2020-11-23T12:25:28.000Z","content":"<h1 id=\"图\">图<a href=\"#图\" title=\"图\"></a></h1><ul><li><strong>图</strong>：Graph=(V,E)</li>\n<li><strong>V</strong>：顶点(数据元素)的有穷非空集合</li>\n<li><strong>E</strong>：边的有穷集合</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121182720.png\" style=\"zoom: 67%;\" /><ul><li><strong>无向图</strong>：每条边都是无方向的</li>\n<li><strong>有向图</strong>：每条边都是有方向的</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201121183057.png\" style=\"zoom:67%;\" /><ul><li><strong>完全图</strong>：任意两个点都有一条边相连</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/20201121230125.png\" style=\"zoom: 67%;\" /><p><strong>路径</strong>：接续的边构成的顶点序列。<br><strong>路径长度</strong>：路径上边或弧的数目/权值之和。<br><strong>回路(环)</strong>：第一个顶点和最后一个顶点相同的路径。<br><strong>简单路径</strong>：除路径起点和终点可以相同外，其余顶点均不相同的路径。<br><strong>简单回路(简单环)</strong>：除路径起点和终点相同外，其余顶点均不相同的路径。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/20201121230543.png\" style=\"zoom:67%;\" /><h2 id=\"连通图（强连通图）\">连通图（强连通图）<a href=\"#连通图（强连通图）\" title=\"连通图（强连通图）\"></a></h2><ul><li>在无（有）向图G=( V, {E} )中，若对任何两个顶点 v、u 都存在从v 到 u 的路径，则称G是<strong>连通图（强连通图）</strong>。</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/20201121231446.png\" style=\"zoom:67%;\" /><h2 id=\"权与网\">权与网<a href=\"#权与网\" title=\"权与网\"></a></h2><ul><li><p>图中边或弧所具有的相关数称为<strong>权</strong>。<strong><font color=\"purple\">表明从一个顶点到另一个顶点的距离或耗费</font></strong>。带权的图称为<strong>网</strong></p>\n</li>\n<li><p>例:(b)、(c) 是 (a) 的子图</p>\n</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/20201121232708.png\" style=\"zoom: 50%;\" /><p><strong>极小连通子图</strong>：该子图是G 的连通子图，在该子图中删除任何一条边，子图不再连通</p>\n<p><strong>生成树</strong>：包含无向图G 所有顶点的极小连通子图。</p>\n<p><strong>生成森林</strong>：对非连通图，由各个连通分量的生成树的集合</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122162847.png\" style=\"zoom:67%;\" /><p><strong>六度空间理论</strong></p>\n<p>你和任何一个陌生人之间所间隔的人不会超过6个，也就是说，最多通过6个中间人你就能够认识任何一个陌生人。</p>\n<h2 id=\"存储结构\">存储结构<a href=\"#存储结构\" title=\"存储结构\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122163215.png\" style=\"zoom:67%;\" /><h3 id=\"数组（邻接矩阵）表示法\">数组（邻接矩阵）表示法<a href=\"#数组（邻接矩阵）表示法\" title=\"数组（邻接矩阵）表示法\"></a></h3><ol><li>建立一个<strong>顶点表</strong>（记录各个顶点信息）和一个<strong>邻接矩阵</strong>（表示各个顶点之间关系）</li>\n<li>设图 <code>A = (V, E)</code> 有 n 个顶点，则图的邻接矩阵是一个二维数组 <code>A.Edge[n][n]</code>，定义为：<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122163743.png\" style=\"zoom: 67%;\" /></li>\n</ol><ul><li><strong>优点</strong>：容易实现图的操作，如：求某顶点的度、判断顶点之间是否有边、找顶点的邻接点等等。</li>\n<li><strong>缺点</strong>：n个顶点需要<code>n*n</code>个单元存储边;空间效率为O(n<sup>2</sup>)。 <strong>对稀疏图而言尤其浪费空间</strong>。</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122164537.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122164904.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122170738.png\" style=\"zoom:67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用两个数组分别存储顶点表和邻接矩阵</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MaxInt 32767                    \t<span class=\"comment\">//表示极大值，即∞</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MVNum 100                       \t<span class=\"comment\">//最大顶点数 </span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> VerTexType;              \t<span class=\"comment\">//假设顶点的数据类型为字符型 </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> ArcType;                  \t<span class=\"comment\">//假设边的权值类型为整型 </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span> </span><br><span class=\"line\">  VerTexType vexs[MVNum];            \t\t<span class=\"comment\">//顶点表 </span></span><br><span class=\"line\">  ArcType arcs[MVNum][MVNum];      \t<span class=\"comment\">//邻接矩阵 </span></span><br><span class=\"line\">  <span class=\"keyword\">int</span> vexnum,arcnum;                \t\t<span class=\"comment\">//图的当前点数和边数 </span></span><br><span class=\"line\">&#125;AMGraph;</span><br></pre></td></tr></table></figure><h3 id=\"邻接表（链式）表示法\">邻接表（链式）表示法<a href=\"#邻接表（链式）表示法\" title=\"邻接表（链式）表示法\"></a></h3><ul><li><strong>优点</strong>：空间效率高，容易寻找顶点的邻接点；</li>\n<li><strong>缺点</strong>：判断两顶点间是否有边或弧，需搜索两结点对应的单链表，没有邻接矩阵方便。</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122170818.png\" style=\"zoom:67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122171914.png\" style=\"zoom: 80%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122172200.png\" style=\"zoom: 80%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//算法6.2　采用邻接表表示法创建无向图</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;iostream&gt;</span></span></span><br><span class=\"line\"><span class=\"keyword\">using</span> <span class=\"keyword\">namespace</span> <span class=\"built_in\">std</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MVNum 100                        \t<span class=\"comment\">//最大顶点数 </span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> OK 1</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">char</span> VerTexType;\t\t\t\t\t<span class=\"comment\">//顶点信息</span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"keyword\">int</span> OtherInfo;\t\t\t\t\t\t<span class=\"comment\">//和边相关的信息 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//- - - - -图的邻接表存储表示- - - - - </span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ArcNode</span>&#123;</span>                \t\t<span class=\"comment\">//边结点 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> adjvex;                          \t<span class=\"comment\">//该边所指向的顶点的位置 </span></span><br><span class=\"line\">    <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">ArcNode</span> *<span class=\"title\">nextarc</span>;</span>          \t\t<span class=\"comment\">//指向下一条边的指针 </span></span><br><span class=\"line\">    OtherInfo info;                      \t<span class=\"comment\">//和边相关的信息 </span></span><br><span class=\"line\">&#125;ArcNode; </span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">VNode</span>&#123;</span> </span><br><span class=\"line\">    VerTexType data;                    \t<span class=\"comment\">//顶点信息 </span></span><br><span class=\"line\">    ArcNode *firstarc;                \t\t<span class=\"comment\">//指向第一条依附该顶点的边的指针 </span></span><br><span class=\"line\">&#125;VNode, AdjList[MVNum];               \t\t<span class=\"comment\">//AdjList表示邻接表类型 </span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span>&#123;</span> </span><br><span class=\"line\">    AdjList vertices;                 \t\t<span class=\"comment\">//邻接表 </span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> vexnum, arcnum;              \t\t<span class=\"comment\">//图的当前顶点数和边数 </span></span><br><span class=\"line\">&#125;ALGraph;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">LocateVex</span><span class=\"params\">(ALGraph G , VerTexType v)</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//确定点v在G中的位置</span></span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; G.vexnum; ++i)</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(G.vertices[i].data == v)</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">return</span> i;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"number\">-1</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//LocateVex</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">CreateUDG</span><span class=\"params\">(ALGraph &amp;G)</span></span>&#123; </span><br><span class=\"line\">\t<span class=\"comment\">//采用邻接表表示法，创建无向图G</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i , k;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt;<span class=\"string\">\"请输入总顶点数，总边数中间以空格隔开:\"</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cin</span> &gt;&gt; G.vexnum &gt;&gt; G.arcnum;\t\t\t\t<span class=\"comment\">//输入总顶点数，总边数 </span></span><br><span class=\"line\">    <span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"输入点的名称，如 a \"</span> &lt;&lt;<span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span>; i &lt; G.vexnum; ++i)&#123;          \t<span class=\"comment\">//输入各点，构造表头结点表</span></span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入第\"</span> &lt;&lt; (i+<span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\"个点的名称:\"</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; G.vertices[i].data;           \t<span class=\"comment\">//输入顶点值 </span></span><br><span class=\"line\">\t\tG.vertices[i].firstarc=<span class=\"literal\">NULL</span>;\t\t\t<span class=\"comment\">//初始化表头结点的指针域为NULL </span></span><br><span class=\"line\">    &#125;<span class=\"comment\">//for</span></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">    </span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入一条边依附的顶点,如 a b\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(k = <span class=\"number\">0</span>; k &lt; G.arcnum;++k)&#123;        \t\t<span class=\"comment\">//输入各边，构造邻接表</span></span><br><span class=\"line\">\t\tVerTexType v1 , v2;</span><br><span class=\"line\">\t\t<span class=\"keyword\">int</span> i , j;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"请输入第\"</span> &lt;&lt; (k + <span class=\"number\">1</span>) &lt;&lt; <span class=\"string\">\"条边依附的顶点:\"</span>;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cin</span> &gt;&gt; v1 &gt;&gt; v2;                 \t\t<span class=\"comment\">//输入一条边依附的两个顶点</span></span><br><span class=\"line\">\t\ti = LocateVex(G, v1);  j = LocateVex(G, v2);</span><br><span class=\"line\">\t\t<span class=\"comment\">//确定v1和v2在G中位置，即顶点在G.vertices中的序号 </span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tArcNode *p1=<span class=\"keyword\">new</span> ArcNode;               \t<span class=\"comment\">//生成一个新的边结点*p1 </span></span><br><span class=\"line\">\t\tp1-&gt;adjvex=j;                   \t\t<span class=\"comment\">//邻接点序号为j </span></span><br><span class=\"line\">\t\tp1-&gt;nextarc= G.vertices[i].firstarc;  G.vertices[i].firstarc=p1;  </span><br><span class=\"line\">\t\t<span class=\"comment\">//将新结点*p1插入顶点vi的边表头部</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tArcNode *p2=<span class=\"keyword\">new</span> ArcNode;                <span class=\"comment\">//生成另一个对称的新的边结点*p2 </span></span><br><span class=\"line\">\t\tp2-&gt;adjvex=i;                   \t\t<span class=\"comment\">//邻接点序号为i </span></span><br><span class=\"line\">\t\tp2-&gt;nextarc= G.vertices[j].firstarc;  G.vertices[j].firstarc=p2;  </span><br><span class=\"line\">\t\t<span class=\"comment\">//将新结点*p2插入顶点vj的边表头部 </span></span><br><span class=\"line\">    &#125;<span class=\"comment\">//for </span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> OK; </span><br><span class=\"line\">&#125;<span class=\"comment\">//CreateUDG</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">()</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"************算法6.2　采用邻接表表示法创建无向图**************\"</span> &lt;&lt; <span class=\"built_in\">endl</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\tALGraph G;</span><br><span class=\"line\">\tCreateUDG(G);</span><br><span class=\"line\">\t<span class=\"keyword\">int</span> i;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"*****邻接表表示法创建的无向图*****\"</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t</span><br><span class=\"line\">\t<span class=\"keyword\">for</span>(i = <span class=\"number\">0</span> ; i &lt; G.vexnum ; ++i)&#123;</span><br><span class=\"line\">\t\tVNode temp = G.vertices[i];</span><br><span class=\"line\">\t\tArcNode *p = temp.firstarc;</span><br><span class=\"line\">\t\t<span class=\"keyword\">if</span>(p == <span class=\"literal\">NULL</span>)&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; G.vertices[i].data;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"keyword\">else</span>&#123;</span><br><span class=\"line\">\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; temp.data;</span><br><span class=\"line\">\t\t\t<span class=\"keyword\">while</span>(p)&#123;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"string\">\"-&gt;\"</span>;</span><br><span class=\"line\">\t\t\t\t<span class=\"built_in\">cout</span> &lt;&lt; p-&gt;adjvex;</span><br><span class=\"line\">\t\t\t\tp = p-&gt;nextarc;</span><br><span class=\"line\">\t\t\t&#125;</span><br><span class=\"line\">\t\t&#125;</span><br><span class=\"line\">\t\t<span class=\"built_in\">cout</span> &lt;&lt; <span class=\"built_in\">endl</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;<span class=\"comment\">//main</span></span><br></pre></td></tr></table></figure><h3 id=\"十字链表\">十字链表<a href=\"#十字链表\" title=\"十字链表\"></a></h3><h4 id=\"有向图\">有向图<a href=\"#有向图\" title=\"有向图\"></a></h4><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122175308.png\" style=\"zoom: 67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122175351.png\" style=\"zoom: 67%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122175509.png\" style=\"zoom:67%;\" /><h4 id=\"无向图\">无向图<a href=\"#无向图\" title=\"无向图\"></a></h4><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122175654.png\" style=\"zoom: 80%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122175812.png\" style=\"zoom:67%;\" /><h2 id=\"邻接矩阵与邻接表表示法的关系\">邻接矩阵与邻接表表示法的关系<a href=\"#邻接矩阵与邻接表表示法的关系\" title=\"邻接矩阵与邻接表表示法的关系\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201122174410.png\" style=\"zoom: 67%;\" /><ul><li><p><strong>联系</strong>：<strong>邻接表</strong>中每个链表对应于<strong>邻接矩阵</strong>中的一行，链表中结点个数等于一行中非零元素的个数。</p>\n</li>\n<li><p><strong>区别</strong>：</p>\n<p>① 对于任一确定的无向图，<strong>邻接矩阵是唯一的</strong>（行列号与顶点编号一致），但<strong>邻接表不唯一</strong>（链接次序与顶点编号无关）。<br>② 邻接矩阵的空间复杂度为<strong>O(n<sup>2</sup>) ** , 而邻接表的空间复杂度为</strong>O(n+e)**。</p>\n</li>\n<li><p><strong>用途</strong>：<strong>邻接矩阵</strong>多用于<strong>稠密图</strong>；而<strong>邻接表</strong>多用于<strong>稀疏图</strong></p>\n</li>\n</ul><h1 id=\"图的遍历\">图的遍历<a href=\"#图的遍历\" title=\"图的遍历\"></a></h1><ul><li><strong>定义</strong>：从已给的连通图中某一顶点出发，沿着一些边访遍图中所有的顶点，且使<strong>每个顶点仅被访问一次</strong>，就叫做<strong>图的遍历</strong>，它是图的<strong>基本运算</strong></li>\n<li><strong>实质</strong>：找每个顶点的邻接点的过程</li>\n<li><strong>特点</strong>：图中可能存在<strong>回路</strong>，且图的任一顶点都可能与其它顶点相通，在访问完某个顶点之后可能会沿着某些边<strong>又回到了曾经访问过的顶点</strong></li>\n<li></li>\n</ul>","prev":{"title":"多媒体嵌入","link":"posts/159769da"},"next":{"title":"DIV+CSS布局","link":"posts/f02a39f0"},"plink":"https://dxsummer.gitee.io/posts/ee040603/","toc":[{"id":"图","title":"图","index":"1","children":[{"id":"连通图（强连通图）","title":"连通图（强连通图）","index":"1.1"},{"id":"权与网","title":"权与网","index":"1.2"},{"id":"存储结构","title":"存储结构","index":"1.3","children":[{"id":"数组（邻接矩阵）表示法","title":"数组（邻接矩阵）表示法","index":"1.3.1"},{"id":"邻接表（链式）表示法","title":"邻接表（链式）表示法","index":"1.3.2"},{"id":"十字链表","title":"十字链表","index":"1.3.3","children":[{"id":"有向图","title":"有向图","index":"1.3.3.1"},{"id":"无向图","title":"无向图","index":"1.3.3.2"}]}]},{"id":"邻接矩阵与邻接表表示法的关系","title":"邻接矩阵与邻接表表示法的关系","index":"1.4"}]},{"id":"图的遍历","title":"图的遍历","index":"2"}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/ee040603/\" title=\"图\">https://dxsummer.gitee.io/posts/ee040603/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年11月21日","updated":"2020年11月23日"}}