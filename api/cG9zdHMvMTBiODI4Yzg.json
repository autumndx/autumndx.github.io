{"title":"数据结构(蓝桥杯)","date":"2022-03-11T12:44:49.000Z","date_formatted":{"ll":"2022年3月11日","L":"2022/03/11","MM-DD":"03-11"},"link":"posts/10b828c8","comments":true,"tags":["Java"],"categories":["Java"],"updated":"2022-03-14T02:46:01.577Z","content":"<h1 id=\"算法分析\">算法分析<a href=\"#算法分析\" title=\"算法分析\"></a></h1><h2 id=\"时间复杂度分析\">时间复杂度分析<a href=\"#时间复杂度分析\" title=\"时间复杂度分析\"></a></h2><p><code>System.currentTimeMillis()</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FileDemo</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> sum = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> n = <span class=\"number\">100</span>;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt;= n; i++) &#123;</span><br><span class=\"line\">            sum += i;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"sum:\"</span> + sum);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(end - start);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"空间复杂度分析\">空间复杂度分析<a href=\"#空间复杂度分析\" title=\"空间复杂度分析\"></a></h2><h3 id=\"java中常见内存占用\">java中常见内存占用<a href=\"#java中常见内存占用\" title=\"java中常见内存占用\"></a></h3><p>1.基本数据类型内存占用情况:</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>数据类型</th><th>内存占用字节数</th></tr>\n</thead><tbody><tr>\n<td>byte</td><td>1</td></tr>\n<tr>\n<td>short</td><td>2</td></tr>\n<tr>\n<td>int</td><td>4</td></tr>\n<tr>\n<td>long</td><td>8</td></tr>\n<tr>\n<td>float</td><td>4</td></tr>\n<tr>\n<td>double</td><td>8</td></tr>\n<tr>\n<td>boolean</td><td>1</td></tr>\n<tr>\n<td>char</td><td>2</td></tr>\n</tbody></table></div></div><p>2.计算机访问内存的方式都是一次一个字节</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203121441247.png\" class=\"φcy\" alt=\"QQ20220312-143406@2x\"></p>\n<p>3.一个引用(机器地址)需要8个字节表示:</p>\n<p>例如: <code>Date date = new Date()</code>,则<code>date</code>这个变量需要占用<strong><font color=\"red\">8个字节</font></strong>来表示</p>\n<p>4.创建一个对象，比如<code>new Date()</code>，除了<code>Date</code>对象内部存储的数据(例如年月日等信息)占用的内存，该对象本身也 有内存开销，每个对象的自身开销是<strong><font color=\"red\">16个字节</font></strong>，用来保存对象的头信息。</p>\n<p>5.一般内存的使用，<strong><font color=\"red\">如果不够8个字节，都会被自动填充为8字节</font></strong>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">public</span> <span class=\"keyword\">int</span> a = <span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">通过<span class=\"keyword\">new</span> A() 创建一个对象的内存占用如下：</span><br><span class=\"line\">\t<span class=\"number\">1</span>. 整型成员变量a占用<span class=\"number\">4</span>个字节</span><br><span class=\"line\">\t<span class=\"number\">2</span>. 对象本身占用<span class=\"number\">16</span>个字节</span><br><span class=\"line\">那么创建该对象总共需要<span class=\"number\">20</span>个字节，但由于不是以<span class=\"number\">8</span>为单位，会自动填充为<span class=\"number\">24</span>个字节</span><br></pre></td></tr></table></figure><p>6.java中数组被被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要<strong><font color=\"red\"> 24字节</font></strong>的头信息 (<strong>16个自己的对象开销，4字节用于保存长度以及4个填充字节</strong>)  再加上保存值所需的内存。</p>\n<h3 id=\"算法的空间复杂度\">算法的空间复杂度<a href=\"#算法的空间复杂度\" title=\"算法的空间复杂度\"></a></h3><p>案例:</p>\n<p>对指定的数组元素进行反转，并返回反转的内容。</p>\n<p>解法一:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] reverse1(<span class=\"keyword\">int</span>[] arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;<span class=\"comment\">// 申请4个字节</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> temp;<span class=\"comment\">// 申请4个字节</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> start = <span class=\"number\">0</span>, end = n - <span class=\"number\">1</span>; start &lt;= end; start++, end--) &#123;</span><br><span class=\"line\">        temp = arr[start];</span><br><span class=\"line\">        arr[start] = arr[end];</span><br><span class=\"line\">        arr[end] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> arr;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>解法二:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span>[] reverse2(<span class=\"keyword\">int</span>[] arr) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;<span class=\"comment\">// 申请4个字节</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span>[] temp = <span class=\"keyword\">new</span> <span class=\"keyword\">int</span>[n]; <span class=\"comment\">// 申请n*4个字节+数组自身头信息开销24个字节</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = n - <span class=\"number\">1</span>; i &gt;= <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">        temp[n - <span class=\"number\">1</span> - i] = arr[i];</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> temp;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>忽略判断条件占用的内存，我们得出的内存占用情况如下: </p>\n<p>算法一: </p>\n<p>不管传入的数组大小为多少，始终额外申请<strong>4+4=8个字节;</strong> </p>\n<p>算法二:</p>\n<p><strong>4+4n+24=4n+28;</strong> </p>\n<p>根据大O推导法则，算法一的空间复杂度为O(1),算法二的空间复杂度为O(n),所以从空间占用的角度讲，算法一要优于算法二。 </p>\n<p>由于java中有内存垃圾回收机制，并且jvm对程序的内存占用也有优化(例如即时编译)，我们无法精确的评估一个java程序的内存占用情况，但是了解了java的基本内存占用，使我们可以对java程序的内存占用情况进行估算。 </p>\n<p>由于现在的计算机设备内存一般都比较大，基本上个人计算机都是4G起步，大的可以达到32G，所以内存占用一般情况下并不是我们算法的瓶颈，普通情况下直接说复杂度，默认为算法的时间复杂度。</p>\n<p>但是，如果你做的程序是嵌入式开发，尤其是一些传感器设备上的内置程序，由于这些设备的内存很小，一般为几 kb，这个时候对算法的空间复杂度就有要求了，但是一般做java开发的，基本上都是服务器开发，一般不存在这样 的问题。</p>\n<h1 id=\"排序\">排序<a href=\"#排序\" title=\"排序\"></a></h1><h2 id=\"简单排序\">简单排序<a href=\"#简单排序\" title=\"简单排序\"></a></h2><p>在java的开发工具包jdk中，已经给我们提供了很多数据结构与算法的实现，比如List，Set，Map，Math等等，都 是以API的方式提供，这种方式的好处在于一次编写，多处使用。我们借鉴jdk的方式，也把算法封装到某个类中， 那如果是这样，在我们写java代码之前，就需要先进行API的设计，设计好之后，再对这些API进行实现。</p>\n<p>就比如我们先设计一套API如下:</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类名</th><th>ArrayList</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>ArrayList():创建ArrayList对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.  <code>boolean add(E e)</code>:向集合中添加元素<br>2.  <code>E remove(int index)</code>:从集合中删除指定的元素</td></tr>\n</tbody></table></div></div><h3 id=\"comparable接口介绍\">Comparable接口介绍<a href=\"#comparable接口介绍\" title=\"Comparable接口介绍\"></a></h3><p>由于我们这里要讲排序，所以肯定会在元素之间进行比较，而Java提供了一个接口Comparable就是用来定义排序 规则的，在这里我们以案例的形式对Comparable接口做一个简单的回顾。</p>\n<p>需求: 1.定义一个学生类Student，具有年龄age和姓名username两个属性，并通过Comparable接口提供比较规则;</p>\n<p> 2.定义测试类Test，在测试类Test中定义测试方法<code>Comparable getMax(Comparable c1,Comparable c2)</code>完成测试</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 学生类</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Student</span> <span class=\"keyword\">implements</span> <span class=\"title\">Comparable</span>&lt;<span class=\"title\">Student</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String username;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">int</span> age;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUsername</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.username = username;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">getAge</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setAge</span><span class=\"params\">(<span class=\"keyword\">int</span> age)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.age = age;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Student&#123;\"</span> +</span><br><span class=\"line\">                <span class=\"string\">\"username='\"</span> + username + <span class=\"string\">'\\''</span> + <span class=\"string\">\", age=\"</span> + age +</span><br><span class=\"line\">                <span class=\"string\">'&#125;'</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 定义比较规则</span></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compareTo</span><span class=\"params\">(Student o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.getAge() - o.getAge();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试类</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Student stu1 = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">        stu1.setUsername(<span class=\"string\">\"zhangsan\"</span>);</span><br><span class=\"line\">        stu1.setAge(<span class=\"number\">17</span>);</span><br><span class=\"line\">        Student stu2 = <span class=\"keyword\">new</span> Student();</span><br><span class=\"line\">        stu2.setUsername(<span class=\"string\">\"lisi\"</span>);</span><br><span class=\"line\">        stu2.setAge(<span class=\"number\">19</span>);</span><br><span class=\"line\">        Comparable max = getMax(stu1, stu2);</span><br><span class=\"line\">        System.out.println(max);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">// 测试方法，获取两个元素中的较大值</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Comparable <span class=\"title\">getMax</span><span class=\"params\">(Comparable c1, Comparable c2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> cmp = c1.compareTo(c2);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (cmp &gt;= <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c1;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> c2;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"冒泡排序\">冒泡排序<a href=\"#冒泡排序\" title=\"冒泡排序\"></a></h3><p>冒泡排序(Bubble Sort)，是一种计算机科学领域的较简单的排序算法。 需求:</p>\n<p>排序前:{4,5,6,3,2,1}</p>\n<p>排序后:{1,2,3,4,5,6} </p>\n<p>排序原理:</p>\n<ol><li><p>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</p>\n</li>\n<li><p>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</p>\n</li>\n</ol><p><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203121710381.png\" class=\"φcy\" alt=\"QQ20220312-170929@2x\"></p>\n<p>冒泡排序API设计:</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类名</th><th>Bubble</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>Bubble() : 创建Bubble对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.<code>public static void sort(Comparable[] a)</code>:对数组内的元素进行排序<br>2.<code>private static boolean greater(Comparable v,Comparable w)</code>:判断v是否大于w<br>3.<code>private static void exch(Comparable[] a,int i,int j)</code>:交换a数组中，索引i和索引j处的值</td></tr>\n</tbody></table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 排序代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Bubble</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 对数组a中的元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = a.length - <span class=\"number\">1</span>; i &gt; <span class=\"number\">0</span>; i--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt; i; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (greater(a[j], a[j + <span class=\"number\">1</span>])) &#123;</span><br><span class=\"line\">                    exch(a, j, j + <span class=\"number\">1</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 比较v元素是否大于w元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">greater</span><span class=\"params\">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.compareTo(w) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组元素i和j交换位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        Comparable t = a[i];</span><br><span class=\"line\">        a[i] = a[j];</span><br><span class=\"line\">        a[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer[] a = &#123; <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">        Bubble.sort(a);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>冒泡排序的时间复杂度分析</strong> 冒泡排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以， 我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p>\n<p>在最坏情况下，也就是假如要排序的元素为{6,5,4,3,2,1}逆序，那么: </p>\n<p>元素比较的次数为:</p>\n<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>\n<p>元素交换的次数为:</p>\n<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>\n<p>总执行次数为:</p>\n<p>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N; </p>\n<p>按照大O推导法则，保留函数中的最高阶项那么最终冒泡排序的<strong><font color=\"red\">时间复杂度为O(N^2)</font></strong></p>\n<h3 id=\"选择排序\">选择排序<a href=\"#选择排序\" title=\"选择排序\"></a></h3><p>选择排序是一种更加简单直观的排序方法。</p>\n<p><strong>需求:</strong></p>\n<p>排序前:{4,6,8,7,9,2,10,1} </p>\n<p>排序后:{1,2,4,5,7,8,9,10}</p>\n<p><strong>排序原理:</strong></p>\n<ol><li><p>每一次遍历的过程中，都<strong>假定第一个索引处的元素是最小值，和其他索引处的值依次进行比较</strong>，如果当前索引处 的值大于其他某个索引处的值，则假定其他某个索引出的值为最小值，最后可以找到最小值所在的索引</p>\n</li>\n<li><p>交换第一个索引处和最小值所在的索引处的值</p>\n</li>\n</ol><p><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203122139281.png\" class=\"φcy\" alt=\"QQ20220312-213801@2x\"></p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类别</th><th>Selection</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>Selection():创建Selection对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.<code>public static void sort(Comparable[] a)</code>:对数组内的元素进行排序<br/>2.<code>private static boolean greater(Comparable v,Comparable w)</code>:判断v是否大于w <br/>3.<code>private static void exch(Comparable[] a,int i,int j)</code>:交换a数组中，索引i和索引j处的值</td></tr>\n</tbody></table></div></div><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// 排序代码</span></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Selection</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 对数组a中的元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt;= a.length - <span class=\"number\">2</span>; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 假定本次遍历，最小 值 所在的索引是i</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> minIndex = i;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; a.length; j++) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (greater(a[minIndex], a[j])) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 跟换最小值 所 在的索引</span></span><br><span class=\"line\">                    minIndex = j;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// 交换i索引处和minIndex索引处的值</span></span><br><span class=\"line\">            exch(a, i, minIndex);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 比较v元素是否大于w元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">greater</span><span class=\"params\">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.compareTo(w) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组元素i和j交换位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        Comparable t = a[i];</span><br><span class=\"line\">        a[i] = a[j];</span><br><span class=\"line\">        a[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 测试代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer[] a = &#123; <span class=\"number\">4</span>, <span class=\"number\">6</span>, <span class=\"number\">8</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">1</span> &#125;;</span><br><span class=\"line\">        Selection.sort(a);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>选择排序的时间复杂度分析:</strong></p>\n<p>选择排序使用了双层for循环，其中外层循环完成了数据交换，内层循环完成了数据比较，所以我们分别统计数据交换次数和数据比较次数:</p>\n<p>数据比较次数:</p>\n<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2;</p>\n<p>数据交换次数:</p>\n<p>N-1 </p>\n<p>时间复杂度:N^2/2-N/2+(N-1)=N^2/2+N/2-1;</p>\n<p>根据大O推导法则，保留最高阶项，去除常数因子，<strong><font color=\"red\">时间复杂度为O(N^2)</font></strong>;</p>\n<h3 id=\"插入排序\">插入排序<a href=\"#插入排序\" title=\"插入排序\"></a></h3><p>插入排序(Insertion sort)是一种简单直观且稳定的排序算法。</p>\n<p>需求: 排序前:{4,3,2,10,12,1,5,6} 排序后:{1,2,3,4,5,6,10,12}</p>\n<p>排序原理:</p>\n<p>1.把所有的元素分为两组，已经排序的和未排序的; </p>\n<p>2.找到未排序的组中的第一个元素，向已经排序的组中进行插入;</p>\n<p>3.倒叙遍历已经排序的元素，依次和待插入的元素进行比较，直到找到一个元素小于等于待插入元素，那么就把待 插入元素放到这个位置，其他的元素向后移动一位;</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203122250093.png\" class=\"φcy\" alt=\"QQ20220312-225015@2x\"></p>\n<p>插入排序API设计:</p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类别</th><th>Insertion</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>Insertion():创建Insertion对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.public static void sort(Comparable[] a):对数组内的元素进行排序<br/>2.private static boolean greater(Comparable v,Comparable w):判断v是否大于w <br/> 3.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值</td></tr>\n</tbody></table></div></div><p>插入排序代码实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Insertion</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 对数组a中的元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">1</span>; i &lt; a.length; i++) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 当前元素为a[i],依次和i前面的元素比较，找到一个小于等于a[i]的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt; <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (greater(a[j - <span class=\"number\">1</span>], a[j])) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 交换元素</span></span><br><span class=\"line\">                    exch(a, j - <span class=\"number\">1</span>, j);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">// 找到了该元素，结束</span></span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 比较v元素是否大于w元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">greater</span><span class=\"params\">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.compareTo(w) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">     * 数组元素i和j交换位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        Comparable t = a[i];</span><br><span class=\"line\">        a[i] = a[j];</span><br><span class=\"line\">        a[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer[] a = &#123; <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">10</span>, <span class=\"number\">12</span>, <span class=\"number\">1</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span> &#125;;</span><br><span class=\"line\">        Insertion.sort(a);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>插入排序的时间复杂度分析</strong></p>\n<p>插入排序使用了双层for循环，其中内层循环的循环体是真正完成排序的代码，所以，我们分析插入排序的时间复 杂度，主要分析一下内层循环体的执行次数即可。</p>\n<p>最坏情况，也就是待排序的数组元素为{12,10,6,5,4,3,2,1}，那么: </p>\n<p>比较的次数为: </p>\n<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; </p>\n<p>交换的次数为:</p>\n<p>(N-1)+(N-2)+(N-3)+…+2+1=((N-1)+1)*(N-1)/2=N^2/2-N/2; </p>\n<p>总执行次数为:</p>\n<p>(N^2/2-N/2)+(N^2/2-N/2)=N^2-N; </p>\n<p>按照大O推导法则，保留函数中的最高阶项那么最终插入排序的<strong><font color = \"red\">时间复杂度为O(N^2)</font></strong>.</p>\n<h2 id=\"高级排序\">高级排序<a href=\"#高级排序\" title=\"高级排序\"></a></h2><p>之前我们学习过基础排序，包括冒泡排序，选择排序还有插入排序，并且对他们在最坏情况下的时间复杂度做了分 析，发现都是O(N^2)，而平方阶通过我们之前学习算法分析我们知道，<strong>随着输入规模的增大，时间成本将急剧上升，所以这些基本排序方法不能处理更大规模的问题</strong>，接下来我们学习一些高级的排序算法，争取降低算法的时间 复杂度最高阶次幂。</p>\n<h3 id=\"希尔排序\">希尔排序<a href=\"#希尔排序\" title=\"希尔排序\"></a></h3><p>希尔排序是插入排序的一种，又称“缩小增量排序”，是插入排序算法的一种更高效的改进版本</p>\n<p>前面学习插入排序的时候，我们会发现一个很不友好的事儿，如果已排序的分组元素为{2,5,7,9,10}，未排序的分组 元素为{1,8}，那么下一个待插入元素为1，我们需要拿着1从后往前，依次和10,9,7,5,2进行交换位置，才能完成真 正的插入，每次交换只能和相邻的元素交换位置。那如果我们要提高效率，直观的想法就是一次交换，能把1放到 更前面的位置，比如一次交换就能把1插到2和5之间，这样一次交换1就向前走了5个位置，可以减少交换的次数， 这样的需求如何实现呢?接下来我们来看看希尔排序的原理。</p>\n<p><strong>需求:</strong> </p>\n<p>排序前:{9,1,2,5,7,4,8,6,3,5} </p>\n<p>排序后:{1,2,3,4,5,5,6,7,8,9}</p>\n<p><strong>排序原理:</strong> </p>\n<ol><li><p>选定一个增长量h，按照增长量h作为数据分组的依据，对数据进行分组; </p>\n</li>\n<li><p>对分好组的每一组数据完成插入排序;</p>\n</li>\n<li><p>减小增长量，最小减为1，重复第二步操作。</p>\n</li>\n</ol><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203131843974.png\" alt=\"QQ20220313-160451@2x\" style=\"zoom:50%;\" /><p><strong>增长量h的确定:增长量h的值每一固定的规则，我们这里采用以下规则:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">while</span>(h&lt;数组的长度/<span class=\"number\">2</span>)&#123;</span><br><span class=\"line\">    h=<span class=\"number\">2</span>*h+<span class=\"number\">1</span>; <span class=\"comment\">// 1 3 7 15</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// 循环结束后我们就可以确定h的最大值</span></span><br><span class=\"line\">h的减小规则：</span><br><span class=\"line\">\t\th=h/<span class=\"number\">2</span>;</span><br></pre></td></tr></table></figure><p><strong>希尔排序的API设计:</strong></p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类别</th><th>shell</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>Shell():创建Shell对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.<code>public static void sort(Comparable[] a)</code>:对数组内的元素进行排序<br/>2.<code>private static boolean greater(Comparable v,Comparable w)</code>:判断v是否大于w<br/>3.<code>private static void exch(Comparable[] a,int i,int j)</code>:交换a数组中，索引i和索引j处的值</td></tr>\n</tbody></table></div></div><p><strong>希尔排序的代码实现:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Shell</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        对数组a中的元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> N = a.length;</span><br><span class=\"line\">        <span class=\"comment\">// 确定增长量h的最大值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> h = <span class=\"number\">1</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (h &lt; N / <span class=\"number\">2</span>) &#123;</span><br><span class=\"line\">            h = h * <span class=\"number\">2</span> + <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// 当增长量h小于1，排序结束</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (h &gt;= <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">// 找到待插入的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class=\"line\">                <span class=\"comment\">// a[i]就是待插入的元素</span></span><br><span class=\"line\">                <span class=\"comment\">//把a[i]插入到a[i-h],a[i-2h],a[i-3h]...序列中</span></span><br><span class=\"line\">                <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i; j &gt;= h; j -= h) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//a[j]就是待插入元素，依次和a[j-h],a[j-2h],a[j-3h]进行比较，如果a[j]小，那么 交换位置，如果不小于，a[j]大，则插入完成。</span></span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (greater(a[j - h], a[j])) &#123;</span><br><span class=\"line\">                        exch(a, j, j - h);</span><br><span class=\"line\">                    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                        <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            h /= <span class=\"number\">2</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        比较v元素是否大于w元素</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">greater</span><span class=\"params\">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.compareTo(w) &gt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        数组元素i和j交换位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        Comparable t = a[i];</span><br><span class=\"line\">        a[i] = a[j];</span><br><span class=\"line\">        a[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        Integer[] a = &#123;<span class=\"number\">9</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">3</span>, <span class=\"number\">5</span>&#125;;</span><br><span class=\"line\">        Shell.sort(a);</span><br><span class=\"line\">        System.out.println(Arrays.toString(a));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>希尔排序的时间复杂度分析</strong></p>\n<p>在希尔排序中，增长量h并没有固定的规则，有很多论文研究了各种不同的递增序列，但都无法证明某个序列是最 好的，对于希尔排序的时间复杂度分析，已经超出了我们课程设计的范畴，所以在这里就不做分析了。</p>\n<p>我们可以使用事后分析法对希尔排序和插入排序做性能比较。</p>\n<p>在资料的测试数据文件夹下有一个reverse_shell_insertion.txt文件，里面存放的是从100000到1的逆向数据，我们 可以根据这个批量数据完成测试。测试的思想:在执行排序前前记录一个时间，在排序完成后记录一个时间，两个 时间的时间差就是排序的耗时。</p>\n<p><strong>希尔排序和插入排序性能比较测试代码:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortCompare</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//读取reverse_arr.txt文件</span></span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"reverse_shell_insertion.txt\"</span>)));</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把每一个数字存入到集合中</span></span><br><span class=\"line\">            list.add(Integer.valueOf(line));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.close();</span><br><span class=\"line\">        <span class=\"comment\">//把集合转换成数组</span></span><br><span class=\"line\">        Integer[] arr = <span class=\"keyword\">new</span> Integer[list.size()];</span><br><span class=\"line\">        list.toArray(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        testInsertion(arr);<span class=\"comment\">//使用插入排序耗时:20859</span></span><br><span class=\"line\">        testShell(arr);<span class=\"comment\">//使用希尔排序耗时:31</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testInsertion</span><span class=\"params\">(Integer[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用插入排序完成测试</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Insertion.sort(arr);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用插入排序耗时:\"</span> + (end - start));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testShell</span><span class=\"params\">(Integer[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用希尔排序完成测试</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Shell.sort(arr);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用希尔排序耗时:\"</span> + (end - start));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过测试发现，在处理大批量数据时，希尔排序的性能确实高于插入排序。</p>\n<h3 id=\"归并排序\">归并排序<a href=\"#归并排序\" title=\"归并排序\"></a></h3><h4 id=\"递归\">递归<a href=\"#递归\" title=\"递归\"></a></h4><p><strong>定义:</strong></p>\n<p>定义方法时，在方法内部调用方法本身，称之为递归.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">show</span><span class=\"params\">()</span></span>&#123; </span><br><span class=\"line\">  \tSystem.out.println(<span class=\"string\">\"aaaa\"</span>); </span><br><span class=\"line\">  \tshow();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>作用:</strong></p>\n<p>它通常把一个大型复杂的问题，层层转换为一个与原问题相似的，规模较小的问题来求解。递归策略只需要少量的程序就可以描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。</p>\n<p><strong>注意事项:</strong></p>\n<p> 在递归中，不能无限制的调用自己，必须要有边界条件，能够让递归结束，因为每一次递归调用都会在栈内存开辟新的空间，重新执行方法，如果递归的层级太深，很容易造成栈内存溢出。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203131949304.png\" class=\"φcy\" alt=\"QQ20220313-194833@2x\"></p>\n<p>需求: 请定义一个方法，使用递归完成求N的阶乘;</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">分析:</span><br><span class=\"line\"><span class=\"number\">1</span>!: <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"number\">2</span>!: <span class=\"number\">2</span>*<span class=\"number\">1</span>=<span class=\"number\">2</span>*<span class=\"number\">1</span>!</span><br><span class=\"line\"><span class=\"number\">3</span>!: <span class=\"number\">3</span>*<span class=\"number\">2</span>*<span class=\"number\">1</span>=<span class=\"number\">3</span>*<span class=\"number\">2</span>!</span><br><span class=\"line\"><span class=\"number\">4</span>!: <span class=\"number\">4</span>*<span class=\"number\">3</span>*<span class=\"number\">2</span>*<span class=\"number\">1</span>=<span class=\"number\">4</span>*<span class=\"number\">3</span>!</span><br><span class=\"line\">...</span><br><span class=\"line\">n!: n*(n-<span class=\"number\">1</span>)*(n-<span class=\"number\">2</span>)...*<span class=\"number\">2</span>*<span class=\"number\">1</span>=n*(n-<span class=\"number\">1</span>)!</span><br><span class=\"line\">所以，假设有一个方法factorial(n)用来求n的阶乘，那么n的阶乘还可以表示为n*factorial(n-<span class=\"number\">1</span>)</span><br></pre></td></tr></table></figure><p><strong>代码实现:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> result = factorial(<span class=\"number\">5</span>);</span><br><span class=\"line\">        System.out.println(result);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">factorial</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (n == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> n * factorial(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h4 id=\"归并排序-1\">归并排序<a href=\"#归并排序-1\" title=\"归并排序\"></a></h4><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用分治法的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列;即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p>\n<p><strong>需求:</strong> </p>\n<p>排序前:{8,4,5,7,1,3,6,2} </p>\n<p>排序后:{1,2,3,4,5,6,7,8} </p>\n<p><strong>排序原理:</strong></p>\n<p>1.尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是1为止。</p>\n<p>2.将相邻的两个子组进行合并成一个有序的大组; </p>\n<p>3.不断的重复步骤2，直到最终只有一个组为止。</p>\n<p><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203132000258.png\" class=\"φcy\" alt=\"QQ20220313-195956@2x\"></p>\n<p><strong>归并排序API设计:</strong></p>\n<div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类别</th><th>Merge</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>Merge():创建Merge对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.<code>public static void sort(Comparable[] a)</code>:对数组内的元素进行排序<br/>2.<code>private static void sort(Comparable[] a, int lo, int hi)</code>:对数组a中从索引lo到索引hi之间的元素进 行排序<br/>3.<code>private static void merge(Comparable[] a, int lo, int mid, int hi)</code>:从索引lo到所以mid为一个子 组，从索引mid+1到索引hi为另一个子组，把数组a中的这两个子组的数据合并成一个有序的大组(从 索引lo到索引hi)<br/>4.<code>private static boolean less(Comparable v,Comparable w)</code>:判断v是否小于w<br/>5.<code>private static void exch(Comparable[] a,int i,int j)</code>:交换a数组中，索引i和索引j处的值</td></tr>\n<tr>\n<td>成员变量</td><td>1.<code>private static Comparable[] assist</code>:完成归并操作需要的辅助数组</td></tr>\n</tbody></table></div></div><p><strong>归并原理:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//排序代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Merge</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Comparable[] assist;<span class=\"comment\">//归并所需要的辅助数组</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        对数组a中的元素进行排序 </span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a)</span> </span>&#123;</span><br><span class=\"line\">        assist = <span class=\"keyword\">new</span> Comparable[a.length];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi = a.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        sort(a, lo, hi);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        对数组a中从lo到hi的元素进行排序</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hi &lt;= lo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> mid = lo + (hi - lo) / <span class=\"number\">2</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//对lo到mid之间的元素进行排序;</span></span><br><span class=\"line\">        sort(a, lo, mid);</span><br><span class=\"line\">        <span class=\"comment\">//对mid+1到hi之间的元素进行排序;</span></span><br><span class=\"line\">        sort(a, mid + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">        <span class=\"comment\">//对lo到mid这组数据和mid到hi这组数据进行归并 </span></span><br><span class=\"line\">        merge(a, lo, mid, hi);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        对数组中，从lo到mid为一组，从mid+1到hi为一组，对这两组数据进行归并</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">merge</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> mid, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//lo到mid这组数据和mid+1到hi这组数据归并到辅助数组assist对应的索引处 </span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> i = lo;<span class=\"comment\">//定义一个指针，指向assist数组中开始填充数据的索引</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p1 = lo;<span class=\"comment\">//定义一个指针，指向第一组数据的第一个元素</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> p2 = mid + <span class=\"number\">1</span>;<span class=\"comment\">//定义一个指针，指向第二组数据的第一个元素</span></span><br><span class=\"line\">        <span class=\"comment\">//比较左边小组和右边小组中的元素大小，哪个小，就把哪个数据填充到assist数组中 </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= hi) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (less(a[p1], a[p2])) &#123;</span><br><span class=\"line\">                assist[i++] = a[p1++];</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                assist[i++] = a[p2++];</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//上面的循环结束后，如果退出循环的条件是p1&lt;=mid，则证明左边小组中的数据已经归并完毕，如果退 出循环的条件是p2&lt;=hi,则证明右边小组的数据已经填充完毕;</span></span><br><span class=\"line\">        <span class=\"comment\">//所以需要把未填充完毕的数据继续填充到assist中</span></span><br><span class=\"line\">      \t<span class=\"comment\">//下面两个循环，只会执行其中的一个 </span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p1 &lt;= mid) &#123;</span><br><span class=\"line\">            assist[i++] = a[p1++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (p2 &lt;= hi) &#123;</span><br><span class=\"line\">            assist[i++] = a[p2++];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//到现在为止，assist数组中，从lo到hi的元素是有序的，再把数据拷贝到a数组中对应的索引处</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> index = lo; index &lt;= hi; index++) &#123;</span><br><span class=\"line\">            a[index] = assist[index];</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">        比较v元素是否小于w元素</span></span><br><span class=\"line\"><span class=\"comment\">    */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.compareTo(w) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* </span></span><br><span class=\"line\"><span class=\"comment\">        数组元素i和j交换位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        Comparable t = a[i];</span><br><span class=\"line\">        a[i] = a[j];</span><br><span class=\"line\">        a[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Integer[] arr = &#123;<span class=\"number\">8</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">7</span>, <span class=\"number\">1</span>, <span class=\"number\">3</span>, <span class=\"number\">6</span>, <span class=\"number\">2</span>&#125;;</span><br><span class=\"line\">        Merge.sort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>归并排序时间复杂度分析:</strong></p>\n<p>归并排序是分治思想的最典型的例子，上面的算法中，对a[lo…hi]进行排序，先将它分为a[lo…mid]和a[mid+1…hi] 两部分，分别通过递归调用将他们单独排序，最后将有序的子数组归并为最终的排序结果。该递归的出口在于如果 一个数组不能再被分为两个子数组，那么就会执行merge进行归并，在归并的时候判断元素的大小进行排序。</p>\n<p>用树状图来描述归并，如果一个数组有8个元素，那么它将每次除以2找最小的子数组，共拆log8次，值为3，所以 树共有3层,那么自顶向下第k层有2^k个子数组，每个数组的长度为2^(3-k)，归并最多需要2^(3-k)次比较。因此每层 的比较次数为 2^k * 2^(3-k)=2^3,那么3层总共为 3*2^3。</p>\n<p>假设元素的个数为n，那么使用归并排序拆分的次数为log2(n),所以共log2(n)层，那么使用log2(n)替换上面3<em>2^3中 的3这个层数，最终得出的归并排序的时间复杂度为:log2(n)\\</em> 2^(log2(n))=log2(n)*n,根据大O推导法则，忽略底 数，最终归并排序的时间复杂度为O(nlogn);</p>\n<p><strong>归并排序的缺点:</strong></p>\n<p>需要申请额外的数组空间，导致空间复杂度提升，是典型的以空间换时间的操作。</p>\n<p><strong>归并排序与希尔排序性能测试:</strong></p>\n<p>之前我们通过测试可以知道希尔排序的性能是由于插入排序的，那现在学习了归并排序后，归并排序的效率与希尔排序的效率哪个高呢?我们使用同样的测试方式来完成一样这两个排序算法之间的性能比较。</p>\n<p>在资料的测试数据文件夹下有一个reverse_arr.txt文件，里面存放的是从1000000到1的逆向数据，我们可以根据 这个批量数据完成测试。测试的思想:在执行排序前前记录一个时间，在排序完成后记录一个时间，两个时间的时 间差就是排序的耗时。</p>\n<p><strong>希尔排序和插入排序性能比较测试代码:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.io.BufferedReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.FileInputStream;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.io.InputStreamReader;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.ArrayList;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SortCompare</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        ArrayList&lt;Integer&gt; list = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</span><br><span class=\"line\">        <span class=\"comment\">//读取a.txt文件</span></span><br><span class=\"line\">        BufferedReader reader = <span class=\"keyword\">new</span> BufferedReader(<span class=\"keyword\">new</span> InputStreamReader(<span class=\"keyword\">new</span> FileInputStream(<span class=\"string\">\"reverse_merge_shell.txt\"</span>)));</span><br><span class=\"line\">        String line = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> ((line = reader.readLine()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//把每一个数字存入到集合中 </span></span><br><span class=\"line\">            list.add(Integer.valueOf(line));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        reader.close();</span><br><span class=\"line\">        <span class=\"comment\">//把集合转换成数组</span></span><br><span class=\"line\">        Integer[] arr = <span class=\"keyword\">new</span> Integer[list.size()];</span><br><span class=\"line\">        list.toArray(arr);</span><br><span class=\"line\"></span><br><span class=\"line\">        testMerge(arr);<span class=\"comment\">//使用归并排序耗时:1200 </span></span><br><span class=\"line\">        testShell(arr);<span class=\"comment\">//使用希尔排序耗时:1277</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testMerge</span><span class=\"params\">(Integer[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用插入排序完成测试</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Merge.sort(arr);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用归并排序耗时:\"</span> + (end - start));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">testShell</span><span class=\"params\">(Integer[] arr)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//使用希尔排序完成测试</span></span><br><span class=\"line\">        <span class=\"keyword\">long</span> start = System.currentTimeMillis();</span><br><span class=\"line\">        Shell.sort(arr);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> end = System.currentTimeMillis();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"使用希尔排序耗时:\"</span> + (end - start));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>通过测试，发现希尔排序和归并排序在处理大批量数据时差别不是很大。</p>\n<h3 id=\"快速排序\">快速排序<a href=\"#快速排序\" title=\"快速排序\"></a></h3><p>快速排序是对冒泡排序的一种改进。它的基本思想是:通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p>\n<p><strong>需求:</strong></p>\n<p>排序前:{6, 1, 2, 7, 9, 3, 4, 5, 8}</p>\n<p>排序后:{1, 2, 3, 4, 5, 6, 7, 8, 9}</p>\n<p><strong>排序原理:</strong> </p>\n<ol><li><p>首先设定一个分界值，通过该分界值将数组分成左右两部分;</p>\n</li>\n<li><p>将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时左边部分中各元素都小于 或等于分界值，而右边部分中各元素都大于或等于分界值;</p>\n</li>\n<li><p>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两 部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理。</p>\n</li>\n<li><p>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当 左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</p>\n</li>\n</ol><img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203140818320.png\" alt=\"QQ20220314-081115@2x\" style=\"zoom: 50%;\" /><div class=\"φcz\"><div class=\"φdb\"><table><thead><tr>\n<th>类别</th><th>Quick</th></tr>\n</thead><tbody><tr>\n<td>构造方法</td><td>Quick():创建Quick对象</td></tr>\n<tr>\n<td>成员方法</td><td>1.public static void sort(Comparable[] a):对数组内的元素进行排序<br/>2.private static void sort(Comparable[] a, int lo, int hi):对数组a中从索引lo到索引hi之间的元素 进行排序<br/>3.public static int partition(Comparable[] a,int lo,int hi):对数组a中，从索引 lo到索引 hi之间的元 素进行分组，并返回分组界限对应的索引<br/>4.private static boolean less(Comparable v,Comparable w):判断v是否小于w<br/>5.private static void exch(Comparable[] a,int i,int j):交换a数组中，索引i和索引j处的值</td></tr>\n</tbody></table></div></div><p><strong>切分原理:</strong></p>\n<p>把一个数组切分成两个子数组的基本思想: </p>\n<p>1.找一个基准值，用两个指针分别指向数组的头部和尾部; </p>\n<p>2.先从尾部向头部开始搜索一个比基准值小的元素，搜索到即停止，并记录指针的位置; </p>\n<p>3.再从头部向尾部开始搜索一个比基准值大的元素，搜索到即停止，并记录指针的位置; </p>\n<p>4.交换当前左边指针位置和右边指针位置的元素; </p>\n<p>5.重复2,3,4步骤，直到左边指针的值大于右边指针的值停止。</p>\n<p> <strong>快速排序代码实现:</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> java.util.Arrays;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//排序代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Quick</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> lo = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> hi = a.length - <span class=\"number\">1</span>;</span><br><span class=\"line\">        sort(a, lo, hi);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (hi &lt;= lo) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//对a数组中，从lo到hi的元素进行切分</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> partition = partition(a, lo, hi);</span><br><span class=\"line\">        <span class=\"comment\">//对左边分组中的元素进行排序</span></span><br><span class=\"line\">        <span class=\"comment\">//对右边分组中的元素进行排序</span></span><br><span class=\"line\">        sort(a, lo, partition - <span class=\"number\">1</span>);</span><br><span class=\"line\">        sort(a, partition + <span class=\"number\">1</span>, hi);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">partition</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> lo, <span class=\"keyword\">int</span> hi)</span> </span>&#123;</span><br><span class=\"line\">        Comparable key = a[lo];<span class=\"comment\">//把最左边的元素当做基准值</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> left = lo;<span class=\"comment\">//定义一个左侧指针，初始指向最左边的元素</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> right = hi + <span class=\"number\">1</span>;<span class=\"comment\">//定义一个右侧指针，初始指向左右侧的元素下一个位置 //进行切分</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (<span class=\"keyword\">true</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//先从右往左扫描，找到一个比基准值小的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (less(key, a[--right])) &#123;<span class=\"comment\">//循环停止，证明找到了一个比基准值小的元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (right == lo) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//已经扫描到最左边了，无需继续扫描</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//再从左往右扫描，找一个比基准值大的元素</span></span><br><span class=\"line\">            <span class=\"keyword\">while</span> (less(a[++left], key)) &#123;<span class=\"comment\">//循环停止，证明找到了一个比基准值大的元素</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (left == hi) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;<span class=\"comment\">//已经扫描到了最右边了，无需继续扫描</span></span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (left &gt;= right) &#123; <span class=\"comment\">//扫描完了所有元素，结束循环</span></span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123; <span class=\"comment\">//交换left和right索引处的元素</span></span><br><span class=\"line\">                exch(a, left, right);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//交换最后rigth索引处和基准值所在的索引处的值</span></span><br><span class=\"line\">        exch(a, lo, right);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> right;<span class=\"comment\">//right就是切分的界限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 数组元素i和j交换位置</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">exch</span><span class=\"params\">(Comparable[] a, <span class=\"keyword\">int</span> i, <span class=\"keyword\">int</span> j)</span> </span>&#123;</span><br><span class=\"line\">        Comparable t = a[i];</span><br><span class=\"line\">        a[i] = a[j];</span><br><span class=\"line\">        a[j] = t;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/* 比较v元素是否小于w元素</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">less</span><span class=\"params\">(Comparable v, Comparable w)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> v.compareTo(w) &lt; <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//测试代码</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Test</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> <span class=\"keyword\">throws</span> Exception </span>&#123;</span><br><span class=\"line\">        Integer[] arr = &#123;<span class=\"number\">6</span>, <span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">7</span>, <span class=\"number\">9</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">8</span>&#125;;</span><br><span class=\"line\">        Quick.sort(arr);</span><br><span class=\"line\">        System.out.println(Arrays.toString(arr));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>快速排序和归并排序的区别:</strong></p>\n<p>快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的:<strong>归并排序</strong>将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而<strong>快速排序</strong>的方式则是当两个数组都有序时，整个数组自然就有序了。在<strong>归并排序</strong>中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在<strong>快速排序</strong>中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</p>\n<p><strong>快速排序时间复杂度分析:</strong></p>\n<p>快速排序的一次切分从两头开始交替搜索，直到left和right重合，因此，一次切分算法的时间复杂度为O(n),但整个 快速排序的时间复杂度和切分的次数相关。</p>\n<p>最优情况:每一次切分选择的基准数字刚好将当前序列等分。</p>\n<img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203141042812.png\" alt=\"QQ20220314-104209@2x\" style=\"zoom:50%;\" /><p>如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了logn次，所以，最优情况下快 速排序的时间复杂度为O(nlogn);</p>\n<p>最坏情况:每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总 共就得切分n次，所以，最坏情况下，快速排序的时间复杂度为O(n^2);</p>\n<img src=\"https://cdn.jsdelivr.net/gh/autumndx/cdn/img/Data_structure/202203141044922.png\" alt=\"QQ20220314-104337@2x\" style=\"zoom:50%;\" /><p>平均情况:每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的时间复杂度为O(nlogn),由于数学归纳法有很多数学相关的知识，容易使我们混乱，所以这里就不对 平均情况的时间复杂度做证明了。</p>\n<h3 id=\"排序的稳定性\">排序的稳定性<a href=\"#排序的稳定性\" title=\"排序的稳定性\"></a></h3>","next":{"title":"Macbook优化","link":"posts/3c3fd7cd"},"plink":"https://dxsummer.gitee.io/posts/10b828c8/","toc":[{"id":"算法分析","title":"算法分析","index":"1","children":[{"id":"时间复杂度分析","title":"时间复杂度分析","index":"1.1"},{"id":"空间复杂度分析","title":"空间复杂度分析","index":"1.2","children":[{"id":"java中常见内存占用","title":"java中常见内存占用","index":"1.2.1"},{"id":"算法的空间复杂度","title":"算法的空间复杂度","index":"1.2.2"}]}]},{"id":"排序","title":"排序","index":"2","children":[{"id":"简单排序","title":"简单排序","index":"2.1","children":[{"id":"comparable接口介绍","title":"Comparable接口介绍","index":"2.1.1"},{"id":"冒泡排序","title":"冒泡排序","index":"2.1.2"},{"id":"选择排序","title":"选择排序","index":"2.1.3"},{"id":"插入排序","title":"插入排序","index":"2.1.4"}]},{"id":"高级排序","title":"高级排序","index":"2.2","children":[{"id":"希尔排序","title":"希尔排序","index":"2.2.1"},{"id":"归并排序","title":"归并排序","index":"2.2.2","children":[{"id":"递归","title":"递归","index":"2.2.2.1"},{"id":"归并排序-1","title":"归并排序","index":"2.2.2.2"}]},{"id":"快速排序","title":"快速排序","index":"2.2.3"},{"id":"排序的稳定性","title":"排序的稳定性","index":"2.2.4"}]}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/10b828c8/\" title=\"数据结构(蓝桥杯)\">https://dxsummer.gitee.io/posts/10b828c8/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2022年3月11日","updated":"2022年3月14日"}}