{"title":"Step7 函数","date":"2020-06-10T12:21:48.000Z","date_formatted":{"ll":"2020年6月10日","L":"2020/06/10","MM-DD":"06-10"},"link":"posts/71adb096","comments":true,"tags":["C语言基础"],"categories":["C语言"],"updated":"2020-06-12T03:39:08.536Z","content":"<p>本章介绍以下内容：</p>\n<p>关键字：<code>return</code></p>\n<p>运算符：<code>*</code>（一元）、<code>&amp;</code>（一元）</p>\n<ul><li>函数及其定义方式</li>\n<li>如何使用参数和返回值</li>\n<li>如何把指针变量用作函数参数</li>\n<li>函数类型</li>\n<li>ANSI C原型</li>\n<li>递归</li>\n</ul><p>如何组织程序？C的设计思想是，把函数用作构件块。我们已经用过C标准库的函数，如<code>printf()</code>、<code>scanf()</code>、<code>getchar()</code>、<code>putchar()</code>和 <code>strlen()</code>。现在要进一步学习如何创建自己的函数。前面章节中已大致介绍了相关过程，本章将巩固以前学过的知识并做进一步的拓展。</p>\n<h2 id=\"复习函数\">复习函数<a href=\"#复习函数\" title=\"复习函数\"></a></h2><p>首先，什么是函数？函数（function）是完成特定任务的独立程序代码单元。语法规则定义了函数的结构和使用方式。虽然C中的函数和其他语言中的函数、子程序、过程作用相同，但是细节上略有不同。一些函数执行某些动作，如<code>printf()</code>把数据打印到屏幕上；一些函数找出一个值供程序使用，如<code>strlen()</code>把指定字符串的长度返回给程序。一般而言，函数可以同时具备以上两种功能。</p>\n<p>为什么要使用函数？首先，使用函数可以省去编写重复代码的苦差。如果程序要多次完成某项任务，那么只需编写一个合适的函数，就可以在需要时使用这个函数，或者在不同的程序中使用该函数，就像许多程序中使用<code>putchar()</code>一样。其次，即使程序只完成某项任务一次，也值得使用函数。因为函数让程序更加模块化，从而提高了程序代码的可读性，更方便后期修改、完善。例如，假设要编写一个程序完成以下任务：</p>\n<p>读入一系列数字；</p>\n<p>分类这些数字；</p>\n<p>找出这些数字的平均值；</p>\n<p>打印一份柱状图。</p>\n<p>可以使用下面的程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SIZE　50</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">float</span> <span class=\"built_in\">list</span>[SIZE];</span><br><span class=\"line\">    readlist(<span class=\"built_in\">list</span>,SIZE);</span><br><span class=\"line\">    sort(<span class=\"built_in\">list</span>,SIZE);</span><br><span class=\"line\">    average(<span class=\"built_in\">list</span>,SIZE);</span><br><span class=\"line\">    bargraph(<span class=\"built_in\">list</span>,SIZE);</span><br><span class=\"line\">    returnb <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>当然，还要编写4个函数<code>readlist()</code>、<code>sort()</code>、<code>average()</code>和<code>bargraph()</code>的实现细节。描述性的函数名能清楚地表达函数的用途和组织结构。然后，单独设计和测试每个函数，直到函数都能正常完成任务。如果这些函数够通用，还可以用于其他程序。</p>\n<p>许多程序员喜欢把函数看作是根据传入信息（输入）及其生成的值或响应的动作（输出）来定义的“黑盒”。如果不是自己编写函数，根本不用关心黑盒的内部行为。例如，使用<code>printf()</code>时，只需知道给该函数传入格式字符串或一些参数以及 <code>printf()</code>生成的输出，无需了解 <code>printf()</code>的内部代码。以这种方式看待函数有助于把注意力集中在程序的整体设计，而不是函数的实现细节上。因此，在动手编写代码之前，仔细考虑一下函数应该完成什么任务，以及函数和程序整体的关系。</p>\n<p>如何了解函数？首先要知道如何正确地定义函数、如何调用函数和如何建立函数间的通信。我们从一个简单的程序示例开始，帮助读者理清这些内容，然后再详细讲解。</p>\n<h3 id=\"创建并使用简单函数\">创建并使用简单函数<a href=\"#创建并使用简单函数\" title=\"创建并使用简单函数\"></a></h3><p>我们的第1个目标是创建一个在一行打印40个星号的函数，并在一个打印表头的程序中使用该函数。如程序清单9.1所示，该程序由<code>main()</code>和<code>starbar()</code>组成。</p>\n<p>程序清单9.1 lethead1.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* lethead1.c */</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> NAME　<span class=\"meta-string\">\"GIGATHINK, INC.\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> ADDRESS　<span class=\"meta-string\">\"101　Megabuck　Plaza\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> PLACE　<span class=\"meta-string\">\"Megapolis,　CA　94904\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> WIDTH　40</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">starbar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;　<span class=\"comment\">/* 函数原型 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    starbar();</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,NAME);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,ADDRESS);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,PLACE);</span><br><span class=\"line\">    starbar();　　　<span class=\"comment\">/* 使用函数 */</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">starbar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span>　<span class=\"comment\">/* 定义函数　 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(count=<span class=\"number\">1</span>;count&lt;=WIDTH;count++)</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'*'</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">****************************************</span><br><span class=\"line\">GIGATHINK,　INC.</span><br><span class=\"line\"><span class=\"number\">101</span>　Megabuck　Plaza</span><br><span class=\"line\">Megapolis,　CA　<span class=\"number\">94904</span></span><br><span class=\"line\">****************************************</span><br></pre></td></tr></table></figure><h3 id=\"分析程序\">分析程序<a href=\"#分析程序\" title=\"分析程序\"></a></h3><p>该程序要注意以下几点。</p>\n<p>程序在3处使用了<code>starbar</code>标识符：函数原型（function prototype）告诉编译器函数<code>starbar()</code>的类型；函数调用（function call）表明在此处执行函数；函数定义（function definition）明确地指定了函数要做什么。</p>\n<p>函数和变量一样，有多种类型。任何程序在使用函数之前都要声明该函数的类型。因此，在main()函数定义的前面出现了下面的ANSI C风格的函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">starbar</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>圆括号表明<code>starbar</code>是一个函数名。第1个<code>void</code>是函数类型，<code>void</code>类型表明函数没有返回值。第2个<code>void</code>（在圆括号中）表明该函数不带参数。分号表明这是在声明函数，不是定义函数。也就是说，这行声明了程序将使用一个名为<code>starbar()</code>、没有返回值、没有参数的函数，并告诉编译器在别处查找该函数的定义。对于不识别ANSI C风格原型的编译器，只需声明函数的类型，如下所示：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">starbar</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><p>注意，一些老版本的编译器甚至连<code>void</code>都识别不了。如果使用这种编译器，就要把没有返回值的函数声明为<code>int</code>类型。当然，最好还是换一个新的编译器。</p>\n<p>一般而言，函数原型指明了函数的返回值类型和函数接受的参数类型。这些信息称为该<strong>函数的签名</strong>（signature）。对于<code>starbar()</code>函数而言，其签名是该函数没有返回值，没有参数。</p>\n<p>程序把 <code>starbar()</code>原型置于 <code>main()</code>的前面。当然，也可以放在 <code>main()</code>里面的声明变量处。放在哪个位置都可以。</p>\n<p>在<code>main()</code>中，执行到下面的语句时调用了<code>starbar()</code>函数：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">starbar();</span><br></pre></td></tr></table></figure><p>这是调用<code>void</code>类型函数的一种形式。当计算机执行到<code>starbar();</code>语句时，会找到该函数的定义并执行其中的内容。执行完<code>starbar()</code>中的代码后，计算机返回主调函数（calling function）继续执行下一行（本例中，主调函数是<code>main()</code>），见图9.1（更确切地说，编译器把C程序翻译成执行以上操作的机器语言代码）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/lethead1.c.png\" class=\"φcy\"></p>\n<p>程序中<code>strarbar()</code>和<code>main()</code>的定义形式相同。首先函数头包括函数类型、函数名和圆括号，接着是左花括号、变量声明、函数表达式语句，最后以右花括号结束（见图9.2）。注意，函数头中的<code>starbar()</code>后面没有分号，告诉编译器这是定义<code>starbar()</code>，而不是调用函数或声明函数原型。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/简单函数的结构.png\" class=\"φcy\"></p>\n<p>程序把 <code>starbar()</code>和 <code>main()</code>放在一个文件中。当然，也可以把它们分别放在两个文件中。把函数都放在一个文件中的单文件形式比较容易编译，而使用多个文件方便在不同的程序中使用同一个函数。如果把函数放在一个单独的文件中，要把<code>#define</code> 和<code>#include</code> 指令也放入该文件。我们稍后会讨论使用多个文件的情况。现在，先把所有的函数都放在一个文件中。<code>main()</code>的右花括号告诉编译器该函数结束的位置，后面的<code>starbar()</code>函数头告诉编译器<code>starbar()</code>是一个函数。</p>\n<p><code>starbar()</code>函数中的变量<code>count</code>是局部变量（local variable），意思是该变量只属于<code>starbar()</code>函数。可以在程序中的其他地方（包括<code>main()</code>中）使用<code>count</code>，这不会引起名称冲突，它们是同名的不同变量。</p>\n<p>如果把<code>starbar()</code>看作是一个黑盒，那么它的行为是打印一行星号。不用给该函数提供任何输入，因为调用它不需要其他信息。而且，它没有返回值，所以也不给 <code>main()</code>提供（或返回）任何信息。简而言之，<code>starbar()</code>不需要与主调函数通信。</p>\n<p>接下来介绍一个函数间需要通信的例子。</p>\n<h3 id=\"函数参数\">函数参数<a href=\"#函数参数\" title=\"函数参数\"></a></h3><p>在程序清单9.1的输出中，如果文字能居中，信头会更加美观。可以通过在打印文字之前打印一定数量的空格来实现，这和打印一定数量的星号（starbar()函数）类似，只不过现在要打印的是一定数量的空格。虽然这是两个任务，但是任务非常相似，与其分别为它们编写一个函数，不如写一个更通用的函数，可以在两种情况下使用。我们设计一个新的函数<code>show_n_char()</code>（显示一个字符n次）。唯一要改变的是使用内置的值来显示字符和重复的次数，<code>show_n_char()</code>将使用函数参数来传递这些值。</p>\n<p>我们来具体分析。假设可用的空间是40个字符宽。调用<code>show_n_char(&#39;*&#39;, 40)</code>应该正好打印一行40个星号，就像<code>starbar()</code>之前做的那样。第2行<code>GIGATHINK, INT.</code>的空格怎么处理？<code>GIGATHINK, INT.</code>是15个字符宽，所以第1个版本中，文字后面有25个空格。为了让文字居中，文字的左侧应该有12个空格，右侧有13个空格。因此，可以调用<code>show_n_char(&#39;*&#39;, 12)</code>。</p>\n<p><code>show_n_char()</code>与<code>starbar()</code>很相似，但是<code>show_n_char()</code>带有参数。从功能上看，前者不会添加换行符，而后者会，因为<code>show_n_char()</code>要把空格和文本打印成一行。程序清单9.2是修改后的版本。为强调参数的工作原理，程序使用了不同的参数形式。</p>\n<p>程序清单9.2 lethead2.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* lethead2.c */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">&lt;string.h&gt;　　　　　/* 为strlen()提供原型 */</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　NAME　<span class=\"meta-string\">\"GIGATHINK,　INC.\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　ADDRESS　<span class=\"meta-string\">\"101　Megabuck　Plaza\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　PLACE　<span class=\"meta-string\">\"Megapolis,　CA　94904\"</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　WIDTH　40</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　SPACE　<span class=\"meta-string\">'　'</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">(<span class=\"keyword\">char</span>　ch,　<span class=\"keyword\">int</span>　num)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> spaces;</span><br><span class=\"line\">    show_n_char(<span class=\"string\">'*'</span>, WIDTH);　　　　　　　　<span class=\"comment\">/* 用符号常量作为参数 */</span></span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    show_n_char(SPACE, <span class=\"number\">12</span>);　　　　　　　　 <span class=\"comment\">/* 用符号常量作为参数 */</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,　NAME);</span><br><span class=\"line\">    spaces = (WIDTH - <span class=\"built_in\">strlen</span>(ADDRESS))/<span class=\"number\">2</span>; <span class=\"comment\">/* 计算要跳过多少个空格*/</span></span><br><span class=\"line\">    show_n_char(SPACE, spaces);　　　　　　 <span class=\"comment\">/* 用一个变量作为参数*/</span></span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>,　ADDRESS);</span><br><span class=\"line\">    show_n_char(SPACE,(WIDTH-<span class=\"built_in\">strlen</span>(PLACE))/<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s\\n\"</span>, PLACE);　　　　　　　　　<span class=\"comment\">/* 用一个表达式作为参数　 */</span></span><br><span class=\"line\">    show_n_char(<span class=\"string\">'*'</span>, WIDTH);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">/* show_n_char()函数的定义 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">(<span class=\"keyword\">char</span> ch,<span class=\"keyword\">int</span> num)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> count;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(count=<span class=\"number\">1</span>;count&lt;=num;count++)</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(ch);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该函数的运行结果如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">**************************************</span><br><span class=\"line\">\t\tGIGATHINK,　INC.</span><br><span class=\"line\">\t  <span class=\"number\">101</span>　Megabuck　Plaza</span><br><span class=\"line\">\t Megapolis,　CA　<span class=\"number\">94904</span></span><br><span class=\"line\">****************************************</span><br></pre></td></tr></table></figure><p>下面我们回顾一下如何编写一个带参数的函数，然后介绍这种函数的用法。</p>\n<h3 id=\"定义带形式参数的函数\">定义带形式参数的函数<a href=\"#定义带形式参数的函数\" title=\"定义带形式参数的函数\"></a></h3><p>函数定义从下面的ANSI C风格的函数头开始：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">(<span class=\"keyword\">char</span> ch,<span class=\"keyword\">int</span> num)</span></span></span><br></pre></td></tr></table></figure><p>该行告知编译器<code>show_n_char()</code>使用两个参数<code>ch</code>和<code>num</code>，ch是<code>char</code>类型，num是<code>int</code>类型。这两个变量被称为<strong>形式参数</strong>（formal argument，但是最近的标准推荐使用formal parameter），简称<strong>形参</strong>。和定义在函数中变量一样，形式参数也是<strong>局部变量</strong>，属该函数私有。这意味着在其他函数中使用同名变量不会引起名称冲突。每次调用函数，就会给这些变量赋值。</p>\n<p>注意，ANSI C要求在每个变量前都声明其类型。也就是说，不能像普通变量声明那样使用同一类型的变量列表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dibs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, y, z)</span>　　　　 <span class=\"comment\">/* 无效的函数头 */</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dubs</span><span class=\"params\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y, <span class=\"keyword\">int</span> z)</span> <span class=\"comment\">/* 有效的函数头 */</span></span></span><br></pre></td></tr></table></figure><p>ANSI C也接受ANSI C之前的形式，但是将其视为废弃不用的形式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">(ch,num)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">char</span> ch</span>;</span><br><span class=\"line\"><span class=\"keyword\">int</span> num;</span><br></pre></td></tr></table></figure><p>这里，圆括号中只有参数名列表，而参数的类型在后面声明。注意，普通的局部变量在左花括号之后声明，而上面的变量在函数左花括号之前声明。如果变量是同一类型，这种形式可以用逗号分隔变量名列表，如下所示：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">dibs</span><span class=\"params\">(x,y,z)</span></span></span><br><span class=\"line\">int x,y,z;　　　/* 有效 */</span><br></pre></td></tr></table></figure><p>当前的标准正逐渐淘汰 ANSI 之前的形式。读者应对此有所了解，以便能看懂以前编写的程序，但是自己编写程序时应使用现在的标准形式（C99和C11标准继续警告这些过时的用法即将被淘汰）。</p>\n<p>虽然<code>show_n_char()</code>接受来自<code>main()</code>的值，但是它没有返回值。因此，<code>show_n_char()</code>的类型是<code>void</code>。</p>\n<p>下面，我们来学习如何使用函数。</p>\n<h3 id=\"声明带形式参数函数的原型\">声明带形式参数函数的原型<a href=\"#声明带形式参数函数的原型\" title=\"声明带形式参数函数的原型\"></a></h3><p>在使用函数之前，要用ANSI C形式声明函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">(<span class=\"keyword\">char</span> ch, <span class=\"keyword\">int</span> num)</span></span>;</span><br></pre></td></tr></table></figure><p>当函数接受参数时，函数原型用逗号分隔的列表指明参数的数量和类型。根据个人喜好，你也可以省略变量名：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">(<span class=\"keyword\">char</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>在原型中使用变量名并没有实际创建变量，<code>char</code>仅代表了一个<code>char</code>类型的变量，以此类推。再次提醒读者注意，ANSI C也接受过去的声明函数形式，即圆括号内没有参数列表：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">show_n_char</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><p>这种形式最终会从标准中剔除。即使没有被剔除，现在函数原型的设计也更有优势（稍后会介绍）。了解这种形式的写法是为了以后读得懂以前写的代码。</p>\n<h3 id=\"调用带实际参数的函数\">调用带实际参数的函数<a href=\"#调用带实际参数的函数\" title=\"调用带实际参数的函数\"></a></h3><p>在函数调用中，实际参数（actual argument，简称实参）提供了<code>ch</code>和<code>num</code>的值。考虑程序清单9.2中第1次调用<code>show_n_char()</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show_n_char(SPACE,<span class=\"number\">12</span>);</span><br></pre></td></tr></table></figure><p>实际参数是空格字符和12。这两个值被赋给<code>show_n_char()</code>中相应的形式参数：变量ch和num。简而言之，形式参数是被调函数（called function）中的变量，实际参数是主调函数（calling function）赋给被调函数的具体值。如上例所示，实际参数可以是常量、变量，或甚至是更复杂的表达式。无论实际参数是何种形式都要被求值，然后该值被拷贝给被调函数相应的形式参数。以程序清单 9.2 中最后一次调用<code>show_n_char()</code>为例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">show_n_char(SPACE,(WIDTH - <span class=\"built_in\">strlen</span>(PLACE))/<span class=\"number\">2</span>);</span><br></pre></td></tr></table></figure><p>构成该函数第2个实际参数的是一个很长的表达式，对该表达式求值为10。然后，10被赋给变量num。被调函数不知道也不关心传入的数值是来自常量、变量还是一般表达式。再次强调，实际参数是具体的值，该值要被赋给作为形式参数的变量（见图 9.3）。因为被调函数使用的值是从主调函数中拷贝而来，所以无论被调函数对拷贝数据进行什么操作，都不会影响主调函数中的原始数据。</p>\n<p>注意 实际参数和形式参数</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/形式参数和实际参数.png\" class=\"φcy\"></p>\n<p>实际参数是出现在函数调用圆括号中的表达式。形式参数是函数定义的函数头中声明的变量。调用函数时，创建了声明为形式参数的变量并初始化为实际参数的求值结果。程序清单 9.2 中，<code>&#39;*&#39;</code>和<code>WIDTH</code>都是第1次调用<code>show_n_char()</code>时的实际参数，而<code>SPACE</code>和<code>11</code>是第2次调用<code>show_n_char()</code>时的实际参数。在函数定义中，ch和num都是该函数的形式参数。</p>\n<h3 id=\"黑盒视角\">黑盒视角<a href=\"#黑盒视角\" title=\"黑盒视角\"></a></h3><p>从黑盒的视角看 <code>show_n_char()</code>，待显示的字符和显示的次数是输入。执行后的结果是打印指定数量的字符。输入以参数的形式被传递给函数。这些信息清楚地表明了如何在 <code>main()</code>中使用该函数。而且，这也可以作为编写该函数的设计说明。</p>\n<p>黑盒方法的核心部分是：<code>ch</code>、<code>num</code>和<code>count</code>都是<code>show_n_char()</code>私有的局部变量。如果在<code>main()</code>中使用同名变量，那么它们相互独立，互不影响。也就是说，如果<code>main()</code>有一个<code>count</code>变量，那么改变它的值不会改变<code>show_n_char()</code>中的<code>count</code>，反之亦然。黑盒里发生了什么对主调函数是不可见的。</p>\n<h3 id=\"使用return从函数中返回值\">使用return从函数中返回值<a href=\"#使用return从函数中返回值\" title=\"使用return从函数中返回值\"></a></h3><p>前面介绍了如何把信息从主调函数传递给被调函数。反过来，函数的返回值可以把信息从<strong>被调函数</strong>传回<strong>主调函数</strong>。为进一步说明，我们将创建一个返回两个参数中较小值的函数。由于函数被设计用来处理<code>int</code>类型的值，所以被命名为<code>imin()</code>。另外，还要创建一个简单的<code>main()</code>，用于检查<code>imin()</code>是否正常工作。这种被设计用于测试函数的程序有时被称为<strong>驱动程序</strong>（driver），该驱动程序调用一个函数。如果函数成功通过了测试，就可以安装在一个更重要的程序中使用。程序清单9.3演示了这个驱动程序和返回最小值的函数。</p>\n<p>程序清单9.3 lesser.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* lesser.c -- 找出两个整数中较小的一个 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imin</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> evil1,evil2;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　a　pair　of　integers　(q　to　quit):\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d　%d\"</span>,&amp;evil1,&amp;evil2)　==　<span class=\"number\">2</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　lesser　of　%d　and　%d　is　%d.\\n\"</span>,</span><br><span class=\"line\">        evil1,evil2,imin(evil1,evil2));</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　a　pair　of　integers　(q　to　quit):\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Bye.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imin</span><span class=\"params\">(<span class=\"keyword\">int</span>　n,　<span class=\"keyword\">int</span>　m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> <span class=\"built_in\">min</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n　&lt;　m)</span><br><span class=\"line\">    \t<span class=\"built_in\">min</span>　=　n;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    \t<span class=\"built_in\">min</span>　=　m;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"built_in\">min</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>回忆一下，scanf()返回成功读数据的个数，所以如果输入不是两个整数会导致循环终止。下面是一个运行示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Enter　a　pair　of　<span class=\"title\">integers</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\"><span class=\"function\">509　333</span></span><br><span class=\"line\">The　lesser　of　509　and　333　is　333.</span><br><span class=\"line\"><span class=\"function\">Enter　a　pair　of　<span class=\"title\">integers</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\">-9393　6</span><br><span class=\"line\">The　lesser　of　<span class=\"number\">-9393</span>　<span class=\"keyword\">and</span>　<span class=\"number\">6</span>　is　<span class=\"number\">-9393.</span></span><br><span class=\"line\"><span class=\"function\">Enter　a　pair　of　<span class=\"title\">integers</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\"><span class=\"function\">q</span></span><br><span class=\"line\">Bye.</span><br></pre></td></tr></table></figure><p>关键字<code>return</code>后面的表达式的值就是函数的返回值。在该例中，该函数返回的值就是变量<code>min</code>的值。因为<code>min</code>是<code>int</code>类型的变量，所以<code>imin()</code>函数的类型也是<code>int</code>。</p>\n<p>变量<code>min</code>属于<code>imin()</code>函数私有，但是<code>return</code>语句把<code>min</code>的值传回了主调函数。下面这条语句的作用是把<code>min</code>的值赋给<code>lesser</code>:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">lesser = imin(n,m);</span><br></pre></td></tr></table></figure><p>是否能像写成下面这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imin(n,m);</span><br><span class=\"line\">lesser = <span class=\"built_in\">min</span>;</span><br></pre></td></tr></table></figure><p>不能。因为主调函数甚至不知道<code>min</code>的存在。记住，<code>imin()</code>中的变量是<code>imin()</code>的局部变量。函数调用<code>imin(evil1, evil2)</code>只是把两个变量的值拷贝了一份。</p>\n<p>返回值不仅可以赋给变量，也可以被用作表达式的一部分。例如，可以这样：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">answer = <span class=\"number\">2</span> * imin(z, zstar) + <span class=\"number\">25</span>;</span><br><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d\\n\"</span>, imin(<span class=\"number\">-32</span> + answer, LIMIT));</span><br></pre></td></tr></table></figure><p><strong>返回值不一定是变量的值，也可以是任意表达式的值。</strong>例如，可以用以下的代码简化程序示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* 返回最小值的函数，第2个版本 */</span></span><br><span class=\"line\">imin(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> m)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"><span class=\"keyword\">return</span> (n&lt;m)?n:m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>条件表达式的值是n和m中的较小者，该值要被返回给主调函数。虽然这里不要求用圆括号把返回值括起来，但是如果想让程序条理更清楚或统一风格，可以把返回值放在圆括号内。</p>\n<p>如果函数返回值的类型与函数声明的类型不匹配会怎样？</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">what_if</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> z=<span class=\"number\">100.0</span>/(<span class=\"keyword\">double</span>)n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> z; <span class=\"comment\">// 会发生什么？</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>实际得到的返回值相当于把函数中指定的返回值赋给与函数类型相同的变量所得到的值。因此在本例中，相当于把z的值赋给int类型的变量，然后返回int类型变量的值。例如，假设有下面的函数调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">result=what_if(<span class=\"number\">64</span>);</span><br></pre></td></tr></table></figure><p>虽然在<code>what_if()</code>函数中赋给z的值是<code>1.5625</code>，但是<code>return</code>语句返回确实<code>int</code>类型的值1。</p>\n<p>使用 <code>return</code> 语句的另一个作用是，终止函数并把控制返回给主调函数的下一条语句。因此，可以这样编写<code>imin()</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*返回最小值的函数，第3个版本*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">imin(<span class=\"keyword\">int</span> n,<span class=\"keyword\">int</span> m)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n　&lt;　m)</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span>　n;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span>　m;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>许多C程序员都认为只在函数末尾使用一次<code>return</code>语句比较好，因为这样做更方便浏览程序的人理解函数的控制流。但是，在函数中使用多个<code>return</code>语句也没有错。无论如何，对用户而言，这3个版本的函数用起来都一样，因为所有的输入和输出都完全相同，不同的是函数内部的实现细节。下面的版本也没问题：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*返回最小值的函数，第4个版本*/</span></span><br><span class=\"line\"></span><br><span class=\"line\">imin(<span class=\"keyword\">int</span>　n,<span class=\"keyword\">int</span>　m)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&lt;m)</span><br><span class=\"line\">    \t<span class=\"keyword\">return</span>　n;</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span>　m;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Professor　Fleppard　is　like　totally　a　fopdoodle.\\n\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><code>return</code>语句导致<code>printf()</code>语句永远不会被执行。如果Fleppard教授在自己的程序中使用这个版本的函数，可能永远不知道编写这个函数的学生对他的看法。</p>\n<p>另外，还可以这样使用<code>return</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span>;</span><br></pre></td></tr></table></figure><p>这条语句会导致终止函数，并把控制返回给主调函数。因为 <code>return</code> 后面没有任何表达式，所以没有返回值，只有在<code>void</code>函数中才会用到这种形式。</p>\n<h3 id=\"函数类型\">函数类型<a href=\"#函数类型\" title=\"函数类型\"></a></h3><p>声明函数时必须声明函数的类型。带返回值的函数类型应该与其返回值类型相同，而没有返回值的函数应声明为<code>void</code>类型。如果没有声明函数的类型，旧版本的C编译器会假定函数的类型是<code>int</code>。这一惯例源于C的早期，那时的函数绝大多数都是<code>int</code>类型。然而，C99标准不再支持<code>int</code>类型函数的这种假定设置。</p>\n<p>类型声明是函数定义的一部分。要记住，函数类型指的是返回值的类型，不是函数参数的类型。例如，下面的函数头定义了一个带两个<code>int</code>类型参数的函数，但是其返回值是<code>double</code>类型。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">klink</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span></span><br></pre></td></tr></table></figure><p>要正确地使用函数，程序在第 1 次使用函数之前必须知道函数的类型。方法之一是，把完整的函数定义放在第1次调用函数的前面。然而，这种方法增加了程序的阅读难度。而且，要使用的函数可能在C库或其他文件中。因此，通常的做法是提前声明函数，把函数的信息告知编译器。例如，程序清单 9.3 中的<code>main()</code>函数包含以下几行代码：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imin</span><span class=\"params\">(<span class=\"keyword\">int</span>,<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> evil1,evil2,lesser;</span><br></pre></td></tr></table></figure><p>第2行代码说明<code>imin</code>是一个函数名，有两个<code>int</code>类型的形参，且返回<code>int</code>类型的值。现在，编译器在程序中调用<code>imin()</code>函数时就知道应该如何处理。</p>\n<p>在程序清单9.3中，我们把函数的前置声明放在主调函数外面。当然，也可以放在主调函数里面。例如，重写lesser.c（程序清单9.3）的开头部分：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imin</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>; <span class=\"comment\">/* 声明imin()函数的原型*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> evil1,evil2,lesser;</span><br></pre></td></tr></table></figure><p>注意在这两种情况中，函数原型都声明在使用函数之前。</p>\n<p>ANSI C标准库中，函数被分成多个系列，每一系列都有各自的头文件。这些头文件中除了其他内容，还包含了本系列所有函数的声明。例如，<code>stdio.h</code> 头文件包含了标准 I/O 库函数（如，<code>printf()</code>和<code>scanf()</code>）的声明。<code>math.h</code>头文件包含了各种数学函数的声明。例如，下面的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">double</span> <span class=\"title\">sqrt</span><span class=\"params\">(<span class=\"keyword\">double</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>告知编译器<code>sqrt()</code>函数有一个<code>double</code>类型的形参，而且返回<code>double</code>类型的值。不要混淆函数的声明和定义。函数声明告知编译器函数的类型，而函数定义则提供实际的代码。在程序中包含 <code>math.h</code> 头文件告知编译器：<code>sqrt()</code>返回<code>double</code>类型，但是<code>sqrt()</code>函数的代码在另一个库函数的文件中。</p>\n<h2 id=\"ansi-c函数原型\">ANSI C函数原型<a href=\"#ansi-c函数原型\" title=\"ANSI C函数原型\"></a></h2><p>在ANSI C标准之前，声明函数的方案有缺陷，因为只需要声明函数的类型，不用声明任何参数。下面我们看一下使用旧式的函数声明会导致什么问题。</p>\n<p>下面是ANSI之前的函数声明，告知编译器<code>imin()</code>返回<code>int</code>类型的值：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imin</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><p>然而，以上函数声明并未给出<code>imin()</code>函数的参数个数和类型。因此，如果调用<code>imin()</code>时使用的参数个数不对或类型不匹配，编译器根本不会察觉出来。</p>\n<h3 id=\"问题所在\">问题所在<a href=\"#问题所在\" title=\"问题所在\"></a></h3><p>我们看看与<code>imax()</code>函数相关的一些示例，该函数与<code>imin()</code>函数关系密切。程序清单9.4演示了一个程序，用过去声明函数的方式声明了<code>imax()</code>函数，然后错误地使用该函数。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单<span class=\"number\">9.4</span> misuse.c程序</span><br><span class=\"line\"><span class=\"comment\">/* misuse.c -- 错误地使用函数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imax</span><span class=\"params\">()</span></span>;　　 <span class=\"comment\">/* 旧式函数声明 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　maximum　of　%d　and　%d　is　%d.\\n\"</span>,<span class=\"number\">3</span>,　<span class=\"number\">5</span>,　imax(<span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　maximum　of　%d　and　%d　is　%d.\\n\"</span>,<span class=\"number\">3</span>,　<span class=\"number\">5</span>,　imax(<span class=\"number\">3.0</span>,　<span class=\"number\">5.0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imax</span><span class=\"params\">(n,m)</span></span></span><br><span class=\"line\">int n,m;</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (n&gt;m?n:m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>第1次调用<code>printf()</code>时省略了<code>imax()</code>的一个参数，第2次调用<code>printf()</code>时用两个浮点参数而不是整数参数。尽管有些问题，但程序可以编译和运行。</p>\n<p>下面是使用Xcode 4.6运行的输出示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The maximum　of　<span class=\"number\">3</span>　<span class=\"keyword\">and</span>　<span class=\"number\">5</span>　is　<span class=\"number\">1606416656.</span></span><br><span class=\"line\">The　maximum　of　<span class=\"number\">3</span>　<span class=\"keyword\">and</span>　<span class=\"number\">5</span>　is　<span class=\"number\">3886.</span></span><br></pre></td></tr></table></figure><p>使用gcc运行该程序，输出的值是1359379472和1359377160。这两个编译器都运行正常，之所以输出错误的结果，是因为它们运行的程序没有使用函数原型。</p>\n<p>到底是哪里出了问题？由于不同系统的内部机制不同，所以出现问题的具体情况也不同。下面介绍的是使用P C和VA X的情况。<strong>主调函数把它的参数储存在被称为<mark>栈（stack）</mark>的临时存储区</strong>，被调函数从栈中读取这些参数。对于该例，这两个过程并未相互协调。主调函数根据函数调用中的实际参数决定传递的类型，而被调函数根据它的形式参数读取值。因此，函数调用<code>imax(3)</code>把一个整数放在栈中。当<code>imax()</code>函数开始执行时，它从栈中读取两个整数。而实际上栈中只存放了一个待读取的整数，所以读取的第 2 个值是当时恰好在栈中的其他值。</p>\n<p>第2次使用<code>imax()</code>函数时，它传递的是<code>float</code>类型的值。这次把两个<code>double</code>类型的值放在栈中（回忆一下，当float类型被作为参数传递时会被升级为double类型）。在我们的系统中，两个<code>double</code>类型的值就是两个64位的值，所以128位的数据被放在栈中。当<code>imax()</code>从栈中读取两个<code>int</code>类型的值时，它从栈中读取前<code>64</code>位。在我们的系统中，每个<code>int</code>类型的变量占用32位。这些数据对应两个整数，其中较大的是3886。</p>\n<h3 id=\"ansi的解决方案\">ANSI的解决方案<a href=\"#ansi的解决方案\" title=\"ANSI的解决方案\"></a></h3><p>针对参数不匹配的问题，ANSI C标准要求在函数声明时还要声明变量的类型，即使用<strong>函数原型</strong>（function prototype）来声明函数的返回类型、参数的数量和每个参数的类型。未标明 <code>imax()</code>函数有两个 <code>int</code> 类型的参数，可以使用下面两种函数原型来声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imax</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imax</span><span class=\"params\">(<span class=\"keyword\">int</span> a, <span class=\"keyword\">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure><p>第1种形式使用以逗号分隔的类型列表，第2种形式在类型后面添加了变量名。注意，这里的变量名是假名，不必与函数定义的形式参数名一致。</p>\n<p>有了这些信息，编译器可以检查函数调用是否与函数原型匹配。参数的数量是否正确？参数的类型是否匹配？以 <code>imax()</code>为例，如果两个参数都是数字，但是类型不匹配，编译器会把实际参数的类型转换成形式参数的类型。例如，<code>imax(3.0, 5.0)</code>会被转换成<code>imax(3, 5)</code>。我们用函数原型替换程序清单9.4中的函数声明，如程序清单9.5所示。</p>\n<p>程序清单9.5 proto.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* proto.c -- 使用函数原型 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imax</span><span class=\"params\">(<span class=\"keyword\">int</span>, <span class=\"keyword\">int</span>)</span></span>;　　　 <span class=\"comment\">/* 函数原型 */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　maximum　of　%d　and　%d　is　%d.\\n\"</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>,　<span class=\"number\">5</span>,　imax(<span class=\"number\">3</span>));</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　maximum　of　%d　and　%d　is　%d.\\n\"</span>,</span><br><span class=\"line\">    <span class=\"number\">3</span>,　<span class=\"number\">5</span>,　imax(<span class=\"number\">3.0</span>,　<span class=\"number\">5.0</span>));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">imax</span><span class=\"params\">(<span class=\"keyword\">int</span>　n,　<span class=\"keyword\">int</span>　m)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (n　&gt;　m　?　n　:　m);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编译程序清单9.5时，我们的编译器给出调用的<code>imax()</code>函数参数太少的错误消息。</p>\n<p>如果是类型不匹配会怎样？为探索这个问题，我们用<code>imax(3, 5)</code>替换<code>imax(3)</code>，然后再次编译该程序。这次编译器没有给出任何错误信息，程序的输出如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">The maximum of <span class=\"number\">3</span> <span class=\"keyword\">and</span> <span class=\"number\">5</span> is <span class=\"number\">5.</span></span><br><span class=\"line\">The maximum of <span class=\"number\">3</span> <span class=\"keyword\">and</span> <span class=\"number\">5</span> is <span class=\"number\">5.</span></span><br></pre></td></tr></table></figure><p>如上文所述，第2次调用中的3.0和5.0被转换成3和5，以便函数能正确地处理输入。</p>\n<p>虽然没有错误消息，但是我们的编译器还是给出了警告：<code>double</code>转换成<code>int</code>可能会导致丢失数据。例如，下面的函数调用：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imax(<span class=\"number\">3.9</span>, <span class=\"number\">5.4</span>)</span><br></pre></td></tr></table></figure><p>相当于:</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">imax(<span class=\"number\">3</span>, <span class=\"number\">5</span>)</span><br></pre></td></tr></table></figure><p>错误和警告的区别是：错误导致无法编译，而警告仍然允许编译。一些编译器在进行类似的类型转换时不会通知用户，因为C标准中对此未作要求。不过，许多编译器都允许用户选择警告级别来控制编译器在描述警告时的详细程度。</p>\n<h3 id=\"无参数和未指定参数\">无参数和未指定参数<a href=\"#无参数和未指定参数\" title=\"无参数和未指定参数\"></a></h3><p>假设有下面的函数原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_name</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure><p>一个支持ANSI C的编译器会假定用户没有用函数原型来声明函数，它将不会检查参数。为了表明函数确实没有参数，应该在圆括号中使用<code>void</code>关键字：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">print_name</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>支持ANSI C的编译器解释为<code>print_name()</code>不接受任何参数。然后在调用该函数时，编译器会检查以确保没有使用参数。</p>\n<p>一些函数接受（如，<code>printf()</code>和<code>scanf()</code>）许多参数。例如对于<code>printf()</code>，第1个参数是字符串，但是其余参数的类型和数量都不固定。对于这种情况，ANSI C允许使用部分原型。例如，对于<code>printf()</code>可以使用下面的原型：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">printf</span><span class=\"params\">(<span class=\"keyword\">const</span> <span class=\"keyword\">char</span> *, ...)</span></span>;</span><br></pre></td></tr></table></figure><p>这种原型表明，第1个参数是一个字符串（第11章中将详细介绍），可能还有其他未指定的参数。</p>\n<p>C库通过<code>stdarg.h</code>头文件提供了一个定义这类（形参数量不固定的）函数的标准方法。第16章中详细介绍相关内容。</p>\n<h3 id=\"函数原型的优点\">函数原型的优点<a href=\"#函数原型的优点\" title=\"函数原型的优点\"></a></h3><p>函数原型是C语言的一个强有力的工具，它让编译器捕获在使用函数时可能出现的许多错误或疏漏。如果编译器没有发现这些问题，就很难觉察出来。是否必须使用函数原型？不一定。你也可以使用旧式的函数声明（即不用声明任何形参），但是这样做的弊大于利。</p>\n<p>有一种方法可以省略函数原型却保留函数原型的优点。首先要明白，之所以使用函数原型，是为了让编译器在第1次执行到该函数之前就知道如何使用它。因此，把整个函数定义放在第1次调用该函数之前，也有相同的效果。此时，函数定义也相当于函数原型。对于较小的函数，这种用法很普遍：</p>\n<p>// 下面这行代码既是函数定义，也是函数原型</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">imax</span><span class=\"params\">(<span class=\"keyword\">int</span>　a,　<span class=\"keyword\">int</span>　b)</span>　</span>&#123;　<span class=\"keyword\">return</span>　a　&gt;　b　?　a　:　b;　&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span>　<span class=\"title\">main</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\"><span class=\"keyword\">int</span>　x,　z;</span><br><span class=\"line\">...</span><br><span class=\"line\">z　=　imax(x,　<span class=\"number\">50</span>);</span><br><span class=\"line\">...</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"递归\">递归<a href=\"#递归\" title=\"递归\"></a></h2><p><strong>C允许函数调用它自己，这种调用过程称为递归</strong>（recursion）。递归有时难以捉摸，有时却很方便实用。结束递归是使用递归的难点，因为如果递归代码中没有终止递归的条件测试部分，一个调用自己的函数会无限递归。</p>\n<p>可以使用循环的地方通常都可以使用递归。有时用循环解决问题比较好，但有时用递归更好。递归方案更简洁，但效率却没有循环高。</p>\n<h3 id=\"演示递归\">演示递归<a href=\"#演示递归\" title=\"演示递归\"></a></h3><p>我们通过一个程序示例，来学习什么是递归。程序清单 9.6 中的 <code>main()</code>函数调用 <code>up_and_down()</code>函数，这次调用称为“第1级递归”。然后<code>up_and_down()</code>调用自己，这次调用称为“第2级递归”。接着第2级递归调用第3级递归，以此类推。该程序示例共有4级递归。为了进一步深入研究递归时发生了什么，程序不仅显示了变量n的值，还显示了储存n的内存地址<code>&amp;n</code>（。本章稍后会详细讨论<code>&amp;</code>运算符，<code>printf()</code>函数使用<code>%p</code>转换说明打印地址，如果你的系统不支持这种格式，请使用<code>%u</code>或<code>%lu</code>代替<code>%p</code>）。</p>\n<p>程序清单9.6 recur.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* recur.c -- 递归演示 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up_and_down</span><span class=\"params\">(<span class=\"keyword\">int</span>)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    up_and_down(<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">up_and_down</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Level　%d:　n　location　%p\\n\"</span>,　n,　&amp;n);　<span class=\"comment\">//　#1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n　&lt;　<span class=\"number\">4</span>)</span><br><span class=\"line\">    up_and_down(n　+　<span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"LEVEL　%d:　n　location　%p\\n\"</span>,　n,　&amp;n);　<span class=\"comment\">//　#2</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>下面是在我们系统中的输出：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Level　<span class=\"number\">1</span>:　n　location　<span class=\"number\">0x0012ff48</span></span><br><span class=\"line\">Level　<span class=\"number\">2</span>:　n　location　<span class=\"number\">0x0012ff3c</span></span><br><span class=\"line\">Level　<span class=\"number\">3</span>:　n　location　<span class=\"number\">0x0012ff30</span></span><br><span class=\"line\">Level　<span class=\"number\">4</span>:　n　location　<span class=\"number\">0x0012ff24</span></span><br><span class=\"line\">LEVEL　<span class=\"number\">4</span>:　n　location　<span class=\"number\">0x0012ff24</span></span><br><span class=\"line\">LEVEL　<span class=\"number\">3</span>:　n　location　<span class=\"number\">0x0012ff30</span></span><br><span class=\"line\">LEVEL　<span class=\"number\">2</span>:　n　location　<span class=\"number\">0x0012ff3c</span></span><br><span class=\"line\">LEVEL　<span class=\"number\">1</span>:　n　location　<span class=\"number\">0x0012ff48</span></span><br></pre></td></tr></table></figure><p>我们来仔细分析程序中的递归是如何工作的。首先，<code>main()</code>调用了带参数1的<code>up_and_down()</code>函数，执行结果是<code>up_and_down()</code>中的形式参数n的值是1，所以打印语句#1打印<code>Level 1</code>。然后，由于n小于4，<code>up_and_down()</code>（第1级）调用实际参数为n + 1（或2）的<code>up_and_down()</code>（第2级）。于是第2级调用中的n的值是2，打印语句#1打印Level 2。与此类似，下面两次调用打印的分别是Level 3和Level 4。</p>\n<p>当执行到第4级时，n的值是4，所以if测试条件为假。<code>up_and_down()</code>函数不再调用自己。第4级调用接着执行打印语句<code>#2</code>，即打印<code>LEVEL 4</code>，因为n的值是4。此时，第4级调用结束，控制被传回它的主调函数（即第3级调用）。在第3级调用中，执行的最后一条语句是调用if语句中的第4级调用。被调函数（第4级调用）把控制返回在这个位置，因此，第3级调用继续执行后面的代码，打印语句<code>#2</code>打印<code>LEVEL 3</code>。然后第3级调用结束，控制被传回第2级调用，接着打印<code>LEVEL 2</code>，以此类推。</p>\n<p>注意，每级递归的变量 n 都属于本级递归私有。这从程序输出的地址值可以看出（当然，不同的系统表示的地址格式不同，这里关键要注意，Level 1和LEVEL 1的地址相同，Level 2和LEVEL 2的地址相同，等等）。</p>\n<p>如果觉得不好理解，可以假设有一条函数调用链——<code>fun1()</code>调用 <code>fun2()</code>、<code>fun2()</code>调用 <code>fun3()</code>、<code>fun3()</code>调用<code>fun4()</code>。当 <code>fun4()</code>结束时，控制传回<code>fun3()</code>；当<code>fun3()</code>结束时，控制传回 <code>fun2()</code>；当<code>fun2()</code>结束时，控制传回<code>fun1()</code>。递归的情况与此类似，只不过<code>fun1()</code>、<code>fun2()</code>、<code>fun3()</code>和<code>fun4()</code>都是相同的函数。</p>\n<h3 id=\"递归的基本原理\">递归的基本原理<a href=\"#递归的基本原理\" title=\"递归的基本原理\"></a></h3><p>初次接触递归会觉得较难理解。为了帮助读者理解递归过程，下面以程序清单9.6为例讲解几个要点。</p>\n<p>第1，每级函数调用都有自己的变量。也就是说，第1级的n和第2级的n不同，所以程序创建了4个单独的变量，每个变量名都是n，但是它们的值各不相同。当程序最终返回 <code>up_and_down()</code>的第1 级调用时，最初的n仍然是它的初值1（见图9.4）。</p>\n<p><img src=\"https://gitee.com/DxSummer/pic/raw/master/img/c/递归中的变量.png\" class=\"φcy\"></p>\n<p>第2，每次函数调用都会返回一次。当函数执行完毕后，控制权将被传回上一级递归。程序必须按顺序逐级返回递归，从某级<code>up_and_down()</code>返回上一级的<code>up_and_down()</code>，不能跳级回到<code>main()</code>中的第1级调用。</p>\n<p>第3，递归函数中位于递归调用之前的语句，均按被调函数的顺序执行。例如，程序清单9.6中的打印语句#1位于递归调用之前，它按照递归的顺序：第1级、第2级、第3级和第4级，被执行了4次。</p>\n<p>第4，递归函数中位于递归调用之后的语句，均按被调函数相反的顺序执行。例如，打印语句#2位于递归调用之后，其执行的顺序是第4级、第3级、第2级、第1级。递归调用的这种特性在解决涉及相反顺序的编程问题时很有用。稍后将介绍一个这样的例子。</p>\n<p>第5，虽然每级递归都有自己的变量，但是并没有拷贝函数的代码。程序按顺序执行函数中的代码，而递归调用就相当于又从头开始执行函数的代码。除了为每次递归调用创建变量外，递归调用非常类似于一个循环语句。实际上，递归有时可用循环来代替，循环有时也能用递归来代替。</p>\n<p>最后，递归函数必须包含能让递归调用停止的语句。通常，递归函数都使用if或其他等价的测试条件在函数形参等于某特定值时终止递归。为此，每次递归调用的形参都要使用不同的值。例如，程序清单9.6中的<code>up_and_down(n)</code>调用<code>up_and_down(n+1)</code>。最终，实际参数等于4时，<code>if</code>的测试条件<code>(n &lt; 4)</code>为假。</p>\n<h3 id=\"尾递归\">尾递归<a href=\"#尾递归\" title=\"尾递归\"></a></h3><p>最简单的递归形式是把递归调用置于函数的末尾，即正好在 <code>return</code> 语句之前。这种形式的递归被称为<strong>尾递归</strong>（tail recursion），因为递归调用在函数的末尾。尾递归是最简单的递归形式，因为它相当于循环。</p>\n<p>下面要介绍的程序示例中，分别用循环和尾递归计算阶乘。一个正整数的阶乘（factorial）是从1到该整数的所有整数的乘积。例如，3的阶乘（写作3！）是1×2×3。另外，0！等于1，负数没有阶乘。程序清单9.7中，第1个函数使用<code>for</code>循环计算阶乘，第2个函数使用递归计算阶乘。</p>\n<p>程序清单9.7 factor.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">// factor.c -- 使用循环和递归计算阶乘</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">fact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> num;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"This　program　calculates　factorials.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>　(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,　&amp;num)　==　<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>　(num　&lt;　<span class=\"number\">0</span>)</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"No　negative　numbers,　please.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span>　<span class=\"keyword\">if</span>　(num　&gt;　<span class=\"number\">12</span>)</span><br><span class=\"line\">        \t<span class=\"built_in\">printf</span>(<span class=\"string\">\"Keep　input　under　13.\\n\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"loop:　%d　factorial　=　%ld\\n\"</span>,</span><br><span class=\"line\">            num,　fact(num));</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"recursion:　%d　factorial　=　%ld\\n\"</span>,</span><br><span class=\"line\">            num,　rfact(num));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　a　value　in　the　range　0-12　(q　to　quit):\\n\"</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Bye.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">fact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span>　　 <span class=\"comment\">// 使用循环的函数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> ans;</span><br><span class=\"line\">    <span class=\"keyword\">for</span>(ans=<span class=\"number\">1</span>;n&gt;<span class=\"number\">1</span>;n--)</span><br><span class=\"line\">    \tans*=n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　ans;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">rfact</span><span class=\"params\">(<span class=\"keyword\">int</span> n)</span>　　<span class=\"comment\">// 使用递归的函数</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span>　ans;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>　(n　&gt;　<span class=\"number\">0</span>)</span><br><span class=\"line\">    \tans = n * rfact(n - <span class=\"number\">1</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    \tans　=　<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ans;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>测试驱动程序把输入限制在0~12。因为<code>12!</code>已快接近5亿，而<code>13!</code>比62亿还大，已超过我们系统中<code>long</code>类型能表示的范围。要计算超过12的阶乘，必须使用能表示更大范围的类型，如<code>double</code>或l<code>ong long</code>。</p>\n<p>下面是该程序的运行示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">This　program　calculates　factorials.</span><br><span class=\"line\">Enter　a　value　in　the　range　<span class=\"number\">0</span><span class=\"number\">-12</span>　(q　to　quit):</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">loop:　<span class=\"number\">5</span>　factorial　=　<span class=\"number\">120</span></span><br><span class=\"line\">recursion:　<span class=\"number\">5</span>　factorial　=　<span class=\"number\">120</span></span><br><span class=\"line\">Enter　a　value　in　the　range　<span class=\"number\">0</span><span class=\"number\">-12</span>　(q　to　quit):</span><br><span class=\"line\"><span class=\"number\">10</span></span><br><span class=\"line\">loop:　<span class=\"number\">10</span>　factorial　=　<span class=\"number\">3628800</span></span><br><span class=\"line\">recursion:　<span class=\"number\">10</span>　factorial　=　<span class=\"number\">3628800</span></span><br><span class=\"line\">Enter　a　value　in　the　range　<span class=\"number\">0</span><span class=\"number\">-12</span>　(q　to　quit):</span><br><span class=\"line\">q</span><br><span class=\"line\">Bye.</span><br></pre></td></tr></table></figure><p>使用循环的函数把<code>ans</code>初始化为1，然后把<code>ans</code>与从n~2的所有递减整数相乘。根据阶乘的公式，还应该乘以1，但是这并不会改变结果。</p>\n<p>现在考虑使用递归的函数。该函数的关键是<code>n! = n×(n-1)!</code>。可以这样做是因为<code>(n-1)!</code>是n-1~1的所有正整数的乘积。因此，n乘以n-1就得到n的阶乘。阶乘的这一特性很适合使用递归。如果调用函数<code>rfact()</code>，<code>rfact(n)</code>是 <code>n*rfact(n-1)</code>。因此，通过调用 <code>rfact(n-1)</code>来计算<code>rfact(n)</code>，如程序清单9.7中所示。当然，必须要在满足某条件时结束递归，可以在n等于0时把返回值设为1。</p>\n<p>程序清单9.7中使用递归的输出和使用循环的输出相同。注意，虽然<code>rfact()</code>的递归调用不是函数的最后一行，但是当<code>n&gt;0</code>时，它是该函数执行的最后一条语句，因此它也是尾递归。</p>\n<p>既然用递归和循环来计算都没问题，那么到底应该使用哪一个？一般而言，选择循环比较好。首先，每次递归都会创建一组变量，所以<strong>递归使用的内存更多</strong>，而且<strong>每次递归调用都会把创建的一组新变量放在栈中</strong>。递归调用的数量受限于内存空间。其次，由于每次函数调用要花费一定的时间，所以递归的执行速度较慢。那么，演示这个程序示例的目的是什么？因为尾递归是递归中最简单的形式，比较容易理解。在某些情况下，不能用简单的循环代替递归，因此读者还是要好好理解递归。</p>\n<h3 id=\"递归和倒序计算\">递归和倒序计算<a href=\"#递归和倒序计算\" title=\"递归和倒序计算\"></a></h3><p>递归在处理倒序时非常方便（在解决这类问题中，递归比循环简单）。我们要解决的问题是：编写一个函数，打印一个整数的二进制数。二进制表示法根据 2 的幂来表示数字。例如，十进制数 234 实际上是2×102+3×101+4×100，所以二进制数101实际上是1×22+0×21+1×20。二进制数由0和1表示。</p>\n<p>我们要设计一个以二进制形式表示整数的方法或算法（algorithm）。例如，如何用二进制表示十进制数5？在二进制中，奇数的末尾一定是1，偶数的末尾一定是0，所以通过<code>5 % 2</code>即可确定5的二进制数的最后一位是1还是0。一般而言，对于数字<code>n</code>，其二进制的最后一位是<code>n % 2</code>。因此，计算的第一位数字实际上是待输出二进制数的最后一位。这一规律提示我们，在递归函数的递归调用之前计算<code>n % 2</code>，在递归调用之后打印计算结果。这样，计算的第1个值正好是最后一个打印的值。</p>\n<p>要获得下一位数字，必须把原数除以 2。这种计算方法相当于在十进制下把小数点左移一位，如果计算结果是偶数，那么二进制的下一位数就是0；如果是奇数，就是1。例如，5/2得2（整数除法），2是偶数（2%2 得 0），所以下一位二进制数是 0。到目前为止，我们已经获得 01。继续重复这个过程。2/2得1，1%2得1，所以下一位二进制数是1。因此，我们得到5的等价二进制数是101。那么，程序应该何时停止计算？当与2相除的结果小于2时停止计算，因为只要结果大于或等于2，就说明还有二进制位。每次除以 2 就相当于去掉一位二进制，直到计算出最后一位为止（如果不好理解，可以拿十进制数来做类比：628%10得8，因此8就是该数最后一位；而628/10得62，而62%10得2，所以该数的下一位是2，以此类推）。程序清单9.8演示了上述算法。</p>\n<p>程序清单9.8 binary.c程序</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* binary.c -- 以二进制形式打印制整数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">to_binary</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> number;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　an　integer　(q　to　quit):\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%lu\"</span>,&amp;number)　==　<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Binary　equivalent:　\"</span>);</span><br><span class=\"line\">        to_binary(number);</span><br><span class=\"line\">        <span class=\"built_in\">putchar</span>(<span class=\"string\">'\\n'</span>);</span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　an　integer　(q　to　quit):\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Done.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">to_binary</span><span class=\"params\">(<span class=\"keyword\">unsigned</span> <span class=\"keyword\">long</span> n)</span>　<span class=\"comment\">/* 递归函数 */</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> r;</span><br><span class=\"line\">    r=n%<span class=\"number\">2</span>;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>(n&gt;=<span class=\"number\">2</span>)</span><br><span class=\"line\">    \tto_binary(n/<span class=\"number\">2</span>);</span><br><span class=\"line\">    <span class=\"built_in\">putchar</span>(r==<span class=\"number\">0</span>?<span class=\"string\">'0'</span>:<span class=\"string\">'1'</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在该程序中，如果<code>r</code>的值是0，<code>to_binary()</code>函数就显示字符’0’；如果<code>r</code>的值是1，<code>to_binary()</code>函数则显示字符’1’。条件表达式<code>r == 0 ? &#39;0&#39; : &#39;1&#39;</code>用于把数值转换成字符。</p>\n<p>下面是该程序的运行示例：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Enter　an　<span class=\"title\">integer</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\"><span class=\"function\">9</span></span><br><span class=\"line\"><span class=\"function\">Binary　equivalent:　1001</span></span><br><span class=\"line\"><span class=\"function\">Enter　an　<span class=\"title\">integer</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\"><span class=\"function\">255</span></span><br><span class=\"line\"><span class=\"function\">Binary　equivalent:　11111111</span></span><br><span class=\"line\"><span class=\"function\">Enter　an　<span class=\"title\">integer</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\"><span class=\"function\">1024</span></span><br><span class=\"line\"><span class=\"function\">Binary　equivalent:　10000000000</span></span><br><span class=\"line\"><span class=\"function\">Enter　an　<span class=\"title\">integer</span>　<span class=\"params\">(q　to　quit)</span>:</span></span><br><span class=\"line\"><span class=\"function\">q</span></span><br><span class=\"line\">done.</span><br></pre></td></tr></table></figure><p>不用递归，是否能实现这种用二进制形式表示整数的算法？当然可以。但是由于这种算法要首先计算最后一位二进制数，所以在显示结果之前必须把所有的位数都储存在别处（例如，数组）。第 15 章中会介绍一个不用递归实现该算法的例子。</p>\n<h3 id=\"递归的优缺点\">递归的优缺点<a href=\"#递归的优缺点\" title=\"递归的优缺点\"></a></h3><p>递归既有优点也有缺点。优点是递归为某些编程问题提供了最简单的解决方案。缺点是一些递归算法会快速消耗计算机的内存资源。另外，递归不方便阅读和维护。我们用一个例子来说明递归的优缺点。</p>\n<p>斐波那契数列的定义如下：第1 个和第2 个数字都是1，而后续的每个数字都是其前两个数字之和。例如，该数列的前几个数是：1、1、2、3、5、8、13。斐波那契数列在数学界深受喜爱，甚至有专门研究它的刊物。不过，这不在本书的讨论范围之内。下面，我们要创建一个函数，接受正整数 n，返回相应的斐波那契数值。</p>\n<p>首先，来看递归。递归提供一个简单的定义。如果把函数命名为<code>Fibonacci()</code>，那么如果n是1或2， <code>Fibonacci(n)</code>应返回1；对于其他数值，则应返回<code>Fibonacci(n-1)+Fibonacci(n-2)</code>：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">unsigned</span>　<span class=\"keyword\">long</span>　<span class=\"title\">Fibonacci</span><span class=\"params\">(<span class=\"keyword\">unsigned</span>　n)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span>　(n　&gt;　<span class=\"number\">2</span>)</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　Fibonacci(n<span class=\"number\">-1</span>)　+　Fibonacci(n<span class=\"number\">-2</span>);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span>　<span class=\"number\">1</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>这个递归函数只是重述了数学定义的递归。该函数使用了<strong>双递归</strong>（double recursion），即函数每一级递归都要调用本身两次。这暴露了一个问题。</p>\n<p>为了说明这个问题，假设调用 <code>Fibonacci(40)</code>。这是第1 级递归调用，将创建一个变量 n。然后在该函数中要调用<code>Fibonacci()</code>两次，在第2级递归中要分别创建两个变量n。这两次调用中的每次调用又会进行两次调用，因而在第3级递归中要创建4个名为n的变量。此时总共创建了7个变量。由于每级递归创建的变量都是上一级递归的两倍，所以变量的数量呈指数增长！在第 5 章中介绍过一个计算小麦粒数的例子，按指数增长很快就会产生非常大的值。在本例中，<strong>指数增长的变量数量很快就消耗掉计算机的大量内存，很可能导致程序崩溃</strong>。</p>\n<p>虽然这是个极端的例子，但是该例说明：<mark>在程序中使用递归要特别注意，尤其是效率优先的程序</mark>。</p>\n<p>所有的C函数皆平等</p>\n<p>程序中的每个C函数与其他函数都是平等的。每个函数都可以调用其他函数，或被其他函数调用。这点与Pascal和Modula-2中的过程不同，虽然过程可以嵌套在另一个过程中，但是嵌套在不同过程中的过程之间不能相互调用。</p>\n<p><code>main()</code>函数是否与其他函数不同？是的，<code>main()</code>的确有点特殊。当 <code>main()</code>与程序中的其他函数放在一起时，最开始执行的是<code>main()</code>函数中的第1条语句，但是这也是局限之处。<code>main()</code>也可以被自己或其他函数递归调用——尽管很少这样做。</p>\n<h2 id=\"编译多源代码文件的程序\">编译多源代码文件的程序<a href=\"#编译多源代码文件的程序\" title=\"编译多源代码文件的程序\"></a></h2><p>使用多个函数最简单的方法是把它们都放在同一个文件中，然后像编译只有一个函数的文件那样编译该文件即可。其他方法因操作系统而异，下面将举例说明。</p>\n<h3 id=\"unix\">UNIX<a href=\"#unix\" title=\"UNIX\"></a></h3><p>假定在<code>UNIX</code>系统中安装了UNIX C编译器cc（最初的cc已经停用，但是许多UNIX系统都给cc命令起了一个别名用作其他编译器命令，典型的是gcc或clang）。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成一个名为a.out的可执行文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc file1.c file2.c</span><br></pre></td></tr></table></figure><p>另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">cc file1.c file2.o</span><br></pre></td></tr></table></figure><p>UNIX系统的<code>make</code>命令可自动管理多文件程序，但是这超出了本书的讨论范围。</p>\n<p>注意，OS X的Terminal工具可以打开UNIX命令行环境，但是必须先下载命令行编译器（<code>GCC</code>和<code>Clang</code>）。</p>\n<h3 id=\"linux\">Linux<a href=\"#linux\" title=\"Linux\"></a></h3><p>假定Linux系统安装了GNU C编译器GCC。假设file1.c和file2.c是两个内含C函数的文件，下面的命令将编译两个文件并生成名为a.out的可执行文件：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc file1.c file2.c</span><br></pre></td></tr></table></figure><p>另外，还生成两个名为file1.o和file2.o的目标文件。如果后来改动了file1.c，而file2.c不变，可以使用以下命令编译第1个文件，并与第2个文件的目标代码合并：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">gcc file1.c file2.o</span><br></pre></td></tr></table></figure><h3 id=\"dos命令行编译器\">DOS命令行编译器<a href=\"#dos命令行编译器\" title=\"DOS命令行编译器\"></a></h3><p>绝大多数DOS命令行编译器的工作原理和<code>UNIX</code>的cc命令类似，只不过使用不同的名称而已。其中一个区别是，对象文件的扩展名是<code>.obj</code>，而不是<code>.o</code>。一些编译器生成的不是目标代码文件，而是汇编语言或其他特殊代码的中间文件。</p>\n<h3 id=\"windows和苹果的ide编译器\">Windows和苹果的IDE编译器<a href=\"#windows和苹果的ide编译器\" title=\"Windows和苹果的IDE编译器\"></a></h3><p>Windows和Macintosh系统使用的集成开发环境中的编译器是面向项目的。项目（project）描述的是特定程序使用的资源。资源包括源代码文件。这种IDE中的编译器要创建项目来运行单文件程序。对于多文件程序，要使用相应的菜单命令，把源代码文件加入一个项目中。要确保所有的源代码文件都在项目列表中列出。许多IDE都不用在项目列表中列出头文件（即扩展名为<code>.h</code>的文件），因为项目只管理使用的源代码文件，源代码文件中的<code>#include</code>指令管理该文件中使用的头文件。但是，Xcode要在项目中添加头文件。</p>\n<h3 id=\"使用头文件\">使用头文件<a href=\"#使用头文件\" title=\"使用头文件\"></a></h3><p>如果把<code>main()</code>放在第1个文件中，把函数定义放在第2个文件中，那么第1个文件仍然要使用函数原型。把函数原型放在头文件中，就不用在每次使用函数文件时都写出函数的原型。C 标准库就是这样做的，例如，把I/O函数原型放在<code>stdio.h</code>中，把数学函数原型放在<code>math.h</code>中。你也可以这样用自定义的函数文件。</p>\n<p>另外，程序中经常用C预处理器定义符号常量。这种定义只储存了那些包含<code>#define</code>指令的文件。如果把程序的一个函数放进一个独立的文件中，你也可以使用<code>#define</code>指令访问每个文件。最直接的方法是在每个文件中再次输入指令，但是这个方法既耗时又容易出错。另外，还会有维护的问题：如果修改了<code>#define</code> 定义的值，就必须在每个文件中修改。<strong>更好的做法是，把<code>#define</code> 指令放进头文件，然后在每个源文件中使用<code>#include</code>指令包含该文件即可。</strong></p>\n<p>总之，把函数原型和已定义的字符常量放在头文件中是一个良好的编程习惯。我们考虑一个例子：假设要管理 4 家酒店的客房服务，每家酒店的房价不同，但是每家酒店所有房间的房价相同。对于预订住宿多天的客户，第2天的房费是第1天的95%，第3天是第2天的95%，以此类推（暂不考虑这种策略的经济效益）。设计一个程序让用户指定酒店和入住天数，然后计算并显示总费用。同时，程序要实现一份菜单，允许用户反复输入数据，除非用户选择退出。</p>\n<p>程序清单9.9、程序清单9.10和程序清单9.11演示了如何编写这样的程序。第1个程序清单包含<code>main()</code>函数，提供整个程序的组织结构。第 2 个程序清单包含支持的函数，我们假设这些函数在独立的文件中。最后，程序清单9.11列出了一个头文件，包含了该程序所有源文件中使用的自定义符号常量和函数原型。前面介绍过，<mark><strong>在UNIX和DOS环境中，<code>#include &quot;hotels.h&quot;</code>指令中的双引号表明被包含的文件位于当前目录中（通常是包含源代码的目录）。</strong></mark>如果使用IDE，需要知道如何把头文件合并成一个项目。</p>\n<p>程序清单9.9 usehotel.c控制模块</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* usehotel.c -- 房间费率程序 */</span></span><br><span class=\"line\"><span class=\"comment\">/* 与程序清单9.10一起编译　　 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span> <span class=\"meta-string\">\"hotel.h\"</span> <span class=\"comment\">/* 定义符号常量，声明函数 */</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">main</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nights;</span><br><span class=\"line\">    <span class=\"keyword\">double</span> hotel_rate;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> code;</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((code　=　menu())　!=　QUIT)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">switch</span>(code)</span><br><span class=\"line\">        &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span>　<span class=\"number\">1</span>:　 hotel_rate　=　HOTEL1;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span>　<span class=\"number\">2</span>:　 hotel_rate　=　HOTEL2;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span>　<span class=\"number\">3</span>:　 hotel_rate　=　HOTEL3;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span>　<span class=\"number\">4</span>:　 hotel_rate　=　HOTEL4;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">default</span>: hotel_rate　=　<span class=\"number\">0.0</span>;</span><br><span class=\"line\">            <span class=\"built_in\">printf</span>(<span class=\"string\">\"Oops!\\n\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        nights　=　getnights();</span><br><span class=\"line\">        showprice(hotel_rate,　nights);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Thank　you　and　goodbye.\\n\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>程序清单9.10 hotel.c函数支持模块</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* hotel.c -- 酒店管理函数 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">&lt;stdio.h&gt;</span></span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">include</span>　<span class=\"meta-string\">\"hotel.h\"</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">menu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> code,status;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"\\n%s%s\\n\"</span>,　STARS,　STARS);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　the　number　of　the　desired　hotel:\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"1)　Fairfield　Arms　　　　　　　 2)　Hotel　Olympic\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"3)　Chertworthy　Plaza　　　　　4)　The　Stockton\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"5)　quit\\n\"</span>);</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"%s%s\\n\"</span>,　STARS,　STARS);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>((status　=　<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;code))　!=　<span class=\"number\">1</span>　||</span><br><span class=\"line\">    (code　&lt;　<span class=\"number\">1</span>　||　code　&gt;　<span class=\"number\">5</span>))</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span>　(status　!=　<span class=\"number\">1</span>)</span><br><span class=\"line\">            <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%*s\"</span>);　<span class=\"comment\">// 处理非整数输入</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Enter　an　integer　from　1　to　5,　please.\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> code;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getnights</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> nights;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"How　many　nights　are　needed?　\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">while</span>(<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,　&amp;nights)　!=　<span class=\"number\">1</span>)</span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        <span class=\"built_in\">scanf</span>(<span class=\"string\">\"%*s\"</span>);　　　<span class=\"comment\">// 处理非整数输入</span></span><br><span class=\"line\">        <span class=\"built_in\">printf</span>(<span class=\"string\">\"Please　enter　an　integer,　such　as　2.\\n\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span>　nights;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showprice</span><span class=\"params\">(<span class=\"keyword\">double</span> rate,<span class=\"keyword\">int</span> nights)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span>　n;</span><br><span class=\"line\">    <span class=\"keyword\">double</span>　total　=　<span class=\"number\">0.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">double</span>　factor　=　<span class=\"number\">1.0</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (n = <span class=\"number\">1</span>; n &lt;= nights; n++, factor *= DISCOUNT)</span><br><span class=\"line\">    \ttotal += rate * factor;</span><br><span class=\"line\">    <span class=\"built_in\">printf</span>(<span class=\"string\">\"The　total　cost　will　be　$%0.2f.\\n\"</span>,　total);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>程序清单9.11 hotel.h头文件</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/* hotel.h -- 符号常量和 hotel.c 中所有函数的原型 */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　QUIT　　　　　5</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　HOTEL1　　180.00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　HOTEL2　　225.00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　HOTEL3　　255.00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　HOTEL4　　355.00</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span>　DISCOUNT　 0.95</span></span><br><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> STARS <span class=\"meta-string\">\"**********************************\"</span></span></span><br><span class=\"line\"><span class=\"comment\">// 显示选择列表</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">menu</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 返回预订天数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getnights</span><span class=\"params\">(<span class=\"keyword\">void</span>)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">// 根据费率、入住天数计算费用</span></span><br><span class=\"line\"><span class=\"comment\">// 并显示结果</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">showprice</span><span class=\"params\">(<span class=\"keyword\">double</span> rate,<span class=\"keyword\">int</span> nights)</span></span>;</span><br></pre></td></tr></table></figure><p>下面是这个多文件程序的运行示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">******************************************************************</span><br><span class=\"line\">Enter　the　number　of　the　desired　hotel:</span><br><span class=\"line\"><span class=\"number\">1</span>)　Fairfield　Arms　　　　　　　 <span class=\"number\">2</span>)　Hotel　Olympic</span><br><span class=\"line\"><span class=\"number\">3</span>)　Chertworthy　Plaza　　　　　 <span class=\"number\">4</span>)　The　Stockton</span><br><span class=\"line\"><span class=\"number\">5</span>)　quit</span><br><span class=\"line\">********************************************************************</span><br><span class=\"line\"><span class=\"number\">3</span></span><br><span class=\"line\">How　many　nights　are　needed?　<span class=\"number\">1</span></span><br><span class=\"line\">The　total　cost　will　be　$<span class=\"number\">255.00</span>.</span><br><span class=\"line\">********************************************************************</span><br><span class=\"line\">Enter　the　number　of　the　desired　hotel:</span><br><span class=\"line\"><span class=\"number\">1</span>)　Fairfield　Arms　　　　　　　 <span class=\"number\">2</span>)　Hotel　Olympic</span><br><span class=\"line\"><span class=\"number\">3</span>)　Chertworthy　Plaza　　　　　 <span class=\"number\">4</span>)　The　Stockton</span><br><span class=\"line\"><span class=\"number\">5</span>)　quit</span><br><span class=\"line\">********************************************************************</span><br><span class=\"line\"><span class=\"number\">4</span></span><br><span class=\"line\">How　many　nights　are　needed?　<span class=\"number\">3</span></span><br><span class=\"line\">The　total　cost　will　be　$<span class=\"number\">1012.64</span>.</span><br><span class=\"line\">********************************************************************</span><br><span class=\"line\">Enter　the　number　of　the　desired　hotel:</span><br><span class=\"line\"><span class=\"number\">1</span>)　Fairfield　Arms　　　　　　　 <span class=\"number\">2</span>)　Hotel　Olympic</span><br><span class=\"line\"><span class=\"number\">3</span>)　Chertworthy　Plaza　　　　　 <span class=\"number\">4</span>)　The　Stockton</span><br><span class=\"line\"><span class=\"number\">5</span>)　quit</span><br><span class=\"line\">********************************************************************</span><br><span class=\"line\"><span class=\"number\">5</span></span><br><span class=\"line\">Thank　you　<span class=\"keyword\">and</span>　goodbye.</span><br></pre></td></tr></table></figure><p>顺带一提，该程序中有几处编写得很巧妙。尤其是，<code>menu()</code>和<code>getnights()</code>函数通过测试<code>scanf()</code>的返回值来跳过非数值数据，而且调用 <code>scanf(&quot;%*s&quot;)</code>跳至下一个空白字符。注意，<code>menu()</code>函数中是如何检查非数值输入和超出范围的数据：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">while</span>((status=<span class=\"built_in\">scanf</span>(<span class=\"string\">\"%d\"</span>,&amp;code))!= <span class=\"number\">1</span>||(code&lt;<span class=\"number\">1</span>||code&gt;<span class=\"number\">5</span>))</span><br></pre></td></tr></table></figure><p>以上代码段利用了C语言的两个规则：从左往右对逻辑表达式求值；一旦求值结果为假，立即停止求值。在该例中，只有在<code>scanf()</code>成功读入一个整数值后，才会检查<code>code</code>的值。</p>\n<p>用不同的函数处理不同的任务时应检查数据的有效性。当然，首次编写<code>menu()</code>或<code>getnights()</code>函数时可以暂不添加这一功能，只写一个简单的<code>scanf()</code>即可。待基本版本运行正常后，再逐步改善各模块。</p>\n<h2 id=\"查找地址：amp运算符\">查找地址：&amp;运算符<a href=\"#查找地址：amp运算符\" title=\"查找地址：&amp;运算符\"></a></h2><p>指针（pointer）是 C 语言最重要的（有时也是最复杂的）概念之一，用于储存变量的地址。前面使用的<code>scanf()</code>函数中就使用地址作为参数。概括地说，如果主调函数不使用<code>return</code>返回的值，则必须通过地址才能修改主调函数中的值。接下来，我们将介绍带地址参数的函数。首先介绍一元<strong>&amp;运算符</strong>的用法。</p>\n<p>一元&amp;运算符给出变量的存储地址。如果<code>pooh</code>是变量名，那么<code>&amp;pooh</code>是变量的地址。可以把地址看作是变量在内存中的位置。假设有下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">pooh = <span class=\"number\">24</span>;</span><br></pre></td></tr></table></figure><p>假设<code>pooh</code>的存储地址是<code>0B76</code>（PC地址通常用十六进制形式表示）。那么，下面的语句：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"built_in\">printf</span>(<span class=\"string\">\"%d %p\\n\"</span>, pooh, &amp;pooh);</span><br></pre></td></tr></table></figure><p>将输出如下内容（%p是输出地址的转换说明）：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"number\">24</span> <span class=\"number\">0B</span>76</span><br></pre></td></tr></table></figure><p>程序清单9.12中使用了这个运算符查看不同函数中的同名变量分别储存在什么位置。</p>\n<p>程序清单9.12 loccheck.c程序</p>\n<p>/* loccheck.c　– 查看变量被储存在何处　*/</p>\n<p>#include　&lt;stdio.h&gt;</p>\n<p>void mikado(int);　　　　　　　/* 函数原型 */</p>\n<p>int　main(void)</p>\n<p>{</p>\n<p>int pooh = 2, bah = 5; /* main()的局部变量 */</p>\n<p>printf(“In　main(),　pooh　=　%d　and　&amp;pooh　=　%p\\n”,　pooh,　&amp;pooh);</p>\n<p>printf(“In　main(),　bah　=　%d　and　&amp;bah　=　%p\\n”,　bah,　&amp;bah);</p>\n<p>mikado(pooh);</p>\n<p>return　0;</p>\n<p>}</p>\n<p>void mikado(int bah)　　　　　 /* 定义函数 */</p>\n<p>{</p>\n","next":{"title":"Step6 字符输入/输出和输入验证","link":"posts/86602531"},"plink":"https://dxsummer.gitee.io/posts/71adb096/","toc":[{"id":"复习函数","title":"复习函数","index":"1","children":[{"id":"创建并使用简单函数","title":"创建并使用简单函数","index":"1.1"},{"id":"分析程序","title":"分析程序","index":"1.2"},{"id":"函数参数","title":"函数参数","index":"1.3"},{"id":"定义带形式参数的函数","title":"定义带形式参数的函数","index":"1.4"},{"id":"声明带形式参数函数的原型","title":"声明带形式参数函数的原型","index":"1.5"},{"id":"调用带实际参数的函数","title":"调用带实际参数的函数","index":"1.6"},{"id":"黑盒视角","title":"黑盒视角","index":"1.7"},{"id":"使用return从函数中返回值","title":"使用return从函数中返回值","index":"1.8"},{"id":"函数类型","title":"函数类型","index":"1.9"}]},{"id":"ansi-c函数原型","title":"ANSI C函数原型","index":"2","children":[{"id":"问题所在","title":"问题所在","index":"2.1"},{"id":"ansi的解决方案","title":"ANSI的解决方案","index":"2.2"},{"id":"无参数和未指定参数","title":"无参数和未指定参数","index":"2.3"},{"id":"函数原型的优点","title":"函数原型的优点","index":"2.4"}]},{"id":"递归","title":"递归","index":"3","children":[{"id":"演示递归","title":"演示递归","index":"3.1"},{"id":"递归的基本原理","title":"递归的基本原理","index":"3.2"},{"id":"尾递归","title":"尾递归","index":"3.3"},{"id":"递归和倒序计算","title":"递归和倒序计算","index":"3.4"},{"id":"递归的优缺点","title":"递归的优缺点","index":"3.5"}]},{"id":"编译多源代码文件的程序","title":"编译多源代码文件的程序","index":"4","children":[{"id":"unix","title":"UNIX","index":"4.1"},{"id":"linux","title":"Linux","index":"4.2"},{"id":"dos命令行编译器","title":"DOS命令行编译器","index":"4.3"},{"id":"windows和苹果的ide编译器","title":"Windows和苹果的IDE编译器","index":"4.4"},{"id":"使用头文件","title":"使用头文件","index":"4.5"}]},{"id":"查找地址：amp运算符","title":"查找地址：&amp;运算符","index":"5"}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/71adb096/\" title=\"Step7 函数\">https://dxsummer.gitee.io/posts/71adb096/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年6月10日","updated":"2020年6月12日"}}