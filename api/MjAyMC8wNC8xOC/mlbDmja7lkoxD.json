{"title":"数据和C","date":"2020-04-18T10:35:51.000Z","date_formatted":{"ll":"Apr 18, 2020","L":"04/18/2020","MM-DD":"04-18"},"link":"2020/04/18/数据和C","comments":true,"tags":["位、字节、字","基本数据类型","数据和C","整数溢出"],"categories":["C语言","资料"],"updated":"2020-05-21T03:03:27.057Z","content":"<p><span id=\"inline-grey\">此经验基于C Primer Plus</span></p>\n<blockquote>\n<p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p>\n</blockquote>\n<ul><li>本章介绍以下内容：<br>关键字：int 、short、long、unsigned、char、float、double、_Bool、_Complex、_Imaginary<br>运算符：sizeof()<br>函数：scanf()<br>整数类型和浮点数类型的区别<br>如何书写整型和浮点型常数，如何声明这些类型的变量<br>如何使用printf()和scanf()函数读写不同类型的值</li>\n</ul><p>C 语言提供两大系列的多种数据类型。本章详细介绍两大数据类型：整数类型和浮点数类型，除此之外，还将介绍常量和变量的区别。</p>\n<h2 id=\"示例程序\">示例程序<a href=\"#示例程序\" title=\"示例程序\"></a></h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">float weight;　 &#x2F;* 你的体重　　　　　　　*&#x2F;</span><br><span class=\"line\">float value;　　&#x2F;* 相等重量的白金价值　　　*&#x2F;</span><br><span class=\"line\">printf(&quot;Are　you　worth　your　weight　in　platinum?\\n&quot;);</span><br><span class=\"line\">printf(&quot;Let&#39;s　check　it　out.\\n&quot;);</span><br><span class=\"line\">printf(&quot;Please　enter　your　weight　in　pounds:　&quot;);   &#x2F;* 获取用户的输入*&#x2F;</span><br><span class=\"line\">scanf(&quot;%f&quot;,　&amp;weight);  &#x2F;* 假设白金的价格是每盎司$1700　　　　　*&#x2F;</span><br><span class=\"line\">                        &#x2F;* 14.5833用于把英镑常衡盎司转换为金衡盎司[1]*&#x2F;</span><br><span class=\"line\">value &#x3D; 1700.0 * weight * 14.5833;</span><br><span class=\"line\">printf(&quot;Your　weight　in　platinum　is　worth　$%.2f.\\n&quot;,　value);</span><br><span class=\"line\">printf(&quot;You　are　easily　worth　that!　If　platinum　prices　drop,\\n&quot;);</span><br><span class=\"line\">printf(&quot;eat　more　to　maintain　your　value.\\n&quot;);</span><br><span class=\"line\">return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"提示-错误与警告\">提示 错误与警告<a href=\"#提示-错误与警告\" title=\"提示 错误与警告\"></a></h3><p>如果输入程序时打错（如，漏了一个分号），编译器会报告语法错误消息。然而，即使输入正确无误，编译器也可能给出一些警告，如“警告：从double类型转换成float类型可能会丢失数据”。错误消息表明程序中有错，不能进行编译。而警告则表明，尽管编写的代码有效，但可能不是程序员想要的。警告并不终止编译。特殊的警告与C如何处理1700.0这样的值有关。</p>\n<p>输入该程序时，可以把1700.0改成贵金属白金当前的市价，但是不要改动14.5833，该数是1英镑的金衡盎司数（金衡盎司用于衡量贵金属，而英镑常衡盎司用于衡量人的体重）。</p>\n<p>注意，“enter your weight”的意思是输入你的体重，然后按下Enter或Return键（不要键入体重后就一直等着）。按下Enter键是告知计算机，你已完成输入数据。该程序需要你输入一个数字（如，155），而不是单词（如，too much）。如果输入字母而不是数字，会导致程序出问题。这个问题要用if语句来解决，因此请先输入数字。下面是程序的输出示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Are　you　worth　your　weight　in　platinum?</span><br><span class=\"line\">Let&#39;s　check　it　out.</span><br><span class=\"line\">Please　enter　your　weight　in　pounds:　156</span><br><span class=\"line\">Your　weight　in　platinum　is　worth　$3867491.25.</span><br><span class=\"line\">You　are　easily　worth　that!　If　platinum　prices　drop,</span><br><span class=\"line\">eat　more　to　maintain　your　value.</span><br></pre></td></tr></table></figure><h3 id=\"程序调整\">程序调整<a href=\"#程序调整\" title=\"程序调整\"></a></h3><p>即使在程序中添加下面一行代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getchar();</span><br></pre></td></tr></table></figure><p>程序的输出是否依旧在屏幕上一闪而过？本例，需要调用两次getchar()函数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">getchar();</span><br><span class=\"line\">getchar();</span><br></pre></td></tr></table></figure><blockquote>\n<p>getchar()函数读取下一个输入字符，因此程序会等待用户输入。在这种情况下，键入 156 并按下Enter（或Return）键（发送一个换行符），然后scanf()读取键入的数字，第1个getchar()读取换行符，第2个getchar()让程序暂停，等待输入。</p>\n</blockquote>\n<h3 id=\"程序中的新元素\">程序中的新元素<a href=\"#程序中的新元素\" title=\"程序中的新元素\"></a></h3><ul><li><p>注意，代码中使用了一种新的变量声明。前面的例子中只使用了整数类型的变量（int），但是本例使用了浮点数类型（float）的变量，以便处理更大范围的数据。<mark>float 类型可以储存带小数的数字</mark>。</p>\n</li>\n<li><p>为了打印新类型的变量，在printf()中使用%f来处理浮点值。%.2f中的.2用于精确控制输出，指定输出的浮点数只显示小数点后面两位。</p>\n</li>\n<li><p>scanf()函数用于读取键盘的输入。%f说明scanf()要读取用户从键盘输入的浮点数，&amp;weight告诉 scanf()把输入的值赋给名为 weight 的变量。scanf()函数使用&amp;符号表明找到 weight变量的地点。</p>\n</li>\n</ul><h2 id=\"变量与常量数据\">变量与常量数据<a href=\"#变量与常量数据\" title=\"变量与常量数据\"></a></h2><ul><li>有些数据类型在程序使用之前已经预先设定好了，在整个程序的运行过程中没有变化，这些称为<span id=\"inline-green\">常量（constant）</span>。<br>其他数据类型在程序运行期间可能会改变或被赋值，这些称为<span id=\"inline-green\">变量（variable）</span>。</li>\n</ul><p>在示例程序中，weight 是一个变量，14.5833 是一个常量。那么，1700.0 是常量还是变量？在现实生活中，白金的价格不会是常量，但是在程序中，像1700.0这样的价格被视为常量。</p>\n<h2 id=\"数据：数据类型关键字\">数据：数据类型关键字<a href=\"#数据：数据类型关键字\" title=\"数据：数据类型关键字\"></a></h2><ul><li>不仅变量和常量不同，不同的数据类型之间也有差异。一些数据类型表示数字，一些数据类型表示字母（更普遍地说是字符）。C通过识别一些基本的数据类型来区分和使用这些不同的数据类型。如果数据是常量，编译器一般通过用户书写的形式来识别类型（如，42是整数，42.100是浮点数）。但是，对变量而言，要在声明时指定其类型。</li>\n</ul><p>现在，我们先来了解一下 C语言的基本类型关键字。K&amp;C给出了7个与类型相关的关键字。C90标准添加了2个关键字，C99标准又添加了3个关键字。</p>\n<p><img src=\"https://i.loli.net/2020/05/17/dcGPDgzRCmibkfw.jpg\" class=\"φcy\" alt=\"C语言的数据类型关键字\"></p>\n<ol><li><p>在C语言中，用int关键字来表示基本的整数类型。后3个关键字（long、short和unsigned）和C90新增的signed用于提供基本整数类型的变式，例如unsigned short int和long long int。char关键字用于指定字母和其他字符（如，#、$、%和*）。</p>\n</li>\n<li><p>另外，char类型也可以表示较小的整数。float、double和long double表示带小数点的数。_Bool类型表示布尔值（true或false），_complex和_Imaginary分别表示复数和虚数。</p>\n</li>\n</ol><p>通过这些关键字创建的类型，按计算机的储存方式可分为两大基本类型：整数类型和浮点数类型。</p>\n<h3 id=\"位、字节和字\">位、字节和字<a href=\"#位、字节和字\" title=\"位、字节和字\"></a></h3><ol><li><p>位、字节和字是描述计算机数据单元或存储单元的术语。这里主要指存储单元。</p>\n</li>\n<li><p>最小的存储单元是位（bit），可以储存0或1（或者说，位用于设置“开”或“关”）。虽然1位储存的信息有限，但是计算机中位的数量十分庞大。位是计算机内存的基本构建块。</p>\n</li>\n<li><p>字节（byte）是常用的计算机存储单位。对于几乎所有的机器，1字节均为8位。这是字节的标准定义，至少在衡量存储单位时是这样（但是，C语言对此有不同的定义，请参阅baidu）。既然1位可以表示0或1，那么8位字节就有256（2的8次方）种可能的0、1的组合。通过二进制编码（仅用0和1便可表示数字），便可表示0～255的整数或一组字符（后面将详细讨论二进制编码，如果感兴趣可以现在浏览一下该章的内容）。</p>\n</li>\n<li><p>字（word）是设计计算机时给定的自然存储单位。对于8位的微型计算机（如，最初的苹果机）， 1个字长只有8位。从那以后，个人计算机字长增至16位、32位，直到目前的64位。计算机的字长越大，其数据转移越快，允许的内存访问也更多。</p>\n</li>\n</ol><h3 id=\"整数\">整数<a href=\"#整数\" title=\"整数\"></a></h3><blockquote>\n<p>和数学的概念一样，在C语言中，整数是没有小数部分的数。例如，2、−23和2456都是整数。而3.14、0.22和2.000都不是整数。计算机以二进制数字储存整数，例如，整数7以二进制写是111。因此，要在8位字节中储存该数字，需要把前5位都设置成0，后3位设置成1</p>\n</blockquote>\n<p><img src=\"https://i.loli.net/2020/05/17/FqRJaOpIe4oVh5k.jpg\" class=\"φcy\"></p>\n<h3 id=\"浮点数\">浮点数<a href=\"#浮点数\" title=\"浮点数\"></a></h3><ol><li><p>浮点数与数学中实数的概念差不多。2.75、3.16E7、7.00 和 2e-8 都是浮点数。注意，在一个值后面加上一个小数点，该值就成为一个浮点值。所以，7是整数，7.00是浮点数。显然，书写浮点数有多种形式。稍后将详细介绍e记数法，这里先做简要介绍：3.16E7 表示3.16×10<sup>7</sup>（3.16 乘以10 的7次方）。其中， 10<sup>7</sup>=10000000，7被称为10的指数。</p>\n</li>\n<li><p>这里关键要理解浮点数和整数的储存方案不同。计算机把浮点数分成小数部分和指数部分来表示，而且分开储存这两部分。因此，虽然7.00和7在数值上相同，但是它们的储存方式不同。在十进制下，可以把7.0写成0.7E1。这里，0.7是小数部分，1是指数部分。</p>\n</li>\n</ol><p><img src=\"https://i.loli.net/2020/05/17/kb7e3jW82RBdJI5.jpg\" class=\"φcy\"></p>\n<blockquote>\n<p>上图演示了一个储存浮点数的例子。当然，计算机在内部使用二进制和2的幂进行储存，而不是10的幂。后面<a>位操作</a>将详述相关内容。现在，我们着重讲解这两种类型的实际区别。</p>\n</blockquote>\n<ol><li>整数没有小数部分，浮点数有小数部分。浮点数可以表示的范围比整数大。对于一些算术运算（如，两个很大的数相减），浮点数损失的精度更多。因为在任何区间内（如，1.0 到 2.0 之间）都存在无穷多个实数，所以计算机的浮点数不能表示区间内所有的值。<mark>浮点数通常只是实际值的近似值</mark>。例如，7.0可能被储存为浮点值6.99999。</li>\n</ol><p>过去，浮点运算比整数运算慢。不过，现在许多CPU都包含浮点处理器，缩小了速度上的差距。</p>\n<h2 id=\"c语言基本数据类型\">C语言基本数据类型<a href=\"#c语言基本数据类型\" title=\"C语言基本数据类型\"></a></h2><h3 id=\"int类型\">int类型<a href=\"#int类型\" title=\"int类型\"></a></h3><p>int类型是有符号整型，即int类型的值必须是整数，可以是正整数、负整数或零。其取值范围依计算机系统而异。一般而言，储存一个int要占用一个机器字长。因此，早期的16位IBM PC兼容机使用16位来储存一个int值，其取值范围（即int值的取值范围）是-32768～32767。目前的个人计算机一般是32位，因此用32位储存一个int值。现在，个人计算机产业正逐步向着64位处理器发展，自然能储存更大的整数。ISO C规定int的取值范围最小为-32768～32767。一般而言，系统用一个特殊位的值表示有符号整数的正负号。</p>\n<h4 id=\"初始化变量\">初始化变量<a href=\"#初始化变量\" title=\"初始化变量\"></a></h4><p>初始化（initialize）变量就是为变量赋一个初始值。在C语言中，初始化可以直接在声明中完成。只需在变量名后面加上赋值运算符（=）和待赋给变量的值即可。如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int hogs &#x3D; 21;</span><br><span class=\"line\">int cows &#x3D; 32, goats &#x3D; 14;</span><br><span class=\"line\">int dogs, cats &#x3D; 94; &#x2F;* 有效，但是这种格式很糟糕 *&#x2F;</span><br></pre></td></tr></table></figure><p>以上示例的最后一行，只初始化了cats，并未初始化dogs。这种写法很容易让人误认为dogs也被初始化为94，所以最好不要把初始化的变量和未初始化的变量放在同一条声明中。</p>\n<p>简而言之，声明为变量创建和标记存储空间，并为其指定初始值</p>\n<p><img src=\"https://i.loli.net/2020/05/17/eWy19LuAIbYD2cm.jpg\" class=\"φcy\"></p>\n<h4 id=\"int类型常量\">int类型常量<a href=\"#int类型常量\" title=\"int类型常量\"></a></h4><p>上面示例中出现的整数（21、32、14和94）都是整型常量或整型字面量。C语言把不含小数点和指数的数作为整数。因此，22和-44都是整型常量，但是22.0和2.2E1则不是。C语言把大多数整型常量视为int类型，但是非常大的整数除外。详见后面“long常量和long long常量”小节对long int类型的讨论。</p>\n<h4 id=\"打印int值\">打印int值<a href=\"#打印int值\" title=\"打印int值\"></a></h4><p>可以使用printf()函数打印int类型的值。%d指明了在一行中打印整数的位置。%d称为转换说明，它指定了printf()应使用什么格式来显示一个值。格式化字符串中的每个%d都与待打印变量列表中相应的int值匹配。这个值可以是int类型的变量、int类型的常量或其他任何值为int类型的表达式。作为程序员，要确保转换说明的数量与待打印值的数量相同，编译器不会捕获这类型的错误。下面演示了一个简单的程序，程序中初始化了一个变量，并打印该变量的值、一个常量值和一个简单表达式的值。另外，程序还演示了如果粗心犯错会导致什么结果。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int　ten　&#x3D;　10;</span><br><span class=\"line\">    int　two　&#x3D;　2;</span><br><span class=\"line\">    printf(&quot;Doing　it　right:　&quot;);</span><br><span class=\"line\">    printf(&quot;%d　minus　%d　is　%d\\n&quot;,ten,2,ten-two);</span><br><span class=\"line\">    printf(&quot;Doing　it　wrong:　&quot;);</span><br><span class=\"line\">    printf(&quot;%d minus %d is %d\\n&quot;,ten);　&#x2F;&#x2F; 遗漏2个参数</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行该程序，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Doing it right: 10 minus 2 is 8</span><br><span class=\"line\">Doing it wrong: 10 minus 16 is 1650287143</span><br></pre></td></tr></table></figure><p>在第一行输出中，第1个%d对应int类型变量ten；第2个%d对应int类型常量2；第3个%d对应int类型表达式ten - two的值。</p>\n<p><mark>在第二行输出中，第1个%d对应ten的值，但是由于没有给后两个%d提供任何值，所以打印出的值是内存中的任意值</mark>（读者在运行该程序时显示的这两个数值会与输出示例中的数值不同，因为内存中储存的数据不同，而且编译器管理内存的位置也不同）。</p>\n<p>你可能会抱怨编译器为何不能捕获这种明显的错误，但实际上问题出在 printf()不寻常的设计。大部分函数都需要指定数目的参数，编译器会检查参数的数目是否正确。但是，printf()函数的参数数目不定，可以有1个、2个、3个或更多，编译器也爱莫能助。记住，使用printf()函数时，要确保转换说明的数量与待打印值的数量相等。</p>\n<blockquote>\n<p>当printf没有为%d提供对应的值时，打印出的值是内存中的任意值</p>\n</blockquote>\n<h4 id=\"八进制和十六进制\">八进制和十六进制<a href=\"#八进制和十六进制\" title=\"八进制和十六进制\"></a></h4><p>通常，C语言都假定整型常量是十进制数。然而，许多程序员很喜欢使用八进制和十六进制数。因为8和16都是2的幂，而10却不是。显然，八进制和十六进制记数系统在表达与计算机相关的值时很方便。</p>\n<p>例如，十进制数65536经常出现在16位机中，用十六进制表示正好是10000。另外，十六进制数的每一位的数恰好由4位二进制数表示。例如，十六进制数3是0011，十六进制数5是0101。因此，十六进制数35的位组合（bit pattern）是00110101，十六进制数53的位组合是01010011。这种对应关系使得十六进制和二进制的转换非常方便。但是，计算机如何知道10000是十进制、十六进制还是二进制？在C语言中，用特定的前缀表示使用哪种进制。</p>\n<p><span id=\"inline-blue\">0x或0X前缀表示十六进制值</span>，所以十进制数16表示成十六进制是0x10或0X10。与此类似，<span id=\"inline-blue\">0前缀表示八进制</span>。例如，十进制数16表示成八进制是020。第15章将更全面地介绍进制相关的内容。</p>\n<p>要清楚，使用不同的进制数是为了方便，不会影响数被储存的方式。也就是说，无论把数字写成16、020或0x10，储存该数的方式都相同，因为计算机内部都以二进制进行编码。</p>\n<h4 id=\"显示八进制和十六进制\">显示八进制和十六进制<a href=\"#显示八进制和十六进制\" title=\"显示八进制和十六进制\"></a></h4><p>在C程序中，既可以使用和显示不同进制的数。不同的进制要使用不同的转换说明。以<span id=\"inline-green\">十进制显示数字，使用%d</span>；以<span id=\"inline-blue\">八进制显示数字，使用%o</span>；<span id=\"inline-purple\">以十六进制显示数字，使用%x</span>。另外，要显示各进制数的前缀0、0x和0X，必须分别使用%#o、%#x、%#X。下面程序演示了一个小程序。回忆一下，在某些集成开发环境（IDE）下编写的代码中插入getchar();语句，程序在执行完毕后不会立即关闭执行窗口。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* bases.c--以十进制、八进制、十六进制打印十进制数100 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int　x　&#x3D;　100;</span><br><span class=\"line\">    printf(&quot;dec&#x3D;%d;octal&#x3D;%o;hex&#x3D;%x\\n&quot;,x,x,x);</span><br><span class=\"line\">    printf(&quot;dec&#x3D;%d;octal&#x3D;%#o;hex&#x3D;%#x\\n&quot;,x,x,x);</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>编译并运行该程序，输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">dec &#x3D; 100; octal &#x3D; 144; hex &#x3D; 64</span><br><span class=\"line\">dec &#x3D; 100; octal &#x3D; 0144; hex &#x3D; 0x64</span><br></pre></td></tr></table></figure><p>该程序以3种不同记数系统显示同一个值。printf()函数做了相应的转换。注意，如果要在八进制和十六进制值前显示0和0x前缀，要分别在转换说明中加入#。</p>\n<h3 id=\"其他整数类型\">其他整数类型<a href=\"#其他整数类型\" title=\"其他整数类型\"></a></h3><p>C语言提供3个附属关键字修饰基本整数类型：<span id=\"inline-green\">short</span>、<span id=\"inline-blue\">long</span>和<span id=\"inline-grey\">unsigned</span>。应记住以下几点。</p>\n<ol><li><p>short int类型（或者简写为short）占用的存储空间可能比int类型少，常用于较小数值的场合以节省空间。与int类似，short是有符号类型。</p>\n</li>\n<li><p>long int或long占用的存储空间可能比int多，适用于较大数值的场合。与int类似，long是有符号类型。</p>\n</li>\n<li><p>long long int或long long（C99标准加入）占用的储存空间可能比long多，适用于更大数值的场合。该类型至少占64位。与int类似，long long是有符号类型。</p>\n</li>\n<li><p>unsigned int或unsigned只用于非负值的场合。这种类型与有符号类型表示的范围不同。例如，16位unsigned int允许的取值范围是0～65535，而不是-32768～32767。用于表示正负号的位现在用于表示另一个二进制位，所以无符号整型可以表示更大的数。</p>\n</li>\n<li><p>在C90标准中，添加了unsigned long int或unsigned long和unsigned int或unsigned short类型。C99标准又添加了unsigned long long int或unsigned long long。</p>\n</li>\n<li><p>在任何有符号类型前面添加关键字signed，可强调使用有符号类型的意图。例如，short、short int、signed short、signed short int都表示同一种类型。</p>\n</li>\n</ol><h4 id=\"声明其他整数类型\">声明其他整数类型<a href=\"#声明其他整数类型\" title=\"声明其他整数类型\"></a></h4><p>其他整数类型的声明方式与int类型相同，下面列出了一些例子。不是所有的C编译器都能识别最后3条声明，最后一个例子所有的类型是C99标准新增的。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">long int　estine;</span><br><span class=\"line\">long johns;</span><br><span class=\"line\">short int　erns;</span><br><span class=\"line\">short　ribs;</span><br><span class=\"line\">unsigned int　s_count;</span><br><span class=\"line\">unsigned　players;</span><br><span class=\"line\">unsigned long　headcount;</span><br><span class=\"line\">unsigned short　yesvotes;</span><br><span class=\"line\">long long　ago;</span><br></pre></td></tr></table></figure><h4 id=\"使用多种整数类型的原因\">使用多种整数类型的原因<a href=\"#使用多种整数类型的原因\" title=\"使用多种整数类型的原因\"></a></h4><p>为什么说short类型“可能”比int类型占用的空间少，long类型“可能”比int类型占用的空间多？因为C语言只规定了short占用的存储空间不能多于int，long占用的存储空间不能少于int。这样规定是为了适应不同的机器。</p>\n<p>例如，过去的一台运行Windows 3的机器上，int类型和short类型都占16位，long类型占32位。后来，Windows和苹果系统都使用16位储存short类型，32位储存int类型和long类型（使用32位可以表示的整数数值超过20亿）。现在，计算机普遍使用64位处理器，为了储存64位的整数，才引入了long long类型。</p>\n<p>现在，个人计算机上最常见的设置是，<mark>long long占64位，long占32位，short占16位，int占16位或32位</mark>（依计算机的自然字长而定）。原则上，这4种类型代表4种不同的大小，但是在实际使用中，有些类型之间通常有重叠。</p>\n<p>C 标准对基本数据类型只规定了允许的最小大小。对于 16 位机，short 和 int 的最小取值范围是[−32767,32767]；对于32位机，long的最小取值范围是[−2147483647,2147483647]。对于unsigned short和unsigned int，最小取值范围是[0,65535]；对于unsigned long，最小取值范围是[0,4294967295]。long long类型是为了支持64位的需求，最小取值范围是[−9223372036854775807,9223372036854775807]；unsigned long long的最小取值范围是[0,18446744073709551615]。如果要开支票，这个数是一千八百亿亿（兆）六千七百四十四万亿零七百三十七亿零九百五十五万一千六百一十五。但是，谁会去数？</p>\n<p>int类型那么多，应该如何选择？首先，考虑unsigned类型。这种类型的数常用于计数，因为计数不用负数。而且，unsigned类型可以表示更大的正数。</p>\n<p>如果一个数超出了int类型的取值范围，且在long类型的取值范围内时，使用long类型。然而，对于那些long占用的空间比int大的系统，使用long类型会减慢运算速度。因此，如非必要，请不要使用long类型。另外要注意一点：如果在long类型和int类型占用空间相同的机器上编写代码，当确实需要32位的整数时，应使用long类型而不是int类型，以便把程序移植到16位机后仍然可以正常工作。类似地，如果确实需要64位的整数，应使用long long类型。</p>\n<p>如果在int设置为32位的系统中要使用16位的值，应使用short类型以节省存储空间。通常，只有当程序使用相对于系统可用内存较大的整型数组时，才需要重点考虑节省空间的问题。使用short类型的另一个原因是，计算机中某些组件使用的硬件寄存器是16位。</p>\n<h4 id=\"long常量和long-long常量\">long常量和long long常量<a href=\"#long常量和long-long常量\" title=\"long常量和long long常量\"></a></h4><p>通常，程序代码中使用的数字（如，2345）都被储存为int类型。如果使用1000000这样的大数字，超出了int类型能表示的范围，编译器会将其视为long int类型（假设这种类型可以表示该数字）。如果数字超出long可表示的最大值，编译器则将其视为unsigned long类型。如果还不够大，编译器则将其视为long long或unsigned long long类型（前提是编译器能识别这些类型）。</p>\n<p>八进制和十六进制常量被视为int类型。如果值太大，编译器会尝试使用unsigned int。如果还不够大，编译器会依次使用long、unsigned long、long long和unsigned long long类型。</p>\n<p>有些情况下，需要编译器以long类型储存一个小数字。例如，编程时要显式使用IBM PC上的内存地址时。另外，一些C标准函数也要求使用long类型的值。<mark>要把一个较小的常量作为long类型对待，可以在值的末尾加上l（小写的L）或L后缀</mark>。使用L后缀更好，因为l看上去和数字1很像。因此，在int为16位、long为32位的系统中，会把7作为16位储存，把7L作为32位储存。l或L后缀也可用于八进制和十六进制整数，如020L和0x10L。</p>\n<p>类似地，<mark>在支持long long类型的系统中，也可以使用ll或LL后缀来表示long long类型的值</mark>，如3LL。另外，<mark>u或U后缀表示unsigned long long</mark>，如5ull、10LLU、6LLU或9Ull。</p>\n<h4 id=\"整数溢出\">整数溢出<a href=\"#整数溢出\" title=\"整数溢出\"></a></h4><p>如果整数超出了相应类型的取值范围会怎样？下面分别将有符号类型和无符号类型的整数设置为比最大值略大，看看会发生什么（printf()函数使用%u说明显示unsigned int类型的值）。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* toobig.c-- 超出系统允许的最大int值*&#x2F;</span><br><span class=\"line\">#include &lt;stdio.h&gt;</span><br><span class=\"line\">int main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int i&#x3D;2147483647;</span><br><span class=\"line\">    unsigned int j&#x3D;4294967295;</span><br><span class=\"line\">    printf(&quot;%d %d %d\\n&quot;,i,i+1,i+2);</span><br><span class=\"line\">    printf(&quot;%u %u %u\\n&quot;,j,j+1,j+2);</span><br><span class=\"line\">    return 0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在我们的系统下输出的结果是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">2147483647　　　-2147483648　 -2147483647</span><br><span class=\"line\">4294967295　　　0　　 1</span><br></pre></td></tr></table></figure><p>可以把无符号整数j看作是汽车的里程表。当达到它能表示的最大值时，会重新从起始点开始。整数 i 也是类似的情况。它们主要的区别是，在超过最大值时，unsigned int 类型的变量 j 从 0开始；而int类型的变量i则从−2147483648开始。注意，当i超出（溢出）其相应类型所能表示的最大值时，系统并未通知用户。因此，在编程时必须自己注意这类问题。</p>\n<p>溢出行为是未定义的行为，C 标准并未定义有符号类型的溢出规则。以上描述的溢出行为比较有代表性，但是也可能会出现其他情况。</p>\n<h4 id=\"打印short、long、long-long和unsigned类型\">打印short、long、long long和unsigned类型<a href=\"#打印short、long、long-long和unsigned类型\" title=\"打印short、long、long long和unsigned类型\"></a></h4><p><mark>打印unsigned int类型的值，使用%u转换说明</mark>；<mark>打印long类型的值，使用%ld转换说明</mark>。如果系统中int和long的大小相同，使用%d就行。但是，这样的程序被移植到其他系统（int和long类型的大小不同）中会无法正常工作。在x和o前面可以使用l前缀，%lx表示以十六进制格式打印long类型整数，%lo表示以八进制格式打印long类型整数。注意，虽然C允许使用大写或小写的常量后缀，但是在转换说明中只能用小写。</p>\n<p>C语言有多种printf()格式。<mark>对于short类型，可以使用h前缀</mark>。<span id=\"inline-purple\">%hd表示以十进制显示short类型的整数，%ho表示以八进制显示short类型的整数</span>。h和l前缀都可以和u一起使用，用于表示无符号类型。例如，<span id=\"inline-purple\">%lu表示打印unsigned long类型的值</span>。下面程序演示了一些例子。对于支持long long类型的系统，%lld和%llu分别表示有符号和无符号类型。《字符串和格式化输入/输出》将详细介绍转换说明。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* print2.c--更多printf()的特性 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    unsigned int un&#x3D;3000000000;     &#x2F;* int为32位和short为16位的系统 *&#x2F;</span><br><span class=\"line\">    short　end&#x3D;200;</span><br><span class=\"line\">    long　big&#x3D;65537;</span><br><span class=\"line\">    long　long　verybig　&#x3D;　12345678908642;</span><br><span class=\"line\">    printf(&quot;un&#x3D;%u　and　not　%d\\n&quot;,　un,　un);</span><br><span class=\"line\">    printf(&quot;end&#x3D;%hd　and　%d\\n&quot;,　end,　end);</span><br><span class=\"line\">    printf(&quot;big&#x3D;%ld　and　not　%hd\\n&quot;,　big,　big);</span><br><span class=\"line\">    printf(&quot;verybig&#x3D;%lld　and　not　%ld\\n&quot;,verybig,verybig);</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>在特定的系统中输出如下（输出的结果可能不同）：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">un &#x3D; 3000000000 and not -1294967296</span><br><span class=\"line\">end &#x3D; 200 and 200</span><br><span class=\"line\">big &#x3D; 65537 and not 1</span><br><span class=\"line\">verybig&#x3D; 12345678908642 and not 1942899938</span><br></pre></td></tr></table></figure><p>该例表明，使用错误的转换说明会得到意想不到的结果。第 1 行输出，对于无符号变量 un，使用%d会生成负值！其原因是，无符号值 3000000000 和有符号值−129496296 在系统内存中的内部表示完全相同（详见位操作）。</p>\n<p>因此，如果告诉printf()该数是无符号数，它打印一个值；如果告诉它该数是有符号数，它将打印另一个值。在待打印的值大于有符号值的最大值时，会发生这种情况。对于较小的正数（如96），有符号和无符号类型的存储、显示都相同。</p>\n<p>第2行输出，对于short类型的变量end，在printf()中无论指定以short类型（%hd）还是int类型（%d）打印，打印出来的值都相同。这是因为在给函数传递参数时，C编译器把short类型的值自动转换成int类型的值。你可能会提出疑问：为什么要进行转换？h修饰符有什么用？第1个问题的答案是， int类型被认为是计算机处理整数类型时最高效的类型。因此，在short和int类型的大小不同的计算机中，用int类型的参数传递速度更快。第2个问题的答案是，使用h修饰符可以显示较大整数被截断成 short 类型值的情况。</p>\n<p>第 3 行输出就演示了这种情况。把 65537 以二进制格式写成一个 32 位数是00000000000000010000000000000001。使用%hd，printf()只会查看后 16 位，所以显示的值是 1。</p>\n<p>与此类似，输出的最后一行先显示了verybig的完整值，然后由于使用了%ld，printf()只显示了储存在后32位的值。</p>\n<p>本章前面介绍过，程序员必须确保转换说明的数量和待打印值的数量相同。以上内容也提醒读者，程序员还必须根据待打印值的类型使用正确的转换说明。</p>\n<blockquote>\n<p>提示 匹配printf()说明符的类型</p>\n</blockquote>\n<p>在使用 printf()函数时，切记检查每个待打印值都有对应的转换说明，还要检查转换说明的类型是否与待打印值的类型相匹配。</p>\n<h3 id=\"使用字符：char类型\">使用字符：char类型<a href=\"#使用字符：char类型\" title=\"使用字符：char类型\"></a></h3><p>char类型用于储存字符（如，字母或标点符号），但是从技术层面看，char是整数类型。因为char类型实际上储存的是整数而不是字符。计算机使用数字编码来处理字符，即用特定的整数表示特定的字符。美国最常用的编码是ASCII编码，本书也使用此编码。例如，在ASCII码中，整数65代表大写字母A。因此，储存字母A实际上储存的是整数65（许多IBM的大型主机使用另一种编码——EBCDIC，其原理相同。另外，其他国家的计算机系统可能使用完全不同的编码）。</p>\n<p>标准ASCII码的范围是0～127，只需7位二进制数即可表示。通常，<strong>char类型被定义为8位的存储单元</strong>，因此容纳标准ASCII码绰绰有余。许多其他系统（如IMB PC和苹果Macs）还提供扩展ASCII码，也在8位的表示范围之内。一般而言，C语言会保证char类型足够大，以储存系统（实现C语言的系统）的基本字符集。</p>\n<p>许多字符集都超过了127，甚至多于255。例如，日本汉字（kanji）字符集。商用的统一码（Unicode）创建了一个能表示世界范围内多种字符集的系统，目前包含的字符已超过110000个。国际标准化组织（ISO）和国际电工技术委员会（IEC）为字符集开发了ISO/IEC 10646标准。统一码标准也与ISO/IEC 10646标准兼容。</p>\n<p><strong>C语言把1字节定义为char类型占用的位（bit）数，因此无论是16位还是32位系统，都可以使用char类型。</strong></p>\n<h4 id=\"声明char类型变量\">声明char类型变量<a href=\"#声明char类型变量\" title=\"声明char类型变量\"></a></h4><p>char类型变量的声明方式与其他类型变量的声明方式相同。下面是一些例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char response;</span><br><span class=\"line\">char itable, latan;</span><br></pre></td></tr></table></figure><p>以上声明创建了3个char类型的变量：response、itable和latan。</p>\n<h4 id=\"字符常量和初始化\">字符常量和初始化<a href=\"#字符常量和初始化\" title=\"字符常量和初始化\"></a></h4><p>如果要把一个字符常量初始化为字母 A，不必背下 ASCII 码，用计算机语言很容易做到。通过以下初始化把字母A赋给grade即可：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char grade &#x3D; &#39;A&#39;;</span><br></pre></td></tr></table></figure><p>在C语言中，用单引号括起来的单个字符被称为字符常量（character constant）。编译器一发现’A’，就会将其转换成相应的代码值。单引号必不可少。下面还有一些其他的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char broiled;　　 &#x2F;* 声明一个char类型的变量 *&#x2F;</span><br><span class=\"line\">broiled &#x3D; &#39;T&#39;;　　&#x2F;* 为其赋值，正确 *&#x2F;</span><br><span class=\"line\">broiled &#x3D; T;　　　&#x2F;* 错误！此时T是一个变量 *&#x2F;</span><br><span class=\"line\">broiled &#x3D; &quot;T&quot;;　　&#x2F;* 错误！此时&quot;T&quot;是一个字符串 *&#x2F;</span><br></pre></td></tr></table></figure><p>如上所示，如果省略单引号，编译器认为T是一个变量名；如果把T用双引号括起来，编译器则认为”T”是一个字符串。字符串的内容将在《字符串和格式化输入/输出》中介绍。</p>\n<p>实际上，字符是以数值形式储存的，所以也可使用数字代码值来赋值：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char grade &#x3D; 65; &#x2F;* 对于ASCII，这样做没问题，但这是一种不好的编程风格 *&#x2F;</span><br></pre></td></tr></table></figure><p>在本例中，虽然65是int类型，但是它在char类型能表示的范围内，所以将其赋值给grade没问题。由于65是字母A对应的ASCII码，因此本例是把A赋给grade。注意，能这样做的前提是系统使用ASCII码。其实，用’A’代替65才是较为妥当的做法，这样在任何系统中都不会出问题。因此，最好使用字符常量，而不是数字代码值。</p>\n<p>奇怪的是，C语言将字符常量视为int类型而非char类型。例如，在int为32位、char为8位的ASCII系统中，有下面的代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char grade &#x3D; &#39;B&#39;;</span><br></pre></td></tr></table></figure><p><mark>本来’B’对应的数值66储存在32位的存储单元中，现在却可以储存在8位的存储单元中（grade）。利用字符常量的这种特性，可以定义一个字符常量’FATE’，即把4个独立的8位ASCII码储存在一个32位存储单元中</mark>。如果把这样的字符常量赋给char类型变量grade，只有最后8位有效。因此，grade的值是’E’。</p>\n<h4 id=\"非打印字符\">非打印字符<a href=\"#非打印字符\" title=\"非打印字符\"></a></h4><p>单引号只适用于字符、数字和标点符号，浏览ASCII表会发现，有些ASCII字符打印不出来。例如，一些代表行为的字符（如，退格、换行、终端响铃或蜂鸣）。C语言提供了3种方法表示这些字符。</p>\n<ol><li>第1种方法前面介绍过——使用ASCII码。例如，蜂鸣字符的ASCII值是7，因此可以这样写：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char beep &#x3D; 7;</span><br></pre></td></tr></table></figure></li>\n<li>第2种方法是，使用特殊的符号序列表示一些特殊的字符。这些符号序列叫作转义序列（escape sequence）。图列出了转义序列及其含义。<br>把转义序列赋给字符变量时，必须用单引号把转义序列括起来。例如，假设有下面一行代码：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char nerf &#x3D; &#39;\\n&#39;;</span><br></pre></td></tr></table></figure>稍后打印变量nerf的效果是，在打印机或屏幕上另起一行。</li>\n</ol><p><img src=\"https://i.loli.net/2020/05/17/mulqT9tWaf47LYC.jpg\" class=\"φcy\"></p>\n<p>现在，我们来仔细分析一下转义序列。使用C90新增的警报字符（\\a）是否能产生听到或看到的警报，取决于计算机的硬件，蜂鸣是最常见的警报（在一些系统中，警报字符不起作用）。<mark>C标准规定警报字符不得改变活跃位置</mark>。标准中的活跃位置（active position）指的是显示设备（屏幕、电传打字机、打印机等）中下一个字符将出现的位置。简而言之，平时常说的屏幕光标位置就是活跃位置。在程序中把警报字符输出在屏幕上的效果是，发出一声蜂鸣，但不会移动屏幕光标。</p>\n<p>接下来的转义字符\\b、\\f、\\n、\\r、\\t和\\v是常用的输出设备控制字符。了解它们最好的方式是查看它们对活跃位置的影响。</p>\n<ul><li><p>换页符（\\f）把活跃位置移至下一页的开始处；</p>\n</li>\n<li><p>换行符（\\n）把活跃位置移至下一行的开始处；</p>\n</li>\n<li><p>回车符（\\r）把活跃位置移动到当前行的开始处；</p>\n</li>\n<li><p>水平制表符（\\t）将活跃位置移至下一个水平制表点（通常是第1个、第9个、第17个、第25个等字符位置）；</p>\n</li>\n<li><p>垂直制表符（\\v）把活跃位置移至下一个垂直制表点。</p>\n</li>\n</ul><p>这些转义序列字符不一定在所有的显示设备上都起作用。例如，换页符和垂直制表符在PC屏幕上会生成奇怪的符号，光标并不会移动。只有将其输出到打印机上时才会产生前面描述的效果。</p>\n<p>接下来的3个转义序列（\\\\、\\‘、\\“）用于打印<code>\\</code>、<code>&#39;</code>、<code>&quot;</code>字符（由于这些字符用于定义字符常量，是printf()函数的一部分，若直接使用它们会造成混乱）。如果打印下面一行内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Gramps sez, &quot;a \\ is a backslash.&quot;</span><br></pre></td></tr></table></figure><p>应这样编写代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash.\\&quot;\\n&quot;);</span><br></pre></td></tr></table></figure><p>表中的最后两个转义序列（\\0oo和\\xhh）是ASCII码的特殊表示。如果要用八进制ASCII码表示一个字符，可以在编码值前面加一个反斜杠（\\）并用单引号括起来。<mark>八进制表示格式为/000，可写<span id=\"inline-red\">1～3位八进制进制数字</span>，每位数最大值为7</mark></p>\n<p>例如，如果编译器不识别警报字符（\\a），可以使用ASCII码来代替：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">beep &#x3D; &#39;\\007&#39;;</span><br></pre></td></tr></table></figure><p>可以省略前面的 0，’\\07’甚至’\\7’都可以。即使没有前缀 0，编译器在处理这种写法时，仍会解释为八进制。</p>\n<p>从C90开始，不仅可以用十进制、八进制形式表示字符常量，C语言还提供了第3种选择——用十六进制形式表示字符常量，即反斜杠后面跟一个x或X。<mark>十六进制数表示格式为/xhh，前面的x表示是十六进制，再加上<span id=\"inline-red\">1～2位十六进制数字</span>，所以后面的两个h可以表示两位数，每位数最大值为f</mark></p>\n<p>例如，Ctrl+P字符的ASCII十六进制码是10（相当于十进制的16），可表示为’\\x10’或’\\x010’。下图列出了一些整数类型的不同进制形式。</p>\n<p><img src=\"https://i.loli.net/2020/05/17/lWNBHUvyro95qt3.jpg\" class=\"φcy\"></p>\n<p>使用ASCII码时，注意<code>数字</code>和<code>数字字符</code>的区别。例如，<code>字符4</code>对应的ASCII码是52。<code>&#39;4&#39;</code>表示字符4，而不是数值4。</p>\n<p>关于转义序列，读者可能有下面3个问题。</p>\n<ol><li><p>上面最后一个例子<code>（printf(&quot;Gramps sez, \\&quot;a \\\\ is a backslash\\&quot;\\&quot;n&quot;）</code>，  为何没有用单引号把转义序列括起来？<br> <mark>无论是普通字符还是转义序列，只要是双引号括起来的字符集合，就无需用单引号括起来</mark>。双引号中的字符集合叫作字符串（<code>详见字符串和格式化输入输出</code>）。注意，该例中的其他字符（<code>G、r、a、m、p、s</code>等）都没有用单引号括起来。与此类似，<code>printf(&quot;Hello!\\007\\n&quot;);</code><mark>将打印<code>Hello!</code>并发出一声蜂鸣</mark>，而 <code>printf(&quot;Hello!7\\n&quot;);</code>则打印 <code>Hello!7</code>。不是转义序列中的数字将作为普通字符被打印出来。</p>\n</li>\n<li><p>何时使用ASCII码？何时使用转义序列？如果要在转义序列（假设使用’\\f’）和ASCII码（’\\014’）之间选择，请选择前者（即’\\f’）。这样的写法不仅更好记，而且可移植性更高。’\\f’在不使用ASCII码的系统中，仍然有效。</p>\n</li>\n<li><p>如果要使用ASCII码，为何要写成’\\032’而不是032？首先，’\\032’能更清晰地表达程序员使用字符编码的意图。其次，类似\\032这样的转义序列可以嵌入C的字符串中，如printf(“Hello!\\007\\n”);中就嵌入了\\007。</p>\n</li>\n</ol><h4 id=\"打印字符\">打印字符<a href=\"#打印字符\" title=\"打印字符\"></a></h4><p>printf()函数用%c指明待打印的字符。前面介绍过，一个字符变量实际上被储存为1字节的整数值。因此，如果用%d转换说明打印 char类型变量的值，打印的是一个整数。而%c转换说明告诉printf()打印该整数值对应的字符。程序清单3.5演示了打印char类型变量的两种方式。</p>\n<p>程序清单3.5 charcode.c程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* charcode.c-显示字符的代码编号 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">char　ch;</span><br><span class=\"line\">printf(&quot;Please　enter　a　character.\\n&quot;);</span><br><span class=\"line\">scanf(&quot;%c&quot;, &amp;ch);　&#x2F;* 用户输入字符 *&#x2F;</span><br><span class=\"line\">printf(&quot;The　code　for　%c　is　%d.\\n&quot;,　ch,　ch);</span><br><span class=\"line\">return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>运行该程序后，输出示例如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Please　enter　a　character.</span><br><span class=\"line\">C</span><br><span class=\"line\">The　code　for　C　is　67.</span><br></pre></td></tr></table></figure><p>运行该程序时，在输入字母后不要忘记按下Enter或Return键。随后，scanf()函数会读取用户输入的字符，&amp;符号表示把输入的字符赋给变量ch。接着，printf()函数打印ch的值两次，第1次打印一个字符（对应代码中的%c），第2次打印一个十进制整数值（对应代码中的%d）。注意，printf()函数中的转换说明决定了数据的显示方式，而不是数据的储存方式。</p>\n<p><img src=\"https://i.loli.net/2020/05/17/a8NgjWyhSUAOJ42.jpg\" class=\"φcy\"></p>\n<h4 id=\"有符号还是无符号\">有符号还是无符号<a href=\"#有符号还是无符号\" title=\"有符号还是无符号\"></a></h4><p>有些C编译器把char实现为有符号类型，这意味着char可表示的范围是-128～127。而有些C编译器把char实现为无符号类型，那么char可表示的范围是0～255。请查阅相应的编译器手册，确定正在使用的编译器如何实现char类型。或者，可以查阅limits.h头文件。下一章将详细介绍头文件的内容。</p>\n<p>根据C90标准，C语言允许在关键字char前面使用signed或unsigned。这样，无论编译器默认char是什么类型，signed char表示有符号类型，而unsigned char表示无符号类型。这在用char类型处理小整数时很有用。如果只用char处理字符，那么char前面无需使用任何修饰符。</p>\n<h3 id=\"bool类型\">Bool类型<a href=\"#bool类型\" title=\"Bool类型\"></a></h3><p>C99标准添加了<code>_Bool</code>类型，用于表示布尔值，即逻辑值<code>true</code>和<code>false</code>。因为C语言用值1表示true，值0表示false，所以<mark>_Bool类型实际上也是一种整数类型</mark>。但原则上它仅间<span id=\"inline-green\">占用1位存储空</span>，因为对0和1而言，1位的存储空间足够了。</p>\n<p>程序通过布尔值可选择执行哪部分代码。</p>\n<h3 id=\"可移植类型：stdinth和inttypesh\">可移植类型：stdint.h和inttypes.h<a href=\"#可移植类型：stdinth和inttypesh\" title=\"可移植类型：stdint.h和inttypes.h\"></a></h3><ol><li><p>C 语言提供了许多有用的整数类型。但是，某些类型名在不同系统中的功能不一样。C99 新增了两个头文件<code>stdint.h</code>和<code>inttypes.h</code>，以确保C语言的类型在各系统中的功能相同。</p>\n<p> C语言为现有类型创建了更多类型名。这些新的类型名定义在<code>stdint.h</code>头文件中。  </p>\n<ul><li><p>例如，<code>int32_t</code>表示32位的<strong>有符号整数类型</strong>。在使用32位int的系统中，头文件会把<code>int32_t</code>作为<code>int</code>的别名。  </p>\n<p>不同的系统也可以定义相同的类型名。</p>\n</li>\n<li><p>例如，<code>int</code>为16位、<code>long</code>为32位的系统会把<code>int32_t</code>作为long的别名。然后，使用<code>int32_t</code>类型编写程序，并包含<code>stdint.h</code>头文件时，编译器会把<code>int</code>或<code>long</code>替换成与当前系统匹配的类型。</p>\n<p>上面讨论的类型别名是<strong>精确宽度整数类型（exact-width integer type）</strong>的示例。<mark>int32_t表示整数类型的宽度正好是32位</mark>。但是，计算机的底层系统可能不支持。因此，精确宽度整数类型是可选项。</p>\n</li>\n</ul></li>\n<li><p>如果系统不支持精确宽度整数类型怎么办？<br> C99和C11提供了第2类别名集合。一些类型名保证所表示的类型一定是至少有指定宽度的最小整数类型。这组类型集合被称为<strong>最小宽度类型（minimum width type）</strong>。</p>\n<p> 例如，<code>int_least8_t</code>是可容纳8位有符号整数值的类型中宽度最小的类型的一个别名。如果某系统的最小整数类型是16位，可能不会定义int8_t类型。尽管如此，该系统仍可使用<code>int_least8_t</code>类型，但可能把该类型实现为16位的整数类型。</p>\n<p> 当然，一些程序员更关心速度而非空间。为此，C99和C11定义了一组可使计算达到最快的类型集合。这组类型集合被称为<strong>最快最小宽度类型（fastst minimum width type）</strong>。</p>\n</li>\n</ol><p>例如，<code>int_fast8_t</code>被定义为系统中对8位有符号值而言运算最快的整数类型的别名。</p>\n<p>另外，有些程序员需要系统的最大整数类型。为此，<code>C99</code>定义了最大的有符号整数类型<code>intmax_t</code>，可储存任何有效的有符号整数值。类似地，<code>unintmax_t</code>表示最大的无符号整数类型。顺带一提，这些类型有可能比<code>long long</code>和<code>unsigned long</code>类型更大，因为C编译器除了实现标准规定的类型以外，还可利用C语言实现其他类型。例如，一些编译器在标准引入 long long 类型之前，已提前实现了该类型。</p>\n<p><code>C99</code> 和<code>C11</code> 不仅提供可移植的类型名，还提供相应的<strong>输入和输出</strong>。</p>\n<p>例如，<code>printf()</code>打印特定类型时要求与相应的转换说明匹配。</p>\n<blockquote>\n<p>如果要打印<code>int32_t</code>类型的值，有些定义使用%d，而有些定义使用%ld，怎么办？</p>\n</blockquote>\n<p>C 标准针对这一情况，提供了一些字符串宏（下章中详细介绍）来显示可移植类型。例如， <code>inttypes.h</code>头文件中定义了<code>PRId32</code><strong>字符串宏</strong>，<mark>代表打印32位有符号值的合适转换说明（如d或l）</mark>。程序清单3.6演示了一种可移植类型和相应转换说明的用法。</p>\n<p>程序清单3.6 altnames.c程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* altnames.c -- 可移植整数类型名 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">#include &lt;inttypes.h&gt; &#x2F;&#x2F; 支持可移植类型</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">\tint32_t me32;　　 &#x2F;&#x2F; me32是一个32位有符号整型变量</span><br><span class=\"line\">\tme32&#x3D;45933945;</span><br><span class=\"line\">\tprintf(&quot;First,assume int32_t is int: &quot;);</span><br><span class=\"line\">\tprintf(&quot;me32&#x3D;%d\\n&quot;,me32);</span><br><span class=\"line\">\tprintf(&quot;Next,let&#39;s not make any assumptions.\\n&quot;);</span><br><span class=\"line\">\tprintf(&quot;Instead,use a \\&quot;macro\\&quot; from　inttypes.h:　&quot;);</span><br><span class=\"line\">\tprintf(&quot;me32&#x3D;%&quot; PRId32 &quot;\\n&quot;,　me32);</span><br><span class=\"line\">\treturn　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序最后一个printf()中，参数PRId32被定义在inttypes.h中的”d”替换，因而这条语句等价于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;me16 &#x3D; %&quot; &quot;d&quot; &quot;\\n&quot;, me16);</span><br></pre></td></tr></table></figure><p>在C语言中，可以把多个连续的字符串组合成一个字符串，所以这条语句又等价于：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;me16 &#x3D; %d\\n&quot;, me16);</span><br></pre></td></tr></table></figure><p>下面是该程序的输出，注意，程序中使用了&quot;转义序列来显示双引号：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">First, assume int32_t is int: me32 &#x3D; 45933945</span><br><span class=\"line\">Next, let&#39;s not make any assumptions.</span><br><span class=\"line\">Instead, use a &quot;macro&quot; from inttypes.h: me32 &#x3D; 45933945</span><br></pre></td></tr></table></figure><p>篇幅有限，无法介绍扩展的所有整数类型。本节主要是为了让读者知道，在需要时可进行这种级别的类型控制。附录B中的参考资料VI“扩展的整数类型”介绍了完整的inttypes.h和stdint.h头文件。</p>\n<p>注意 对C99/C11的支持</p>\n<p>C语言发展至今，虽然ISO已发布了C11标准，但是编译器供应商对C99的实现程度却各不相同。在本书第6版的编写过程中，一些编译器仍未实现inttypes.h头文件及其相关功能。</p>\n<h3 id=\"float、double和long-double\">float、double和long double<a href=\"#float、double和long-double\" title=\"float、double和long double\"></a></h3><p>各种整数类型对大多数软件开发项目而言够用了。然而，面向金融和数学的程序经常使用浮点数。C语言中的浮点类型有<code>float</code>、<code>double</code>和<code>long double</code>类型。它们与FORTRAN和Pascal中的real类型一致。前面提到过，<strong>浮点类型能表示包括小数在内更大范围的数</strong>。<mark>浮点数的表示类似于科学记数法（即用小数乘以10的幂来表示数字）</mark>。<strong>该记数系统常用于表示非常大或非常小的数</strong>。表3.3列出了一些示例。</p>\n<p>表3.3 记数法示例</p>\n<p><img src=\"https://i.loli.net/2020/05/17/JNo2cunsDfqZzU1.jpg\" class=\"φcy\"></p>\n<p>第1列是一般记数法；第2列是科学记数法；第3列是指数记数法（或称为e记数法），这是科学记数法在计算机中的写法，e后面的数字代表10的指数。图3.7演示了更多的浮点数写法。</p>\n<p>C标准规定，<mark>float类型必须至少能表示6位有效数字，且取值范围至少是10<sup>-37</sup>～10<sup>+37</sup></mark>。前一项规定指float类型必须至少精确表示小数点后的6位有效数字，如33.333333。后一项规定用于方便地表示诸如太阳质量（2.0e30千克）、一个质子的电荷量（1.6e-19库仑）或国家债务之类的数字。通常，系统储存<mark>一个<code>long</code>浮点数要占用32位</mark>。其中8位用于表示指数的值和符号，剩下24位用于表示非指数部分（也叫作尾数或有效数）及其符号。</p>\n<p><img src=\"https://i.loli.net/2020/05/17/1fws4XUSManYvzV.jpg\" class=\"φcy\"></p>\n<p>C语言提供的另一种浮点类型是<code>double</code>（意为双精度）。<strong><code>double</code>类型和<code>float</code>类型的最小取值范围相同，但至少必须能表示10位有效数字</strong>。一般情况下，<mark>double占用64位而不是32位</mark>。<strong>一些系统将多出的 32 位全部用来表示非指数部分，这不仅增加了有效数字的位数（即提高了精度），而且还减少了舍入误差。</strong>另一些系统把其中的一些位分配给指数部分，以容纳更大的指数，从而增加了可表示数的范围。无论哪种方法，<mark>double类型的值至少有13位有效数字</mark>，超过了标准的最低位数规定。</p>\n<p>C语言的第3种浮点类型是<code>long double</code>，以满足比<code>double</code>类型更高的精度要求。不过，C只保证<code>long double</code>类型至少与<code>double</code>类型的精度相同。</p>\n<ol><li><p>声明浮点型变量<br> 浮点型变量的声明和初始化方式与整型变量相同，下面是一些例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float　noah,　jonah;</span><br><span class=\"line\">double　trouble;</span><br><span class=\"line\">float　planck　&#x3D;　6.63e-34;</span><br><span class=\"line\">long　double　gnp;</span><br></pre></td></tr></table></figure></li>\n<li><p>浮点型常量<br> 在代码中，可以用多种形式书写浮点型常量。浮点型常量的基本形式是：有符号的数字（包括小数点），后面紧跟e或E，最后是一个有符号数表示10的指数。下面是两个有效的浮点型常量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">-1.56E+12</span><br><span class=\"line\">2.87e-3</span><br></pre></td></tr></table></figure><p> 正号可以省略。可以没有小数点（如，2E5）或指数部分（如，19.28），但是不能同时省略两者。可以省略小数部分（如，3.E16）或整数部分（如，.45E-6），但是不能同时省略两者。下面是更多的有效浮点型常量示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">3.14159</span><br><span class=\"line\">.2</span><br><span class=\"line\">4e16</span><br><span class=\"line\">.8E-5</span><br><span class=\"line\">100.</span><br></pre></td></tr></table></figure><p><mark>不要在浮点型常量中间加空格：1.56 E+12（错误！）</mark></p>\n</li>\n</ol><p><strong>默认情况下，编译器假定浮点型常量是double类型的精度</strong>。例如，假设some是<code>float</code>类型的变量，编写下面的语句：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">some &#x3D; 4.0 * 2.0;</span><br></pre></td></tr></table></figure><p>通常，4.0和2.0被储存为64位的double类型，使用双精度进行乘法运算，然后将乘积截断成float类型的宽度。这样做虽然计算精度更高，但是会减慢程序的运行速度。</p>\n<ul><li>在浮点数后面加上<code>f</code>或<code>F</code>后缀可覆盖默认设置，<strong>编译器会将浮点型常量看作float类型，如2.3f和9.11E9F。使用<code>l</code>或<code>L</code>后缀使得数字成为<code>long double</code>类型，如54.3l和4.32L</strong>。注意，建议使用L后缀，因为字母l和数字1很容易混淆。<strong>没有后缀的浮点型常量是double类型</strong>。</li>\n</ul><blockquote>\n<p>C99 标准添加了一种新的浮点型常量格式——用十六进制表示浮点型常量，即在十六进制数前加上十六进制前缀（0x或0X），用p和P分别代替e和E，用2的幂代替10的幂（即，p计数法）。如下所示：</p>\n</blockquote>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">0xa.1fp10</span><br></pre></td></tr></table></figure><p>十六进制a等于十进制10，.1f是1/16加上15/256（十六进制f等于十进制15），p10是210或1024。0xa.1fp10表示的值是(10 + 1/16 + 15/256)×1024（即，十进制10364.0）。</p>\n<ul><li>注意，并非所有的编译器都支持C99的这一特性。</li>\n</ul><h4 id=\"打印浮点值\">打印浮点值<a href=\"#打印浮点值\" title=\"打印浮点值\"></a></h4><p><code>printf()</code>函数使用<code>%f</code>转换说明打印十进制记数法的<code>float</code>和<code>double</code>类型浮点数，<strong>用<code>%e</code>打印指数记数法的浮点数。如果系统支持十六进制格式的浮点数，可用a和A分别代替e和E</strong>。打印<code>long double</code>类型要使用<code>%Lf</code>、<code>%Le</code>或<code>%La</code>转换说明。给那些未在函数原型中显式说明参数类型的函数（如，<code>printf()</code>）传递参数时，C编译器会把<code>float</code>类型的值自动转换成<code>double</code>类型。程序清单3.7演示了这些特性。</p>\n<p>程序清单3.7 showf_pt.c程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* showf_pt.c -- 以两种方式显示float类型的值 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float　aboat　&#x3D;　32000.0;</span><br><span class=\"line\">    double　abet　&#x3D;　2.14e9;</span><br><span class=\"line\">    long　double　dip　&#x3D;　5.32e-5;</span><br><span class=\"line\">    printf(&quot;%f　can　be　written　%e\\n&quot;,　aboat,　aboat);</span><br><span class=\"line\">    &#x2F;&#x2F; 下一行要求编译器支持C99或其中的相关特性</span><br><span class=\"line\">    printf(&quot;And　it&#39;s　%a　in　hexadecimal,　powers　of　2　notation\\n&quot;,　aboat);</span><br><span class=\"line\">    printf(&quot;%f　can　be　written　%e\\n&quot;,　abet,　abet);</span><br><span class=\"line\">    printf(&quot;%Lf　can　be　written　%Le\\n&quot;,　dip,　dip);</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下，前提是编译器支持C99/C11：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">32000.000000　can　be　written　3.200000e+04</span><br><span class=\"line\">And　it&#39;s　0x1.f4p+14　in　hexadecimal,　powers　of　2　notation</span><br><span class=\"line\">2140000000.000000　can　be　written　2.140000e+09</span><br><span class=\"line\">0.000053　can　be　written　5.320000e-05</span><br></pre></td></tr></table></figure><p>该程序示例演示了默认的输出效果。下一章将介绍如何通过设置字段宽度和小数位数来控制输出格式。</p>\n<h4 id=\"浮点值的上溢和下溢\">浮点值的上溢和下溢<a href=\"#浮点值的上溢和下溢\" title=\"浮点值的上溢和下溢\"></a></h4><p>假设系统的最大float类型值是3.4E38，编写如下代码：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float toobig &#x3D; 3.4E38 * 100.0f;</span><br><span class=\"line\">printf(&quot;%e\\n&quot;, toobig);</span><br></pre></td></tr></table></figure><p>会发生什么？这是一个<strong>上溢（overflow）</strong>的示例。当计算导致数字过大，超过当前类型能表达的范围时，就会发生上溢。这种行为在过去是未定义的，不过现在C语言规定，<strong>在这种情况下会给<code>toobig</code>赋一个表示无穷大的特定值，而且printf()显示该值为<code>inf</code>或<code>infinity</code>（或者具有无穷含义的其他内容）</strong>。</p>\n<p>当除以一个很小的数时，情况更为复杂。回忆一下，<strong>float类型的数以指数和尾数部分来储存</strong>。存在这样一个数，它的指数部分是最小值，即由全部可用位表示的最小尾数值。该数字是float类型能用全部精度表示的最小数字。现在把它除以 2。通常，这个操作会减小指数部分，但是假设的情况中，指数已经是最小值了。所以计算机只好把尾数部分的位向右移，空出第 1 个二进制位，并丢弃最后一个二进制数。以十进制为例，把一个有4位有效数字的数（如，0.1234E-10）除以10，得到的结果是0.0123E-10。<strong>虽然得到了结果，但是在计算过程中却损失了原末尾有效位上的数字。这种情况叫作下溢（underflow）</strong>。<strong>C语言把损失了类型全精度的浮点值称为低于正常的（subnormal）浮点值</strong>。因此，把最小的正浮点数除以 2将得到一个低于正常的值。如果除以一个非常大的值，会导致所有的位都为0。现在，C库已提供了用于检查计算是否会产生低于正常值的函数。</p>\n<p>还有另一个特殊的浮点值<code>NaN</code>（not a number的缩写）。例如，给<code>asin()</code>函数传递一个值，该函数将返回一个角度，该角度的正弦就是传入函数的值。但是正弦值不能大于1，因此，如果传入的参数大于1，该函数的行为是未定义的。在这种情况下，该函数将返回<code>NaN</code>值，<code>printf()</code>函数可将其显示为<code>nan</code>、<code>NaN</code>或其他类似的内容。</p>\n<h5 id=\"浮点数舍入错误\">浮点数舍入错误<a href=\"#浮点数舍入错误\" title=\"浮点数舍入错误\"></a></h5><p>给定一个数，加上1，再减去原来给定的数，结果是多少？你一定认为是1。但是，下面的浮点运算给出了不同的答案：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* floaterr.c--演示舍入错误 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float　a,b;</span><br><span class=\"line\">    b　&#x3D;　2.0e20　+　1.0;</span><br><span class=\"line\">    a　&#x3D;　b　-　2.0e20;</span><br><span class=\"line\">    printf(&quot;%f　\\n&quot;,　a);</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p>该程序的输出如下：<br><img src=\"https://i.loli.net/2020/04/24/pIM1fPDzQNqRJa9.jpg\" class=\"φcy\" alt=\"该程序的输出\"></p>\n<p>得出这些奇怪答案的原因是，计算机缺少足够的小数位来完成正确的运算。2.0e20是 2后面有20个0。如果把该数加1，那么发生变化的是第21位。要正确运算，程序至少要储存21位数字。而float类型的数字通常只能储存按指数比例缩小或放大的6或7位有效数字。在这种情况下，计算结果一定是错误的。另一方面，如果把2.0e20改成2.0e4，计算结果就没问题。因为2.0e4加1只需改变第5位上的数字，float类型的精度足够进行这样的计算。</p>\n<h4 id=\"浮点数表示法\">浮点数表示法<a href=\"#浮点数表示法\" title=\"浮点数表示法\"></a></h4><p>上一个方框中列出了由于计算机使用的系统不同，一个程序有不同的输出。原因是，根据前面介绍的知识，实现浮点数表示法的方法有多种。为了尽可能地统一实现，电子和电气工程师协会（IEEE）为浮点数计算和表示法开发了一套标准。现在，许多硬件浮点单元都采用该标准。2011年，该标准被ISO/IEC/IEEE 60559:2011标准收录。该标准作为C99和C11的可选项，符合硬件要求的平台可开启。floaterr.c程序的第3个输出示例即是支持该浮点标准的系统显示的结果。支持C标准的编译器还包含捕获异常问题的工具。详见附录B.5，参考资料V。</p>\n<h3 id=\"复数和虚数类型\">复数和虚数类型<a href=\"#复数和虚数类型\" title=\"复数和虚数类型\"></a></h3><p>许多科学和工程计算都要用到<strong>复数和虚数</strong>。C99 标准支持复数类型和虚数类型，但是有所保留。一些独立实现，如嵌入式处理器的实现，就不需要使用复数和虚数（VCR芯片就不需要复数）。一般而言，虚数类型都是可选项。C11标准把整个复数软件包都作为可选项。</p>\n<p>简而言之，C语言有3种复数类型：<code>float_Complex</code>、<code>double_Complex</code>和<code>long double _Complex</code>。例如，<code>float _Complex</code>类型的变量应包含两个<code>float</code>类型的值，分别表示复数的实部和虚部。类似地， C语言的3种虚数类型是<code>float _Imaginary</code>、<code>double _Imaginary</code>和<code>long double _Imaginary</code>。</p>\n<p>如果包含<code>complex.h</code>头文件，便可用<code>complex</code>代替<code>_Complex</code>，用<code>imaginary</code>代替<code>_Imaginary</code>，还可以用<code>I</code>代替<code>-1</code>的平方根。</p>\n<blockquote>\n<p>为何 C 标准不直接用 <code>complex</code> 作为关键字来代替<code>_Complex</code>，而要添加一个头文件（该头文件中把<code>complex</code>定义为<code>_Complex</code>）？</p>\n</blockquote>\n<p>因为标准委员会考虑到，如果使用新的关键字，会导致以该关键字作为标识符的现有代码全部失效。例如，之前的 C99，许多程序员已经使用 <code>struct complex</code> 定义一个结构来表示复数或者心理学程序中的心理状况（关键字<code>struc</code>t用于定义能储存多个值的结构，详见第14章）。让<code>complex</code>成为关键字会导致之前的这些代码出现语法错误。但是，使用<code>struct _Complex</code>的人很少，特别是标准使用首字母是下划线的标识符作为预留字以后。因此，标准委员会选定<code>_Complex</code>作为关键字，在不用考虑名称冲突的情况下可选择使用<code>complex</code>。</p>\n<h3 id=\"其他类型\">其他类型<a href=\"#其他类型\" title=\"其他类型\"></a></h3><p>现在已经介绍完C语言的所有基本数据类型。有些人认为这些类型实在太多了，但有些人觉得还不够用。注意，虽然C语言没有字符串类型，但也能很好地处理字符串。第4章将详细介绍相关内容。</p>\n<p>C语言还有一些从基本类型衍生的其他类型，包括数组、指针、结构和联合。尽管后面章节中会详细介绍这些类型，但是本章的程序示例中已经用到了指针〔指针（pointer）指向变量或其他数据对象位置〕。例如，在 scanf()函数中用到的前缀&amp;，便创建了一个指针，告诉 scanf()把数据放在何处。</p>\n<h2 id=\"小结：基本数据类型\"><strong>小结：基本数据类型</strong><a href=\"#小结：基本数据类型\" title=\"小结：基本数据类型\"></a></h2><ul><li><p>关键字：<br>基本数据类型由11个关键字组成：<code>int</code>、<code>long、short</code>、<code>unsigned</code>、<code>char</code>、<code>float</code>、<code>double</code>、<code>signed</code>、<code>_Bool</code>、<code>_Complex</code>和<code>_Imaginary</code>。</p>\n</li>\n<li><p>有符号整型：<br>  有符号整型可用于表示正整数和负整数。</p>\n<p>  <code>int</code>——系统给定的基本整数类型。C语言规定int类型不小于16位。</p>\n<p>  <code>short</code>或<code>short int</code> ——最大的<code>short</code>类型整数小于或等于最大的<code>int</code>类型整数。C语言规定short类型至少占16位。</p>\n<p>  <code>long</code>或<code>long int</code> ——该类型可表示的整数大于或等于最大的<code>int</code>类型整数。C语言规定<code>long</code>类型至少占32位。</p>\n<p>  <code>long long</code>或<code>long long int</code> ——该类型可表示的整数大于或等于最大的long类型整数。Long long类型至少占64位。</p>\n<p>  一般而言，<code>long</code>类型占用的内存比<code>short</code>类型大，<code>int</code>类型的宽度要么和<code>long</code>类型相同，要么和<code>short</code>类型相同。例如，旧DOS系统的PC提供16位的<code>short</code>和<code>int</code>，以及32位的<code>long</code>；Windows 95系统提供16位的<code>short</code>以及32位的<code>int</code>和<code>long</code>。</p>\n</li>\n<li><p>无符号整型：</p>\n<p>  无符号整型只能用于表示零和正整数，因此无符号整型可表示的正整数比有符号整型的大。在整型类型前加上关键字<code>unsigned</code>表明该类型是无符号整型：<code>unsignedint</code>、<code>unsigned long</code>、<code>unsigned short</code>。单独的<code>unsigned</code>相当于<code>unsigned int</code>。</p>\n</li>\n<li><p>字符类型：</p>\n<p>  可打印出来的符号（如<code>A</code>、<code>&amp;</code>和<code>+</code>）都是字符。根据定义，<code>char</code>类型表示一个字符要占用1字节内存。出于历史原因，<strong>1字节通常是8位</strong>，但是<strong>如果要表示基本字符集，也可以是16位或更大</strong>。</p>\n<p>  <code>char</code> ——字符类型的关键字。有些编译器使用有符号的<code>char</code>，而有些则使用无符号的<code>char</code>。在需要时，可在<code>char</code>前面加上关键字<code>signed</code>或<code>unsigned</code>来指明具体使用哪一种类型。</p>\n</li>\n<li><p>布尔类型：</p>\n<p>  布尔值表示<code>true</code>和<code>false</code>。C语言用1表示<code>true</code>，0表示<code>false</code>。</p>\n<p>  <code>_Bool</code> ——布尔类型的关键字。布尔类型是无符号 <code>int</code>类型，所占用的空间只要能储存0或1即可。</p>\n</li>\n<li><p>实浮点类型：</p>\n<p>  实浮点类型可表示正浮点数和负浮点数。</p>\n<p>  <code>float</code> ——系统的基本浮点类型，可精确表示至少-<strong>6位有效数字</strong>。</p>\n<p>  <code>double</code> ——储存浮点数的范围（可能）更大，能表示比 <code>float</code> 类型更多的有效数字（至少 10位，通常会更多）和更大的指数。</p>\n<p>  <code>long long</code> ——储存浮点数的范围（可能）比double更大，能表示比double更多的有效数字和更大的指数。</p>\n</li>\n<li><p>复数和虚数浮点数：</p>\n<p>  虚数类型是可选的类型。复数的实部和虚部类型都基于实浮点类型来构成：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float _Complex</span><br><span class=\"line\">double _Complex</span><br><span class=\"line\">long double _Complex</span><br><span class=\"line\">float _Imaginary</span><br><span class=\"line\">double _Imaginary</span><br><span class=\"line\">long long _Imaginary</span><br></pre></td></tr></table></figure><blockquote>\n<p>小结：如何声明简单变量</p>\n</blockquote>\n</li>\n</ul><ol><li><p>选择需要的类型。</p>\n</li>\n<li><p>使用有效的字符给变量起一个变量名。</p>\n</li>\n<li><p>按以下格式进行声明：</p>\n<p> 类型说明符 变量名;</p>\n<p> 类型说明符由一个或多个关键字组成。下面是一些示例：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int erest;</span><br><span class=\"line\">unsigned short cash;</span><br></pre></td></tr></table></figure></li>\n<li><p>可以同时声明相同类型的多个变量，用逗号分隔各变量名，如下所示：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">char ch, init, ans;</span><br></pre></td></tr></table></figure></li>\n<li><p>在声明的同时还可以初始化变量：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">float mass &#x3D; 6.0E24;</span><br></pre></td></tr></table></figure></li>\n</ol><h3 id=\"类型大小\">类型大小<a href=\"#类型大小\" title=\"类型大小\"></a></h3><p>如何知道当前系统的指定类型的大小是多少？运行程序清单3.8，会列出当前系统的各类型的大小。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">程序清单3.8 typesize.c程序</span><br><span class=\"line\">&#x2F;&#x2F;* typesize.c -- 打印类型大小 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    &#x2F;* C99为类型大小提供%zd转换说明 *&#x2F;</span><br><span class=\"line\">    printf(&quot;Type　int　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(int));</span><br><span class=\"line\">    printf(&quot;Type　char　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(char));</span><br><span class=\"line\">    printf(&quot;Type　long　has　a　size　of　%zd　bytes.\\n&quot;,　sizeof(long));</span><br><span class=\"line\">    printf(&quot;Type　long　long　has　a　size　of　%zd　bytes.\\n&quot;,</span><br><span class=\"line\">    sizeof(long　long));</span><br><span class=\"line\">    printf(&quot;Type　double　has　a　size　of　%zd　bytes.\\n&quot;,</span><br><span class=\"line\">    sizeof(double));</span><br><span class=\"line\">    printf(&quot;Type　long　double　has　a　size　of　%zd　bytes.\\n&quot;,</span><br><span class=\"line\">    sizeof(long　double));</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><mark><code>sizeof</code>是C语言的内置运算符，以字节为单位给出指定类型的大小</mark>。C99和C11提供<code>%zd</code>转换说明匹配<code>sizeof</code>的返回类型。一些不支持C99和C11的编译器可用<code>%u</code>或%<code>lu</code>代替<code>%zd</code>。</p>\n<p>该程序的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Type int has a size of 4 bytes.</span><br><span class=\"line\">Type char has a size of 1 bytes.</span><br><span class=\"line\">Type long has a size of 8 bytes.</span><br><span class=\"line\">Type long long has a size of 8 bytes.</span><br><span class=\"line\">Type double has a size of 8 bytes.</span><br><span class=\"line\">Type long double has a size of 16 bytes.</span><br></pre></td></tr></table></figure><p>该程序列出了6种类型的大小，你也可以把程序中的类型更换成感兴趣的其他类型。注意，因为C语言定义了<code>char</code>类型是1字节，所以<code>char</code>类型的大小一定是1字节。而在<code>char</code>类型为16位、<code>double</code>类型为64位的系统中，<code>sizeof</code>给出的<code>double</code>是4字节。在limits.h和float.h头文件中有类型限制的相关信息（下一章将详细介绍这两个头文件）。</p>\n<p><strong>顺带一提，注意该程序最后几行 printf()语句都被分为两行，只要不在引号内部或一个单词中间断行，就可以这样写</strong>。</p>\n<h3 id=\"使用数据类型\">使用数据类型<a href=\"#使用数据类型\" title=\"使用数据类型\"></a></h3><p>编写程序时，应注意合理选择所需的变量及其类型。通常，用int或float类型表示数字，char类型表示字符。在使用变量之前必须先声明，并选择有意义的变量名。初始化变量应使用与变量类型匹配的常数类型。例如：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int apples &#x3D; 3;　　　 &#x2F;* 正确 *&#x2F;</span><br><span class=\"line\">int oranges &#x3D; 3.0;　　&#x2F;* 不好的形式 *&#x2F;</span><br></pre></td></tr></table></figure><p>与Pascal相比，C在检查类型匹配方面不太严格。C编译器甚至允许二次初始化，但在激活了较高级别警告时，会给出警告。最好不要养成这样的习惯。</p>\n<p>把一个类型的数值初始化给不同类型的变量时，编译器会把值转换成与变量匹配的类型，这将导致部分数据丢失。例如，下面的初始化：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">int cost &#x3D; 12.99;　　 &#x2F;* 用double类型的值初始化int类型的变量 *&#x2F;</span><br><span class=\"line\">float pi &#x3D; 3.1415926536;　 &#x2F;* 用double类型的值初始化float类型的变量 *&#x2F;</span><br></pre></td></tr></table></figure><p>第1个声明，<code>cost</code>的值是12。C编译器把浮点数转换成整数时，会直接丢弃（截断）小数部分，而不进行四舍五入。第2个声明会损失一些精度，因为C只保证了<code>float</code>类型前6位的精度。编译器对这样的初始化可能给出警告。读者在编译程序清单3.1时可能就遇到了这种警告。</p>\n<p>许多程序员和公司内部都有系统化的命名约定，在变量名中体现其类型。例如，用 <code>i_</code>前缀表示 <code>int</code>类型，<code>us_</code>前缀表示 <code>unsigned short</code> 类型。这样，一眼就能看出来<code>i_smart</code> 是 <code>int</code> 类型的变量， <code>us_versmart</code>是<code>unsigned short</code>类型的变量。</p>\n<h3 id=\"参数和陷阱\">参数和陷阱<a href=\"#参数和陷阱\" title=\"参数和陷阱\"></a></h3><p>有必要再次提醒读者注意 <code>printf()</code>函数的用法。读者应该还记得，传递给函数的信息被称为参数。例如，<code>printf(&quot;Hello, pal.&quot;)</code>函数调用有一个参数：<code>&quot;Hello,pal.&quot;</code>。双引号中的字符序列（如，”<code>Hello,pal.</code>“）被称为<strong>字符串（string）</strong>，第4章将详细讲解相关内容。现在，关键是要理解无论双引号中包含多少个字符和标点符号，一个字符串就是一个参数。</p>\n<p>与此类似，<code>scanf(&quot;%d&quot;, &amp;weight)</code>函数调用有两个参数：<code>&quot;%d&quot;</code>和<code>&amp;weight</code>。C语言用逗号分隔函数中的参数。<code>printf()</code>和<code>scanf()</code>函数与一般函数不同，它们的参数个数是可变的。例如，前面的程序示例中调用过带一个、两个，甚至三个参数的 <code>printf()</code>函数。程序要知道函数的参数个数才能正常工作。<code>printf()</code>和<code>scanf()</code>函数用第1个参数表明后续有多少个参数，即第1个字符串中的转换说明与后面的参数一一对应。例如，下面的语句有两个<code>%d</code>转换说明，说明后面还有两个参数：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;%d cats ate %d cans of tuna\\n&quot;, cats, cans);</span><br></pre></td></tr></table></figure><p>后面的确还有两个参数：<code>cats</code>和<code>cans</code>。</p>\n<p>程序员要负责确保转换说明的数量、类型与后面参数的数量、类型相匹配。<strong>现在，C 语言通过函数原型机制检查函数调用时参数的个数和类型是否正确。但是，该机制对<code>printf()</code>和<code>scanf()</code>不起作用，因为这两个函数的参数个数可变。</strong>如果参数在匹配上有问题，会出现什么情况？假设你编写了程序清单 3.9中的程序。</p>\n<p>程序清单3.9 badcount.c程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* badcount.c -- 参数错误的情况 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    int　n　&#x3D;　4;</span><br><span class=\"line\">    int　m　&#x3D;　5;</span><br><span class=\"line\">    float　f　&#x3D;　7.0f;</span><br><span class=\"line\">    float　g　&#x3D;　8.0f;</span><br><span class=\"line\">    printf(&quot;%d\\n&quot;, n, m);　 &#x2F;* 参数太多　*&#x2F;</span><br><span class=\"line\">    printf(&quot;%d %d %d\\n&quot;, n); &#x2F;* 参数太少　*&#x2F;</span><br><span class=\"line\">    printf(&quot;%d %d\\n&quot;, f, g); &#x2F;* 值的类型不匹配 *&#x2F;</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><code>XCode 4.6</code>（OS 10.8）的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">4　1　-706337836</span><br><span class=\"line\">1606414344　1</span><br></pre></td></tr></table></figure><p><code>Microsoft Visual Studio Express 2012</code>（Windows 7）的输出如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">4</span><br><span class=\"line\">4　0　0</span><br><span class=\"line\">0　1075576832</span><br></pre></td></tr></table></figure><blockquote>\n<p><mark>注意，用<code>%d</code>显示<code>float</code>类型的值，其值不会被转换成<code>int</code>类型。在不同的平台下，缺少参数或参数类型不匹配导致的结果不同。</mark></p>\n</blockquote>\n<p>所有编译器都能顺利编译并运行该程序，但其中大部分会给出警告。的确，有些编译器会捕获到这类问题，然而C标准对此未作要求。因此，计算机在运行时可能不会捕获这类错误。如果程序正常运行，很难觉察出来。如果程序没有打印出期望值或打印出意想不到的值，你才会检查 <code>printf()</code>函数中的参数个数和类型是否得当。</p>\n<h3 id=\"转义序列示例\">转义序列示例<a href=\"#转义序列示例\" title=\"转义序列示例\"></a></h3><p>再来看一个程序示例，该程序使用了一些特殊的转义序列。程序清单 3.10 演示了退格（<code>\\b</code>）、水平制表符（<code>\\t</code>）和回车（<code>\\r</code>）的工作方式。这些概念在计算机使用电传打字机作为输出设备时就有了，但是它们不一定能与现代的图形接口兼容。例如，程序清单3.10在某些<code>Macintosh</code>的实现中就无法正常运行。</p>\n<p>程序清单3.10 escape.c程序</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&#x2F;* escape.c -- 使用转移序列 *&#x2F;</span><br><span class=\"line\">#include　&lt;stdio.h&gt;</span><br><span class=\"line\">int　main(void)</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">    float　salary;</span><br><span class=\"line\">    printf(&quot;\\aEnter your desired monthly salary:&quot;);　&#x2F;* 1 *&#x2F;</span><br><span class=\"line\">    printf(&quot; $_______\\b\\b\\b\\b\\b\\b\\b&quot;);　　　　　　　 &#x2F;* 2 *&#x2F;</span><br><span class=\"line\">    scanf(&quot;%f&quot;,　&amp;salary);</span><br><span class=\"line\">    printf(&quot;\\n\\t$%.2f　a　month　is　$%.2f　a　year.&quot;,　salary,</span><br><span class=\"line\">    salary * 12.0);　　　　　　　　　　　　　　&#x2F;* 3 *&#x2F;</span><br><span class=\"line\">    printf(&quot;\\rGee!\\n&quot;);　　　　　　　　　　　　　　　 &#x2F;* 4 *&#x2F;</span><br><span class=\"line\">    return　0;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"程序运行情况\">程序运行情况<a href=\"#程序运行情况\" title=\"程序运行情况\"></a></h3><p>假设在系统中运行的转义序列行为与本章描述的行为一致（实际行为可能不同。例如，XCode 4.6把<code>\\a</code>、<code>\\b</code>和<code>\\r</code>显示为颠倒的问号），下面我们来分析这个程序。</p>\n<p>第1条<code>printf()</code>语句（注释中标为1）发出一声警报（因为使用了<code>\\a</code>），然后打印下面的内容：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter your desired monthly salary:</span><br></pre></td></tr></table></figure><p>因为<code>printf()</code>中的字符串末尾没有<code>\\n</code>，所以光标停留在冒号后面。</p>\n<p>第2条<code>printf()</code>语句在光标处接着打印，屏幕上显示的内容是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter your desired monthly salary: $_______</span><br></pre></td></tr></table></figure><p>冒号和美元符号之间有一个空格，这是因为第2条<code>printf()</code>语句中的字符串以一个空格开始。7个退格字符使得光标左移7个位置，即把光标移至7个下划线字符的前面，紧跟在美元符号后面。通常，退格不会擦除退回所经过的字符，但有些实现是擦除的，这和本例不同。</p>\n<p>假设键入的数据是4000.00（并按下Enter键），屏幕显示的内容应该是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter your desired monthly salary: $4000.00</span><br></pre></td></tr></table></figure><p>键入的字符替换了下划线字符。按下<code>Enter</code>键后，光标移至下一行的起始处。</p>\n<p>第3条<code>printf()</code>语句中的字符串以<code>\\n``\\t</code>开始。换行字符使光标移至下一行起始处。水平制表符使光标移至该行的下一个制表点，一般是第9列（但不一定）。然后打印字符串中的其他内容。执行完该语句后，此时屏幕显示的内容应该是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter　your　desired　monthly　salary:　$4000.00</span><br><span class=\"line\">$4000.00　a　month　is　$48000.00　a　year.</span><br></pre></td></tr></table></figure><p>因为这条printf()语句中没有使用换行字符，所以光标停留在最后的点号后面。</p>\n<p>第4条<code>printf()</code>语句以<code>\\r</code>开始。这使得光标回到当前行的起始处。然后打印<code>Gee!</code>，接着<code>\\n</code>使光标移至下一行的起始处。屏幕最后显示的内容应该是：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Enter　your　desired　monthly　salary:　$4000.00</span><br><span class=\"line\">Gee!　$4000.00　a　month　is　$48000.00　a　year.</span><br></pre></td></tr></table></figure><h3 id=\"刷新输出\">刷新输出<a href=\"#刷新输出\" title=\"刷新输出\"></a></h3><p><code>printf()</code>何时把输出发送到屏幕上？最初，<code>printf()</code>语句把输出发送到一个叫作<strong>缓冲区（buffer）</strong>的中间存储区域，然后<strong>缓冲区</strong>中的内容再不断被发送到屏幕上。C 标准明确规定了何时把<strong>缓冲区</strong>中的内容发送到屏幕：  </p>\n<ul><li>当<strong>缓冲区</strong>满、遇到<strong>换行字符</strong>或需要<strong>输入</strong>的时候（从缓冲区把数据发送到屏幕或文件被称为<strong>刷新缓冲区</strong>）。</li>\n</ul><blockquote>\n<p>例如，前两个 <code>printf()</code>语句既没有填满缓冲区，也没有换行符，但是下一条 scanf()语句要求用户输入，这迫使printf()的输出被发送到屏幕上。</p>\n</blockquote>\n<ul><li>旧式编译器遇到scanf()也不会强行刷新缓冲区，程序会停在那里不显示任何提示内容，等待用户输入数据。在这种情况下，可以使用换行字符刷新缓冲区。代码应改为：<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">printf(&quot;Enter your desired monthly salary:\\n&quot;);</span><br></pre></td></tr></table></figure></li>\n</ul><p><code>scanf(&quot;%f&quot;, &amp;salary);</code>无论接下来的输入是否能刷新缓冲区，代码都会正常运行。这将导致光标移至下一行起始处，用户无法在提示内容同一行输入数据。还有一种刷新缓冲区的方法是使用<code>fflush()函数</code>，详见其他章。</p>\n<h3 id=\"关键概念\">关键概念<a href=\"#关键概念\" title=\"关键概念\"></a></h3><p>C语言提供了大量的数值类型，目的是为程序员提供方便。那以整数类型为例，C认为一种整型不够，提供了有符号、无符号，以及大小不同的整型，以满足不同程序的需求。</p>\n<p>计算机中的<strong>浮点数</strong>和<strong>整数</strong>在本质上不同，其存储方式和运算过程有很大区别。即使两个<code>32位</code>存储单元储存的位组合完全相同，但是一个解释为<code>float</code>类型，另一个解释为<code>long</code>类型，这两个相同的位组合表示的值也完全不同。</p>\n<ul><li>例如，在PC中，假设一个位组合表示float类型的数256.0，如果将其解释为long类型，得到的值是113246208。C语言允许编写混合数据类型的表达式，但是会进行自动类型转换，以便在实际运算时统一使用一种类型。</li>\n</ul><p>计算机在内存中用<strong>数值编码</strong>来表示字符。美国最常用的是<code>ASCII码</code>，除此之外C也支持其他编码。字符常量是计算机系统使用的数值编码的符号表示，它表示为单引号括起来的字符，如<code>&#39;A&#39;</code>。</p>\n<h3 id=\"本章小结\">本章小结<a href=\"#本章小结\" title=\"本章小结\"></a></h3><p>C 有多种的数据类型。基本数据类型分为两大类：<strong>整数</strong>类型和<strong>浮点数</strong>类型。通过为类型分配的储存量以及是<strong>有符号</strong>还是<strong>无符号</strong>，区分不同的整数类型。<span id=\"inline-green\">最小的整数类型是</span><code>char</code>，因实现不同，可以是有符号的<code>char</code>或无符号的<code>char</code>，即<code>unsigned char</code>或<code>signed char</code>。但是，通常用char类型表示小整数时才这样显示说明。其他整数类型有<code>short</code>、<code>int</code>、<code>long</code>和<code>long long</code>类型。</p>\n<p>C规定，后面的类型不能小于前面的类型。上述都是有符号类型，但也可以使用<code>unsigned</code>关键字创建相应的无符号类型：<code>unsigned short</code>、<code>unsigned int</code>、<code>unsigned long</code>和<code>unsigned long long</code>。或者，在类型名前加上<code>signed</code>修饰符显式表明该类型是有符号类型。最后，<code>_Bool</code>类型是一种无符号类型，可储存<code>0</code>或<code>1</code>，分别代表<code>false</code>和<code>true</code>。</p>\n<p>浮点类型有3种：<code>float</code>、<code>double</code>和C90新增的<code>long double</code>。后面的类型应大于或等于前面的类型。有些实现可选择支持复数类型和虚数类型，通过关键字<code>_Complex</code>和<code>_Imaginary</code>与浮点类型的关键字组合（如，<code>double _Complex</code>类型和<code>float _Imaginary</code>类型）来表示这些类型。</p>\n<p>整数可以表示为十进制、八进制或十六进制。<code>0</code>前缀表示八进制数，<code>0x</code>或<code>0X</code>前缀表示十六进制数。例如，32、040、0x20分别以十进制、八进制、十六进制表示同一个值。<code>l</code>或<code>L</code>前缀表明该值是<code>long</code>类型， <code>ll</code>或<code>LL</code>前缀表明该值是<code>long long</code>类型。</p>\n<p>在C语言中，直接<mark>表示一个字符常量的方法是：把该字符用单引号括起来，如<code>&#39;Q&#39;</code>、<code>&#39;8&#39;</code>和<code>&#39;$&#39;</code></mark>。C语言的转义序列（如，<code>&#39;\\n&#39;</code>）表示某些非打印字符。另外，还可以在八进制或十六进制数前加上一个反斜杠（如，<code>&#39;\\007&#39;</code>），表示ASCII码中的一个字符。</p>\n<p>浮点数可写成固定小数点的形式（如，9393.912）或指数形式（如，7.38E10）。C99和C11提供了第3种指数表示法，即用十六进制数和2的幂来表示（如，0xa.1fp10）。</p>\n<p><code>printf()</code>函数根据转换说明打印各种类型的值。转换说明最简单的形式由一个百分号（<code>%</code>）和一个转换字符组成，如<code>%d</code>或<code>%f</code>。</p>\n","prev":{"title":"字体、颜色常用代码","link":"2020/04/19/字体、颜色常用代码"},"next":{"title":"hexo详解","link":"2020/04/17/hexo详解"},"plink":"https://dxsummer.gitee.io/2020/04/18/数据和C/","toc":[{"id":"示例程序","title":"示例程序","index":"1","children":[{"id":"提示-错误与警告","title":"提示 错误与警告","index":"1.1"},{"id":"程序调整","title":"程序调整","index":"1.2"},{"id":"程序中的新元素","title":"程序中的新元素","index":"1.3"}]},{"id":"变量与常量数据","title":"变量与常量数据","index":"2"},{"id":"数据：数据类型关键字","title":"数据：数据类型关键字","index":"3","children":[{"id":"位、字节和字","title":"位、字节和字","index":"3.1"},{"id":"整数","title":"整数","index":"3.2"},{"id":"浮点数","title":"浮点数","index":"3.3"}]},{"id":"c语言基本数据类型","title":"C语言基本数据类型","index":"4","children":[{"id":"int类型","title":"int类型","index":"4.1"},{"id":"其他整数类型","title":"其他整数类型","index":"4.2"},{"id":"使用字符：char类型","title":"使用字符：char类型","index":"4.3"},{"id":"bool类型","title":"Bool类型","index":"4.4"},{"id":"可移植类型：stdinth和inttypesh","title":"可移植类型：stdint.h和inttypes.h","index":"4.5"},{"id":"float、double和long-double","title":"float、double和long double","index":"4.6"},{"id":"复数和虚数类型","title":"复数和虚数类型","index":"4.7"},{"id":"其他类型","title":"其他类型","index":"4.8"}]},{"id":"小结：基本数据类型","title":"小结：基本数据类型","index":"5","children":[{"id":"类型大小","title":"类型大小","index":"5.1"},{"id":"使用数据类型","title":"使用数据类型","index":"5.2"},{"id":"参数和陷阱","title":"参数和陷阱","index":"5.3"},{"id":"转义序列示例","title":"转义序列示例","index":"5.4"},{"id":"程序运行情况","title":"程序运行情况","index":"5.5"},{"id":"刷新输出","title":"刷新输出","index":"5.6"},{"id":"关键概念","title":"关键概念","index":"5.7"},{"id":"本章小结","title":"本章小结","index":"5.8"}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/2020/04/18/数据和C/\" title=\"数据和C\">https://dxsummer.gitee.io/2020/04/18/数据和C/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"April 18, 2020","updated":"May 21, 2020"}}