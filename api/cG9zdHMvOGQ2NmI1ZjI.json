{"title":"栈和队列","date":"2020-10-19T13:37:29.000Z","date_formatted":{"ll":"2020年10月19日","L":"2020/10/19","MM-DD":"10-19"},"link":"posts/8d66b5f2","comments":true,"tags":["数据结构"],"categories":["数据结构"],"updated":"2020-10-24T15:35:09.632Z","content":"<h1 id=\"栈\">栈<a href=\"#栈\" title=\"栈\"></a></h1><h2 id=\"顺序栈\">顺序栈<a href=\"#顺序栈\" title=\"顺序栈\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201019214034.png\" style=\"zoom:67%;\" /><blockquote>\n<p>“进” ＝压入=PUSH（)<br>“出” ＝弹出=POP( )</p>\n</blockquote>\n<p><strong>定义</strong>：只能在<strong>表的一端（栈顶）</strong>进行插入和删除运算的<strong>线性表</strong></p>\n<p><strong>逻辑结构</strong>：与线性表相同，仍为<strong>一对一</strong>关系</p>\n<p><strong>存储结构</strong>：用<strong>顺序栈</strong>或<strong>链栈</strong>存储均可，但以顺序栈更常见</p>\n<p><strong>运算规则</strong>：只能在<strong>栈顶</strong>运算，且访问结点时依照<strong>后进先出（LIFO）</strong>或<strong>先进后出（FILO）</strong>的原则</p>\n<p><strong>实现方式</strong>：关键是编写<strong>入栈</strong>和<strong>出栈</strong>函数，具体实现依顺序栈或链栈的不同而不同，基本操作有<strong>入栈、出栈、读栈顶元素值、建栈、判断栈满、栈空</strong>等</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201019220304.png\" style=\"zoom: 80%;\" /><h3 id=\"表示\">表示<a href=\"#表示\" title=\"表示\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201019222237.png\" style=\"zoom:67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> MAXSIZE  100<span class=\"comment\">//顺序栈存储空间的初始分配量</span></span></span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tSElemType *base;<span class=\"comment\">//栈底指针</span></span><br><span class=\"line\">\tSElemType *top;<span class=\"comment\">//栈顶指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">int</span> stacksize;<span class=\"comment\">//栈可用的最大容量</span></span><br><span class=\"line\">&#125; SqStack;</span><br></pre></td></tr></table></figure><h3 id=\"初始化\">初始化<a href=\"#初始化\" title=\"初始化\"></a></h3><p><strong>构造一个空栈</strong><br>步骤：</p>\n<ol><li><p>分配空间并检查空间是否分配失败，若失败则返回错误</p>\n</li>\n<li><p>设置栈底和栈顶指针 <code>S.top = S.base;</code></p>\n</li>\n<li><p>设置栈大小</p>\n</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitStack</span><span class=\"params\">(SqStack &amp;S)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//构造一个空栈S</span></span><br><span class=\"line\">\tS.base = <span class=\"keyword\">new</span> SElemType[MAXSIZE];<span class=\"comment\">//为顺序栈动态分配一个最大容量为MAXSIZE的数组空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!S.base)</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">\tS.top = S.base; <span class=\"comment\">//top初始为base，空栈</span></span><br><span class=\"line\">\tS.stacksize = MAXSIZE; <span class=\"comment\">//stacksize置为栈的最大容量MAXSIZE</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断顺序栈是否为空</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">bool</span> <span class=\"title\">StackEmpty</span><span class=\"params\">( SqStack S )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>(S.top == S.base) <span class=\"keyword\">return</span> <span class=\"literal\">true</span>;</span><br><span class=\"line\">   <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> <span class=\"literal\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>求顺序栈的长度</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">StackLength</span><span class=\"params\">( SqStack S )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> S.top – S.base;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>清空顺序栈</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">ClearStack</span><span class=\"params\">( SqStack S )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( S.base ) S.top = S.base;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>销毁顺序栈</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DestroyStack</span><span class=\"params\">( SqStack &amp;S )</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span>( S.base )</span><br><span class=\"line\">\t&#123;</span><br><span class=\"line\">\t\t<span class=\"keyword\">delete</span> S.base ;</span><br><span class=\"line\">\t\tS.stacksize = <span class=\"number\">0</span>;</span><br><span class=\"line\">\t\tS.base = S.top = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">  <span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"进栈\">进栈<a href=\"#进栈\" title=\"进栈\"></a></h3><ol><li>判断是否栈满，若满则出错</li>\n<li>元素e压入栈顶</li>\n<li>栈顶指针加1</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Push</span><span class=\"params\">(SqStack &amp;S, SElemType e)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">// 插入元素e为新的栈顶元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (S.top - S.base == S.stacksize)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//栈满</span></span><br><span class=\"line\">\t*(S.top++) = e; <span class=\"comment\">//元素e压入栈顶，栈顶指针加1 *S.top=e;S.top++;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"出栈\">出栈<a href=\"#出栈\" title=\"出栈\"></a></h3><ol><li>判断是否栈空，若空则出错</li>\n<li>获取栈顶元素e</li>\n<li>栈顶指针减1</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Pop</span><span class=\"params\">(SqStack &amp;S, SElemType &amp;e)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//删除S的栈顶元素，用e返回其值\t</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (S.base == S.top)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;<span class=\"comment\">//栈空</span></span><br><span class=\"line\">\te = *(--S.top); <span class=\"comment\">//栈顶指针减1，将栈顶元素赋给e --S.top;e=*S.top;</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"取栈顶元素\">取栈顶元素<a href=\"#取栈顶元素\" title=\"取栈顶元素\"></a></h3><ol><li>判断是否空栈，若空则返回错误</li>\n<li>否则通过栈顶指针获取栈顶元素</li>\n</ol><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">GetTop</span><span class=\"params\">( SqStack S)</span>  </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (S.top != S.base) <span class=\"comment\">//栈非空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> *(S.top - <span class=\"number\">1</span>); <span class=\"comment\">//返回栈顶元素的值，栈顶指针不变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"链栈\">链栈<a href=\"#链栈\" title=\"链栈\"></a></h2><p>运算是受限的<strong>单链表</strong>，只能在<strong>链表头部进行操作</strong>，故没有必要附加头结点。<strong>栈顶指针就是链表的头指针</strong></p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021190735.png\" style=\"zoom:67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> &#123;</span></span><br><span class=\"line\">\tSElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">StackNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; StackNode, *LinkStack;</span><br></pre></td></tr></table></figure><h3 id=\"初始化-1\">初始化<a href=\"#初始化-1\" title=\"初始化\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021191007.png\" style=\"zoom:67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitStack</span><span class=\"params\">(LinkStack &amp;S)</span> </span>&#123; <span class=\"comment\">// 构造一个空栈 S，栈顶指针置空</span></span><br><span class=\"line\">\tS = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><strong>判断链栈是否为空</strong></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">StackEmpty</span><span class=\"params\">(LinkStack S)</span></span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;\t</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (S==<span class=\"literal\">NULL</span>) <span class=\"keyword\">return</span> TRUE;</span><br><span class=\"line\"> \t<span class=\"keyword\">else</span> <span class=\"keyword\">return</span> FALSE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"进栈-1\">进栈<a href=\"#进栈-1\" title=\"进栈\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021194036.png\" style=\"zoom:67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Push</span><span class=\"params\">(LinkStack &amp;S, SElemType e)</span> </span>&#123;<span class=\"comment\">//在栈顶插入元素e</span></span><br><span class=\"line\">\tLinkStack p;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> StackNode; <span class=\"comment\">//生成新结点</span></span><br><span class=\"line\">\tp-&gt;data = e; <span class=\"comment\">//将新结点数据域置为e</span></span><br><span class=\"line\">\tp-&gt;next = S; <span class=\"comment\">//将新结点插入栈顶</span></span><br><span class=\"line\">\tS = p; <span class=\"comment\">//修改栈顶指针为p</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"出栈-1\">出栈<a href=\"#出栈-1\" title=\"出栈\"></a></h3><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021194337.png\" style=\"zoom:67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">Pop</span><span class=\"params\">(LinkStack &amp;S, SElemType &amp;e)</span> </span>&#123;<span class=\"comment\">//删除S的栈顶元素，用e返回其值</span></span><br><span class=\"line\">\tLinkStack p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (S == <span class=\"literal\">NULL</span>)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//栈空</span></span><br><span class=\"line\">\te = S-&gt;data; <span class=\"comment\">//将栈顶元素赋给e</span></span><br><span class=\"line\">\tp = S; <span class=\"comment\">//用p临时保存栈顶元素空间，以备释放</span></span><br><span class=\"line\">\tS = S-&gt;next; <span class=\"comment\">//修改栈顶指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p; <span class=\"comment\">//释放原栈顶元素的空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"取栈顶元素-1\">取栈顶元素<a href=\"#取栈顶元素-1\" title=\"取栈顶元素\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SElemType <span class=\"title\">GetTop</span><span class=\"params\">(LinkStack S)</span> </span>&#123;<span class=\"comment\">//返回S的栈顶元素，不修改栈顶指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (S != <span class=\"literal\">NULL</span>) <span class=\"comment\">//栈非空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> S-&gt;data; <span class=\"comment\">//返回栈顶元素的值，栈顶指针不变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h1 id=\"栈与递归\">栈与递归<a href=\"#栈与递归\" title=\"栈与递归\"></a></h1><p><strong>递归的定义</strong>：若一个函数、过程或者数据结构定义的内部又直接（或间接）出现定义本身的应用，则称他们是递归的。若一个过程<strong><font color=\"red\">直接地或间接地调用自己</font></strong>, 则称这个过程是<strong>递归的过程</strong>。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">long</span> <span class=\"title\">Fact</span> <span class=\"params\">( <span class=\"keyword\">long</span> n )</span> </span></span><br><span class=\"line\"><span class=\"function\"></span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> ( n == <span class=\"number\">0</span>) <span class=\"keyword\">return</span> <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">return</span> n * Fact (n<span class=\"number\">-1</span>); </span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><p><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021195734.png\" class=\"φcy\"></p>\n<p><strong>以下三种情况常常用到递归方法</strong></p>\n<ul><li>递归定义的数学函数</li>\n<li>具有递归特性的数据结构</li>\n<li>可递归求解的问题</li>\n</ul><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021200319.png\" style=\"zoom: 67%;\" /><p><strong>优点：</strong>结构清晰，程序易读</p>\n<p><strong>缺点：</strong>每次调用要生成工作记录，保存状态信息，入栈；返回时要出栈，恢复状态信息。时间开销大。</p>\n<h1 id=\"队列\">队列<a href=\"#队列\" title=\"队列\"></a></h1><p>队列是一种<strong>先进先出(FIFO)</strong> 的<strong>线性表</strong>. 在表<strong>一端插入,在另一端删除</strong></p>\n<p><strong>定义</strong>：只能在表的一端（<strong>队尾</strong>）进行插入，在另一端（<strong>队头</strong>）进行删除运算的<strong>线性表</strong></p>\n<p><strong>逻辑结构</strong>：与线性表相同，仍为<strong>一对一</strong>关系</p>\n<p><strong>存储结构</strong>：用<strong>顺序队列</strong>或<strong>链队</strong>存储均可</p>\n<p><strong>运算规则</strong>：<strong>先进先出（FIFO）</strong></p>\n<p><strong>实现方式</strong>：关键是编写<strong>入队</strong>和<strong>出队</strong>函数，具体实现依顺序队或链队的不同而不同</p>\n<img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201019215810.png\" style=\"zoom: 50%;\" /><h2 id=\"队列的顺序表示-一维数组basem\">队列的顺序表示 一维数组base[M]<a href=\"#队列的顺序表示-一维数组basem\" title=\"队列的顺序表示 一维数组base[M]\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021202604.png\" style=\"zoom: 50%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">#<span class=\"meta-keyword\">define</span> M  100   <span class=\"comment\">//最大队列长度</span></span></span><br><span class=\"line\">Typedef <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">   QElemType *base;  <span class=\"comment\">//初始化的动态分配存储空间</span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>  front;            <span class=\"comment\">//头指针   </span></span><br><span class=\"line\">   <span class=\"keyword\">int</span>  rear;             <span class=\"comment\">//尾指针</span></span><br><span class=\"line\">&#125;SqQueue;</span><br></pre></td></tr></table></figure><h2 id=\"存在问题\">存在问题<a href=\"#存在问题\" title=\"存在问题\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201021202840.png\" style=\"zoom: 67%;\" /><h2 id=\"循环队列\">循环队列<a href=\"#循环队列\" title=\"循环队列\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201024170714.png\" style=\"zoom: 50%;\" /><blockquote>\n<p><strong><font color=\"red\">问题：队空：front==rear    队满：front==rear</font></strong></p>\n</blockquote>\n<p><strong>解决方案：</strong></p>\n<ol><li>另外设一个标志以区别队空、队满</li>\n<li>少用一个元素空间：<pre><code>队空：front==rear\n队满：(rear+1)%M==front</code></pre></li>\n</ol><h3 id=\"初始化-2\">初始化<a href=\"#初始化-2\" title=\"初始化\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitQueue</span><span class=\"params\">(SqQueue &amp;Q)</span> </span>&#123;<span class=\"comment\">//构造一个空队列Q</span></span><br><span class=\"line\">\tQ.base = <span class=\"keyword\">new</span> QElemType[MAXQSIZE]; <span class=\"comment\">//为队列分配一个最大容量为MAXSIZE的数组空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (!Q.base)</span><br><span class=\"line\">\t\t<span class=\"built_in\">exit</span>(OVERFLOW); <span class=\"comment\">//存储分配失败</span></span><br><span class=\"line\">\tQ.front = Q.rear = <span class=\"number\">0</span>; <span class=\"comment\">//头指针和尾指针置为零，队列为空</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"求循环队列的长度\">求循环队列的长度<a href=\"#求循环队列的长度\" title=\"求循环队列的长度\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">QueueLength</span><span class=\"params\">(SqQueue Q)</span> </span>&#123;<span class=\"comment\">//返回Q的元素个数，即队列的长度</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> (Q.rear - Q.front + MAXQSIZE) % MAXQSIZE;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"入队\">入队<a href=\"#入队\" title=\"入队\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">EnQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType e)</span> </span>&#123;<span class=\"comment\">//插入元素e为Q的新的队尾元素</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> ((Q.rear + <span class=\"number\">1</span>) % MAXQSIZE == Q.front) <span class=\"comment\">//尾指针在循环意义上加1后等于头指针，表明队满</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR;</span><br><span class=\"line\">\tQ.base[Q.rear] = e; <span class=\"comment\">//新元素插入队尾</span></span><br><span class=\"line\">\tQ.rear = (Q.rear + <span class=\"number\">1</span>) % MAXQSIZE; <span class=\"comment\">//队尾指针加1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"出队\">出队<a href=\"#出队\" title=\"出队\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DeQueue</span><span class=\"params\">(SqQueue &amp;Q, QElemType &amp;e)</span> </span>&#123;<span class=\"comment\">//删除Q的队头元素，用e返回其值</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Q.front == Q.rear)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//队空</span></span><br><span class=\"line\">\te = Q.base[Q.front]; <span class=\"comment\">//保存队头元素</span></span><br><span class=\"line\">\tQ.front = (Q.front + <span class=\"number\">1</span>) % MAXQSIZE; <span class=\"comment\">//队头指针加1</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"取循环队列的队头元素\">取循环队列的队头元素<a href=\"#取循环队列的队头元素\" title=\"取循环队列的队头元素\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SElemType <span class=\"title\">GetHead</span><span class=\"params\">(SqQueue Q)</span> </span>&#123;<span class=\"comment\">//返回Q的队头元素，不修改队头指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Q.front != Q.rear) <span class=\"comment\">//队列非空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Q.base[Q.front]; <span class=\"comment\">//返回队头元素的值，队头指针不变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h2 id=\"链队\">链队<a href=\"#链队\" title=\"链队\"></a></h2><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201024175917.png\" style=\"zoom: 33%;\" /><img src=\"https://cdn.jsdelivr.net/gh/dxsummer/cdn/img/data/20201024232755.png\" style=\"zoom: 67%;\" /><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> &#123;</span></span><br><span class=\"line\">\tQElemType data;</span><br><span class=\"line\">\t<span class=\"class\"><span class=\"keyword\">struct</span> <span class=\"title\">QNode</span> *<span class=\"title\">next</span>;</span></span><br><span class=\"line\">&#125; QNode, *QueuePtr;</span><br><span class=\"line\"><span class=\"keyword\">typedef</span> <span class=\"class\"><span class=\"keyword\">struct</span> &#123;</span></span><br><span class=\"line\">\tQueuePtr front; <span class=\"comment\">//队头指针c</span></span><br><span class=\"line\">\tQueuePtr rear; <span class=\"comment\">//队尾指针</span></span><br><span class=\"line\">&#125; LinkQueue;</span><br></pre></td></tr></table></figure><h3 id=\"初始化-3\">初始化<a href=\"#初始化-3\" title=\"初始化\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">InitQueue</span><span class=\"params\">(LinkQueue &amp;Q)</span> </span>&#123;<span class=\"comment\">//构造一个空队列Q</span></span><br><span class=\"line\">\tQ.front = Q.rear = <span class=\"keyword\">new</span> QNode; <span class=\"comment\">//生成新结点作为头结点，队头和队尾指针指向此结点</span></span><br><span class=\"line\">\tQ.front-&gt;next = <span class=\"literal\">NULL</span>; <span class=\"comment\">//头结点的指针域置空</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"入队-1\">入队<a href=\"#入队-1\" title=\"入队\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">EnQueue</span><span class=\"params\">(LinkQueue &amp;Q, QElemType e)</span> </span>&#123;<span class=\"comment\">//插入元素e为Q的新的队尾元素</span></span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\tp = <span class=\"keyword\">new</span> QNode; <span class=\"comment\">//为入队元素分配结点空间，用指针p指向</span></span><br><span class=\"line\">\tp-&gt;data = e; <span class=\"comment\">//将新结点数据域置为e</span></span><br><span class=\"line\">\tp-&gt;next = <span class=\"literal\">NULL</span>;</span><br><span class=\"line\">\tQ.rear-&gt;next = p; <span class=\"comment\">//将新结点插入到队尾</span></span><br><span class=\"line\">\tQ.rear = p; <span class=\"comment\">//修改队尾指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"出队-1\">出队<a href=\"#出队-1\" title=\"出队\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">Status <span class=\"title\">DeQueue</span><span class=\"params\">(LinkQueue &amp;Q, QElemType &amp;e)</span> </span>&#123;<span class=\"comment\">//删除Q的队头元素，用e返回其值 </span></span><br><span class=\"line\">\tQueuePtr p;</span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Q.front == Q.rear)</span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> ERROR; <span class=\"comment\">//若队列空，则返回ERROR</span></span><br><span class=\"line\">\tp = Q.front-&gt;next; <span class=\"comment\">//p指向队头元素</span></span><br><span class=\"line\">\te = p-&gt;data; <span class=\"comment\">//e保存队头元素的值</span></span><br><span class=\"line\">\tQ.front-&gt;next = p-&gt;next; <span class=\"comment\">//修改头指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Q.rear == p)</span><br><span class=\"line\">\t\tQ.rear = Q.front; <span class=\"comment\">//最后一个元素被删，队尾指针指向头结点</span></span><br><span class=\"line\">\t<span class=\"keyword\">delete</span> p; <span class=\"comment\">//释放原队头元素的空间</span></span><br><span class=\"line\">\t<span class=\"keyword\">return</span> OK;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure><h3 id=\"取链队的队头元素\">取链队的队头元素<a href=\"#取链队的队头元素\" title=\"取链队的队头元素\"></a></h3><figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\">SElemType <span class=\"title\">GetHead</span><span class=\"params\">(LinkQueue Q)</span> </span>&#123;<span class=\"comment\">//返回Q的队头元素，不修改队头指针</span></span><br><span class=\"line\">\t<span class=\"keyword\">if</span> (Q.front != Q.rear) <span class=\"comment\">//队列非空</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> Q.front-&gt;next-&gt;data; <span class=\"comment\">//返回队头元素的值，队头指针不变</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","prev":{"title":"ACM数据结构","link":"posts/5d201f0e"},"next":{"title":"盒子模型","link":"posts/998dffd6"},"plink":"https://dxsummer.gitee.io/posts/8d66b5f2/","toc":[{"id":"栈","title":"栈","index":"1","children":[{"id":"顺序栈","title":"顺序栈","index":"1.1","children":[{"id":"表示","title":"表示","index":"1.1.1"},{"id":"初始化","title":"初始化","index":"1.1.2"},{"id":"进栈","title":"进栈","index":"1.1.3"},{"id":"出栈","title":"出栈","index":"1.1.4"},{"id":"取栈顶元素","title":"取栈顶元素","index":"1.1.5"}]},{"id":"链栈","title":"链栈","index":"1.2","children":[{"id":"初始化-1","title":"初始化","index":"1.2.1"},{"id":"进栈-1","title":"进栈","index":"1.2.2"},{"id":"出栈-1","title":"出栈","index":"1.2.3"},{"id":"取栈顶元素-1","title":"取栈顶元素","index":"1.2.4"}]}]},{"id":"栈与递归","title":"栈与递归","index":"2"},{"id":"队列","title":"队列","index":"3","children":[{"id":"队列的顺序表示-一维数组basem","title":"队列的顺序表示 一维数组base[M]","index":"3.1"},{"id":"存在问题","title":"存在问题","index":"3.2"},{"id":"循环队列","title":"循环队列","index":"3.3","children":[{"id":"初始化-2","title":"初始化","index":"3.3.1"},{"id":"求循环队列的长度","title":"求循环队列的长度","index":"3.3.2"},{"id":"入队","title":"入队","index":"3.3.3"},{"id":"出队","title":"出队","index":"3.3.4"},{"id":"取循环队列的队头元素","title":"取循环队列的队头元素","index":"3.3.5"}]},{"id":"链队","title":"链队","index":"3.4","children":[{"id":"初始化-3","title":"初始化","index":"3.4.1"},{"id":"入队-1","title":"入队","index":"3.4.2"},{"id":"出队-1","title":"出队","index":"3.4.3"},{"id":"取链队的队头元素","title":"取链队的队头元素","index":"3.4.4"}]}]}],"reward":true,"copyright":{"author":"DxSummer","link":"<a href=\"https://dxsummer.gitee.io/posts/8d66b5f2/\" title=\"栈和队列\">https://dxsummer.gitee.io/posts/8d66b5f2/</a>","license":"Attribution-NonCommercial-NoDerivatives 4.0 International (<a href=\\\"https://creativecommons.org/licenses/by-nc-sa/4.0/\\\" rel=\\\"external nofollow\\\" target=\\\"_blank\\\">CC BY-NC-ND 4.0</a>)","published":"2020年10月19日","updated":"2020年10月24日"}}